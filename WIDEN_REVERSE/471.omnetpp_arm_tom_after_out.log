/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherAppCli.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherAppCli.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherAppCli_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherAppCli_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherAppSrv.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherAppSrv.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherAppSrv_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherAppSrv_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherApp_m.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherApp_m.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherBus.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherBus.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherBus_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherBus_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherCtrl_m.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherCtrl_m.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherEncap.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherEncap.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherEncap_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherEncap_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherFrame_m.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherFrame_m.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherHost_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherHost_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherHub.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherHub.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherHub_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherHub_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherLLC.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherLLC.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherLLC_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherLLC_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherMAC.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherMAC.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherMAC_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherMAC_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o EtherSwitch_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherSwitch_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o LargeNet_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           LargeNet_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o MACAddress.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           MACAddress.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o MACAddress_m.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           MACAddress_m.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o MACRelayUnitBase.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           MACRelayUnitBase.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o MACRelayUnitNP.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           MACRelayUnitNP.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o MACRelayUnitNP_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           MACRelayUnitNP_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o MACRelayUnitPP.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           MACRelayUnitPP.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o MACRelayUnitPP_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           MACRelayUnitPP_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o MACRelayUnit_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           MACRelayUnit_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o Networks_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           Networks_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o eth-index_n.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           eth-index_n.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o utils.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           utils.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/cmdenv/cmdenv.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/cmdenv/cmdenv.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/cmdenv/enumstr.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/cmdenv/enumstr.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/cmdenv/heap.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/cmdenv/heap.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/akoutvectormgr.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/akoutvectormgr.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/args.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/args.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/cenvir.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/cenvir.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/cinifile.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/cinifile.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/filemgrs.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/filemgrs.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/main.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/main.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/omnetapp.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/omnetapp.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/patmatch.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/patmatch.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/platdep.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/platdep.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/seeds.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/seeds.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/slaveapp.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/slaveapp.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/envir/speedmtr.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/envir/speedmtr.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/carray.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/carray.cc
========== Loop: _ZN4cBag5setupEiii' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%mul22> = mul nuw nsw ir<%indvars.iv>, ir<%add>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%mul22>
    CLONE store ir<0>, ir<%add.ptr>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN4cBag5setupEiii' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%mul22> = mul nuw nsw ir<%indvars.iv>, ir<%add>
    REPLICATE ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%mul22>
    REPLICATE store ir<0>, ir<%add.ptr>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN4cBag5setupEiii' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%mul22> = mul nuw nsw ir<%indvars.iv>, ir<%add>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%mul22>
    REPLICATE store ir<0>, ir<%add.ptr>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN4cBag5setupEiii' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%mul22> = mul nuw nsw ir<%indvars.iv>, ir<%add>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%mul22>
    WIDEN store ir<%add.ptr>, ir<0>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 31138512872, RTCostB: 10737418235
A is not scalable.	B is not scalable.	
RTCostA: 31138512872, RTCostB: 10737418235

-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 30601641942, RTCostB: 10737418235
A is not scalable.	B is not scalable.	
RTCostA: 30601641942, RTCostB: 10737418235

-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF 8 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 30333206450, RTCostB: 10737418235
A is not scalable.	B is not scalable.	
RTCostA: 30333206450, RTCostB: 10737418235

-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF 16 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 208 for VF 16 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 30198988650, RTCostB: 10737418235
A is not scalable.	B is not scalable.	
RTCostA: 30198988650, RTCostB: 10737418235

-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418235

-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 23622320099, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: 23622320099, RTCostB: 10737418235

-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449165, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: 23085449165, RTCostB: 10737418235

-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 22817013665, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: 22817013665, RTCostB: 10737418235

-----------------Function that is being costed:'_ZN4cBag5setupEiii' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %mul22 = mul nuw nsw i64 %indvars.iv, %add of type:mul
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %call, i64 %mul22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   store i8 0, ptr %add.ptr, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 22682795849, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: 22682795849, RTCostB: 10737418235
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN4cBag5setupEiii at line: libs/sim/carray.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%mul22> = mul nuw nsw vp<%4>, ir<%add>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%call>, ir<%mul22>
    CLONE store ir<0>, ir<%add.ptr>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 1
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN4cBag3addEPv' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %15 to i64))<nsw> + ((sext i32 %add53.pre-phi to i64) smax (1 + (sext i32 %15 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    CLONE ir<%mul60> = mul nsw ir<%add59>, ir<%indvars.iv>
    CLONE ir<%add.ptr61> = getelementptr inbounds ir<%call>, ir<%mul60>
    CLONE store ir<0>, ir<%add.ptr61>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp54> = icmp slt ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN4cBag3addEPv' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %15 to i64))<nsw> + ((sext i32 %add53.pre-phi to i64) smax (1 + (sext i32 %15 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN ir<%mul60> = mul nsw ir<%add59>, ir<%indvars.iv>
    REPLICATE ir<%add.ptr61> = getelementptr inbounds ir<%call>, ir<%mul60>
    REPLICATE store ir<0>, ir<%add.ptr61>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp54> = icmp slt ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN4cBag3addEPv' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %15 to i64))<nsw> + ((sext i32 %add53.pre-phi to i64) smax (1 + (sext i32 %15 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN ir<%mul60> = mul nsw ir<%add59>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var] ir<%add.ptr61> = getelementptr inbounds ir<%call>, ir<%mul60>
    REPLICATE store ir<0>, ir<%add.ptr61>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp54> = icmp slt ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN4cBag3addEPv' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %15 to i64))<nsw> + ((sext i32 %add53.pre-phi to i64) smax (1 + (sext i32 %15 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN ir<%mul60> = mul nsw ir<%add59>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var] ir<%add.ptr61> = getelementptr inbounds ir<%call>, ir<%mul60>
    WIDEN store ir<%add.ptr61>, ir<0>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp54> = icmp slt ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Vector loop of width 2 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 62277025768, RTCostB: 21474836475
A is not scalable.	B is not scalable.	
RTCostA: 62277025768, RTCostB: 21474836475

-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Vector loop of width 4 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 61203283926, RTCostB: 21474836475
A is not scalable.	B is not scalable.	
RTCostA: 61203283926, RTCostB: 21474836475

-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 8 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Vector loop of width 8 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 60666412978, RTCostB: 21474836475
A is not scalable.	B is not scalable.	
RTCostA: 60666412978, RTCostB: 21474836475

-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 16 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 208 for VF 16 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Vector loop of width 16 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 60397977450, RTCostB: 21474836475
A is not scalable.	B is not scalable.	
RTCostA: 60397977450, RTCostB: 21474836475

-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836475
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836475

-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 47244640227, RTCostB: 21474836475
A is scalable.	B is not scalable.	
RTCostA: 47244640227, RTCostB: 21474836475

-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 46170898381, RTCostB: 21474836475
A is scalable.	B is not scalable.	
RTCostA: 46170898381, RTCostB: 21474836475

-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 45634027425, RTCostB: 21474836475
A is scalable.	B is not scalable.	
RTCostA: 45634027425, RTCostB: 21474836475

-----------------Function that is being costed:'_ZN4cBag3addEPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %mul60 = mul nsw i64 %add59, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %add.ptr61 = getelementptr inbounds i8, ptr %call, i64 %mul60 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   store i8 0, ptr %add.ptr61, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp54 = icmp slt i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp54, label %for.body, label %for.cond.cleanup.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 45365591881, RTCostB: 21474836475
A is scalable.	B is not scalable.	
RTCostA: 45365591881, RTCostB: 21474836475
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN4cBag3addEPv at line: libs/sim/carray.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %15 to i64))<nsw> + ((sext i32 %add53.pre-phi to i64) smax (1 + (sext i32 %15 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%16> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%mul60> = mul nsw ir<%add59>, vp<%5>
    CLONE ir<%add.ptr61> = getelementptr inbounds ir<%call>, ir<%mul60>
    CLONE store ir<0>, ir<%add.ptr61>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN4cBag5addAtEiPv' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %12 to i64))<nsw> + ((sext i32 (1 + %m) to i64) smax ((sext i32 %9 to i64) + (sext i32 %0 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<1>
    CLONE ir<%mul63> = mul nsw ir<%add62>, ir<%indvars.iv>
    CLONE ir<%add.ptr64> = getelementptr inbounds ir<%call>, ir<%mul63>
    CLONE store ir<0>, ir<%add.ptr64>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv42>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN4cBag5addAtEiPv' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %12 to i64))<nsw> + ((sext i32 (1 + %m) to i64) smax ((sext i32 %9 to i64) + (sext i32 %0 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<1>
    WIDEN ir<%mul63> = mul nsw ir<%add62>, ir<%indvars.iv>
    REPLICATE ir<%add.ptr64> = getelementptr inbounds ir<%call>, ir<%mul63>
    REPLICATE store ir<0>, ir<%add.ptr64>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv42>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN4cBag5addAtEiPv' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %12 to i64))<nsw> + ((sext i32 (1 + %m) to i64) smax ((sext i32 %9 to i64) + (sext i32 %0 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<1>
    WIDEN ir<%mul63> = mul nsw ir<%add62>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var] ir<%add.ptr64> = getelementptr inbounds ir<%call>, ir<%mul63>
    REPLICATE store ir<0>, ir<%add.ptr64>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv42>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN4cBag5addAtEiPv' from libs/sim/carray.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %12 to i64))<nsw> + ((sext i32 (1 + %m) to i64) smax ((sext i32 %9 to i64) + (sext i32 %0 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<1>
    WIDEN ir<%mul63> = mul nsw ir<%add62>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var] ir<%add.ptr64> = getelementptr inbounds ir<%call>, ir<%mul63>
    WIDEN store ir<%add.ptr64>, ir<0>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv42>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 14
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 10
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 14
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 57
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 57, CostB * EstimatedWidthA: 20
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 57
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 57, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 8 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 14
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 113
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 113, CostB * EstimatedWidthA: 40
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 113
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 113, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF 16 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 208 for VF 16 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 14
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 225
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 225, CostB * EstimatedWidthA: 80
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 225
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 225, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 44
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 44
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 86
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 86, CostB * EstimatedWidthA: 40
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 86
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 86, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 10
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 170
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 170, CostB * EstimatedWidthA: 80
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 170
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 170, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'_ZN4cBag5addAtEiPv' from libs/sim/carray.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %mul63 = mul nsw i64 %add62, %indvars.iv of type:mul
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %add.ptr64 = getelementptr inbounds i8, ptr %call, i64 %mul63 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   store i8 0, ptr %add.ptr64, align 1, !tbaa !16 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv42 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 10
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 338
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 338, CostB * EstimatedWidthA: 160
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 338
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 338, CostB * EstimatedWidthA: 160
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN4cBag5addAtEiPv at line: libs/sim/carray.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %12 to i64))<nsw> + ((sext i32 (1 + %m) to i64) smax ((sext i32 %9 to i64) + (sext i32 %0 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%13> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%mul63> = mul nsw ir<%add62>, vp<%5>
    CLONE ir<%add.ptr64> = getelementptr inbounds ir<%call>, ir<%mul63>
    CLONE store ir<0>, ir<%add.ptr64>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cexception.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cexception.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cmessage.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cmessage.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cpar.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cpar.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/ctypes.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/ctypes.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/task.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/task.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cchannel.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cchannel.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cfsm.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cfsm.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cmodule.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cmodule.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cpsquare.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cpsquare.cc
@@ Instruction =>  %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %14, ptr %arrayidx26, align 8, !tbaa !23 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %14, ptr %arrayidx26, align 8, !tbaa !23 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %14, ptr %arrayidx26, align 8, !tbaa !23 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %14, ptr %arrayidx26, align 8, !tbaa !23 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %14, ptr %arrayidx26, align 8, !tbaa !23 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN8cPSquareaSERKS_' from libs/sim/cpsquare.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %4) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%11>, ir<%indvars.iv>
    CLONE ir<%13> = load ir<%arrayidx>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%call8>, ir<%indvars.iv>
    CLONE store ir<%13>, ir<%arrayidx20>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%12>, ir<%indvars.iv>
    CLONE ir<%14> = load ir<%arrayidx23>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%call12>, ir<%indvars.iv>
    CLONE store ir<%14>, ir<%arrayidx26>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<return.loopexit>, scalar.ph

ir-bb<return.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN8cPSquareaSERKS_' from libs/sim/cpsquare.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %4) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%11>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%call8>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx20>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%12>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%14> = load vp<%6>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%call12>, ir<%indvars.iv>
    vp<%7> = vector-pointer ir<%arrayidx26>
    WIDEN store vp<%7>, ir<%14>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<return.loopexit>, scalar.ph

ir-bb<return.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN8cPSquareaSERKS_' from libs/sim/cpsquare.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %4) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%11>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%call8>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx20>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%12>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%14> = load vp<%6>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%call12>, ir<%indvars.iv>
    vp<%7> = vector-pointer ir<%arrayidx26>
    WIDEN store vp<%7>, ir<%14>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<return.loopexit>, scalar.ph

ir-bb<return.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN8cPSquareaSERKS_' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %11, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx20 = getelementptr inbounds i32, ptr %call8, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23 = getelementptr inbounds double, ptr %12, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx26 = getelementptr inbounds double, ptr %call12, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %14, ptr %arrayidx26, align 8, !tbaa !23 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond, label %return.loopexit, label %for.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN8cPSquareaSERKS_' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %11, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx20 = getelementptr inbounds i32, ptr %call8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23 = getelementptr inbounds double, ptr %12, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx26 = getelementptr inbounds double, ptr %call12, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %14, ptr %arrayidx26, align 8, !tbaa !23 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond, label %return.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450954, RTCostB: 21474836490
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450954, RTCostB: 21474836490
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN8cPSquareaSERKS_' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %11, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx20 = getelementptr inbounds i32, ptr %call8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx23 = getelementptr inbounds double, ptr %12, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx26 = getelementptr inbounds double, ptr %call12, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store double %14, ptr %arrayidx26, align 8, !tbaa !23 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond, label %return.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967306, RTCostB: 21474836490
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967306, RTCostB: 6442450954
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN8cPSquareaSERKS_' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %11, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx20 = getelementptr inbounds i32, ptr %call8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23 = getelementptr inbounds double, ptr %12, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx26 = getelementptr inbounds double, ptr %call12, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %14, ptr %arrayidx26, align 8, !tbaa !23 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond, label %return.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836490
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967306

-----------------Function that is being costed:'_ZN8cPSquareaSERKS_' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %11, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %13 = load i32, ptr %arrayidx, align 4, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx20 = getelementptr inbounds i32, ptr %call8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %13, ptr %arrayidx20, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23 = getelementptr inbounds double, ptr %12, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %14 = load double, ptr %arrayidx23, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx26 = getelementptr inbounds double, ptr %call12, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %14, ptr %arrayidx26, align 8, !tbaa !23 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond, label %return.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225482, RTCostB: 21474836490
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225482, RTCostB: 4294967306
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN8cPSquareaSERKS_ at line: libs/sim/cpsquare.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %4) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%11>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%21> = load vp<%5>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%call8>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx20>
    WIDEN store vp<%6>, ir<%21>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%13>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%22> = load vp<%7>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%call12>, vp<%4>
    vp<%8> = vector-pointer ir<%arrayidx26>
    WIDEN store vp<%8>, ir<%22>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<return.loopexit>, scalar.ph

ir-bb<return.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 1
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store i32 %7, ptr %arrayidx, align 4, !tbaa !25 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %7, ptr %arrayidx, align 4, !tbaa !25 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %7, ptr %arrayidx, align 4, !tbaa !25 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %7, ptr %arrayidx, align 4, !tbaa !25 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store i32 %7, ptr %arrayidx, align 4, !tbaa !25 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN8cPSquareC2EPKci' from libs/sim/cpsquare.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %b) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<%7>, ir<%arrayidx>
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%call6>, ir<%indvars.iv>
    CLONE store ir<-1.000000e+50>, ir<%arrayidx12>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN8cPSquareC2EPKci' from libs/sim/cpsquare.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %b) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%7>
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%call6>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx12>
    WIDEN store vp<%5>, ir<-1.000000e+50>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN8cPSquareC2EPKci' from libs/sim/cpsquare.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %b) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%7>
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%call6>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx12>
    WIDEN store vp<%5>, ir<-1.000000e+50>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN8cPSquareC2EPKci' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %7 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %7, ptr %arrayidx, align 4, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx12 = getelementptr inbounds double, ptr %call6, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN8cPSquareC2EPKci' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %7 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %7, ptr %arrayidx, align 4, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx12 = getelementptr inbounds double, ptr %call6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967302, RTCostB: 12884901894
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967302, RTCostB: 12884901894
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN8cPSquareC2EPKci' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %7 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %7, ptr %arrayidx, align 4, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx12 = getelementptr inbounds double, ptr %call6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 12884901894
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 4294967302
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN8cPSquareC2EPKci' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %7 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %7, ptr %arrayidx, align 4, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx12 = getelementptr inbounds double, ptr %call6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901894
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225478

-----------------Function that is being costed:'_ZN8cPSquareC2EPKci' from libs/sim/cpsquare.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %7 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %7, ptr %arrayidx, align 4, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx12 = getelementptr inbounds double, ptr %call6, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double -1.000000e+50, ptr %arrayidx12, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483654, RTCostB: 12884901894
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483654, RTCostB: 3221225478
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN8cPSquareC2EPKci at line: libs/sim/cpsquare.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (2 + %b) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%7>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%7>
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%call6>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx12>
    WIDEN store vp<%6>, ir<-1.000000e+50>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cvarhist.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cvarhist.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/util.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/util.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/ccoroutine.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/ccoroutine.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cgate.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cgate.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cmsgheap.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cmsgheap.cc
@@ Instruction =>  %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN12cMessageHeap4sortEv' from libs/sim/cmsgheap.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %2) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    CLONE ir<%5> = load ir<%arrayidx>
    CLONE ir<%heapindex> = getelementptr inbounds ir<%5>, ir<152>
    CLONE ir<%6> = trunc ir<%indvars.iv>
    CLONE store ir<%6>, ir<%heapindex>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN12cMessageHeap4sortEv' from libs/sim/cmsgheap.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %2) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 1, %indvars.iv.next\l" +
    "  ir<%6>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%4>
    REPLICATE ir<%heapindex> = getelementptr inbounds ir<%5>, ir<152>
    REPLICATE store ir<%6>, ir<%heapindex>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN12cMessageHeap4sortEv' from libs/sim/cmsgheap.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %2) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 1, %indvars.iv.next\l" +
    "  ir<%6>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%heapindex> = getelementptr inbounds ir<%5>, ir<152>
    REPLICATE store ir<%6>, ir<%heapindex>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN12cMessageHeap4sortEv' from libs/sim/cmsgheap.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %2) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 1, %indvars.iv.next\l" +
    "  ir<%6>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%heapindex> = getelementptr inbounds ir<%5>, ir<152>
    WIDEN store ir<%heapindex>, ir<%6>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN12cMessageHeap4sortEv' from libs/sim/cmsgheap.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %heapindex = getelementptr inbounds i8, ptr %5, i64 152 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %6 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %6, ptr %heapindex, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN12cMessageHeap4sortEv' from libs/sim/cmsgheap.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %heapindex = getelementptr inbounds i8, ptr %5, i64 152 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %6 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i32 %6, ptr %heapindex, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 35433480165, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 35433480165, RTCostB: 12884901882

-----------------Function that is being costed:'_ZN12cMessageHeap4sortEv' from libs/sim/cmsgheap.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %heapindex = getelementptr inbounds i8, ptr %5, i64 152 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %6 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i32 %6, ptr %heapindex, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 34896609233, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 34896609233, RTCostB: 12884901882

-----------------Function that is being costed:'_ZN12cMessageHeap4sortEv' from libs/sim/cmsgheap.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %heapindex = getelementptr inbounds i8, ptr %5, i64 152 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %6 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %6, ptr %heapindex, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'_ZN12cMessageHeap4sortEv' from libs/sim/cmsgheap.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load ptr, ptr %arrayidx, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %heapindex = getelementptr inbounds i8, ptr %5, i64 152 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %6 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %6, ptr %heapindex, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 23622320102, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 23622320102, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN12cMessageHeap4sortEv at line: libs/sim/cmsgheap.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %2) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, vp<%5>
    CLONE ir<%5> = load ir<%arrayidx>
    CLONE ir<%heapindex> = getelementptr inbounds ir<%5>, ir<152>
    CLONE ir<%6> = trunc vp<%5>
    CLONE store ir<%6>, ir<%heapindex>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %7 = load ptr, ptr %arrayidx, align 8, !tbaa !21 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %7, ptr %arrayidx8, align 8, !tbaa !21 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load ptr, ptr %arrayidx, align 8, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %7, ptr %arrayidx8, align 8, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %7 = load ptr, ptr %arrayidx, align 8, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %7, ptr %arrayidx8, align 8, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN12cMessageHeap6insertEP8cMessage' from libs/sim/cmsgheap.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %1) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%.pre>, ir<%indvars.iv>
    CLONE ir<%7> = load ir<%arrayidx>
    CLONE ir<%arrayidx8> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<%7>, ir<%arrayidx8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.thread>, scalar.ph

ir-bb<for.end.thread>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN12cMessageHeap6insertEP8cMessage' from libs/sim/cmsgheap.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %1) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%.pre>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%7> = load vp<%4>
    CLONE ir<%arrayidx8> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx8>
    WIDEN store vp<%5>, ir<%7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.thread>, scalar.ph

ir-bb<for.end.thread>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN12cMessageHeap6insertEP8cMessage' from libs/sim/cmsgheap.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %1) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%.pre>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%7> = load vp<%4>
    CLONE ir<%arrayidx8> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx8>
    WIDEN store vp<%5>, ir<%7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.thread>, scalar.ph

ir-bb<for.end.thread>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN12cMessageHeap6insertEP8cMessage' from libs/sim/cmsgheap.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %.pre, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load ptr, ptr %arrayidx, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx8 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %7, ptr %arrayidx8, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.thread, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN12cMessageHeap6insertEP8cMessage' from libs/sim/cmsgheap.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %7 = load ptr, ptr %arrayidx, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx8 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %7, ptr %arrayidx8, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.thread, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN12cMessageHeap6insertEP8cMessage' from libs/sim/cmsgheap.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load ptr, ptr %arrayidx, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx8 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %7, ptr %arrayidx8, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.thread, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967298

-----------------Function that is being costed:'_ZN12cMessageHeap6insertEP8cMessage' from libs/sim/cmsgheap.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %.pre, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %7 = load ptr, ptr %arrayidx, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx8 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %7, ptr %arrayidx8, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.thread, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN12cMessageHeap6insertEP8cMessage at line: libs/sim/cmsgheap.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %1) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%.pre>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN ir<%11> = load vp<%6>
    CLONE ir<%arrayidx8> = getelementptr inbounds ir<%call>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx8>
    WIDEN store vp<%7>, ir<%11>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.thread>, scalar.ph

ir-bb<for.end.thread>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 6
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cqueue.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cqueue.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cwatch.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cwatch.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cdensity.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cdensity.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/chead.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/chead.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cnetmod.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cnetmod.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/csimul.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/csimul.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/distrib.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/distrib.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cdetect.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cdetect.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/chist.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/chist.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cobject.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cobject.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cstat.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cstat.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/errmsg.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/errmsg.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cdispstr.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cdispstr.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cksplit.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cksplit.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/coutvect.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/coutvect.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cstruct.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cstruct.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/onstartup.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/onstartup.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cenum.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cenum.cc
========== Loop: _ZN5cEnumC2EPKci' from libs/sim/cenum.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%string> = getelementptr inbounds ir<%call>, ir<%indvars.iv>, ir<1>
    CLONE store ir<null>, ir<%string>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN5cEnumC2EPKci' from libs/sim/cenum.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%string> = getelementptr inbounds ir<%call>, ir<%indvars.iv>, ir<1>
    REPLICATE store ir<null>, ir<%string>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN5cEnumC2EPKci' from libs/sim/cenum.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%string> = getelementptr inbounds ir<%call>, ir<%indvars.iv>, ir<1>
    REPLICATE store ir<null>, ir<%string>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN5cEnumC2EPKci' from libs/sim/cenum.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%string> = getelementptr inbounds ir<%call>, ir<%indvars.iv>, ir<1>
    WIDEN store ir<%string>, ir<null>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN5cEnumC2EPKci' from libs/sim/cenum.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %string = getelementptr inbounds %"struct.cEnum::sEnum", ptr %call, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %string, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN5cEnumC2EPKci' from libs/sim/cenum.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %string = getelementptr inbounds %"struct.cEnum::sEnum", ptr %call, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store ptr null, ptr %string, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'_ZN5cEnumC2EPKci' from libs/sim/cenum.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %string = getelementptr inbounds %"struct.cEnum::sEnum", ptr %call, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %string, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588

-----------------Function that is being costed:'_ZN5cEnumC2EPKci' from libs/sim/cenum.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %string = getelementptr inbounds %"struct.cEnum::sEnum", ptr %call, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr null, ptr %string, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN5cEnumC2EPKci at line: libs/sim/cenum.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %siz to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%string> = getelementptr inbounds ir<%call>, vp<%4>, ir<1>
    CLONE store ir<null>, ir<%string>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN5cEnum6insertEiPKc' from libs/sim/cenum.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body15.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %3) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv200 = phi 0, %indvars.iv.next201, ir<1>
    CLONE ir<%string> = getelementptr inbounds ir<%call>, ir<%indvars.iv200>, ir<1>
    CLONE store ir<null>, ir<%string>
    CLONE ir<%indvars.iv.next201> = add nuw nsw ir<%indvars.iv200>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next201>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond22.preheader.loopexit>, scalar.ph

ir-bb<for.cond22.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN5cEnum6insertEiPKc' from libs/sim/cenum.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body15.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %3) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv200 = phi 0, %indvars.iv.next201, ir<1>
    REPLICATE ir<%string> = getelementptr inbounds ir<%call>, ir<%indvars.iv200>, ir<1>
    REPLICATE store ir<null>, ir<%string>
    REPLICATE ir<%indvars.iv.next201> = add nuw nsw ir<%indvars.iv200>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next201>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond22.preheader.loopexit>, scalar.ph

ir-bb<for.cond22.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN5cEnum6insertEiPKc' from libs/sim/cenum.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body15.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %3) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv200 = phi 0, %indvars.iv.next201, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%string> = getelementptr inbounds ir<%call>, ir<%indvars.iv200>, ir<1>
    REPLICATE store ir<null>, ir<%string>
    WIDEN ir<%indvars.iv.next201> = add nuw nsw ir<%indvars.iv200>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next201>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond22.preheader.loopexit>, scalar.ph

ir-bb<for.cond22.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN5cEnum6insertEiPKc' from libs/sim/cenum.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body15.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %3) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv200 = phi 0, %indvars.iv.next201, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%string> = getelementptr inbounds ir<%call>, ir<%indvars.iv200>, ir<1>
    WIDEN store ir<%string>, ir<null>
    WIDEN ir<%indvars.iv.next201> = add nuw nsw ir<%indvars.iv200>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next201>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond22.preheader.loopexit>, scalar.ph

ir-bb<for.cond22.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN5cEnum6insertEiPKc' from libs/sim/cenum.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv200 = phi i64 [ 0, %for.body15.preheader ], [ %indvars.iv.next201, %for.body15 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %string = getelementptr inbounds %"struct.cEnum::sEnum", ptr %call, i64 %indvars.iv200, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %string, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next201 = add nuw nsw i64 %indvars.iv200, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next201, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body15 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN5cEnum6insertEiPKc' from libs/sim/cenum.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv200 = phi i64 [ 0, %for.body15.preheader ], [ %indvars.iv.next201, %for.body15 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %string = getelementptr inbounds %"struct.cEnum::sEnum", ptr %call, i64 %indvars.iv200, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store ptr null, ptr %string, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next201 = add nuw nsw i64 %indvars.iv200, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next201, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body15 of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'_ZN5cEnum6insertEiPKc' from libs/sim/cenum.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv200 = phi i64 [ 0, %for.body15.preheader ], [ %indvars.iv.next201, %for.body15 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %string = getelementptr inbounds %"struct.cEnum::sEnum", ptr %call, i64 %indvars.iv200, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %string, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next201 = add nuw nsw i64 %indvars.iv200, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next201, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body15 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588

-----------------Function that is being costed:'_ZN5cEnum6insertEiPKc' from libs/sim/cenum.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv200 = phi i64 [ 0, %for.body15.preheader ], [ %indvars.iv.next201, %for.body15 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %string = getelementptr inbounds %"struct.cEnum::sEnum", ptr %call, i64 %indvars.iv200, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr null, ptr %string, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next201 = add nuw nsw i64 %indvars.iv200, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next201, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond22.preheader.loopexit, label %for.body15 of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN5cEnum6insertEiPKc at line: libs/sim/cenum.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body15.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %3) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%string> = getelementptr inbounds ir<%call>, vp<%4>, ir<1>
    CLONE store ir<null>, ir<%string>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond22.preheader.loopexit>, scalar.ph

ir-bb<for.cond22.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cllist.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cllist.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/cpacket.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/cpacket.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/ctopo.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/ctopo.cc
========== Loop: _ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%known> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<7>
    CLONE store ir<0>, ir<%known>
    CLONE ir<%dist> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<8>
    CLONE store ir<0x7FF0000000000000>, ir<%dist>
    CLONE ir<%out_path> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<9>
    CLONE store ir<null>, ir<%out_path>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%known> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<7>
    REPLICATE store ir<0>, ir<%known>
    REPLICATE ir<%dist> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<8>
    REPLICATE store ir<0x7FF0000000000000>, ir<%dist>
    REPLICATE ir<%out_path> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<9>
    REPLICATE store ir<null>, ir<%out_path>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%known> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<7>
    REPLICATE store ir<0>, ir<%known>
    WIDEN-GEP Inv[Var][Inv] ir<%dist> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<8>
    REPLICATE store ir<0x7FF0000000000000>, ir<%dist>
    WIDEN-GEP Inv[Var][Inv] ir<%out_path> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<9>
    REPLICATE store ir<null>, ir<%out_path>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%known> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<7>
    WIDEN store ir<%known>, ir<0>
    WIDEN-GEP Inv[Var][Inv] ir<%dist> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<8>
    WIDEN store ir<%dist>, ir<0x7FF0000000000000>
    WIDEN-GEP Inv[Var][Inv] ir<%out_path> = getelementptr inbounds ir<%3>, ir<%indvars.iv>, ir<9>
    WIDEN store ir<%out_path>, ir<null>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %known = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 7 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 0, ptr %known, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dist = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double 0x7FF0000000000000, ptr %dist, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %out_path = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 9 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %out_path, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'_ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %known = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i8 0, ptr %known, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dist = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store double 0x7FF0000000000000, ptr %dist, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %out_path = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store ptr null, ptr %out_path, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 40

-----------------Function that is being costed:'_ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %known = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i8 0, ptr %known, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dist = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store double 0x7FF0000000000000, ptr %dist, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %out_path = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store ptr null, ptr %out_path, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 39

-----------------Function that is being costed:'_ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %known = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   store i8 0, ptr %known, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dist = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   store double 0x7FF0000000000000, ptr %dist, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %out_path = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   store ptr null, ptr %out_path, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 39

-----------------Function that is being costed:'_ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %known = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 208 for VF 16 For instruction:   store i8 0, ptr %known, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dist = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 208 for VF 16 For instruction:   store double 0x7FF0000000000000, ptr %dist, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %out_path = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 208 for VF 16 For instruction:   store ptr null, ptr %out_path, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 39

-----------------Function that is being costed:'_ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %known = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 0, ptr %known, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dist = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double 0x7FF0000000000000, ptr %dist, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %out_path = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %out_path, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176

-----------------Function that is being costed:'_ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE' from libs/sim/ctopo.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %known = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 0, ptr %known, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dist = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double 0x7FF0000000000000, ptr %dist, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %out_path = getelementptr inbounds %"class.cTopology::Node", ptr %3, i64 %indvars.iv, i32 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr null, ptr %out_path, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
RTCostA: 67108863899, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 67108863899, RTCostB: 17179869176
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN9cTopology31unweightedSingleShortestPathsToEPNS_4NodeE at line: libs/sim/ctopo.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%known> = getelementptr inbounds ir<%3>, vp<%4>, ir<7>
    CLONE store ir<0>, ir<%known>
    CLONE ir<%dist> = getelementptr inbounds ir<%3>, vp<%4>, ir<8>
    CLONE store ir<0x7FF0000000000000>, ir<%dist>
    CLONE ir<%out_path> = getelementptr inbounds ir<%3>, vp<%4>, ir<9>
    CLONE store ir<null>, ir<%out_path>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/random.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/random.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/sim/std/netpack.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/sim/std/netpack.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o libs/spec/spec_qsort.o -DSPEC_CPU -DNDEBUG -I. -Iomnet_include -Ilibs/envir   -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           libs/spec/spec_qsort.cc
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %l.addr.07 = phi %dec, %l, ir<-1>
    EMIT ir<%b.06> = WIDEN-POINTER-INDUCTION ir<%y>, 1
    EMIT ir<%a.05> = WIDEN-POINTER-INDUCTION ir<%x>, 1
    CLONE ir<%dec> = add ir<%l.addr.07>, ir<-1>
    CLONE ir<%0> = load ir<%a.05>
    CLONE ir<%1> = load ir<%b.06>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%a.05>, ir<1>
    CLONE store ir<%1>, ir<%a.05>
    CLONE ir<%incdec.ptr1> = getelementptr inbounds ir<%b.06>, ir<1>
    CLONE store ir<%0>, ir<%b.06>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %l.addr.07 = phi %dec, %l, ir<-1>
    EMIT ir<%b.06> = WIDEN-POINTER-INDUCTION ir<%y>, 1
    EMIT ir<%a.05> = WIDEN-POINTER-INDUCTION ir<%x>, 1
    CLONE ir<%dec> = add ir<%l.addr.07>, ir<-1>
    vp<%3> = vector-pointer ir<%a.05>
    WIDEN ir<%0> = load vp<%3>
    vp<%4> = vector-pointer ir<%b.06>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%a.05>, ir<1>
    vp<%5> = vector-pointer ir<%a.05>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%incdec.ptr1> = getelementptr inbounds ir<%b.06>, ir<1>
    vp<%6> = vector-pointer ir<%b.06>
    WIDEN store vp<%6>, ir<%0>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %l.addr.07 = phi %dec, %l, ir<-1>
    EMIT ir<%b.06> = WIDEN-POINTER-INDUCTION ir<%y>, 1
    EMIT ir<%a.05> = WIDEN-POINTER-INDUCTION ir<%x>, 1
    CLONE ir<%dec> = add ir<%l.addr.07>, ir<-1>
    vp<%3> = vector-pointer ir<%a.05>
    WIDEN ir<%0> = load vp<%3>
    vp<%4> = vector-pointer ir<%b.06>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%a.05>, ir<1>
    vp<%5> = vector-pointer ir<%a.05>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%incdec.ptr1> = getelementptr inbounds ir<%b.06>, ir<1>
    vp<%6> = vector-pointer ir<%b.06>
    WIDEN store vp<%6>, ir<%0>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 40
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'_ZL9spec_swapPvS_m' from libs/spec/spec_qsort.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 320
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: _ZL9spec_swapPvS_m at line: libs/spec/spec_qsort.cc
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: _ZL9spec_swapPvS_m at line: libs/spec/spec_qsort.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%y>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%x>, vp<%5>
    vp<%7> = vector-pointer vp<%6>
    WIDEN ir<%0> = load vp<%7>
    vp<%8> = vector-pointer vp<%4>
    WIDEN ir<%1> = load vp<%8>
    vp<%9> = vector-pointer vp<%6>
    WIDEN store vp<%9>, ir<%1>
    vp<%10> = vector-pointer vp<%4>
    WIDEN store vp<%10>, ir<%0>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: _ZL9spec_swapPvS_m at line: libs/spec/spec_qsort.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%y>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%x>, vp<%5>
    vp<%7> = vector-pointer vp<%6>
    WIDEN ir<%35> = load vp<%7>
    vp<%8> = vector-pointer vp<%4>
    WIDEN ir<%36> = load vp<%8>
    vp<%9> = vector-pointer vp<%6>
    WIDEN store vp<%9>, ir<%36>
    vp<%10> = vector-pointer vp<%4>
    WIDEN store vp<%10>, ir<%35>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration     -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           EtherAppCli.o EtherAppCli_n.o EtherAppSrv.o EtherAppSrv_n.o EtherApp_m.o EtherBus.o EtherBus_n.o EtherCtrl_m.o EtherEncap.o EtherEncap_n.o EtherFrame_m.o EtherHost_n.o EtherHub.o EtherHub_n.o EtherLLC.o EtherLLC_n.o EtherMAC.o EtherMAC_n.o EtherSwitch_n.o LargeNet_n.o MACAddress.o MACAddress_m.o MACRelayUnitBase.o MACRelayUnitNP.o MACRelayUnitNP_n.o MACRelayUnitPP.o MACRelayUnitPP_n.o MACRelayUnit_n.o Networks_n.o eth-index_n.o utils.o libs/cmdenv/cmdenv.o libs/cmdenv/enumstr.o libs/cmdenv/heap.o libs/envir/akoutvectormgr.o libs/envir/args.o libs/envir/cenvir.o libs/envir/cinifile.o libs/envir/filemgrs.o libs/envir/main.o libs/envir/omnetapp.o libs/envir/patmatch.o libs/envir/platdep.o libs/envir/seeds.o libs/envir/slaveapp.o libs/envir/speedmtr.o libs/sim/carray.o libs/sim/cexception.o libs/sim/cmessage.o libs/sim/cpar.o libs/sim/ctypes.o libs/sim/task.o libs/sim/cchannel.o libs/sim/cfsm.o libs/sim/cmodule.o libs/sim/cpsquare.o libs/sim/cvarhist.o libs/sim/util.o libs/sim/ccoroutine.o libs/sim/cgate.o libs/sim/cmsgheap.o libs/sim/cqueue.o libs/sim/cwatch.o libs/sim/cdensity.o libs/sim/chead.o libs/sim/cnetmod.o libs/sim/csimul.o libs/sim/distrib.o libs/sim/cdetect.o libs/sim/chist.o libs/sim/cobject.o libs/sim/cstat.o libs/sim/errmsg.o libs/sim/cdispstr.o libs/sim/cksplit.o libs/sim/coutvect.o libs/sim/cstruct.o libs/sim/onstartup.o libs/sim/cenum.o libs/sim/cllist.o libs/sim/cpacket.o libs/sim/ctopo.o libs/sim/random.o libs/sim/std/netpack.o libs/spec/spec_qsort.o                     -o omnetpp
