/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o av.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         av.c
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%66> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi %66, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%add.ptr119>, ir<%indvars.iv>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx>
    CLONE ir<%tobool149.old.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%66>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.end150.loopexit>, scalar.ph

ir-bb<if.end150.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%66> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %66, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%add.ptr119>, ir<%indvars.iv>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%tobool149.old.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%66>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end150.loopexit>, scalar.ph

ir-bb<if.end150.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%66> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %66, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%add.ptr119>, ir<%indvars.iv>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%3>, ir<@PL_sv_undef>
    CLONE ir<%tobool149.old.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%66>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end150.loopexit>, scalar.ph

ir-bb<if.end150.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %66, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr ptr, ptr %add.ptr119, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool149.old.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool149.old.not, label %if.end150.loopexit, label %while.body of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %66, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr ptr, ptr %add.ptr119, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool149.old.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool149.old.not, label %if.end150.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %66, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr ptr, ptr %add.ptr119, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool149.old.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool149.old.not, label %if.end150.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %66, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr ptr, ptr %add.ptr119, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool149.old.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool149.old.not, label %if.end150.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %66, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr ptr, ptr %add.ptr119, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool149.old.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool149.old.not, label %if.end150.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: vscale x 1, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_av_extend at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%66> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3>    = DERIVED-IV ir<%66> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%add.ptr119>, vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%5>, ir<@PL_sv_undef>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%66>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end150.loopexit>, scalar.ph

ir-bb<if.end150.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx280, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx280, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx280, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx280, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body277.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %tmp108.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv398 = phi %110, %indvars.iv.next399, ir<-1>
    CLONE ir<%indvars.iv.next399> = add nsw ir<%indvars.iv398>, ir<-1>
    CLONE ir<%arrayidx280> = getelementptr ir<%add.ptr228.pn>, ir<%indvars.iv398>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx280>
    CLONE ir<%tobool276.old.not> = icmp eq ir<%indvars.iv.next399>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end282.loopexit>, scalar.ph

ir-bb<if.end282.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body277.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %tmp108.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv398 = phi %110, %indvars.iv.next399, ir<-1>
    CLONE ir<%indvars.iv.next399> = add nsw ir<%indvars.iv398>, ir<-1>
    CLONE ir<%arrayidx280> = getelementptr ir<%add.ptr228.pn>, ir<%indvars.iv398>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx280>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%tobool276.old.not> = icmp eq ir<%indvars.iv.next399>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end282.loopexit>, scalar.ph

ir-bb<if.end282.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_extend' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body277.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %tmp108.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv398 = phi %110, %indvars.iv.next399, ir<-1>
    CLONE ir<%indvars.iv.next399> = add nsw ir<%indvars.iv398>, ir<-1>
    CLONE ir<%arrayidx280> = getelementptr ir<%add.ptr228.pn>, ir<%indvars.iv398>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx280>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%tobool276.old.not> = icmp eq ir<%indvars.iv.next399>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end282.loopexit>, scalar.ph

ir-bb<if.end282.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv398 = phi i64 [ %110, %while.body277.preheader ], [ %indvars.iv.next399, %while.body277 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next399 = add nsw i64 %indvars.iv398, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx280 = getelementptr ptr, ptr %add.ptr228.pn, i64 %indvars.iv398 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx280, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool276.old.not = icmp eq i64 %indvars.iv.next399, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool276.old.not, label %if.end282.loopexit, label %while.body277 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv398 = phi i64 [ %110, %while.body277.preheader ], [ %indvars.iv.next399, %while.body277 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next399 = add nsw i64 %indvars.iv398, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx280 = getelementptr ptr, ptr %add.ptr228.pn, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx280, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool276.old.not = icmp eq i64 %indvars.iv.next399, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool276.old.not, label %if.end282.loopexit, label %while.body277 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv398 = phi i64 [ %110, %while.body277.preheader ], [ %indvars.iv.next399, %while.body277 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next399 = add nsw i64 %indvars.iv398, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx280 = getelementptr ptr, ptr %add.ptr228.pn, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx280, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool276.old.not = icmp eq i64 %indvars.iv.next399, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool276.old.not, label %if.end282.loopexit, label %while.body277 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv398 = phi i64 [ %110, %while.body277.preheader ], [ %indvars.iv.next399, %while.body277 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next399 = add nsw i64 %indvars.iv398, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx280 = getelementptr ptr, ptr %add.ptr228.pn, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx280, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool276.old.not = icmp eq i64 %indvars.iv.next399, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool276.old.not, label %if.end282.loopexit, label %while.body277 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_extend' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv398 = phi i64 [ %110, %while.body277.preheader ], [ %indvars.iv.next399, %while.body277 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next399 = add nsw i64 %indvars.iv398, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx280 = getelementptr ptr, ptr %add.ptr228.pn, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx280, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool276.old.not = icmp eq i64 %indvars.iv.next399, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool276.old.not, label %if.end282.loopexit, label %while.body277 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: vscale x 1, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_av_extend at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body277.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %tmp108.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%110> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx280> = getelementptr ir<%add.ptr228.pn>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx280>
    WIDEN store vp<%6>, ir<@PL_sv_undef>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end282.loopexit>, scalar.ph

ir-bb<if.end282.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 6
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx133, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx133, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx133, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx133, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_av_fill' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body131.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 (trunc i64 %54 to i32) to i64))<nsw> + (-1 smax (sext i32 %fill to i64)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv206 = phi %59, %indvars.iv.next207, ir<1>
    CLONE ir<%indvars.iv.next207> = add nsw ir<%indvars.iv206>, ir<1>
    CLONE ir<%arrayidx133> = getelementptr inbounds ir<%55>, ir<%indvars.iv.next207>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx133>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next207>, ir<%conv108>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_fill' from av.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body131.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 (trunc i64 %54 to i32) to i64))<nsw> + (-1 smax (sext i32 %fill to i64)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv206 = phi %59, %indvars.iv.next207, ir<1>
    CLONE ir<%indvars.iv.next207> = add nsw ir<%indvars.iv206>, ir<1>
    CLONE ir<%arrayidx133> = getelementptr inbounds ir<%55>, ir<%indvars.iv.next207>
    vp<%4> = vector-pointer ir<%arrayidx133>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next207>, ir<%conv108>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_fill' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body131.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 (trunc i64 %54 to i32) to i64))<nsw> + (-1 smax (sext i32 %fill to i64)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv206 = phi %59, %indvars.iv.next207, ir<1>
    CLONE ir<%indvars.iv.next207> = add nsw ir<%indvars.iv206>, ir<1>
    CLONE ir<%arrayidx133> = getelementptr inbounds ir<%55>, ir<%indvars.iv.next207>
    vp<%4> = vector-pointer ir<%arrayidx133>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next207>, ir<%conv108>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_av_fill' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv206 = phi i64 [ %59, %while.body131.preheader ], [ %indvars.iv.next207, %while.body131 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next207 = add nsw i64 %indvars.iv206, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx133 = getelementptr inbounds ptr, ptr %55, i64 %indvars.iv.next207 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx133, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next207, %conv108 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end135.loopexit, label %while.body131 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'Perl_av_fill' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv206 = phi i64 [ %59, %while.body131.preheader ], [ %indvars.iv.next207, %while.body131 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next207 = add nsw i64 %indvars.iv206, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx133 = getelementptr inbounds ptr, ptr %55, i64 %indvars.iv.next207 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx133, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next207, %conv108 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end135.loopexit, label %while.body131 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_fill' from av.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv206 = phi i64 [ %59, %while.body131.preheader ], [ %indvars.iv.next207, %while.body131 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next207 = add nsw i64 %indvars.iv206, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx133 = getelementptr inbounds ptr, ptr %55, i64 %indvars.iv.next207 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx133, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next207, %conv108 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end135.loopexit, label %while.body131 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_av_fill' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv206 = phi i64 [ %59, %while.body131.preheader ], [ %indvars.iv.next207, %while.body131 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next207 = add nsw i64 %indvars.iv206, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx133 = getelementptr inbounds ptr, ptr %55, i64 %indvars.iv.next207 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx133, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next207, %conv108 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end135.loopexit, label %while.body131 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_av_fill' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv206 = phi i64 [ %59, %while.body131.preheader ], [ %indvars.iv.next207, %while.body131 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next207 = add nsw i64 %indvars.iv206, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx133 = getelementptr inbounds ptr, ptr %55, i64 %indvars.iv.next207 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx133, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next207, %conv108 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end135.loopexit, label %while.body131 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_av_fill at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body131.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 (trunc i64 %54 to i32) to i64))<nsw> + (-1 smax (sext i32 %fill to i64)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%59> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next207> = add nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx133> = getelementptr inbounds ir<%55>, ir<%indvars.iv.next207>
    vp<%6> = vector-pointer ir<%arrayidx133>
    WIDEN store vp<%6>, ir<@PL_sv_undef>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr @PL_sv_undef, ptr %incdec.ptr54, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr @PL_sv_undef, ptr %incdec.ptr54, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr @PL_sv_undef, ptr %incdec.ptr54, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr @PL_sv_undef, ptr %incdec.ptr54, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %num.addr.0275 = phi %dec, %num, ir<-1>
    EMIT ir<%sp.1274> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr51>, 8
    CLONE ir<%dec> = add nsw ir<%num.addr.0275>, ir<-1>
    CLONE ir<%incdec.ptr54> = getelementptr inbounds ir<%sp.1274>, ir<8>
    CLONE store ir<@PL_sv_undef>, ir<%incdec.ptr54>
    CLONE ir<%cmp52> = icmp ugt ir<%num.addr.0275>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr54.lcssa = ir<%incdec.ptr54>
}

========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %num.addr.0275 = phi %dec, %num, ir<-1>
    EMIT ir<%sp.1274> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr51>, 8
    CLONE ir<%dec> = add nsw ir<%num.addr.0275>, ir<-1>
    CLONE ir<%incdec.ptr54> = getelementptr inbounds ir<%sp.1274>, ir<8>
    vp<%4> = vector-pointer ir<%incdec.ptr54>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%cmp52> = icmp ugt ir<%num.addr.0275>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr54.lcssa = ir<%incdec.ptr54>
}

========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %num.addr.0275 = phi %dec, %num, ir<-1>
    EMIT ir<%sp.1274> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr51>, 8
    CLONE ir<%dec> = add nsw ir<%num.addr.0275>, ir<-1>
    CLONE ir<%incdec.ptr54> = getelementptr inbounds ir<%sp.1274>, ir<8>
    vp<%4> = vector-pointer ir<%incdec.ptr54>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%cmp52> = icmp ugt ir<%num.addr.0275>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr54.lcssa = ir<%incdec.ptr54>
}


-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %num.addr.0275 = phi i32 [ %dec, %while.body ], [ %num, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sp.1274 = phi ptr [ %incdec.ptr54, %while.body ], [ %incdec.ptr51, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %num.addr.0275, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr54 = getelementptr inbounds i8, ptr %sp.1274, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %incdec.ptr54, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp52 = icmp ugt i32 %num.addr.0275, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp52, label %while.body, label %while.end.loopexit of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %num.addr.0275 = phi i32 [ %dec, %while.body ], [ %num, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sp.1274 = phi ptr [ %incdec.ptr54, %while.body ], [ %incdec.ptr51, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %num.addr.0275, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr54 = getelementptr inbounds i8, ptr %sp.1274, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %incdec.ptr54, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp52 = icmp ugt i32 %num.addr.0275, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp52, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 12884901885
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 12884901885
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %num.addr.0275 = phi i32 [ %dec, %while.body ], [ %num, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sp.1274 = phi ptr [ %incdec.ptr54, %while.body ], [ %incdec.ptr51, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %num.addr.0275, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr54 = getelementptr inbounds i8, ptr %sp.1274, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr @PL_sv_undef, ptr %incdec.ptr54, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp52 = icmp ugt i32 %num.addr.0275, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp52, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967301, RTCostB: 12884901885
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967301, RTCostB: 6442450944
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %num.addr.0275 = phi i32 [ %dec, %while.body ], [ %num, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sp.1274 = phi ptr [ %incdec.ptr54, %while.body ], [ %incdec.ptr51, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %num.addr.0275, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr54 = getelementptr inbounds i8, ptr %sp.1274, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %incdec.ptr54, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp52 = icmp ugt i32 %num.addr.0275, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp52, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 12884901885
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 4294967301

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %num.addr.0275 = phi i32 [ %dec, %while.body ], [ %num, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sp.1274 = phi ptr [ %incdec.ptr54, %while.body ], [ %incdec.ptr51, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %num.addr.0275, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr54 = getelementptr inbounds i8, ptr %sp.1274, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %incdec.ptr54, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp52 = icmp ugt i32 %num.addr.0275, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp52, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967301, RTCostB: 12884901885
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967301, RTCostB: 4294967301
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_av_unshift at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%incdec.ptr51>, vp<%5>
    CLONE ir<%incdec.ptr54> = getelementptr inbounds vp<%6>, ir<8>
    vp<%7> = vector-pointer ir<%incdec.ptr54>
    WIDEN store vp<%7>, ir<@PL_sv_undef>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr54.lcssa = ir<%incdec.ptr54>
}
================ Final VPlan ================

@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then151>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (0 smax (trunc i64 %74 to i32)) to i64) + (sext i32 %num.addr.1272 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %81, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%78>, ir<%indvars.iv.next>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx>
    CLONE ir<%tobool174.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then151>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (0 smax (trunc i64 %74 to i32)) to i64) + (sext i32 %num.addr.1272 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %81, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%78>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%tobool174.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_av_unshift' from av.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then151>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (0 smax (trunc i64 %74 to i32)) to i64) + (sext i32 %num.addr.1272 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %81, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%78>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%tobool174.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body ], [ %81, %if.then151 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %78, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool174.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool174.not, label %do.end, label %do.body of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body ], [ %81, %if.then151 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %78, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool174.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool174.not, label %do.end, label %do.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body ], [ %81, %if.then151 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %78, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool174.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool174.not, label %do.end, label %do.body of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body ], [ %81, %if.then151 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %78, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool174.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool174.not, label %do.end, label %do.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_av_unshift' from av.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body ], [ %81, %if.then151 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %78, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool174.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool174.not, label %do.end, label %do.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: vscale x 1, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_av_unshift at line: av.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then151>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (0 smax (trunc i64 %74 to i32)) to i64) + (sext i32 %num.addr.1272 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%81> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%78>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%6>, ir<@PL_sv_undef>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 15
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o deb.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         deb.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o doio.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         doio.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o doop.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         doop.c
@@ Instruction =>  %12 = load i8, ptr %s.067, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %s.067, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %s.067, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %s.067, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %s.067, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %s.067, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: S_do_trans_count' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond to i64)) + ((1 + (ptrtoint ptr %cond to i64)) umax ((ptrtoint ptr %cond to i64) + %8)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.067> = WIDEN-POINTER-INDUCTION ir<%cond>, 1
    WIDEN-REDUCTION-PHI ir<%matches.066> = phi ir<0>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.067>, ir<1>
    CLONE ir<%12> = load ir<%s.067>
    CLONE ir<%idxprom> = zext ir<%12>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%idxprom>
    CLONE ir<%13> = load ir<%arrayidx>
    CLONE ir<%cmp1160> = icmp sgt ir<%13>, ir<-1>
    CLONE ir<%inc> = zext ir<%cmp1160>
    CLONE ir<%spec.select> = add ir<%matches.066>, ir<%inc>
    CLONE ir<%cmp8> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%matches.066>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end38.loopexit>, scalar.ph

ir-bb<if.end38.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%6>
}

========== Loop: S_do_trans_count' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond to i64)) + ((1 + (ptrtoint ptr %cond to i64)) umax ((ptrtoint ptr %cond to i64) + %8)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.067> = WIDEN-POINTER-INDUCTION ir<%cond>, 1
    WIDEN-REDUCTION-PHI ir<%matches.066> = phi ir<0>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.067>, ir<1>
    vp<%4> = vector-pointer ir<%s.067>
    WIDEN ir<%12> = load vp<%4>
    WIDEN-CAST ir<%idxprom> = zext  ir<%12> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%idxprom>
    WIDEN ir<%13> = load ir<%arrayidx>
    WIDEN ir<%cmp1160> = icmp sgt ir<%13>, ir<-1>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1160> to i32
    WIDEN ir<%spec.select> = add ir<%matches.066>, ir<%inc>
    CLONE ir<%cmp8> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%matches.066>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end38.loopexit>, scalar.ph

ir-bb<if.end38.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}

========== Loop: S_do_trans_count' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond to i64)) + ((1 + (ptrtoint ptr %cond to i64)) umax ((ptrtoint ptr %cond to i64) + %8)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.067> = WIDEN-POINTER-INDUCTION ir<%cond>, 1
    WIDEN-REDUCTION-PHI ir<%matches.066> = phi ir<0>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.067>, ir<1>
    vp<%4> = vector-pointer ir<%s.067>
    WIDEN ir<%12> = load vp<%4>
    WIDEN-CAST ir<%idxprom> = zext  ir<%12> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%idxprom>
    WIDEN ir<%13> = load ir<%arrayidx>
    WIDEN ir<%cmp1160> = icmp sgt ir<%13>, ir<-1>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1160> to i32
    WIDEN ir<%spec.select> = add ir<%matches.066>, ir<%inc>
    CLONE ir<%cmp8> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%matches.066>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end38.loopexit>, scalar.ph

ir-bb<if.end38.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}


-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.067 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %matches.066 = phi i32 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.067, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %12 = load i8, ptr %s.067, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %13 = load i16, ptr %arrayidx, align 2 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1160 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = zext i1 %cmp1160 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add nuw nsw i32 %matches.066, %inc of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp8 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp8, label %while.body, label %if.end38.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.067 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %matches.066 = phi i32 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.067, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %12 = load i8, ptr %s.067, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %13 = load i16, ptr %arrayidx, align 2 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1160 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %inc = zext i1 %cmp1160 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add nuw nsw i32 %matches.066, %inc of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp8 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp8, label %while.body, label %if.end38.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.067 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %matches.066 = phi i32 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.067, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %12 = load i8, ptr %s.067, align 1 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %13 = load i16, ptr %arrayidx, align 2 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1160 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc = zext i1 %cmp1160 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = add nuw nsw i32 %matches.066, %inc of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp8 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp8, label %while.body, label %if.end38.loopexit of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.067 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %matches.066 = phi i32 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.067, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %12 = load i8, ptr %s.067, align 1 of type:load
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %13 = load i16, ptr %arrayidx, align 2 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp1160 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 4 for VF 8 For instruction:   %inc = zext i1 %cmp1160 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select = add nuw nsw i32 %matches.066, %inc of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp8 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp8, label %while.body, label %if.end38.loopexit of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 21
B VF: 4, EstimatedWidthB: 4, CostB: 12
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.067 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %matches.066 = phi i32 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.067, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %12 = load i8, ptr %s.067, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %13 = load i16, ptr %arrayidx, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1160 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %inc = zext i1 %cmp1160 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = add nuw nsw i32 %matches.066, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp8 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp8, label %while.body, label %if.end38.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 9
B VF: 8, EstimatedWidthB: 8, CostB: 21
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 42

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.067 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %matches.066 = phi i32 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.067, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %12 = load i8, ptr %s.067, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %13 = load i16, ptr %arrayidx, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1160 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc = zext i1 %cmp1160 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add nuw nsw i32 %matches.066, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp8 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp8, label %while.body, label %if.end38.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 12
B VF: 8, EstimatedWidthB: 8, CostB: 21
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 84

-----------------Function that is being costed:'S_do_trans_count' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.067 = phi ptr [ %incdec.ptr, %while.body ], [ %cond, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %matches.066 = phi i32 [ %spec.select, %while.body ], [ 0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.067, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %12 = load i8, ptr %s.067, align 1 of type:load
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %idxprom = zext i8 %12 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %13 = load i16, ptr %arrayidx, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp1160 = icmp sgt i16 %13, -1 of type:icmp
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %inc = zext i1 %cmp1160 to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %spec.select = add nuw nsw i32 %matches.066, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp8 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp8, label %while.body, label %if.end38.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 21
B VF: 8, EstimatedWidthB: 8, CostB: 21
CostA * EstimatedWidthB: 168, CostB * EstimatedWidthA: 168
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: S_do_trans_count at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond to i64)) + ((1 + (ptrtoint ptr %cond to i64)) umax ((ptrtoint ptr %cond to i64) + %8)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%matches.066> = phi ir<0>, ir<%spec.select>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%cond>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%12> = load vp<%6>
    WIDEN-CAST ir<%idxprom> = zext  ir<%12> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%idxprom>
    WIDEN ir<%13> = load ir<%arrayidx>
    WIDEN ir<%cmp1160> = icmp sgt ir<%13>, ir<-1>
    WIDEN-CAST ir<%inc> = zext  ir<%cmp1160> to i32
    WIDEN ir<%spec.select> = add ir<%matches.066>, ir<%inc>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%matches.066>, ir<%spec.select>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end38.loopexit>, scalar.ph

ir-bb<if.end38.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body355.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.2687> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.2686> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.2685> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.2684 = phi %dec353, %conv308, ir<-1>
    CLONE ir<%dec353> = add nsw ir<%len.2684>, ir<-1>
    CLONE ir<%incdec.ptr356> = getelementptr inbounds ir<%ll.2686>, ir<8>
    CLONE ir<%80> = load ir<%ll.2686>
    CLONE ir<%incdec.ptr357> = getelementptr inbounds ir<%rl.2685>, ir<8>
    CLONE ir<%81> = load ir<%rl.2685>
    CLONE ir<%or358> = or ir<%81>, ir<%80>
    CLONE ir<%incdec.ptr359> = getelementptr inbounds ir<%dl.2687>, ir<8>
    CLONE store ir<%or358>, ir<%dl.2687>
    CLONE ir<%incdec.ptr360> = getelementptr inbounds ir<%ll.2686>, ir<16>
    CLONE ir<%82> = load ir<%incdec.ptr356>
    CLONE ir<%incdec.ptr361> = getelementptr inbounds ir<%rl.2685>, ir<16>
    CLONE ir<%83> = load ir<%incdec.ptr357>
    CLONE ir<%or362> = or ir<%83>, ir<%82>
    CLONE ir<%incdec.ptr363> = getelementptr inbounds ir<%dl.2687>, ir<16>
    CLONE store ir<%or362>, ir<%incdec.ptr359>
    CLONE ir<%incdec.ptr364> = getelementptr inbounds ir<%ll.2686>, ir<24>
    CLONE ir<%84> = load ir<%incdec.ptr360>
    CLONE ir<%incdec.ptr365> = getelementptr inbounds ir<%rl.2685>, ir<24>
    CLONE ir<%85> = load ir<%incdec.ptr361>
    CLONE ir<%or366> = or ir<%85>, ir<%84>
    CLONE ir<%incdec.ptr367> = getelementptr inbounds ir<%dl.2687>, ir<24>
    CLONE store ir<%or366>, ir<%incdec.ptr363>
    CLONE ir<%incdec.ptr368> = getelementptr inbounds ir<%ll.2686>, ir<32>
    CLONE ir<%86> = load ir<%incdec.ptr364>
    CLONE ir<%incdec.ptr369> = getelementptr inbounds ir<%rl.2685>, ir<32>
    CLONE ir<%87> = load ir<%incdec.ptr365>
    CLONE ir<%or370> = or ir<%87>, ir<%86>
    CLONE ir<%incdec.ptr371> = getelementptr inbounds ir<%dl.2687>, ir<32>
    CLONE store ir<%or370>, ir<%incdec.ptr367>
    CLONE ir<%tobool354.not> = icmp eq ir<%dec353>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end375.loopexit796>, scalar.ph

ir-bb<if.end375.loopexit796>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr368.lcssa = ir<%incdec.ptr368>
Live-out ptr %incdec.ptr369.lcssa = ir<%incdec.ptr369>
Live-out ptr %incdec.ptr371.lcssa = ir<%incdec.ptr371>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body355.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.2687> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.2686> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.2685> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.2684 = phi %dec353, %conv308, ir<-1>
    CLONE ir<%dec353> = add nsw ir<%len.2684>, ir<-1>
    CLONE ir<%incdec.ptr356> = getelementptr inbounds ir<%ll.2686>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %80, ir<%ll.2686>
      ir<%80> = load from index 0
      ir<%82> = load from index 1
      ir<%84> = load from index 2
      ir<%86> = load from index 3
    CLONE ir<%incdec.ptr357> = getelementptr inbounds ir<%rl.2685>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %81, ir<%rl.2685>
      ir<%81> = load from index 0
      ir<%83> = load from index 1
      ir<%85> = load from index 2
      ir<%87> = load from index 3
    WIDEN ir<%or358> = or ir<%81>, ir<%80>
    CLONE ir<%incdec.ptr359> = getelementptr inbounds ir<%dl.2687>, ir<8>
    CLONE ir<%incdec.ptr360> = getelementptr inbounds ir<%ll.2686>, ir<16>
    CLONE ir<%incdec.ptr361> = getelementptr inbounds ir<%rl.2685>, ir<16>
    WIDEN ir<%or362> = or ir<%83>, ir<%82>
    CLONE ir<%incdec.ptr363> = getelementptr inbounds ir<%dl.2687>, ir<16>
    CLONE ir<%incdec.ptr364> = getelementptr inbounds ir<%ll.2686>, ir<24>
    CLONE ir<%incdec.ptr365> = getelementptr inbounds ir<%rl.2685>, ir<24>
    WIDEN ir<%or366> = or ir<%85>, ir<%84>
    CLONE ir<%incdec.ptr367> = getelementptr inbounds ir<%dl.2687>, ir<24>
    CLONE ir<%incdec.ptr368> = getelementptr inbounds ir<%ll.2686>, ir<32>
    CLONE ir<%incdec.ptr369> = getelementptr inbounds ir<%rl.2685>, ir<32>
    WIDEN ir<%or370> = or ir<%87>, ir<%86>
    CLONE ir<%incdec.ptr371> = getelementptr inbounds ir<%dl.2687>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr367>
      store ir<%or358> to index 0
      store ir<%or362> to index 1
      store ir<%or366> to index 2
      store ir<%or370> to index 3
    CLONE ir<%tobool354.not> = icmp eq ir<%dec353>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end375.loopexit796>, scalar.ph

ir-bb<if.end375.loopexit796>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr368.lcssa = ir<%incdec.ptr368>
Live-out ptr %incdec.ptr369.lcssa = ir<%incdec.ptr369>
Live-out ptr %incdec.ptr371.lcssa = ir<%incdec.ptr371>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body355.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.2687> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.2686> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.2685> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.2684 = phi %dec353, %conv308, ir<-1>
    CLONE ir<%dec353> = add nsw ir<%len.2684>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr356> = getelementptr inbounds ir<%ll.2686>, ir<8>
    WIDEN ir<%80> = load ir<%ll.2686>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr357> = getelementptr inbounds ir<%rl.2685>, ir<8>
    WIDEN ir<%81> = load ir<%rl.2685>
    WIDEN ir<%or358> = or ir<%81>, ir<%80>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr359> = getelementptr inbounds ir<%dl.2687>, ir<8>
    WIDEN store ir<%dl.2687>, ir<%or358>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr360> = getelementptr inbounds ir<%ll.2686>, ir<16>
    WIDEN ir<%82> = load ir<%incdec.ptr356>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr361> = getelementptr inbounds ir<%rl.2685>, ir<16>
    WIDEN ir<%83> = load ir<%incdec.ptr357>
    WIDEN ir<%or362> = or ir<%83>, ir<%82>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr363> = getelementptr inbounds ir<%dl.2687>, ir<16>
    WIDEN store ir<%incdec.ptr359>, ir<%or362>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr364> = getelementptr inbounds ir<%ll.2686>, ir<24>
    WIDEN ir<%84> = load ir<%incdec.ptr360>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr365> = getelementptr inbounds ir<%rl.2685>, ir<24>
    WIDEN ir<%85> = load ir<%incdec.ptr361>
    WIDEN ir<%or366> = or ir<%85>, ir<%84>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr367> = getelementptr inbounds ir<%dl.2687>, ir<24>
    WIDEN store ir<%incdec.ptr363>, ir<%or366>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr368> = getelementptr inbounds ir<%ll.2686>, ir<32>
    WIDEN ir<%86> = load ir<%incdec.ptr364>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr369> = getelementptr inbounds ir<%rl.2685>, ir<32>
    WIDEN ir<%87> = load ir<%incdec.ptr365>
    WIDEN ir<%or370> = or ir<%87>, ir<%86>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr371> = getelementptr inbounds ir<%dl.2687>, ir<32>
    WIDEN store ir<%incdec.ptr367>, ir<%or370>
    CLONE ir<%tobool354.not> = icmp eq ir<%dec353>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end375.loopexit796>, scalar.ph

ir-bb<if.end375.loopexit796>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr368.lcssa = ir<%incdec.ptr368>
Live-out ptr %incdec.ptr369.lcssa = ir<%incdec.ptr369>
Live-out ptr %incdec.ptr371.lcssa = ir<%incdec.ptr371>
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dl.2687 = phi ptr [ %incdec.ptr371, %while.body355 ], [ %dc.2, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ll.2686 = phi ptr [ %incdec.ptr368, %while.body355 ], [ %cond, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rl.2685 = phi ptr [ %incdec.ptr369, %while.body355 ], [ %cond57, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.2684 = phi i32 [ %dec353, %while.body355 ], [ %conv308, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec353 = add nsw i32 %len.2684, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr356 = getelementptr inbounds i8, ptr %ll.2686, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %80 = load i64, ptr %ll.2686, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr357 = getelementptr inbounds i8, ptr %rl.2685, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %81 = load i64, ptr %rl.2685, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or358 = or i64 %81, %80 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr359 = getelementptr inbounds i8, ptr %dl.2687, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %or358, ptr %dl.2687, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr360 = getelementptr inbounds i8, ptr %ll.2686, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %82 = load i64, ptr %incdec.ptr356, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr361 = getelementptr inbounds i8, ptr %rl.2685, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %83 = load i64, ptr %incdec.ptr357, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or362 = or i64 %83, %82 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr363 = getelementptr inbounds i8, ptr %dl.2687, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %or362, ptr %incdec.ptr359, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr364 = getelementptr inbounds i8, ptr %ll.2686, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %84 = load i64, ptr %incdec.ptr360, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr365 = getelementptr inbounds i8, ptr %rl.2685, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %85 = load i64, ptr %incdec.ptr361, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or366 = or i64 %85, %84 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr367 = getelementptr inbounds i8, ptr %dl.2687, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %or366, ptr %incdec.ptr363, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr368 = getelementptr inbounds i8, ptr %ll.2686, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %86 = load i64, ptr %incdec.ptr364, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %rl.2685, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %87 = load i64, ptr %incdec.ptr365, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or370 = or i64 %87, %86 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr371 = getelementptr inbounds i8, ptr %dl.2687, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %or370, ptr %incdec.ptr367, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool354.not = icmp eq i32 %dec353, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool354.not, label %if.end375.loopexit796, label %while.body355 of type:br
LV: Scalar loop costs: 18.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dl.2687 = phi ptr [ %incdec.ptr371, %while.body355 ], [ %dc.2, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ll.2686 = phi ptr [ %incdec.ptr368, %while.body355 ], [ %cond, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rl.2685 = phi ptr [ %incdec.ptr369, %while.body355 ], [ %cond57, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.2684 = phi i32 [ %dec353, %while.body355 ], [ %conv308, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec353 = add nsw i32 %len.2684, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 2 For instruction:   %80 = load i64, ptr %ll.2686, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 2 For instruction:   %81 = load i64, ptr %rl.2685, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or358 = or i64 %81, %80 of type:or
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %or358, ptr %dl.2687, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %82 = load i64, ptr %incdec.ptr356, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %83 = load i64, ptr %incdec.ptr357, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or362 = or i64 %83, %82 of type:or
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %or362, ptr %incdec.ptr359, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %84 = load i64, ptr %incdec.ptr360, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %85 = load i64, ptr %incdec.ptr361, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or366 = or i64 %85, %84 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr367 = getelementptr inbounds i8, ptr %dl.2687, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %or366, ptr %incdec.ptr363, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr368 = getelementptr inbounds i8, ptr %ll.2686, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %86 = load i64, ptr %incdec.ptr364, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %rl.2685, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %87 = load i64, ptr %incdec.ptr365, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or370 = or i64 %87, %86 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr371 = getelementptr inbounds i8, ptr %dl.2687, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i64 %or370, ptr %incdec.ptr367, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool354.not = icmp eq i32 %dec353, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool354.not, label %if.end375.loopexit796, label %while.body355 of type:br
LV: Vector loop of width 2 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 45097156605, RTCostB: 77309411310
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 45097156605, RTCostB: 77309411310
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dl.2687 = phi ptr [ %incdec.ptr371, %while.body355 ], [ %dc.2, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ll.2686 = phi ptr [ %incdec.ptr368, %while.body355 ], [ %cond, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rl.2685 = phi ptr [ %incdec.ptr369, %while.body355 ], [ %cond57, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.2684 = phi i32 [ %dec353, %while.body355 ], [ %conv308, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec353 = add nsw i32 %len.2684, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 9 for VF 4 For instruction:   %80 = load i64, ptr %ll.2686, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 9 for VF 4 For instruction:   %81 = load i64, ptr %rl.2685, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or358 = or i64 %81, %80 of type:or
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 %or358, ptr %dl.2687, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %82 = load i64, ptr %incdec.ptr356, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %83 = load i64, ptr %incdec.ptr357, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or362 = or i64 %83, %82 of type:or
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 %or362, ptr %incdec.ptr359, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %84 = load i64, ptr %incdec.ptr360, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %85 = load i64, ptr %incdec.ptr361, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or366 = or i64 %85, %84 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr367 = getelementptr inbounds i8, ptr %dl.2687, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 %or366, ptr %incdec.ptr363, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr368 = getelementptr inbounds i8, ptr %ll.2686, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %86 = load i64, ptr %incdec.ptr364, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %rl.2685, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %87 = load i64, ptr %incdec.ptr365, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or370 = or i64 %87, %86 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr371 = getelementptr inbounds i8, ptr %dl.2687, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 9 for VF 4 For instruction:   store i64 %or370, ptr %incdec.ptr367, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool354.not = icmp eq i32 %dec353, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool354.not, label %if.end375.loopexit796, label %while.body355 of type:br
LV: Vector loop of width 4 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 39728447505, RTCostB: 77309411310
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 39728447505, RTCostB: 45097156605
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dl.2687 = phi ptr [ %incdec.ptr371, %while.body355 ], [ %dc.2, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ll.2686 = phi ptr [ %incdec.ptr368, %while.body355 ], [ %cond, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rl.2685 = phi ptr [ %incdec.ptr369, %while.body355 ], [ %cond57, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.2684 = phi i32 [ %dec353, %while.body355 ], [ %conv308, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec353 = add nsw i32 %len.2684, -1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 1 For instruction:   %80 = load i64, ptr %ll.2686, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 1 For instruction:   %81 = load i64, ptr %rl.2685, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or358 = or i64 %81, %80 of type:or
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %or358, ptr %dl.2687, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %82 = load i64, ptr %incdec.ptr356, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %83 = load i64, ptr %incdec.ptr357, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or362 = or i64 %83, %82 of type:or
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %or362, ptr %incdec.ptr359, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %84 = load i64, ptr %incdec.ptr360, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %85 = load i64, ptr %incdec.ptr361, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or366 = or i64 %85, %84 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr367 = getelementptr inbounds i8, ptr %dl.2687, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %or366, ptr %incdec.ptr363, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr368 = getelementptr inbounds i8, ptr %ll.2686, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %86 = load i64, ptr %incdec.ptr364, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %rl.2685, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %87 = load i64, ptr %incdec.ptr365, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or370 = or i64 %87, %86 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr371 = getelementptr inbounds i8, ptr %dl.2687, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 1 For instruction:   store i64 %or370, ptr %incdec.ptr367, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool354.not = icmp eq i32 %dec353, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool354.not, label %if.end375.loopexit796, label %while.body355 of type:br
LV: Vector loop of width vscale x 1 costs: 15
A is scalable.	B is not scalable.	
RTCostA: 64424509428, RTCostB: 77309411310
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 64424509428, RTCostB: 39728447505

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dl.2687 = phi ptr [ %incdec.ptr371, %while.body355 ], [ %dc.2, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ll.2686 = phi ptr [ %incdec.ptr368, %while.body355 ], [ %cond, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rl.2685 = phi ptr [ %incdec.ptr369, %while.body355 ], [ %cond57, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.2684 = phi i32 [ %dec353, %while.body355 ], [ %conv308, %while.body355.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec353 = add nsw i32 %len.2684, -1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 2 For instruction:   %80 = load i64, ptr %ll.2686, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 2 For instruction:   %81 = load i64, ptr %rl.2685, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or358 = or i64 %81, %80 of type:or
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %or358, ptr %dl.2687, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %82 = load i64, ptr %incdec.ptr356, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %83 = load i64, ptr %incdec.ptr357, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or362 = or i64 %83, %82 of type:or
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %or362, ptr %incdec.ptr359, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %84 = load i64, ptr %incdec.ptr360, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %85 = load i64, ptr %incdec.ptr361, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or366 = or i64 %85, %84 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr367 = getelementptr inbounds i8, ptr %dl.2687, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %or366, ptr %incdec.ptr363, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr368 = getelementptr inbounds i8, ptr %ll.2686, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %86 = load i64, ptr %incdec.ptr364, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %rl.2685, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %87 = load i64, ptr %incdec.ptr365, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or370 = or i64 %87, %86 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr371 = getelementptr inbounds i8, ptr %dl.2687, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 2 For instruction:   store i64 %or370, ptr %incdec.ptr367, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool354.not = icmp eq i32 %dec353, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool354.not, label %if.end375.loopexit796, label %while.body355 of type:br
LV: Vector loop of width vscale x 2 costs: 14
A is scalable.	B is not scalable.	
RTCostA: 62277025788, RTCostB: 77309411310
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 62277025788, RTCostB: 39728447505
LV: Selecting VF: 4 With Cost: 9.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=4, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body355.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<32>
    EMIT vp<%6> = ptradd ir<%dc.2>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<32>
    EMIT vp<%9> = ptradd ir<%cond>, vp<%8>
    vp<%10>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%11> = SCALAR-STEPS vp<%10>, ir<32>
    EMIT vp<%12> = ptradd ir<%cond57>, vp<%11>
    INTERLEAVE-GROUP with factor 4 at %84, vp<%9>
      ir<%84> = load from index 0
      ir<%86> = load from index 1
      ir<%88> = load from index 2
      ir<%90> = load from index 3
    INTERLEAVE-GROUP with factor 4 at %85, vp<%12>
      ir<%85> = load from index 0
      ir<%87> = load from index 1
      ir<%89> = load from index 2
      ir<%91> = load from index 3
    WIDEN ir<%or358> = or ir<%85>, ir<%84>
    WIDEN ir<%or362> = or ir<%87>, ir<%86>
    WIDEN ir<%or366> = or ir<%89>, ir<%88>
    CLONE ir<%incdec.ptr367> = getelementptr inbounds vp<%6>, ir<24>
    CLONE ir<%incdec.ptr368> = getelementptr inbounds vp<%9>, ir<32>
    CLONE ir<%incdec.ptr369> = getelementptr inbounds vp<%12>, ir<32>
    WIDEN ir<%or370> = or ir<%91>, ir<%90>
    CLONE ir<%incdec.ptr371> = getelementptr inbounds vp<%6>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr367>
      store ir<%or358> to index 0
      store ir<%or362> to index 1
      store ir<%or366> to index 2
      store ir<%or370> to index 3
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<if.end375.loopexit796>, scalar.ph

ir-bb<if.end375.loopexit796>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr368.lcssa = ir<%incdec.ptr368>
Live-out ptr %incdec.ptr369.lcssa = ir<%incdec.ptr369>
Live-out ptr %incdec.ptr371.lcssa = ir<%incdec.ptr371>
}
================ Final VPlan ================

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body333.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.1694> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.1693> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.1692> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.1691 = phi %dec331, %conv308, ir<-1>
    CLONE ir<%dec331> = add nsw ir<%len.1691>, ir<-1>
    CLONE ir<%incdec.ptr334> = getelementptr inbounds ir<%ll.1693>, ir<8>
    CLONE ir<%98> = load ir<%ll.1693>
    CLONE ir<%incdec.ptr335> = getelementptr inbounds ir<%rl.1692>, ir<8>
    CLONE ir<%99> = load ir<%rl.1692>
    CLONE ir<%xor336> = xor ir<%99>, ir<%98>
    CLONE ir<%incdec.ptr337> = getelementptr inbounds ir<%dl.1694>, ir<8>
    CLONE store ir<%xor336>, ir<%dl.1694>
    CLONE ir<%incdec.ptr338> = getelementptr inbounds ir<%ll.1693>, ir<16>
    CLONE ir<%100> = load ir<%incdec.ptr334>
    CLONE ir<%incdec.ptr339> = getelementptr inbounds ir<%rl.1692>, ir<16>
    CLONE ir<%101> = load ir<%incdec.ptr335>
    CLONE ir<%xor340> = xor ir<%101>, ir<%100>
    CLONE ir<%incdec.ptr341> = getelementptr inbounds ir<%dl.1694>, ir<16>
    CLONE store ir<%xor340>, ir<%incdec.ptr337>
    CLONE ir<%incdec.ptr342> = getelementptr inbounds ir<%ll.1693>, ir<24>
    CLONE ir<%102> = load ir<%incdec.ptr338>
    CLONE ir<%incdec.ptr343> = getelementptr inbounds ir<%rl.1692>, ir<24>
    CLONE ir<%103> = load ir<%incdec.ptr339>
    CLONE ir<%xor344> = xor ir<%103>, ir<%102>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds ir<%dl.1694>, ir<24>
    CLONE store ir<%xor344>, ir<%incdec.ptr341>
    CLONE ir<%incdec.ptr346> = getelementptr inbounds ir<%ll.1693>, ir<32>
    CLONE ir<%104> = load ir<%incdec.ptr342>
    CLONE ir<%incdec.ptr347> = getelementptr inbounds ir<%rl.1692>, ir<32>
    CLONE ir<%105> = load ir<%incdec.ptr343>
    CLONE ir<%xor348> = xor ir<%105>, ir<%104>
    CLONE ir<%incdec.ptr349> = getelementptr inbounds ir<%dl.1694>, ir<32>
    CLONE store ir<%xor348>, ir<%incdec.ptr345>
    CLONE ir<%tobool332.not> = icmp eq ir<%dec331>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end375.loopexit795>, scalar.ph

ir-bb<if.end375.loopexit795>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr346.lcssa = ir<%incdec.ptr346>
Live-out ptr %incdec.ptr347.lcssa = ir<%incdec.ptr347>
Live-out ptr %incdec.ptr349.lcssa = ir<%incdec.ptr349>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body333.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.1694> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.1693> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.1692> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.1691 = phi %dec331, %conv308, ir<-1>
    CLONE ir<%dec331> = add nsw ir<%len.1691>, ir<-1>
    CLONE ir<%incdec.ptr334> = getelementptr inbounds ir<%ll.1693>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %98, ir<%ll.1693>
      ir<%98> = load from index 0
      ir<%100> = load from index 1
      ir<%102> = load from index 2
      ir<%104> = load from index 3
    CLONE ir<%incdec.ptr335> = getelementptr inbounds ir<%rl.1692>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %99, ir<%rl.1692>
      ir<%99> = load from index 0
      ir<%101> = load from index 1
      ir<%103> = load from index 2
      ir<%105> = load from index 3
    WIDEN ir<%xor336> = xor ir<%99>, ir<%98>
    CLONE ir<%incdec.ptr337> = getelementptr inbounds ir<%dl.1694>, ir<8>
    CLONE ir<%incdec.ptr338> = getelementptr inbounds ir<%ll.1693>, ir<16>
    CLONE ir<%incdec.ptr339> = getelementptr inbounds ir<%rl.1692>, ir<16>
    WIDEN ir<%xor340> = xor ir<%101>, ir<%100>
    CLONE ir<%incdec.ptr341> = getelementptr inbounds ir<%dl.1694>, ir<16>
    CLONE ir<%incdec.ptr342> = getelementptr inbounds ir<%ll.1693>, ir<24>
    CLONE ir<%incdec.ptr343> = getelementptr inbounds ir<%rl.1692>, ir<24>
    WIDEN ir<%xor344> = xor ir<%103>, ir<%102>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds ir<%dl.1694>, ir<24>
    CLONE ir<%incdec.ptr346> = getelementptr inbounds ir<%ll.1693>, ir<32>
    CLONE ir<%incdec.ptr347> = getelementptr inbounds ir<%rl.1692>, ir<32>
    WIDEN ir<%xor348> = xor ir<%105>, ir<%104>
    CLONE ir<%incdec.ptr349> = getelementptr inbounds ir<%dl.1694>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr345>
      store ir<%xor336> to index 0
      store ir<%xor340> to index 1
      store ir<%xor344> to index 2
      store ir<%xor348> to index 3
    CLONE ir<%tobool332.not> = icmp eq ir<%dec331>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end375.loopexit795>, scalar.ph

ir-bb<if.end375.loopexit795>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr346.lcssa = ir<%incdec.ptr346>
Live-out ptr %incdec.ptr347.lcssa = ir<%incdec.ptr347>
Live-out ptr %incdec.ptr349.lcssa = ir<%incdec.ptr349>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body333.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.1694> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.1693> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.1692> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.1691 = phi %dec331, %conv308, ir<-1>
    CLONE ir<%dec331> = add nsw ir<%len.1691>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr334> = getelementptr inbounds ir<%ll.1693>, ir<8>
    WIDEN ir<%98> = load ir<%ll.1693>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr335> = getelementptr inbounds ir<%rl.1692>, ir<8>
    WIDEN ir<%99> = load ir<%rl.1692>
    WIDEN ir<%xor336> = xor ir<%99>, ir<%98>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr337> = getelementptr inbounds ir<%dl.1694>, ir<8>
    WIDEN store ir<%dl.1694>, ir<%xor336>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr338> = getelementptr inbounds ir<%ll.1693>, ir<16>
    WIDEN ir<%100> = load ir<%incdec.ptr334>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr339> = getelementptr inbounds ir<%rl.1692>, ir<16>
    WIDEN ir<%101> = load ir<%incdec.ptr335>
    WIDEN ir<%xor340> = xor ir<%101>, ir<%100>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr341> = getelementptr inbounds ir<%dl.1694>, ir<16>
    WIDEN store ir<%incdec.ptr337>, ir<%xor340>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr342> = getelementptr inbounds ir<%ll.1693>, ir<24>
    WIDEN ir<%102> = load ir<%incdec.ptr338>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr343> = getelementptr inbounds ir<%rl.1692>, ir<24>
    WIDEN ir<%103> = load ir<%incdec.ptr339>
    WIDEN ir<%xor344> = xor ir<%103>, ir<%102>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr345> = getelementptr inbounds ir<%dl.1694>, ir<24>
    WIDEN store ir<%incdec.ptr341>, ir<%xor344>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr346> = getelementptr inbounds ir<%ll.1693>, ir<32>
    WIDEN ir<%104> = load ir<%incdec.ptr342>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr347> = getelementptr inbounds ir<%rl.1692>, ir<32>
    WIDEN ir<%105> = load ir<%incdec.ptr343>
    WIDEN ir<%xor348> = xor ir<%105>, ir<%104>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr349> = getelementptr inbounds ir<%dl.1694>, ir<32>
    WIDEN store ir<%incdec.ptr345>, ir<%xor348>
    CLONE ir<%tobool332.not> = icmp eq ir<%dec331>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end375.loopexit795>, scalar.ph

ir-bb<if.end375.loopexit795>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr346.lcssa = ir<%incdec.ptr346>
Live-out ptr %incdec.ptr347.lcssa = ir<%incdec.ptr347>
Live-out ptr %incdec.ptr349.lcssa = ir<%incdec.ptr349>
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dl.1694 = phi ptr [ %incdec.ptr349, %while.body333 ], [ %dc.2, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ll.1693 = phi ptr [ %incdec.ptr346, %while.body333 ], [ %cond, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rl.1692 = phi ptr [ %incdec.ptr347, %while.body333 ], [ %cond57, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.1691 = phi i32 [ %dec331, %while.body333 ], [ %conv308, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec331 = add nsw i32 %len.1691, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr334 = getelementptr inbounds i8, ptr %ll.1693, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %98 = load i64, ptr %ll.1693, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr335 = getelementptr inbounds i8, ptr %rl.1692, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %99 = load i64, ptr %rl.1692, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor336 = xor i64 %99, %98 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr337 = getelementptr inbounds i8, ptr %dl.1694, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %xor336, ptr %dl.1694, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr338 = getelementptr inbounds i8, ptr %ll.1693, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %100 = load i64, ptr %incdec.ptr334, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr339 = getelementptr inbounds i8, ptr %rl.1692, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %101 = load i64, ptr %incdec.ptr335, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor340 = xor i64 %101, %100 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr341 = getelementptr inbounds i8, ptr %dl.1694, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %xor340, ptr %incdec.ptr337, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr342 = getelementptr inbounds i8, ptr %ll.1693, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %102 = load i64, ptr %incdec.ptr338, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr343 = getelementptr inbounds i8, ptr %rl.1692, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %103 = load i64, ptr %incdec.ptr339, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor344 = xor i64 %103, %102 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %dl.1694, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %xor344, ptr %incdec.ptr341, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr346 = getelementptr inbounds i8, ptr %ll.1693, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %104 = load i64, ptr %incdec.ptr342, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr347 = getelementptr inbounds i8, ptr %rl.1692, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %105 = load i64, ptr %incdec.ptr343, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor348 = xor i64 %105, %104 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr349 = getelementptr inbounds i8, ptr %dl.1694, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %xor348, ptr %incdec.ptr345, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool332.not = icmp eq i32 %dec331, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool332.not, label %if.end375.loopexit795, label %while.body333 of type:br
LV: Scalar loop costs: 18.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dl.1694 = phi ptr [ %incdec.ptr349, %while.body333 ], [ %dc.2, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ll.1693 = phi ptr [ %incdec.ptr346, %while.body333 ], [ %cond, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rl.1692 = phi ptr [ %incdec.ptr347, %while.body333 ], [ %cond57, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.1691 = phi i32 [ %dec331, %while.body333 ], [ %conv308, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec331 = add nsw i32 %len.1691, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 2 For instruction:   %98 = load i64, ptr %ll.1693, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 2 For instruction:   %99 = load i64, ptr %rl.1692, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor336 = xor i64 %99, %98 of type:xor
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %xor336, ptr %dl.1694, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %100 = load i64, ptr %incdec.ptr334, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %101 = load i64, ptr %incdec.ptr335, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor340 = xor i64 %101, %100 of type:xor
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %xor340, ptr %incdec.ptr337, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %102 = load i64, ptr %incdec.ptr338, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %103 = load i64, ptr %incdec.ptr339, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor344 = xor i64 %103, %102 of type:xor
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %dl.1694, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %xor344, ptr %incdec.ptr341, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr346 = getelementptr inbounds i8, ptr %ll.1693, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %104 = load i64, ptr %incdec.ptr342, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr347 = getelementptr inbounds i8, ptr %rl.1692, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %105 = load i64, ptr %incdec.ptr343, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor348 = xor i64 %105, %104 of type:xor
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr349 = getelementptr inbounds i8, ptr %dl.1694, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i64 %xor348, ptr %incdec.ptr345, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool332.not = icmp eq i32 %dec331, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool332.not, label %if.end375.loopexit795, label %while.body333 of type:br
LV: Vector loop of width 2 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 45097156605, RTCostB: 77309411310
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 45097156605, RTCostB: 77309411310
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dl.1694 = phi ptr [ %incdec.ptr349, %while.body333 ], [ %dc.2, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ll.1693 = phi ptr [ %incdec.ptr346, %while.body333 ], [ %cond, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rl.1692 = phi ptr [ %incdec.ptr347, %while.body333 ], [ %cond57, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.1691 = phi i32 [ %dec331, %while.body333 ], [ %conv308, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec331 = add nsw i32 %len.1691, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 9 for VF 4 For instruction:   %98 = load i64, ptr %ll.1693, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 9 for VF 4 For instruction:   %99 = load i64, ptr %rl.1692, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xor336 = xor i64 %99, %98 of type:xor
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 %xor336, ptr %dl.1694, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %100 = load i64, ptr %incdec.ptr334, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %101 = load i64, ptr %incdec.ptr335, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xor340 = xor i64 %101, %100 of type:xor
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 %xor340, ptr %incdec.ptr337, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %102 = load i64, ptr %incdec.ptr338, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %103 = load i64, ptr %incdec.ptr339, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xor344 = xor i64 %103, %102 of type:xor
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %dl.1694, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 %xor344, ptr %incdec.ptr341, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr346 = getelementptr inbounds i8, ptr %ll.1693, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %104 = load i64, ptr %incdec.ptr342, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr347 = getelementptr inbounds i8, ptr %rl.1692, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %105 = load i64, ptr %incdec.ptr343, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xor348 = xor i64 %105, %104 of type:xor
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr349 = getelementptr inbounds i8, ptr %dl.1694, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 9 for VF 4 For instruction:   store i64 %xor348, ptr %incdec.ptr345, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool332.not = icmp eq i32 %dec331, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool332.not, label %if.end375.loopexit795, label %while.body333 of type:br
LV: Vector loop of width 4 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 39728447505, RTCostB: 77309411310
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 39728447505, RTCostB: 45097156605
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dl.1694 = phi ptr [ %incdec.ptr349, %while.body333 ], [ %dc.2, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ll.1693 = phi ptr [ %incdec.ptr346, %while.body333 ], [ %cond, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rl.1692 = phi ptr [ %incdec.ptr347, %while.body333 ], [ %cond57, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.1691 = phi i32 [ %dec331, %while.body333 ], [ %conv308, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec331 = add nsw i32 %len.1691, -1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 1 For instruction:   %98 = load i64, ptr %ll.1693, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 1 For instruction:   %99 = load i64, ptr %rl.1692, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xor336 = xor i64 %99, %98 of type:xor
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %xor336, ptr %dl.1694, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %100 = load i64, ptr %incdec.ptr334, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %101 = load i64, ptr %incdec.ptr335, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xor340 = xor i64 %101, %100 of type:xor
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %xor340, ptr %incdec.ptr337, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %102 = load i64, ptr %incdec.ptr338, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %103 = load i64, ptr %incdec.ptr339, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xor344 = xor i64 %103, %102 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %dl.1694, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %xor344, ptr %incdec.ptr341, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr346 = getelementptr inbounds i8, ptr %ll.1693, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %104 = load i64, ptr %incdec.ptr342, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr347 = getelementptr inbounds i8, ptr %rl.1692, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %105 = load i64, ptr %incdec.ptr343, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xor348 = xor i64 %105, %104 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr349 = getelementptr inbounds i8, ptr %dl.1694, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 1 For instruction:   store i64 %xor348, ptr %incdec.ptr345, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool332.not = icmp eq i32 %dec331, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool332.not, label %if.end375.loopexit795, label %while.body333 of type:br
LV: Vector loop of width vscale x 1 costs: 15
A is scalable.	B is not scalable.	
RTCostA: 64424509428, RTCostB: 77309411310
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 64424509428, RTCostB: 39728447505

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dl.1694 = phi ptr [ %incdec.ptr349, %while.body333 ], [ %dc.2, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ll.1693 = phi ptr [ %incdec.ptr346, %while.body333 ], [ %cond, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rl.1692 = phi ptr [ %incdec.ptr347, %while.body333 ], [ %cond57, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.1691 = phi i32 [ %dec331, %while.body333 ], [ %conv308, %while.body333.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec331 = add nsw i32 %len.1691, -1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 2 For instruction:   %98 = load i64, ptr %ll.1693, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 2 For instruction:   %99 = load i64, ptr %rl.1692, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xor336 = xor i64 %99, %98 of type:xor
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %xor336, ptr %dl.1694, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %100 = load i64, ptr %incdec.ptr334, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %101 = load i64, ptr %incdec.ptr335, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xor340 = xor i64 %101, %100 of type:xor
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %xor340, ptr %incdec.ptr337, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %102 = load i64, ptr %incdec.ptr338, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %103 = load i64, ptr %incdec.ptr339, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xor344 = xor i64 %103, %102 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr345 = getelementptr inbounds i8, ptr %dl.1694, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %xor344, ptr %incdec.ptr341, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr346 = getelementptr inbounds i8, ptr %ll.1693, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %104 = load i64, ptr %incdec.ptr342, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr347 = getelementptr inbounds i8, ptr %rl.1692, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %105 = load i64, ptr %incdec.ptr343, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xor348 = xor i64 %105, %104 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr349 = getelementptr inbounds i8, ptr %dl.1694, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 2 For instruction:   store i64 %xor348, ptr %incdec.ptr345, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool332.not = icmp eq i32 %dec331, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool332.not, label %if.end375.loopexit795, label %while.body333 of type:br
LV: Vector loop of width vscale x 2 costs: 14
A is scalable.	B is not scalable.	
RTCostA: 62277025788, RTCostB: 77309411310
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 62277025788, RTCostB: 39728447505
LV: Selecting VF: 4 With Cost: 9.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=4, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body333.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<32>
    EMIT vp<%6> = ptradd ir<%dc.2>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<32>
    EMIT vp<%9> = ptradd ir<%cond>, vp<%8>
    vp<%10>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%11> = SCALAR-STEPS vp<%10>, ir<32>
    EMIT vp<%12> = ptradd ir<%cond57>, vp<%11>
    INTERLEAVE-GROUP with factor 4 at %102, vp<%9>
      ir<%102> = load from index 0
      ir<%104> = load from index 1
      ir<%106> = load from index 2
      ir<%108> = load from index 3
    INTERLEAVE-GROUP with factor 4 at %103, vp<%12>
      ir<%103> = load from index 0
      ir<%105> = load from index 1
      ir<%107> = load from index 2
      ir<%109> = load from index 3
    WIDEN ir<%xor336> = xor ir<%103>, ir<%102>
    WIDEN ir<%xor340> = xor ir<%105>, ir<%104>
    WIDEN ir<%xor344> = xor ir<%107>, ir<%106>
    CLONE ir<%incdec.ptr345> = getelementptr inbounds vp<%6>, ir<24>
    CLONE ir<%incdec.ptr346> = getelementptr inbounds vp<%9>, ir<32>
    CLONE ir<%incdec.ptr347> = getelementptr inbounds vp<%12>, ir<32>
    WIDEN ir<%xor348> = xor ir<%109>, ir<%108>
    CLONE ir<%incdec.ptr349> = getelementptr inbounds vp<%6>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr345>
      store ir<%xor336> to index 0
      store ir<%xor340> to index 1
      store ir<%xor344> to index 2
      store ir<%xor348> to index 3
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<if.end375.loopexit795>, scalar.ph

ir-bb<if.end375.loopexit795>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr346.lcssa = ir<%incdec.ptr346>
Live-out ptr %incdec.ptr347.lcssa = ir<%incdec.ptr347>
Live-out ptr %incdec.ptr349.lcssa = ir<%incdec.ptr349>
}
================ Final VPlan ================

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body312.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.0702> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.0701> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.0700> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.0699 = phi %dec, %conv308, ir<-1>
    CLONE ir<%dec> = add nsw ir<%len.0699>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%ll.0701>, ir<8>
    CLONE ir<%116> = load ir<%ll.0701>
    CLONE ir<%incdec.ptr313> = getelementptr inbounds ir<%rl.0700>, ir<8>
    CLONE ir<%117> = load ir<%rl.0700>
    CLONE ir<%and314> = and ir<%117>, ir<%116>
    CLONE ir<%incdec.ptr315> = getelementptr inbounds ir<%dl.0702>, ir<8>
    CLONE store ir<%and314>, ir<%dl.0702>
    CLONE ir<%incdec.ptr316> = getelementptr inbounds ir<%ll.0701>, ir<16>
    CLONE ir<%118> = load ir<%incdec.ptr>
    CLONE ir<%incdec.ptr317> = getelementptr inbounds ir<%rl.0700>, ir<16>
    CLONE ir<%119> = load ir<%incdec.ptr313>
    CLONE ir<%and318> = and ir<%119>, ir<%118>
    CLONE ir<%incdec.ptr319> = getelementptr inbounds ir<%dl.0702>, ir<16>
    CLONE store ir<%and318>, ir<%incdec.ptr315>
    CLONE ir<%incdec.ptr320> = getelementptr inbounds ir<%ll.0701>, ir<24>
    CLONE ir<%120> = load ir<%incdec.ptr316>
    CLONE ir<%incdec.ptr321> = getelementptr inbounds ir<%rl.0700>, ir<24>
    CLONE ir<%121> = load ir<%incdec.ptr317>
    CLONE ir<%and322> = and ir<%121>, ir<%120>
    CLONE ir<%incdec.ptr323> = getelementptr inbounds ir<%dl.0702>, ir<24>
    CLONE store ir<%and322>, ir<%incdec.ptr319>
    CLONE ir<%incdec.ptr324> = getelementptr inbounds ir<%ll.0701>, ir<32>
    CLONE ir<%122> = load ir<%incdec.ptr320>
    CLONE ir<%incdec.ptr325> = getelementptr inbounds ir<%rl.0700>, ir<32>
    CLONE ir<%123> = load ir<%incdec.ptr321>
    CLONE ir<%and326> = and ir<%123>, ir<%122>
    CLONE ir<%incdec.ptr327> = getelementptr inbounds ir<%dl.0702>, ir<32>
    CLONE store ir<%and326>, ir<%incdec.ptr323>
    CLONE ir<%tobool311.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end375.loopexit>, scalar.ph

ir-bb<if.end375.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr324.lcssa = ir<%incdec.ptr324>
Live-out ptr %incdec.ptr325.lcssa = ir<%incdec.ptr325>
Live-out ptr %incdec.ptr327.lcssa = ir<%incdec.ptr327>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body312.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.0702> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.0701> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.0700> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.0699 = phi %dec, %conv308, ir<-1>
    CLONE ir<%dec> = add nsw ir<%len.0699>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%ll.0701>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %116, ir<%ll.0701>
      ir<%116> = load from index 0
      ir<%118> = load from index 1
      ir<%120> = load from index 2
      ir<%122> = load from index 3
    CLONE ir<%incdec.ptr313> = getelementptr inbounds ir<%rl.0700>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %117, ir<%rl.0700>
      ir<%117> = load from index 0
      ir<%119> = load from index 1
      ir<%121> = load from index 2
      ir<%123> = load from index 3
    WIDEN ir<%and314> = and ir<%117>, ir<%116>
    CLONE ir<%incdec.ptr315> = getelementptr inbounds ir<%dl.0702>, ir<8>
    CLONE ir<%incdec.ptr316> = getelementptr inbounds ir<%ll.0701>, ir<16>
    CLONE ir<%incdec.ptr317> = getelementptr inbounds ir<%rl.0700>, ir<16>
    WIDEN ir<%and318> = and ir<%119>, ir<%118>
    CLONE ir<%incdec.ptr319> = getelementptr inbounds ir<%dl.0702>, ir<16>
    CLONE ir<%incdec.ptr320> = getelementptr inbounds ir<%ll.0701>, ir<24>
    CLONE ir<%incdec.ptr321> = getelementptr inbounds ir<%rl.0700>, ir<24>
    WIDEN ir<%and322> = and ir<%121>, ir<%120>
    CLONE ir<%incdec.ptr323> = getelementptr inbounds ir<%dl.0702>, ir<24>
    CLONE ir<%incdec.ptr324> = getelementptr inbounds ir<%ll.0701>, ir<32>
    CLONE ir<%incdec.ptr325> = getelementptr inbounds ir<%rl.0700>, ir<32>
    WIDEN ir<%and326> = and ir<%123>, ir<%122>
    CLONE ir<%incdec.ptr327> = getelementptr inbounds ir<%dl.0702>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr323>
      store ir<%and314> to index 0
      store ir<%and318> to index 1
      store ir<%and322> to index 2
      store ir<%and326> to index 3
    CLONE ir<%tobool311.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end375.loopexit>, scalar.ph

ir-bb<if.end375.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr324.lcssa = ir<%incdec.ptr324>
Live-out ptr %incdec.ptr325.lcssa = ir<%incdec.ptr325>
Live-out ptr %incdec.ptr327.lcssa = ir<%incdec.ptr327>
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body312.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dl.0702> = WIDEN-POINTER-INDUCTION ir<%dc.2>, 32
    EMIT ir<%ll.0701> = WIDEN-POINTER-INDUCTION ir<%cond>, 32
    EMIT ir<%rl.0700> = WIDEN-POINTER-INDUCTION ir<%cond57>, 32
    WIDEN-INDUCTION %len.0699 = phi %dec, %conv308, ir<-1>
    CLONE ir<%dec> = add nsw ir<%len.0699>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%ll.0701>, ir<8>
    WIDEN ir<%116> = load ir<%ll.0701>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr313> = getelementptr inbounds ir<%rl.0700>, ir<8>
    WIDEN ir<%117> = load ir<%rl.0700>
    WIDEN ir<%and314> = and ir<%117>, ir<%116>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr315> = getelementptr inbounds ir<%dl.0702>, ir<8>
    WIDEN store ir<%dl.0702>, ir<%and314>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr316> = getelementptr inbounds ir<%ll.0701>, ir<16>
    WIDEN ir<%118> = load ir<%incdec.ptr>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr317> = getelementptr inbounds ir<%rl.0700>, ir<16>
    WIDEN ir<%119> = load ir<%incdec.ptr313>
    WIDEN ir<%and318> = and ir<%119>, ir<%118>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr319> = getelementptr inbounds ir<%dl.0702>, ir<16>
    WIDEN store ir<%incdec.ptr315>, ir<%and318>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr320> = getelementptr inbounds ir<%ll.0701>, ir<24>
    WIDEN ir<%120> = load ir<%incdec.ptr316>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr321> = getelementptr inbounds ir<%rl.0700>, ir<24>
    WIDEN ir<%121> = load ir<%incdec.ptr317>
    WIDEN ir<%and322> = and ir<%121>, ir<%120>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr323> = getelementptr inbounds ir<%dl.0702>, ir<24>
    WIDEN store ir<%incdec.ptr319>, ir<%and322>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr324> = getelementptr inbounds ir<%ll.0701>, ir<32>
    WIDEN ir<%122> = load ir<%incdec.ptr320>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr325> = getelementptr inbounds ir<%rl.0700>, ir<32>
    WIDEN ir<%123> = load ir<%incdec.ptr321>
    WIDEN ir<%and326> = and ir<%123>, ir<%122>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr327> = getelementptr inbounds ir<%dl.0702>, ir<32>
    WIDEN store ir<%incdec.ptr323>, ir<%and326>
    CLONE ir<%tobool311.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end375.loopexit>, scalar.ph

ir-bb<if.end375.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr324.lcssa = ir<%incdec.ptr324>
Live-out ptr %incdec.ptr325.lcssa = ir<%incdec.ptr325>
Live-out ptr %incdec.ptr327.lcssa = ir<%incdec.ptr327>
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dl.0702 = phi ptr [ %incdec.ptr327, %while.body312 ], [ %dc.2, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ll.0701 = phi ptr [ %incdec.ptr324, %while.body312 ], [ %cond, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rl.0700 = phi ptr [ %incdec.ptr325, %while.body312 ], [ %cond57, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.0699 = phi i32 [ %dec, %while.body312 ], [ %conv308, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %len.0699, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %ll.0701, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %116 = load i64, ptr %ll.0701, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %rl.0700, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %117 = load i64, ptr %rl.0700, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and314 = and i64 %117, %116 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr315 = getelementptr inbounds i8, ptr %dl.0702, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %and314, ptr %dl.0702, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr316 = getelementptr inbounds i8, ptr %ll.0701, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %118 = load i64, ptr %incdec.ptr, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr317 = getelementptr inbounds i8, ptr %rl.0700, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %119 = load i64, ptr %incdec.ptr313, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and318 = and i64 %119, %118 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr319 = getelementptr inbounds i8, ptr %dl.0702, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %and318, ptr %incdec.ptr315, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr320 = getelementptr inbounds i8, ptr %ll.0701, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %120 = load i64, ptr %incdec.ptr316, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr321 = getelementptr inbounds i8, ptr %rl.0700, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %121 = load i64, ptr %incdec.ptr317, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and322 = and i64 %121, %120 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr323 = getelementptr inbounds i8, ptr %dl.0702, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %and322, ptr %incdec.ptr319, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr324 = getelementptr inbounds i8, ptr %ll.0701, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %122 = load i64, ptr %incdec.ptr320, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr325 = getelementptr inbounds i8, ptr %rl.0700, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %123 = load i64, ptr %incdec.ptr321, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and326 = and i64 %123, %122 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr327 = getelementptr inbounds i8, ptr %dl.0702, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %and326, ptr %incdec.ptr323, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool311.not, label %if.end375.loopexit, label %while.body312 of type:br
LV: Scalar loop costs: 18.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dl.0702 = phi ptr [ %incdec.ptr327, %while.body312 ], [ %dc.2, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ll.0701 = phi ptr [ %incdec.ptr324, %while.body312 ], [ %cond, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rl.0700 = phi ptr [ %incdec.ptr325, %while.body312 ], [ %cond57, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.0699 = phi i32 [ %dec, %while.body312 ], [ %conv308, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %len.0699, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 2 For instruction:   %116 = load i64, ptr %ll.0701, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 2 For instruction:   %117 = load i64, ptr %rl.0700, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and314 = and i64 %117, %116 of type:and
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %and314, ptr %dl.0702, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %118 = load i64, ptr %incdec.ptr, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %119 = load i64, ptr %incdec.ptr313, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and318 = and i64 %119, %118 of type:and
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %and318, ptr %incdec.ptr315, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %120 = load i64, ptr %incdec.ptr316, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %121 = load i64, ptr %incdec.ptr317, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and322 = and i64 %121, %120 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr323 = getelementptr inbounds i8, ptr %dl.0702, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 %and322, ptr %incdec.ptr319, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr324 = getelementptr inbounds i8, ptr %ll.0701, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %122 = load i64, ptr %incdec.ptr320, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr325 = getelementptr inbounds i8, ptr %rl.0700, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %123 = load i64, ptr %incdec.ptr321, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and326 = and i64 %123, %122 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr327 = getelementptr inbounds i8, ptr %dl.0702, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i64 %and326, ptr %incdec.ptr323, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool311.not, label %if.end375.loopexit, label %while.body312 of type:br
LV: Vector loop of width 2 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 45097156605, RTCostB: 77309411310
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 45097156605, RTCostB: 77309411310
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dl.0702 = phi ptr [ %incdec.ptr327, %while.body312 ], [ %dc.2, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ll.0701 = phi ptr [ %incdec.ptr324, %while.body312 ], [ %cond, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rl.0700 = phi ptr [ %incdec.ptr325, %while.body312 ], [ %cond57, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.0699 = phi i32 [ %dec, %while.body312 ], [ %conv308, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %len.0699, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 9 for VF 4 For instruction:   %116 = load i64, ptr %ll.0701, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 9 for VF 4 For instruction:   %117 = load i64, ptr %rl.0700, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and314 = and i64 %117, %116 of type:and
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 %and314, ptr %dl.0702, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %118 = load i64, ptr %incdec.ptr, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %119 = load i64, ptr %incdec.ptr313, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and318 = and i64 %119, %118 of type:and
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 %and318, ptr %incdec.ptr315, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %120 = load i64, ptr %incdec.ptr316, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %121 = load i64, ptr %incdec.ptr317, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and322 = and i64 %121, %120 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr323 = getelementptr inbounds i8, ptr %dl.0702, i64 24 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 %and322, ptr %incdec.ptr319, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr324 = getelementptr inbounds i8, ptr %ll.0701, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %122 = load i64, ptr %incdec.ptr320, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr325 = getelementptr inbounds i8, ptr %rl.0700, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %123 = load i64, ptr %incdec.ptr321, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and326 = and i64 %123, %122 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr327 = getelementptr inbounds i8, ptr %dl.0702, i64 32 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 9 for VF 4 For instruction:   store i64 %and326, ptr %incdec.ptr323, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool311.not, label %if.end375.loopexit, label %while.body312 of type:br
LV: Vector loop of width 4 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 39728447505, RTCostB: 77309411310
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 39728447505, RTCostB: 45097156605
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dl.0702 = phi ptr [ %incdec.ptr327, %while.body312 ], [ %dc.2, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ll.0701 = phi ptr [ %incdec.ptr324, %while.body312 ], [ %cond, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rl.0700 = phi ptr [ %incdec.ptr325, %while.body312 ], [ %cond57, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.0699 = phi i32 [ %dec, %while.body312 ], [ %conv308, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %len.0699, -1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 1 For instruction:   %116 = load i64, ptr %ll.0701, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 1 For instruction:   %117 = load i64, ptr %rl.0700, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and314 = and i64 %117, %116 of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %and314, ptr %dl.0702, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %118 = load i64, ptr %incdec.ptr, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %119 = load i64, ptr %incdec.ptr313, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and318 = and i64 %119, %118 of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %and318, ptr %incdec.ptr315, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %120 = load i64, ptr %incdec.ptr316, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %121 = load i64, ptr %incdec.ptr317, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and322 = and i64 %121, %120 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr323 = getelementptr inbounds i8, ptr %dl.0702, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 %and322, ptr %incdec.ptr319, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr324 = getelementptr inbounds i8, ptr %ll.0701, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %122 = load i64, ptr %incdec.ptr320, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr325 = getelementptr inbounds i8, ptr %rl.0700, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %123 = load i64, ptr %incdec.ptr321, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and326 = and i64 %123, %122 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr327 = getelementptr inbounds i8, ptr %dl.0702, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 1 For instruction:   store i64 %and326, ptr %incdec.ptr323, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool311.not, label %if.end375.loopexit, label %while.body312 of type:br
LV: Vector loop of width vscale x 1 costs: 15
A is scalable.	B is not scalable.	
RTCostA: 64424509428, RTCostB: 77309411310
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 64424509428, RTCostB: 39728447505

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dl.0702 = phi ptr [ %incdec.ptr327, %while.body312 ], [ %dc.2, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ll.0701 = phi ptr [ %incdec.ptr324, %while.body312 ], [ %cond, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rl.0700 = phi ptr [ %incdec.ptr325, %while.body312 ], [ %cond57, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.0699 = phi i32 [ %dec, %while.body312 ], [ %conv308, %while.body312.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %len.0699, -1 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 2 For instruction:   %116 = load i64, ptr %ll.0701, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 2 For instruction:   %117 = load i64, ptr %rl.0700, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and314 = and i64 %117, %116 of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %and314, ptr %dl.0702, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %118 = load i64, ptr %incdec.ptr, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %119 = load i64, ptr %incdec.ptr313, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and318 = and i64 %119, %118 of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %and318, ptr %incdec.ptr315, align 8 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %120 = load i64, ptr %incdec.ptr316, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %121 = load i64, ptr %incdec.ptr317, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and322 = and i64 %121, %120 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr323 = getelementptr inbounds i8, ptr %dl.0702, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 %and322, ptr %incdec.ptr319, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr324 = getelementptr inbounds i8, ptr %ll.0701, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %122 = load i64, ptr %incdec.ptr320, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr325 = getelementptr inbounds i8, ptr %rl.0700, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %123 = load i64, ptr %incdec.ptr321, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and326 = and i64 %123, %122 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr327 = getelementptr inbounds i8, ptr %dl.0702, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 2 For instruction:   store i64 %and326, ptr %incdec.ptr323, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool311.not, label %if.end375.loopexit, label %while.body312 of type:br
LV: Vector loop of width vscale x 2 costs: 14
A is scalable.	B is not scalable.	
RTCostA: 62277025788, RTCostB: 77309411310
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 62277025788, RTCostB: 39728447505
LV: Selecting VF: 4 With Cost: 9.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=4, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body312.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 (%conv193.pre-phi /u 32) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<32>
    EMIT vp<%6> = ptradd ir<%dc.2>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<32>
    EMIT vp<%9> = ptradd ir<%cond>, vp<%8>
    vp<%10>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%11> = SCALAR-STEPS vp<%10>, ir<32>
    EMIT vp<%12> = ptradd ir<%cond57>, vp<%11>
    INTERLEAVE-GROUP with factor 4 at %120, vp<%9>
      ir<%120> = load from index 0
      ir<%122> = load from index 1
      ir<%124> = load from index 2
      ir<%126> = load from index 3
    INTERLEAVE-GROUP with factor 4 at %121, vp<%12>
      ir<%121> = load from index 0
      ir<%123> = load from index 1
      ir<%125> = load from index 2
      ir<%127> = load from index 3
    WIDEN ir<%and314> = and ir<%121>, ir<%120>
    WIDEN ir<%and318> = and ir<%123>, ir<%122>
    WIDEN ir<%and322> = and ir<%125>, ir<%124>
    CLONE ir<%incdec.ptr323> = getelementptr inbounds vp<%6>, ir<24>
    CLONE ir<%incdec.ptr324> = getelementptr inbounds vp<%9>, ir<32>
    CLONE ir<%incdec.ptr325> = getelementptr inbounds vp<%12>, ir<32>
    WIDEN ir<%and326> = and ir<%127>, ir<%126>
    CLONE ir<%incdec.ptr327> = getelementptr inbounds vp<%6>, ir<32>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%incdec.ptr323>
      store ir<%and314> to index 0
      store ir<%and318> to index 1
      store ir<%and322> to index 2
      store ir<%and326> to index 3
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<if.end375.loopexit>, scalar.ph

ir-bb<if.end375.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr324.lcssa = ir<%incdec.ptr324>
Live-out ptr %incdec.ptr325.lcssa = ir<%incdec.ptr325>
Live-out ptr %incdec.ptr327.lcssa = ir<%incdec.ptr327>
}
================ Final VPlan ================

@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %170 = load i8, ptr %lc.7709, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %171 = load i8, ptr %rc.7708, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %or411667, ptr %dc.10710, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body406.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3785 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dc.10710> = WIDEN-POINTER-INDUCTION ir<%dc.7788>, 1
    EMIT ir<%lc.7709> = WIDEN-POINTER-INDUCTION ir<%lc.4787>, 1
    EMIT ir<%rc.7708> = WIDEN-POINTER-INDUCTION ir<%rc.4786>, 1
    WIDEN-INDUCTION %len.6707 = phi %dec404, %len.3785, ir<-1>
    CLONE ir<%dec404> = add nsw ir<%len.6707>, ir<-1>
    CLONE ir<%incdec.ptr407> = getelementptr inbounds ir<%lc.7709>, ir<1>
    CLONE ir<%170> = load ir<%lc.7709>
    CLONE ir<%incdec.ptr409> = getelementptr inbounds ir<%rc.7708>, ir<1>
    CLONE ir<%171> = load ir<%rc.7708>
    CLONE ir<%or411667> = or ir<%171>, ir<%170>
    CLONE ir<%incdec.ptr413> = getelementptr inbounds ir<%dc.10710>, ir<1>
    CLONE store ir<%or411667>, ir<%dc.10710>
    CLONE ir<%tobool405.not> = icmp eq ir<%dec404>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<mop_up.loopexit794>, scalar.ph

ir-bb<mop_up.loopexit794>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body406.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3785 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%dc.10710> = WIDEN-POINTER-INDUCTION ir<%dc.7788>, 1
    EMIT ir<%lc.7709> = WIDEN-POINTER-INDUCTION ir<%lc.4787>, 1
    EMIT ir<%rc.7708> = WIDEN-POINTER-INDUCTION ir<%rc.4786>, 1
    WIDEN-INDUCTION %len.6707 = phi %dec404, %len.3785, ir<-1>
    CLONE ir<%dec404> = add nsw ir<%len.6707>, ir<-1>
    CLONE ir<%incdec.ptr407> = getelementptr inbounds ir<%lc.7709>, ir<1>
    vp<%4> = vector-pointer ir<%lc.7709>
    WIDEN ir<%170> = load vp<%4>
    CLONE ir<%incdec.ptr409> = getelementptr inbounds ir<%rc.7708>, ir<1>
    vp<%5> = vector-pointer ir<%rc.7708>
    WIDEN ir<%171> = load vp<%5>
    WIDEN ir<%or411667> = or ir<%171>, ir<%170>
    CLONE ir<%incdec.ptr413> = getelementptr inbounds ir<%dc.10710>, ir<1>
    vp<%6> = vector-pointer ir<%dc.10710>
    WIDEN store vp<%6>, ir<%or411667>
    CLONE ir<%tobool405.not> = icmp eq ir<%dec404>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<mop_up.loopexit794>, scalar.ph

ir-bb<mop_up.loopexit794>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body406.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3785 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%dc.10710> = WIDEN-POINTER-INDUCTION ir<%dc.7788>, 1
    EMIT ir<%lc.7709> = WIDEN-POINTER-INDUCTION ir<%lc.4787>, 1
    EMIT ir<%rc.7708> = WIDEN-POINTER-INDUCTION ir<%rc.4786>, 1
    WIDEN-INDUCTION %len.6707 = phi %dec404, %len.3785, ir<-1>
    CLONE ir<%dec404> = add nsw ir<%len.6707>, ir<-1>
    CLONE ir<%incdec.ptr407> = getelementptr inbounds ir<%lc.7709>, ir<1>
    vp<%4> = vector-pointer ir<%lc.7709>
    WIDEN ir<%170> = load vp<%4>
    CLONE ir<%incdec.ptr409> = getelementptr inbounds ir<%rc.7708>, ir<1>
    vp<%5> = vector-pointer ir<%rc.7708>
    WIDEN ir<%171> = load vp<%5>
    WIDEN ir<%or411667> = or ir<%171>, ir<%170>
    CLONE ir<%incdec.ptr413> = getelementptr inbounds ir<%dc.10710>, ir<1>
    vp<%6> = vector-pointer ir<%dc.10710>
    WIDEN store vp<%6>, ir<%or411667>
    CLONE ir<%tobool405.not> = icmp eq ir<%dec404>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<mop_up.loopexit794>, scalar.ph

ir-bb<mop_up.loopexit794>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 25769803770
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 25769803770
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 6442450956
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 25769803770
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 3221225508
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 25769803770
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 1610612820
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 25769803770
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 25769803770
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 25769803770
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dc.10710 = phi ptr [ %incdec.ptr413, %while.body406 ], [ %dc.7788, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %lc.7709 = phi ptr [ %incdec.ptr407, %while.body406 ], [ %lc.4787, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %rc.7708 = phi ptr [ %incdec.ptr409, %while.body406 ], [ %rc.4786, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %len.6707 = phi i32 [ %dec404, %while.body406 ], [ %len.3785, %while.body406.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec404 = add nsw i32 %len.6707, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr407 = getelementptr inbounds i8, ptr %lc.7709, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %170 = load i8, ptr %lc.7709, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr409 = getelementptr inbounds i8, ptr %rc.7708, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %171 = load i8, ptr %rc.7708, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %or411667 = or i8 %171, %170 of type:or
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr413 = getelementptr inbounds i8, ptr %dc.10710, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %or411667, ptr %dc.10710, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool405.not = icmp eq i32 %dec404, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool405.not, label %mop_up.loopexit794, label %while.body406 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 25769803770
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 1342177456
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body406.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3785 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%dc.7788>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%lc.4787>, vp<%6>
    vp<%8> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%9> = ptradd ir<%rc.4786>, vp<%8>
    vp<%10> = vector-pointer vp<%7>
    WIDEN ir<%174> = load vp<%10>
    vp<%11> = vector-pointer vp<%9>
    WIDEN ir<%175> = load vp<%11>
    WIDEN ir<%or411667> = or ir<%175>, ir<%174>
    vp<%12> = vector-pointer vp<%5>
    WIDEN store vp<%12>, ir<%or411667>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<mop_up.loopexit794>, scalar.ph

ir-bb<mop_up.loopexit794>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %188 = load i8, ptr %lc.6714, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %189 = load i8, ptr %rc.6713, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %xor398668, ptr %dc.9715, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body393.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3776 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dc.9715> = WIDEN-POINTER-INDUCTION ir<%dc.7779>, 1
    EMIT ir<%lc.6714> = WIDEN-POINTER-INDUCTION ir<%lc.4778>, 1
    EMIT ir<%rc.6713> = WIDEN-POINTER-INDUCTION ir<%rc.4777>, 1
    WIDEN-INDUCTION %len.5712 = phi %dec391, %len.3776, ir<-1>
    CLONE ir<%dec391> = add nsw ir<%len.5712>, ir<-1>
    CLONE ir<%incdec.ptr394> = getelementptr inbounds ir<%lc.6714>, ir<1>
    CLONE ir<%188> = load ir<%lc.6714>
    CLONE ir<%incdec.ptr396> = getelementptr inbounds ir<%rc.6713>, ir<1>
    CLONE ir<%189> = load ir<%rc.6713>
    CLONE ir<%xor398668> = xor ir<%189>, ir<%188>
    CLONE ir<%incdec.ptr400> = getelementptr inbounds ir<%dc.9715>, ir<1>
    CLONE store ir<%xor398668>, ir<%dc.9715>
    CLONE ir<%tobool392.not> = icmp eq ir<%dec391>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<mop_up.loopexit>, scalar.ph

ir-bb<mop_up.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body393.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3776 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%dc.9715> = WIDEN-POINTER-INDUCTION ir<%dc.7779>, 1
    EMIT ir<%lc.6714> = WIDEN-POINTER-INDUCTION ir<%lc.4778>, 1
    EMIT ir<%rc.6713> = WIDEN-POINTER-INDUCTION ir<%rc.4777>, 1
    WIDEN-INDUCTION %len.5712 = phi %dec391, %len.3776, ir<-1>
    CLONE ir<%dec391> = add nsw ir<%len.5712>, ir<-1>
    CLONE ir<%incdec.ptr394> = getelementptr inbounds ir<%lc.6714>, ir<1>
    vp<%4> = vector-pointer ir<%lc.6714>
    WIDEN ir<%188> = load vp<%4>
    CLONE ir<%incdec.ptr396> = getelementptr inbounds ir<%rc.6713>, ir<1>
    vp<%5> = vector-pointer ir<%rc.6713>
    WIDEN ir<%189> = load vp<%5>
    WIDEN ir<%xor398668> = xor ir<%189>, ir<%188>
    CLONE ir<%incdec.ptr400> = getelementptr inbounds ir<%dc.9715>, ir<1>
    vp<%6> = vector-pointer ir<%dc.9715>
    WIDEN store vp<%6>, ir<%xor398668>
    CLONE ir<%tobool392.not> = icmp eq ir<%dec391>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<mop_up.loopexit>, scalar.ph

ir-bb<mop_up.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body393.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3776 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%dc.9715> = WIDEN-POINTER-INDUCTION ir<%dc.7779>, 1
    EMIT ir<%lc.6714> = WIDEN-POINTER-INDUCTION ir<%lc.4778>, 1
    EMIT ir<%rc.6713> = WIDEN-POINTER-INDUCTION ir<%rc.4777>, 1
    WIDEN-INDUCTION %len.5712 = phi %dec391, %len.3776, ir<-1>
    CLONE ir<%dec391> = add nsw ir<%len.5712>, ir<-1>
    CLONE ir<%incdec.ptr394> = getelementptr inbounds ir<%lc.6714>, ir<1>
    vp<%4> = vector-pointer ir<%lc.6714>
    WIDEN ir<%188> = load vp<%4>
    CLONE ir<%incdec.ptr396> = getelementptr inbounds ir<%rc.6713>, ir<1>
    vp<%5> = vector-pointer ir<%rc.6713>
    WIDEN ir<%189> = load vp<%5>
    WIDEN ir<%xor398668> = xor ir<%189>, ir<%188>
    CLONE ir<%incdec.ptr400> = getelementptr inbounds ir<%dc.9715>, ir<1>
    vp<%6> = vector-pointer ir<%dc.9715>
    WIDEN store vp<%6>, ir<%xor398668>
    CLONE ir<%tobool392.not> = icmp eq ir<%dec391>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<mop_up.loopexit>, scalar.ph

ir-bb<mop_up.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 25769803770
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 25769803770
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 6442450956
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 25769803770
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 3221225508
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 25769803770
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 1610612820
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 25769803770
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 25769803770
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 25769803770
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dc.9715 = phi ptr [ %incdec.ptr400, %while.body393 ], [ %dc.7779, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %lc.6714 = phi ptr [ %incdec.ptr394, %while.body393 ], [ %lc.4778, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %rc.6713 = phi ptr [ %incdec.ptr396, %while.body393 ], [ %rc.4777, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %len.5712 = phi i32 [ %dec391, %while.body393 ], [ %len.3776, %while.body393.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec391 = add nsw i32 %len.5712, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr394 = getelementptr inbounds i8, ptr %lc.6714, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %188 = load i8, ptr %lc.6714, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr396 = getelementptr inbounds i8, ptr %rc.6713, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %189 = load i8, ptr %rc.6713, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %xor398668 = xor i8 %189, %188 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr400 = getelementptr inbounds i8, ptr %dc.9715, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %xor398668, ptr %dc.9715, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool392.not = icmp eq i32 %dec391, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool392.not, label %mop_up.loopexit, label %while.body393 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 25769803770
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 1342177456
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body393.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3776 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%dc.7779>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%lc.4778>, vp<%6>
    vp<%8> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%9> = ptradd ir<%rc.4777>, vp<%8>
    vp<%10> = vector-pointer vp<%7>
    WIDEN ir<%192> = load vp<%10>
    vp<%11> = vector-pointer vp<%9>
    WIDEN ir<%193> = load vp<%11>
    WIDEN ir<%xor398668> = xor ir<%193>, ir<%192>
    vp<%12> = vector-pointer vp<%5>
    WIDEN store vp<%12>, ir<%xor398668>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<mop_up.loopexit>, scalar.ph

ir-bb<mop_up.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %206 = load i8, ptr %lc.5719, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %207 = load i8, ptr %rc.5718, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %and385669, ptr %dc.8720, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body380.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3767 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dc.8720> = WIDEN-POINTER-INDUCTION ir<%dc.7770>, 1
    EMIT ir<%lc.5719> = WIDEN-POINTER-INDUCTION ir<%lc.4769>, 1
    EMIT ir<%rc.5718> = WIDEN-POINTER-INDUCTION ir<%rc.4768>, 1
    WIDEN-INDUCTION %len.4717 = phi %dec378, %len.3767, ir<-1>
    CLONE ir<%dec378> = add nsw ir<%len.4717>, ir<-1>
    CLONE ir<%incdec.ptr381> = getelementptr inbounds ir<%lc.5719>, ir<1>
    CLONE ir<%206> = load ir<%lc.5719>
    CLONE ir<%incdec.ptr383> = getelementptr inbounds ir<%rc.5718>, ir<1>
    CLONE ir<%207> = load ir<%rc.5718>
    CLONE ir<%and385669> = and ir<%207>, ir<%206>
    CLONE ir<%incdec.ptr387> = getelementptr inbounds ir<%dc.8720>, ir<1>
    CLONE store ir<%and385669>, ir<%dc.8720>
    CLONE ir<%tobool379.not> = icmp eq ir<%dec378>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<finish.loopexit>, scalar.ph

ir-bb<finish.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body380.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3767 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%dc.8720> = WIDEN-POINTER-INDUCTION ir<%dc.7770>, 1
    EMIT ir<%lc.5719> = WIDEN-POINTER-INDUCTION ir<%lc.4769>, 1
    EMIT ir<%rc.5718> = WIDEN-POINTER-INDUCTION ir<%rc.4768>, 1
    WIDEN-INDUCTION %len.4717 = phi %dec378, %len.3767, ir<-1>
    CLONE ir<%dec378> = add nsw ir<%len.4717>, ir<-1>
    CLONE ir<%incdec.ptr381> = getelementptr inbounds ir<%lc.5719>, ir<1>
    vp<%4> = vector-pointer ir<%lc.5719>
    WIDEN ir<%206> = load vp<%4>
    CLONE ir<%incdec.ptr383> = getelementptr inbounds ir<%rc.5718>, ir<1>
    vp<%5> = vector-pointer ir<%rc.5718>
    WIDEN ir<%207> = load vp<%5>
    WIDEN ir<%and385669> = and ir<%207>, ir<%206>
    CLONE ir<%incdec.ptr387> = getelementptr inbounds ir<%dc.8720>, ir<1>
    vp<%6> = vector-pointer ir<%dc.8720>
    WIDEN store vp<%6>, ir<%and385669>
    CLONE ir<%tobool379.not> = icmp eq ir<%dec378>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<finish.loopexit>, scalar.ph

ir-bb<finish.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_do_vop' from doop.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body380.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3767 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%dc.8720> = WIDEN-POINTER-INDUCTION ir<%dc.7770>, 1
    EMIT ir<%lc.5719> = WIDEN-POINTER-INDUCTION ir<%lc.4769>, 1
    EMIT ir<%rc.5718> = WIDEN-POINTER-INDUCTION ir<%rc.4768>, 1
    WIDEN-INDUCTION %len.4717 = phi %dec378, %len.3767, ir<-1>
    CLONE ir<%dec378> = add nsw ir<%len.4717>, ir<-1>
    CLONE ir<%incdec.ptr381> = getelementptr inbounds ir<%lc.5719>, ir<1>
    vp<%4> = vector-pointer ir<%lc.5719>
    WIDEN ir<%206> = load vp<%4>
    CLONE ir<%incdec.ptr383> = getelementptr inbounds ir<%rc.5718>, ir<1>
    vp<%5> = vector-pointer ir<%rc.5718>
    WIDEN ir<%207> = load vp<%5>
    WIDEN ir<%and385669> = and ir<%207>, ir<%206>
    CLONE ir<%incdec.ptr387> = getelementptr inbounds ir<%dc.8720>, ir<1>
    vp<%6> = vector-pointer ir<%dc.8720>
    WIDEN store vp<%6>, ir<%and385669>
    CLONE ir<%tobool379.not> = icmp eq ir<%dec378>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<finish.loopexit>, scalar.ph

ir-bb<finish.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 25769803770
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 25769803770
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 6442450956
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 25769803770
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 3221225508
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 25769803770
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 1610612820
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 25769803770
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450956, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 25769803770
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225508, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 25769803770
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612820, RTCostB: 1342177456

-----------------Function that is being costed:'Perl_do_vop' from doop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dc.8720 = phi ptr [ %incdec.ptr387, %while.body380 ], [ %dc.7770, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %lc.5719 = phi ptr [ %incdec.ptr381, %while.body380 ], [ %lc.4769, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %rc.5718 = phi ptr [ %incdec.ptr383, %while.body380 ], [ %rc.4768, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %len.4717 = phi i32 [ %dec378, %while.body380 ], [ %len.3767, %while.body380.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec378 = add nsw i32 %len.4717, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr381 = getelementptr inbounds i8, ptr %lc.5719, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %206 = load i8, ptr %lc.5719, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr383 = getelementptr inbounds i8, ptr %rc.5718, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %207 = load i8, ptr %rc.5718, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %and385669 = and i8 %207, %206 of type:and
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr387 = getelementptr inbounds i8, ptr %dc.8720, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %and385669, ptr %dc.8720, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool379.not = icmp eq i32 %dec378, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool379.not, label %finish.loopexit, label %while.body380 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 25769803770
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177456, RTCostB: 1342177456
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_do_vop at line: doop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body380.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len.3767 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%dc.7770>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%lc.4769>, vp<%6>
    vp<%8> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%9> = ptradd ir<%rc.4768>, vp<%8>
    vp<%10> = vector-pointer vp<%7>
    WIDEN ir<%210> = load vp<%10>
    vp<%11> = vector-pointer vp<%9>
    WIDEN ir<%211> = load vp<%11>
    WIDEN ir<%and385669> = and ir<%211>, ir<%210>
    vp<%12> = vector-pointer vp<%5>
    WIDEN store vp<%12>, ir<%and385669>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<finish.loopexit>, scalar.ph

ir-bb<finish.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 37
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o dump.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         dump.c
@@ Instruction =>  %157 = load i32, ptr %arrayidx635, align 4 -> Cost: 4 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %157 = load i32, ptr %arrayidx635, align 4 -> Cost: 4 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %157 = load i32, ptr %arrayidx635, align 4 -> Cost: 10 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %157 = load i32, ptr %arrayidx635, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %157 = load i32, ptr %arrayidx635, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %157 = load i32, ptr %arrayidx635, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_do_sv_dump' from dump.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body633.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((199 umin {0,+,1}<nuw><nsw><%for.cond584>) smax %max.01607) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1633 = phi %indvars.iv.next1634, %152, ir<-1>
    WIDEN-REDUCTION-PHI ir<%sum.01612> = phi ir<0.000000e+00>, ir<%add639>.1
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1633 = phi %indvars.iv.next1634, %152\l" +
    "  ir<%158>, ir<-1>
    CLONE ir<%arrayidx635> = getelementptr inbounds ir<%freq>, ir<0>, ir<%indvars.iv1633>
    CLONE ir<%157> = load ir<%arrayidx635>
    CLONE ir<%mul636> = mul ir<%158>, ir<%158>
    CLONE ir<%mul637> = mul ir<%mul636>, ir<%157>
    CLONE ir<%conv638> = sitofp ir<%mul637>
    CLONE ir<%add639> = fadd ir<%sum.01612>, ir<%conv638>
    CLONE ir<%indvars.iv.next1634> = add nsw ir<%indvars.iv1633>, ir<-1>
    CLONE ir<%cmp631> = icmp sgt ir<%indvars.iv1633>, ir<1>
    REDUCE ir<%add639>.1 = ir<%sum.01612> + reduce.fadd (ir<%conv638>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%sum.01612>, ir<%add639>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add639.lcssa = vp<%6>
}

========== Loop: Perl_do_sv_dump' from dump.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body633.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((199 umin {0,+,1}<nuw><nsw><%for.cond584>) smax %max.01607) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1633 = phi %indvars.iv.next1634, %152, ir<-1>
    WIDEN-REDUCTION-PHI ir<%sum.01612> = phi ir<0.000000e+00>, ir<%add639>.1
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1633 = phi %indvars.iv.next1634, %152\l" +
    "  ir<%158>, ir<-1>
    CLONE ir<%arrayidx635> = getelementptr inbounds ir<%freq>, ir<0>, ir<%indvars.iv1633>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx635>
    WIDEN ir<%157> = load vp<%4>
    WIDEN ir<%mul636> = mul ir<%158>, ir<%158>
    WIDEN ir<%mul637> = mul ir<%mul636>, ir<%157>
    WIDEN-CAST ir<%conv638> = sitofp  ir<%mul637> to double
    WIDEN ir<%add639> = fadd ir<%sum.01612>, ir<%conv638>
    WIDEN ir<%indvars.iv.next1634> = add nsw ir<%indvars.iv1633>, ir<-1>
    CLONE ir<%cmp631> = icmp sgt ir<%indvars.iv1633>, ir<1>
    REDUCE ir<%add639>.1 = ir<%sum.01612> + reduce.fadd (ir<%conv638>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.01612>, ir<%add639>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add639.lcssa = vp<%7>
}

========== Loop: Perl_do_sv_dump' from dump.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body633.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((199 umin {0,+,1}<nuw><nsw><%for.cond584>) smax %max.01607) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1633 = phi %indvars.iv.next1634, %152, ir<-1>
    WIDEN-REDUCTION-PHI ir<%sum.01612> = phi ir<0.000000e+00>, ir<%add639>.1
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1633 = phi %indvars.iv.next1634, %152\l" +
    "  ir<%158>, ir<-1>
    CLONE ir<%arrayidx635> = getelementptr inbounds ir<%freq>, ir<0>, ir<%indvars.iv1633>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx635>
    WIDEN ir<%157> = load vp<%4>
    WIDEN ir<%mul636> = mul ir<%158>, ir<%158>
    WIDEN ir<%mul637> = mul ir<%mul636>, ir<%157>
    WIDEN-CAST ir<%conv638> = sitofp  ir<%mul637> to double
    WIDEN ir<%add639> = fadd ir<%sum.01612>, ir<%conv638>
    WIDEN ir<%indvars.iv.next1634> = add nsw ir<%indvars.iv1633>, ir<-1>
    CLONE ir<%cmp631> = icmp sgt ir<%indvars.iv1633>, ir<1>
    REDUCE ir<%add639>.1 = ir<%sum.01612> + reduce.fadd (ir<%conv638>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.01612>, ir<%add639>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add639.lcssa = vp<%7>
}


-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1633 = phi i64 [ %indvars.iv.next1634, %for.body633 ], [ %152, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum.01612 = phi double [ %add639, %for.body633 ], [ 0.000000e+00, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx635 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1633 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %157 = load i32, ptr %arrayidx635, align 4 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %158 = trunc nuw nsw i64 %indvars.iv1633 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul636 = mul i32 %158, %158 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul637 = mul i32 %mul636, %157 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv638 = sitofp i32 %mul637 to double of type:sitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   %add639 = fadd double %sum.01612, %conv638 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1634 = add nsw i64 %indvars.iv1633, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp631 = icmp sgt i64 %indvars.iv1633, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp631, label %for.body633, label %while.cond.preheader.loopexit of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1633 = phi i64 [ %indvars.iv.next1634, %for.body633 ], [ %152, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sum.01612 = phi double [ %add639, %for.body633 ], [ 0.000000e+00, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx635 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1633 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %157 = load i32, ptr %arrayidx635, align 4 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %158 = trunc nuw nsw i64 %indvars.iv1633 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul636 = mul i32 %158, %158 of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul637 = mul i32 %mul636, %157 of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv638 = sitofp i32 %mul637 to double of type:sitofp
LV: Found an estimated cost of 4 for VF 2 For instruction:   %add639 = fadd double %sum.01612, %conv638 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1634 = add nsw i64 %indvars.iv1633, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp631 = icmp sgt i64 %indvars.iv1633, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp631, label %for.body633, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 13958643707, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 13958643707, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1633 = phi i64 [ %indvars.iv.next1634, %for.body633 ], [ %152, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sum.01612 = phi double [ %add639, %for.body633 ], [ 0.000000e+00, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx635 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1633 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %157 = load i32, ptr %arrayidx635, align 4 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %158 = trunc nuw nsw i64 %indvars.iv1633 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul636 = mul i32 %158, %158 of type:mul
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul637 = mul i32 %mul636, %157 of type:mul
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv638 = sitofp i32 %mul637 to double of type:sitofp
LV: Found an estimated cost of 6 for VF 4 For instruction:   %add639 = fadd double %sum.01612, %conv638 of type:fadd
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1634 = add nsw i64 %indvars.iv1633, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp631 = icmp sgt i64 %indvars.iv1633, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp631, label %for.body633, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 8589934600, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934600, RTCostB: 13958643707
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1633 = phi i64 [ %indvars.iv.next1634, %for.body633 ], [ %152, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %sum.01612 = phi double [ %add639, %for.body633 ], [ 0.000000e+00, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx635 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1633 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 8 For instruction:   %157 = load i32, ptr %arrayidx635, align 4 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %158 = trunc nuw nsw i64 %indvars.iv1633 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 8 For instruction:   %mul636 = mul i32 %158, %158 of type:mul
LV: Found an estimated cost of 2 for VF 8 For instruction:   %mul637 = mul i32 %mul636, %157 of type:mul
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv638 = sitofp i32 %mul637 to double of type:sitofp
LV: Found an estimated cost of 10 for VF 8 For instruction:   %add639 = fadd double %sum.01612, %conv638 of type:fadd
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next1634 = add nsw i64 %indvars.iv1633, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp631 = icmp sgt i64 %indvars.iv1633, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp631, label %for.body633, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 8053063706, RTCostB: 17179869176
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8053063706, RTCostB: 8589934600
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1633 = phi i64 [ %indvars.iv.next1634, %for.body633 ], [ %152, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sum.01612 = phi double [ %add639, %for.body633 ], [ 0.000000e+00, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx635 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1633 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %157 = load i32, ptr %arrayidx635, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %158 = trunc nuw nsw i64 %indvars.iv1633 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %mul636 = mul i32 %158, %158 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %mul637 = mul i32 %mul636, %157 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv638 = sitofp i32 %mul637 to double of type:sitofp
LV: Found an estimated cost of 4 for VF vscale x 1 For instruction:   %add639 = fadd double %sum.01612, %conv638 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1634 = add nsw i64 %indvars.iv1633, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp631 = icmp sgt i64 %indvars.iv1633, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp631, label %for.body633, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 5
A is scalable.	B is not scalable.	
RTCostA: 11811160061, RTCostB: 17179869176
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 11811160061, RTCostB: 8053063706

-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1633 = phi i64 [ %indvars.iv.next1634, %for.body633 ], [ %152, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sum.01612 = phi double [ %add639, %for.body633 ], [ 0.000000e+00, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx635 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1633 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %157 = load i32, ptr %arrayidx635, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %158 = trunc nuw nsw i64 %indvars.iv1633 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul636 = mul i32 %158, %158 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul637 = mul i32 %mul636, %157 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv638 = sitofp i32 %mul637 to double of type:sitofp
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %add639 = fadd double %sum.01612, %conv638 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1634 = add nsw i64 %indvars.iv1633, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp631 = icmp sgt i64 %indvars.iv1633, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp631, label %for.body633, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7516192778, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192778, RTCostB: 8053063706
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_do_sv_dump' from dump.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1633 = phi i64 [ %indvars.iv.next1634, %for.body633 ], [ %152, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sum.01612 = phi double [ %add639, %for.body633 ], [ 0.000000e+00, %for.body633.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx635 = getelementptr inbounds [200 x i32], ptr %freq, i64 0, i64 %indvars.iv1633 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   %157 = load i32, ptr %arrayidx635, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %158 = trunc nuw nsw i64 %indvars.iv1633 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul636 = mul i32 %158, %158 of type:mul
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul637 = mul i32 %mul636, %157 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv638 = sitofp i32 %mul637 to double of type:sitofp
LV: Found an estimated cost of 10 for VF vscale x 4 For instruction:   %add639 = fadd double %sum.01612, %conv638 of type:fadd
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next1634 = add nsw i64 %indvars.iv1633, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp631 = icmp sgt i64 %indvars.iv1633, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp631, label %for.body633, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 6174015521, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 6174015521, RTCostB: 7516192778
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: Perl_do_sv_dump at line: dump.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body633.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((199 umin {0,+,1}<nuw><nsw><%for.cond584>) smax %max.01607) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%sum.01612> = phi ir<0.000000e+00>, ir<%add639>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1633 = phi %indvars.iv.next1634, %152\l" +
    "  ir<%158>, ir<-1>
    vp<%4>    = DERIVED-IV ir<%152> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx635> = getelementptr inbounds ir<%freq>, ir<0>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx635>
    WIDEN ir<%157> = load vp<%6>
    WIDEN ir<%mul636> = mul ir<%158>, ir<%158>
    WIDEN ir<%mul637> = mul ir<%mul636>, ir<%157>
    WIDEN-CAST ir<%conv638> = sitofp  ir<%mul637> to double
    REDUCE ir<%add639> = ir<%sum.01612> + reduce.fadd (ir<%conv638>)
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sum.01612>, ir<%add639>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %add639.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 12
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o globals.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         globals.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o gv.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         gv.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o hv.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         hv.c
========== Loop: S_more_he' from hv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%he.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %he.0.idx12 = phi 24, %he.0.add, ir<24>
    CLONE ir<%he.0.add> = add nuw nsw ir<%he.0.idx12>, ir<24>
    CLONE ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%he.0.add>
    CLONE store ir<%add.ptr.ptr>, ir<%he.0.ptr13>
    CLONE ir<%cmp> = icmp ult ir<%he.0.idx12>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_he' from hv.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%he.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %he.0.idx12 = phi 24, %he.0.add, ir<24>
    WIDEN ir<%he.0.add> = add nuw nsw ir<%he.0.idx12>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%he.0.add>
    WIDEN store ir<%he.0.ptr13>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%he.0.idx12>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_he' from hv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%he.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %he.0.idx12 = phi 24, %he.0.add, ir<24>
    WIDEN ir<%he.0.add> = add nuw nsw ir<%he.0.idx12>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%he.0.add>
    WIDEN store ir<%he.0.ptr13>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%he.0.idx12>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}


-----------------Function that is being costed:'S_more_he' from hv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %he.0.ptr13 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %he.0.idx12 = phi i64 [ 24, %entry ], [ %he.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %he.0.add = add nuw nsw i64 %he.0.idx12, 24 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %he.0.add of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr.ptr, ptr %he.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %he.0.idx12, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_more_he' from hv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %he.0.ptr13 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %he.0.idx12 = phi i64 [ 24, %entry ], [ %he.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %he.0.add = add nuw nsw i64 %he.0.idx12, 24 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %he.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %add.ptr.ptr, ptr %he.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %he.0.idx12, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 336, RTCostB: 504
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 336, RTCostB: 504
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_he' from hv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %he.0.ptr13 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %he.0.idx12 = phi i64 [ 24, %entry ], [ %he.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %he.0.add = add nuw nsw i64 %he.0.idx12, 24 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %he.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %add.ptr.ptr, ptr %he.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ult i64 %he.0.idx12, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 504
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 336
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_more_he' from hv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %he.0.ptr13 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %he.0.idx12 = phi i64 [ 24, %entry ], [ %he.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %he.0.add = add nuw nsw i64 %he.0.idx12, 24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %he.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %add.ptr.ptr, ptr %he.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %he.0.idx12, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 336, RTCostB: 504
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 336, RTCostB: 294

-----------------Function that is being costed:'S_more_he' from hv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %he.0.ptr13 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %he.0.idx12 = phi i64 [ 24, %entry ], [ %he.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %he.0.add = add nuw nsw i64 %he.0.idx12, 24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %he.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %add.ptr.ptr, ptr %he.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %he.0.idx12, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 504
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 294
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_more_he at line: hv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%he.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %he.0.idx12 = phi 24, %he.0.add, ir<24>
    WIDEN ir<%he.0.add> = add nuw nsw ir<%he.0.idx12>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%he.0.add>
    WIDEN store ir<%he.0.ptr13>, ir<%add.ptr.ptr>
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 27
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o locale.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         locale.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o mg.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         mg.c
@@ Instruction =>  %56 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: Perl_magic_set' from mg.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%55> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %i190.0892 = phi %inc, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%any_fatals.0891> = phi ir<0>, ir<%or209>
    WIDEN-REDUCTION-PHI ir<%accumulate.0890> = phi ir<0>, ir<%or205>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%cond201>, ir<%i190.0892>
    CLONE ir<%56> = load ir<%arrayidx>
    CLONE ir<%conv204> = zext ir<%56>
    CLONE ir<%or205> = or ir<%accumulate.0890>, ir<%conv204>
    CLONE ir<%and208> = and ir<%conv204>, ir<170>
    CLONE ir<%or209> = or ir<%and208>, ir<%any_fatals.0891>
    CLONE ir<%inc> = add nuw ir<%i190.0892>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%55>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = compute-reduction-result ir<%any_fatals.0891>, ir<%or209>
  EMIT vp<%6> = compute-reduction-result ir<%accumulate.0890>, ir<%or205>
  EMIT vp<%7> = icmp eq ir<%55>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %or205.lcssa = vp<%6>
Live-out i32 %or209.lcssa = vp<%5>
}

========== Loop: Perl_magic_set' from mg.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%55> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i190.0892 = phi %inc, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%any_fatals.0891> = phi ir<0>, ir<%or209>
    WIDEN-REDUCTION-PHI ir<%accumulate.0890> = phi ir<0>, ir<%or205>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%cond201>, ir<%i190.0892>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%56> = load vp<%3>
    WIDEN-CAST ir<%conv204> = zext  ir<%56> to i32
    WIDEN ir<%or205> = or ir<%accumulate.0890>, ir<%conv204>
    WIDEN ir<%and208> = and ir<%conv204>, ir<170>
    WIDEN ir<%or209> = or ir<%and208>, ir<%any_fatals.0891>
    CLONE ir<%inc> = add nuw ir<%i190.0892>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%55>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%any_fatals.0891>, ir<%or209>
  EMIT vp<%7> = compute-reduction-result ir<%accumulate.0890>, ir<%or205>
  EMIT vp<%8> = icmp eq ir<%55>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %or205.lcssa = vp<%7>
Live-out i32 %or209.lcssa = vp<%6>
}

========== Loop: Perl_magic_set' from mg.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%55> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i190.0892 = phi %inc, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%any_fatals.0891> = phi ir<0>, ir<%or209>
    WIDEN-REDUCTION-PHI ir<%accumulate.0890> = phi ir<0>, ir<%or205>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%cond201>, ir<%i190.0892>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%56> = load vp<%3>
    WIDEN-CAST ir<%conv204> = zext  ir<%56> to i32
    WIDEN ir<%or205> = or ir<%accumulate.0890>, ir<%conv204>
    WIDEN ir<%and208> = and ir<%conv204>, ir<170>
    WIDEN ir<%or209> = or ir<%and208>, ir<%any_fatals.0891>
    CLONE ir<%inc> = add nuw ir<%i190.0892>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<%55>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%any_fatals.0891>, ir<%or209>
  EMIT vp<%7> = compute-reduction-result ir<%accumulate.0890>, ir<%or205>
  EMIT vp<%8> = icmp eq ir<%55>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %or205.lcssa = vp<%7>
Live-out i32 %or209.lcssa = vp<%6>
}


-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i190.0892 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %any_fatals.0891 = phi i32 [ %or209, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %accumulate.0890 = phi i32 [ %or205, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond201, i64 %i190.0892 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %56 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv204 = zext i8 %56 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or205 = or i32 %accumulate.0890, %conv204 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and208 = and i32 %conv204, 170 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or209 = or i32 %and208, %any_fatals.0891 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw i64 %i190.0892, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %inc, %55 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i190.0892 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %any_fatals.0891 = phi i32 [ %or209, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %accumulate.0890 = phi i32 [ %or205, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond201, i64 %i190.0892 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %56 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv204 = zext i8 %56 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or205 = or i32 %accumulate.0890, %conv204 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and208 = and i32 %conv204, 170 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or209 = or i32 %and208, %any_fatals.0891 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw i64 %i190.0892, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %inc, %55 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i190.0892 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %any_fatals.0891 = phi i32 [ %or209, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %accumulate.0890 = phi i32 [ %or205, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond201, i64 %i190.0892 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %56 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv204 = zext i8 %56 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or205 = or i32 %accumulate.0890, %conv204 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and208 = and i32 %conv204, 170 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or209 = or i32 %and208, %any_fatals.0891 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nuw i64 %i190.0892, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %inc, %55 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i190.0892 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %any_fatals.0891 = phi i32 [ %or209, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %accumulate.0890 = phi i32 [ %or205, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond201, i64 %i190.0892 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %56 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %conv204 = zext i8 %56 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %or205 = or i32 %accumulate.0890, %conv204 of type:or
LV: Found an estimated cost of 2 for VF 8 For instruction:   %and208 = and i32 %conv204, 170 of type:and
LV: Found an estimated cost of 2 for VF 8 For instruction:   %or209 = or i32 %and208, %any_fatals.0891 of type:or
LV: Found an estimated cost of 1 for VF 8 For instruction:   %inc = add nuw i64 %i190.0892, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %inc, %55 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 11
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i190.0892 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %any_fatals.0891 = phi i32 [ %or209, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %accumulate.0890 = phi i32 [ %or205, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond201, i64 %i190.0892 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %56 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv204 = zext i8 %56 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or205 = or i32 %accumulate.0890, %conv204 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and208 = and i32 %conv204, 170 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or209 = or i32 %and208, %any_fatals.0891 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nuw i64 %i190.0892, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %inc, %55 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 11
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i190.0892 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %any_fatals.0891 = phi i32 [ %or209, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %accumulate.0890 = phi i32 [ %or205, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond201, i64 %i190.0892 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %56 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv204 = zext i8 %56 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or205 = or i32 %accumulate.0890, %conv204 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and208 = and i32 %conv204, 170 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or209 = or i32 %and208, %any_fatals.0891 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nuw i64 %i190.0892, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %inc, %55 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 11
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 44

-----------------Function that is being costed:'Perl_magic_set' from mg.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i190.0892 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %any_fatals.0891 = phi i32 [ %or209, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %accumulate.0890 = phi i32 [ %or205, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %cond201, i64 %i190.0892 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %56 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv204 = zext i8 %56 to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %or205 = or i32 %accumulate.0890, %conv204 of type:or
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and208 = and i32 %conv204, 170 of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %or209 = or i32 %and208, %any_fatals.0891 of type:or
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc = add nuw i64 %i190.0892, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %inc, %55 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 11
B VF: 8, EstimatedWidthB: 8, CostB: 11
CostA * EstimatedWidthB: 88, CostB * EstimatedWidthA: 88
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: Perl_magic_set at line: mg.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%55> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%any_fatals.0891> = phi ir<0>, ir<%or209>
    WIDEN-REDUCTION-PHI ir<%accumulate.0890> = phi ir<0>, ir<%or205>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%cond201>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%56> = load vp<%4>
    WIDEN-CAST ir<%conv204> = zext  ir<%56> to i32
    WIDEN ir<%or205> = or ir<%accumulate.0890>, ir<%conv204>
    WIDEN ir<%and208> = and ir<%conv204>, ir<170>
    WIDEN ir<%or209> = or ir<%and208>, ir<%any_fatals.0891>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%any_fatals.0891>, ir<%or209>
  EMIT vp<%8> = compute-reduction-result ir<%accumulate.0890>, ir<%or205>
  EMIT vp<%9> = icmp eq ir<%55>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %or205.lcssa = vp<%8>
Live-out i32 %or209.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o numeric.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         numeric.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o op.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         op.c
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %7 = load i8, ptr %add.ptr69, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %7, ptr %p.1169, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_allocmy' from op.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (-1 * (ptrtoint ptr %name to i64)) + (ptrtoint ptr %p.0 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%p.1169> = WIDEN-POINTER-INDUCTION ir<%p.0>, -1
    CLONE ir<%add.ptr69> = getelementptr inbounds ir<%p.1169>, ir<-1>
    CLONE ir<%7> = load ir<%add.ptr69>
    CLONE store ir<%7>, ir<%p.1169>
    CLONE ir<%sub.ptr.lhs.cast64> = ptrtoint ir<%add.ptr69>
    CLONE ir<%sub.ptr.sub66> = sub ir<%sub.ptr.lhs.cast64>, ir<%sub.ptr.rhs.cast>
    CLONE ir<%cmp67> = icmp sgt ir<%sub.ptr.sub66>, ir<2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_allocmy' from op.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (-1 * (ptrtoint ptr %name to i64)) + (ptrtoint ptr %p.0 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%p.1169> = WIDEN-POINTER-INDUCTION ir<%p.0>, -1
    CLONE ir<%add.ptr69> = getelementptr inbounds ir<%p.1169>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%add.ptr69>
    WIDEN ir<%7> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%p.1169>
    WIDEN store vp<%5>, ir<%7>
    CLONE ir<%sub.ptr.lhs.cast64> = ptrtoint ir<%add.ptr69>
    CLONE ir<%sub.ptr.sub66> = sub ir<%sub.ptr.lhs.cast64>, ir<%sub.ptr.rhs.cast>
    CLONE ir<%cmp67> = icmp sgt ir<%sub.ptr.sub66>, ir<2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_allocmy' from op.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (-1 * (ptrtoint ptr %name to i64)) + (ptrtoint ptr %p.0 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%p.1169> = WIDEN-POINTER-INDUCTION ir<%p.0>, -1
    CLONE ir<%add.ptr69> = getelementptr inbounds ir<%p.1169>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%add.ptr69>
    WIDEN ir<%7> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%p.1169>
    WIDEN store vp<%5>, ir<%7>
    CLONE ir<%sub.ptr.lhs.cast64> = ptrtoint ir<%add.ptr69>
    CLONE ir<%sub.ptr.sub66> = sub ir<%sub.ptr.lhs.cast64>, ir<%sub.ptr.rhs.cast>
    CLONE ir<%cmp67> = icmp sgt ir<%sub.ptr.sub66>, ir<2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 8 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 10
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 16 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 64
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 10
B VF: 8, EstimatedWidthB: 8, CostB: 10
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 32 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 24
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 128
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 24
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 384, CostB * EstimatedWidthA: 320

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_allocmy' from op.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %p.1169 = phi ptr [ %add.ptr69, %for.body ], [ %p.0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %add.ptr69 = getelementptr inbounds i8, ptr %p.1169, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %7 = load i8, ptr %add.ptr69, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %7, ptr %p.1169, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %sub.ptr.lhs.cast64 = ptrtoint ptr %add.ptr69 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast of type:sub
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp67, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 8
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_allocmy at line: op.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (-1 * (ptrtoint ptr %name to i64)) + (ptrtoint ptr %p.0 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    EMIT vp<%6> = ptradd ir<%p.0>, vp<%5>
    CLONE ir<%add.ptr69> = getelementptr inbounds vp<%6>, ir<-1>
    vp<%7> = vector-pointer (reverse) ir<%add.ptr69>
    WIDEN ir<%7> = load vp<%7>
    vp<%8> = vector-pointer (reverse) vp<%6>
    WIDEN store vp<%8>, ir<%7>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 1
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o pad.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         pad.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o perl.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         perl.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o perlapi.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         perlapi.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o perlio.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         perlio.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o perlmain.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         perlmain.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o perly.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         perly.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o pp.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         pp.c
@@ Instruction =>  %44 = load i64, ptr %tmpl.0390, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %not219, ptr %tmpl.0390, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %44 = load i64, ptr %tmpl.0390, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %not219, ptr %tmpl.0390, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %44 = load i64, ptr %tmpl.0390, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %not219, ptr %tmpl.0390, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %44 = load i64, ptr %tmpl.0390, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %not219, ptr %tmpl.0390, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body218.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-8 + %anum.0.lcssa) to i64) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%tmpl.0390> = WIDEN-POINTER-INDUCTION ir<%tmps.3.lcssa>, 8
    WIDEN-INDUCTION %anum.1389 = phi %sub, %anum.0.lcssa, ir<-8>
    CLONE ir<%44> = load ir<%tmpl.0390>
    CLONE ir<%not219> = xor ir<%44>, ir<-1>
    CLONE store ir<%not219>, ir<%tmpl.0390>
    CLONE ir<%sub> = add ir<%anum.1389>, ir<-8>
    CLONE ir<%incdec.ptr223> = getelementptr inbounds ir<%tmpl.0390>, ir<8>
    CLONE ir<%cmp216> = icmp ugt ir<%sub>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond225.preheader.loopexit>, scalar.ph

ir-bb<for.cond225.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %sub.lcssa = ir<%sub>
Live-out ptr %incdec.ptr223.lcssa = ir<%incdec.ptr223>
}

========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body218.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-8 + %anum.0.lcssa) to i64) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%tmpl.0390> = WIDEN-POINTER-INDUCTION ir<%tmps.3.lcssa>, 8
    WIDEN-INDUCTION %anum.1389 = phi %sub, %anum.0.lcssa, ir<-8>
    vp<%4> = vector-pointer ir<%tmpl.0390>
    WIDEN ir<%44> = load vp<%4>
    WIDEN ir<%not219> = xor ir<%44>, ir<-1>
    vp<%5> = vector-pointer ir<%tmpl.0390>
    WIDEN store vp<%5>, ir<%not219>
    CLONE ir<%sub> = add ir<%anum.1389>, ir<-8>
    CLONE ir<%incdec.ptr223> = getelementptr inbounds ir<%tmpl.0390>, ir<8>
    CLONE ir<%cmp216> = icmp ugt ir<%sub>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond225.preheader.loopexit>, scalar.ph

ir-bb<for.cond225.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %sub.lcssa = ir<%sub>
Live-out ptr %incdec.ptr223.lcssa = ir<%incdec.ptr223>
}

========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body218.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-8 + %anum.0.lcssa) to i64) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%tmpl.0390> = WIDEN-POINTER-INDUCTION ir<%tmps.3.lcssa>, 8
    WIDEN-INDUCTION %anum.1389 = phi %sub, %anum.0.lcssa, ir<-8>
    vp<%4> = vector-pointer ir<%tmpl.0390>
    WIDEN ir<%44> = load vp<%4>
    WIDEN ir<%not219> = xor ir<%44>, ir<-1>
    vp<%5> = vector-pointer ir<%tmpl.0390>
    WIDEN store vp<%5>, ir<%not219>
    CLONE ir<%sub> = add ir<%anum.1389>, ir<-8>
    CLONE ir<%incdec.ptr223> = getelementptr inbounds ir<%tmpl.0390>, ir<8>
    CLONE ir<%cmp216> = icmp ugt ir<%sub>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond225.preheader.loopexit>, scalar.ph

ir-bb<for.cond225.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %sub.lcssa = ir<%sub>
Live-out ptr %incdec.ptr223.lcssa = ir<%incdec.ptr223>
}


-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tmpl.0390 = phi ptr [ %incdec.ptr223, %for.body218 ], [ %tmps.3.lcssa, %for.body218.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %anum.1389 = phi i32 [ %sub, %for.body218 ], [ %anum.0.lcssa, %for.body218.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %44 = load i64, ptr %tmpl.0390, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not219 = xor i64 %44, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %not219, ptr %tmpl.0390, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = add i32 %anum.1389, -8 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmpl.0390, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp216 = icmp ugt i32 %sub, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp216, label %for.body218, label %for.cond225.preheader.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tmpl.0390 = phi ptr [ %incdec.ptr223, %for.body218 ], [ %tmps.3.lcssa, %for.body218.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %anum.1389 = phi i32 [ %sub, %for.body218 ], [ %anum.0.lcssa, %for.body218.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %44 = load i64, ptr %tmpl.0390, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not219 = xor i64 %44, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %not219, ptr %tmpl.0390, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = add i32 %anum.1389, -8 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmpl.0390, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp216 = icmp ugt i32 %sub, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp216, label %for.body218, label %for.cond225.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 1342177280, RTCostB: 2684354560
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1342177280, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %tmpl.0390 = phi ptr [ %incdec.ptr223, %for.body218 ], [ %tmps.3.lcssa, %for.body218.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %anum.1389 = phi i32 [ %sub, %for.body218 ], [ %anum.0.lcssa, %for.body218.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %44 = load i64, ptr %tmpl.0390, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not219 = xor i64 %44, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i64 %not219, ptr %tmpl.0390, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub = add i32 %anum.1389, -8 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmpl.0390, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp216 = icmp ugt i32 %sub, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp216, label %for.body218, label %for.cond225.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 1073741824, RTCostB: 2684354560
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741824, RTCostB: 1342177280
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tmpl.0390 = phi ptr [ %incdec.ptr223, %for.body218 ], [ %tmps.3.lcssa, %for.body218.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %anum.1389 = phi i32 [ %sub, %for.body218 ], [ %anum.0.lcssa, %for.body218.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %44 = load i64, ptr %tmpl.0390, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not219 = xor i64 %44, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i64 %not219, ptr %tmpl.0390, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub = add i32 %anum.1389, -8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmpl.0390, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp216 = icmp ugt i32 %sub, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp216, label %for.body218, label %for.cond225.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 1342177280, RTCostB: 2684354560
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177280, RTCostB: 1073741824

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tmpl.0390 = phi ptr [ %incdec.ptr223, %for.body218 ], [ %tmps.3.lcssa, %for.body218.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %anum.1389 = phi i32 [ %sub, %for.body218 ], [ %anum.0.lcssa, %for.body218.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %44 = load i64, ptr %tmpl.0390, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not219 = xor i64 %44, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i64 %not219, ptr %tmpl.0390, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = add i32 %anum.1389, -8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr223 = getelementptr inbounds i8, ptr %tmpl.0390, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp216 = icmp ugt i32 %sub, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp216, label %for.body218, label %for.cond225.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 1073741824, RTCostB: 2684354560
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741824, RTCostB: 1073741824
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_pp_complement at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body218.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-8 + %anum.0.lcssa) to i64) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%tmps.3.lcssa>, vp<%5>
    vp<%7>    = DERIVED-IV ir<%anum.0.lcssa> + vp<%3> * ir<-8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-8>
    vp<%9> = vector-pointer vp<%6>
    WIDEN ir<%44> = load vp<%9>
    WIDEN ir<%not219> = xor ir<%44>, ir<-1>
    vp<%10> = vector-pointer vp<%6>
    WIDEN store vp<%10>, ir<%not219>
    CLONE ir<%sub> = add vp<%8>, ir<-8>
    CLONE ir<%incdec.ptr223> = getelementptr inbounds vp<%6>, ir<8>
    EMIT vp<%11> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<for.cond225.preheader.loopexit>, scalar.ph

ir-bb<for.cond225.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %sub.lcssa = ir<%sub>
Live-out ptr %incdec.ptr223.lcssa = ir<%incdec.ptr223>
}
================ Final VPlan ================

@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i8, ptr %tmps.4395, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %not230, ptr %tmps.4395, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body228.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %anum.1.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%tmps.4395> = WIDEN-POINTER-INDUCTION ir<%tmpl.0.lcssa>, 1
    WIDEN-INDUCTION %anum.2394 = phi %dec233, %anum.1.lcssa, ir<-1>
    CLONE ir<%65> = load ir<%tmps.4395>
    CLONE ir<%not230> = xor ir<%65>, ir<-1>
    CLONE store ir<%not230>, ir<%tmps.4395>
    CLONE ir<%dec233> = add nsw ir<%anum.2394>, ir<-1>
    CLONE ir<%incdec.ptr234> = getelementptr inbounds ir<%tmps.4395>, ir<1>
    CLONE ir<%cmp226> = icmp ugt ir<%anum.2394>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end235.loopexit>, scalar.ph

ir-bb<for.end235.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body228.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %anum.1.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%tmps.4395> = WIDEN-POINTER-INDUCTION ir<%tmpl.0.lcssa>, 1
    WIDEN-INDUCTION %anum.2394 = phi %dec233, %anum.1.lcssa, ir<-1>
    vp<%4> = vector-pointer ir<%tmps.4395>
    WIDEN ir<%65> = load vp<%4>
    WIDEN ir<%not230> = xor ir<%65>, ir<-1>
    vp<%5> = vector-pointer ir<%tmps.4395>
    WIDEN store vp<%5>, ir<%not230>
    CLONE ir<%dec233> = add nsw ir<%anum.2394>, ir<-1>
    CLONE ir<%incdec.ptr234> = getelementptr inbounds ir<%tmps.4395>, ir<1>
    CLONE ir<%cmp226> = icmp ugt ir<%anum.2394>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end235.loopexit>, scalar.ph

ir-bb<for.end235.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_complement' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body228.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %anum.1.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%tmps.4395> = WIDEN-POINTER-INDUCTION ir<%tmpl.0.lcssa>, 1
    WIDEN-INDUCTION %anum.2394 = phi %dec233, %anum.1.lcssa, ir<-1>
    vp<%4> = vector-pointer ir<%tmps.4395>
    WIDEN ir<%65> = load vp<%4>
    WIDEN ir<%not230> = xor ir<%65>, ir<-1>
    vp<%5> = vector-pointer ir<%tmps.4395>
    WIDEN store vp<%5>, ir<%not230>
    CLONE ir<%dec233> = add nsw ir<%anum.2394>, ir<-1>
    CLONE ir<%incdec.ptr234> = getelementptr inbounds ir<%tmps.4395>, ir<1>
    CLONE ir<%cmp226> = icmp ugt ir<%anum.2394>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end235.loopexit>, scalar.ph

ir-bb<for.end235.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 21474836475
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 21474836475
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 21474836475
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 10737418240
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 2684354590, RTCostB: 21474836475
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354590, RTCostB: 5368709130
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1342177350, RTCostB: 21474836475
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1342177350, RTCostB: 2684354590
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1073741971, RTCostB: 21474836475
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741971, RTCostB: 1342177350
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 21474836475
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 1073741971

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 21474836475
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 1073741971

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2684354590, RTCostB: 21474836475
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354590, RTCostB: 1073741971

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177350, RTCostB: 21474836475
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177350, RTCostB: 1073741971

-----------------Function that is being costed:'Perl_pp_complement' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %tmps.4395 = phi ptr [ %incdec.ptr234, %for.body228 ], [ %tmpl.0.lcssa, %for.body228.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %anum.2394 = phi i32 [ %dec233, %for.body228 ], [ %anum.1.lcssa, %for.body228.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %65 = load i8, ptr %tmps.4395, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %not230 = xor i8 %65, -1 of type:xor
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %not230, ptr %tmps.4395, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec233 = add nsw i32 %anum.2394, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr234 = getelementptr inbounds i8, ptr %tmps.4395, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp226 = icmp ugt i32 %anum.2394, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp226, label %for.body228, label %for.end235.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741971, RTCostB: 21474836475
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741971, RTCostB: 1073741971
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_pp_complement at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body228.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %anum.1.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%tmpl.0.lcssa>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%65> = load vp<%6>
    WIDEN ir<%not230> = xor ir<%65>, ir<-1>
    vp<%7> = vector-pointer vp<%5>
    WIDEN store vp<%7>, ir<%not230>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end235.loopexit>, scalar.ph

ir-bb<for.end235.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1211, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select, ptr %s.1211, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_pp_uc' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond108 to i64)) + ((1 + (ptrtoint ptr %cond108 to i64)) umax ((ptrtoint ptr %cond108 to i64) + %47)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.1211> = WIDEN-POINTER-INDUCTION ir<%cond108>, 1
    CLONE ir<%48> = load ir<%s.1211>
    CLONE ir<%49> = add ir<%48>, ir<-97>
    CLONE ir<%or.cond204> = icmp ult ir<%49>, ir<26>
    CLONE ir<%sub124> = add nsw ir<%48>, ir<-32>
    CLONE ir<%spec.select> = select ir<%or.cond204>, ir<%sub124>, ir<%48>
    CLONE store ir<%spec.select>, ir<%s.1211>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1211>, ir<1>
    CLONE ir<%cmp113> = icmp ult ir<%incdec.ptr>, ir<%add.ptr112>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_uc' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond108 to i64)) + ((1 + (ptrtoint ptr %cond108 to i64)) umax ((ptrtoint ptr %cond108 to i64) + %47)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1211> = WIDEN-POINTER-INDUCTION ir<%cond108>, 1
    vp<%4> = vector-pointer ir<%s.1211>
    WIDEN ir<%48> = load vp<%4>
    WIDEN ir<%49> = add ir<%48>, ir<-97>
    WIDEN ir<%or.cond204> = icmp ult ir<%49>, ir<26>
    WIDEN ir<%sub124> = add nsw ir<%48>, ir<-32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond204>, ir<%sub124>, ir<%48>
    vp<%5> = vector-pointer ir<%s.1211>
    WIDEN store vp<%5>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1211>, ir<1>
    CLONE ir<%cmp113> = icmp ult ir<%incdec.ptr>, ir<%add.ptr112>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_uc' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond108 to i64)) + ((1 + (ptrtoint ptr %cond108 to i64)) umax ((ptrtoint ptr %cond108 to i64) + %47)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1211> = WIDEN-POINTER-INDUCTION ir<%cond108>, 1
    vp<%4> = vector-pointer ir<%s.1211>
    WIDEN ir<%48> = load vp<%4>
    WIDEN ir<%49> = add ir<%48>, ir<-97>
    WIDEN ir<%or.cond204> = icmp ult ir<%49>, ir<26>
    WIDEN ir<%sub124> = add nsw ir<%48>, ir<-32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond204>, ir<%sub124>, ir<%48>
    vp<%5> = vector-pointer ir<%s.1211>
    WIDEN store vp<%5>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1211>, ir<1>
    CLONE ir<%cmp113> = icmp ult ir<%incdec.ptr>, ir<%add.ptr112>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 2 for VF 32 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 2 for VF 32 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 2 for VF 32 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 224
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 13
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 208, CostB * EstimatedWidthA: 224
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 224, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 224, CostB * EstimatedWidthA: 52

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 224, CostB * EstimatedWidthA: 104

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 112
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 224, CostB * EstimatedWidthA: 208

-----------------Function that is being costed:'Perl_pp_uc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.1211 = phi ptr [ %incdec.ptr, %for.body ], [ %cond108, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %48 = load i8, ptr %s.1211, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %49 = add i8 %48, -97 of type:add
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %or.cond204 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %sub124 = add nsw i8 %48, -32 of type:add
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %spec.select = select i1 %or.cond204, i8 %sub124, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %spec.select, ptr %s.1211, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1211, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp113 = icmp ult ptr %incdec.ptr, %add.ptr112 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp113, label %for.body, label %if.end131.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 224
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 13
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 416, CostB * EstimatedWidthA: 416
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_pp_uc at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond108 to i64)) + ((1 + (ptrtoint ptr %cond108 to i64)) umax ((ptrtoint ptr %cond108 to i64) + %47)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%cond108>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%48> = load vp<%6>
    WIDEN ir<%49> = add ir<%48>, ir<-97>
    WIDEN ir<%or.cond204> = icmp ult ir<%49>, ir<26>
    WIDEN ir<%sub124> = add nsw ir<%48>, ir<-32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond204>, ir<%sub124>, ir<%48>
    vp<%7> = vector-pointer vp<%5>
    WIDEN store vp<%7>, ir<%spec.select>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end131.loopexit>, scalar.ph

ir-bb<if.end131.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 22
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %48 = load i8, ptr %s.1215, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select, ptr %s.1215, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_pp_lc' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond112 to i64)) + ((1 + (ptrtoint ptr %cond112 to i64)) umax ((ptrtoint ptr %cond112 to i64) + %47)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.1215> = WIDEN-POINTER-INDUCTION ir<%cond112>, 1
    CLONE ir<%48> = load ir<%s.1215>
    CLONE ir<%49> = add ir<%48>, ir<-65>
    CLONE ir<%or.cond208> = icmp ult ir<%49>, ir<26>
    CLONE ir<%narrow> = add nuw nsw ir<%48>, ir<32>
    CLONE ir<%spec.select> = select ir<%or.cond208>, ir<%narrow>, ir<%48>
    CLONE store ir<%spec.select>, ir<%s.1215>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1215>, ir<1>
    CLONE ir<%cmp117> = icmp ult ir<%incdec.ptr>, ir<%add.ptr116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_lc' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond112 to i64)) + ((1 + (ptrtoint ptr %cond112 to i64)) umax ((ptrtoint ptr %cond112 to i64) + %47)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1215> = WIDEN-POINTER-INDUCTION ir<%cond112>, 1
    vp<%4> = vector-pointer ir<%s.1215>
    WIDEN ir<%48> = load vp<%4>
    WIDEN ir<%49> = add ir<%48>, ir<-65>
    WIDEN ir<%or.cond208> = icmp ult ir<%49>, ir<26>
    WIDEN ir<%narrow> = add nuw nsw ir<%48>, ir<32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond208>, ir<%narrow>, ir<%48>
    vp<%5> = vector-pointer ir<%s.1215>
    WIDEN store vp<%5>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1215>, ir<1>
    CLONE ir<%cmp117> = icmp ult ir<%incdec.ptr>, ir<%add.ptr116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_lc' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond112 to i64)) + ((1 + (ptrtoint ptr %cond112 to i64)) umax ((ptrtoint ptr %cond112 to i64) + %47)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1215> = WIDEN-POINTER-INDUCTION ir<%cond112>, 1
    vp<%4> = vector-pointer ir<%s.1215>
    WIDEN ir<%48> = load vp<%4>
    WIDEN ir<%49> = add ir<%48>, ir<-65>
    WIDEN ir<%or.cond208> = icmp ult ir<%49>, ir<26>
    WIDEN ir<%narrow> = add nuw nsw ir<%48>, ir<32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond208>, ir<%narrow>, ir<%48>
    vp<%5> = vector-pointer ir<%s.1215>
    WIDEN store vp<%5>, ir<%spec.select>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1215>, ir<1>
    CLONE ir<%cmp117> = icmp ult ir<%incdec.ptr>, ir<%add.ptr116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 2 for VF 32 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 2 for VF 32 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 2 for VF 32 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 224
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 13
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 208, CostB * EstimatedWidthA: 224
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 224, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 224, CostB * EstimatedWidthA: 52

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 224, CostB * EstimatedWidthA: 104

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 112
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 224, CostB * EstimatedWidthA: 208

-----------------Function that is being costed:'Perl_pp_lc' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.1215 = phi ptr [ %incdec.ptr, %for.body ], [ %cond112, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %48 = load i8, ptr %s.1215, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %49 = add i8 %48, -65 of type:add
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %or.cond208 = icmp ult i8 %49, 26 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %narrow = add nuw nsw i8 %48, 32 of type:add
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %spec.select = select i1 %or.cond208, i8 %narrow, i8 %48 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %spec.select, ptr %s.1215, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp117 = icmp ult ptr %incdec.ptr, %add.ptr116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp117, label %for.body, label %if.end135.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 224
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 13
B VF: 32, EstimatedWidthB: 32, CostB: 13
CostA * EstimatedWidthB: 416, CostB * EstimatedWidthA: 416
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_pp_lc at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %cond112 to i64)) + ((1 + (ptrtoint ptr %cond112 to i64)) umax ((ptrtoint ptr %cond112 to i64) + %47)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%cond112>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%48> = load vp<%6>
    WIDEN ir<%49> = add ir<%48>, ir<-65>
    WIDEN ir<%or.cond208> = icmp ult ir<%49>, ir<26>
    WIDEN ir<%narrow> = add nuw nsw ir<%48>, ir<32>
    WIDEN-SELECT ir<%spec.select> = select ir<%or.cond208>, ir<%narrow>, ir<%48>
    vp<%7> = vector-pointer vp<%5>
    WIDEN store vp<%7>, ir<%spec.select>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end135.loopexit>, scalar.ph

ir-bb<if.end135.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 24
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %24 = load i8, ptr %s.1195, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %24, ptr %d.1193, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_pp_quotemeta' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i8 %23 to i64) umin %21)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.1195> = WIDEN-POINTER-INDUCTION ir<%s.0199>, 1
    WIDEN-INDUCTION %ulen.1194 = phi %dec, %spec.select, ir<-1>
    EMIT ir<%d.1193> = WIDEN-POINTER-INDUCTION ir<%d.0198>, 1
    CLONE ir<%dec> = add ir<%ulen.1194>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1195>, ir<1>
    CLONE ir<%24> = load ir<%s.1195>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds ir<%d.1193>, ir<1>
    CLONE store ir<%24>, ir<%d.1193>
    CLONE ir<%tobool41.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end76.loopexit>, scalar.ph

ir-bb<if.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr.lcssa = ir<%incdec.ptr>
Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}

========== Loop: Perl_pp_quotemeta' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i8 %23 to i64) umin %21)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1195> = WIDEN-POINTER-INDUCTION ir<%s.0199>, 1
    WIDEN-INDUCTION %ulen.1194 = phi %dec, %spec.select, ir<-1>
    EMIT ir<%d.1193> = WIDEN-POINTER-INDUCTION ir<%d.0198>, 1
    CLONE ir<%dec> = add ir<%ulen.1194>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1195>, ir<1>
    vp<%4> = vector-pointer ir<%s.1195>
    WIDEN ir<%24> = load vp<%4>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds ir<%d.1193>, ir<1>
    vp<%5> = vector-pointer ir<%d.1193>
    WIDEN store vp<%5>, ir<%24>
    CLONE ir<%tobool41.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end76.loopexit>, scalar.ph

ir-bb<if.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr.lcssa = ir<%incdec.ptr>
Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}

========== Loop: Perl_pp_quotemeta' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i8 %23 to i64) umin %21)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.1195> = WIDEN-POINTER-INDUCTION ir<%s.0199>, 1
    WIDEN-INDUCTION %ulen.1194 = phi %dec, %spec.select, ir<-1>
    EMIT ir<%d.1193> = WIDEN-POINTER-INDUCTION ir<%d.0198>, 1
    CLONE ir<%dec> = add ir<%ulen.1194>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%s.1195>, ir<1>
    vp<%4> = vector-pointer ir<%s.1195>
    WIDEN ir<%24> = load vp<%4>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds ir<%d.1193>, ir<1>
    vp<%5> = vector-pointer ir<%d.1193>
    WIDEN store vp<%5>, ir<%24>
    CLONE ir<%tobool41.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end76.loopexit>, scalar.ph

ir-bb<if.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr.lcssa = ir<%incdec.ptr>
Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}


-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 64
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 128
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 96

-----------------Function that is being costed:'Perl_pp_quotemeta' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.1195 = phi ptr [ %incdec.ptr, %while.body42 ], [ %s.0199, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %ulen.1194 = phi i64 [ %dec, %while.body42 ], [ %spec.select, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %d.1193 = phi ptr [ %incdec.ptr43, %while.body42 ], [ %d.0198, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add i64 %ulen.1194, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %s.1195, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %24 = load i8, ptr %s.1195, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %d.1193, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %24, ptr %d.1193, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool41.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool41.not, label %if.end76.loopexit, label %while.body42 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_pp_quotemeta at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i8 %23 to i64) umin %21)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%s.0199>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%d.0198>, vp<%6>
    CLONE ir<%incdec.ptr> = getelementptr inbounds vp<%5>, ir<1>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%27> = load vp<%8>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds vp<%7>, ir<1>
    vp<%9> = vector-pointer vp<%7>
    WIDEN store vp<%9>, ir<%27>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end76.loopexit>, scalar.ph

ir-bb<if.end76.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr.lcssa = ir<%incdec.ptr>
Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 26
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %126 = load ptr, ptr %src.1782, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %126, ptr %dst.5781, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %126 = load ptr, ptr %src.1782, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %126, ptr %dst.5781, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %126 = load ptr, ptr %src.1782, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %126, ptr %dst.5781, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %126 = load ptr, ptr %src.1782, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %126, ptr %dst.5781, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then449>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %after.0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%src.1782> = WIDEN-POINTER-INDUCTION ir<%add.ptr457>, -8
    EMIT ir<%dst.5781> = WIDEN-POINTER-INDUCTION ir<%add.ptr454>, -8
    WIDEN-INDUCTION %i.5780 = phi %after.0, %dec464, ir<-1>
    CLONE ir<%incdec.ptr461> = getelementptr inbounds ir<%src.1782>, ir<-8>
    CLONE ir<%126> = load ir<%src.1782>
    CLONE ir<%incdec.ptr462> = getelementptr inbounds ir<%dst.5781>, ir<-8>
    CLONE store ir<%126>, ir<%dst.5781>
    CLONE ir<%dec464> = add nsw ir<%i.5780>, ir<-1>
    CLONE ir<%tobool459.not> = icmp eq ir<%dec464>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end468.loopexit>, scalar.ph

ir-bb<if.end468.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then449>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %after.0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%src.1782> = WIDEN-POINTER-INDUCTION ir<%add.ptr457>, -8
    EMIT ir<%dst.5781> = WIDEN-POINTER-INDUCTION ir<%add.ptr454>, -8
    WIDEN-INDUCTION %i.5780 = phi %after.0, %dec464, ir<-1>
    CLONE ir<%incdec.ptr461> = getelementptr inbounds ir<%src.1782>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%src.1782>
    WIDEN ir<%126> = load vp<%4>
    CLONE ir<%incdec.ptr462> = getelementptr inbounds ir<%dst.5781>, ir<-8>
    vp<%5> = vector-pointer (reverse) ir<%dst.5781>
    WIDEN store vp<%5>, ir<%126>
    CLONE ir<%dec464> = add nsw ir<%i.5780>, ir<-1>
    CLONE ir<%tobool459.not> = icmp eq ir<%dec464>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end468.loopexit>, scalar.ph

ir-bb<if.end468.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then449>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %after.0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%src.1782> = WIDEN-POINTER-INDUCTION ir<%add.ptr457>, -8
    EMIT ir<%dst.5781> = WIDEN-POINTER-INDUCTION ir<%add.ptr454>, -8
    WIDEN-INDUCTION %i.5780 = phi %after.0, %dec464, ir<-1>
    CLONE ir<%incdec.ptr461> = getelementptr inbounds ir<%src.1782>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%src.1782>
    WIDEN ir<%126> = load vp<%4>
    CLONE ir<%incdec.ptr462> = getelementptr inbounds ir<%dst.5781>, ir<-8>
    vp<%5> = vector-pointer (reverse) ir<%dst.5781>
    WIDEN store vp<%5>, ir<%126>
    CLONE ir<%dec464> = add nsw ir<%i.5780>, ir<-1>
    CLONE ir<%tobool459.not> = icmp eq ir<%dec464>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end468.loopexit>, scalar.ph

ir-bb<if.end468.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %src.1782 = phi ptr [ %add.ptr457, %if.then449 ], [ %incdec.ptr461, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dst.5781 = phi ptr [ %add.ptr454, %if.then449 ], [ %incdec.ptr462, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.5780 = phi i32 [ %after.0, %if.then449 ], [ %dec464, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr461 = getelementptr inbounds i8, ptr %src.1782, i64 -8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %126 = load ptr, ptr %src.1782, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr462 = getelementptr inbounds i8, ptr %dst.5781, i64 -8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %126, ptr %dst.5781, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec464 = add nsw i32 %i.5780, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool459.not = icmp eq i32 %dec464, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool459.not, label %if.end468.loopexit, label %for.body460 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %src.1782 = phi ptr [ %add.ptr457, %if.then449 ], [ %incdec.ptr461, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dst.5781 = phi ptr [ %add.ptr454, %if.then449 ], [ %incdec.ptr462, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.5780 = phi i32 [ %after.0, %if.then449 ], [ %dec464, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr461 = getelementptr inbounds i8, ptr %src.1782, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %126 = load ptr, ptr %src.1782, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr462 = getelementptr inbounds i8, ptr %dst.5781, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %126, ptr %dst.5781, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec464 = add nsw i32 %i.5780, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool459.not = icmp eq i32 %dec464, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool459.not, label %if.end468.loopexit, label %for.body460 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418234, RTCostB: 8589934588
A is not scalable.	B is not scalable.	
RTCostA: 10737418234, RTCostB: 8589934588

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %src.1782 = phi ptr [ %add.ptr457, %if.then449 ], [ %incdec.ptr461, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dst.5781 = phi ptr [ %add.ptr454, %if.then449 ], [ %incdec.ptr462, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.5780 = phi i32 [ %after.0, %if.then449 ], [ %dec464, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr461 = getelementptr inbounds i8, ptr %src.1782, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   %126 = load ptr, ptr %src.1782, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr462 = getelementptr inbounds i8, ptr %dst.5781, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr %126, ptr %dst.5781, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec464 = add nsw i32 %i.5780, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool459.not = icmp eq i32 %dec464, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool459.not, label %if.end468.loopexit, label %for.body460 of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 11811160054, RTCostB: 8589934588
A is not scalable.	B is not scalable.	
RTCostA: 11811160054, RTCostB: 8589934588

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %src.1782 = phi ptr [ %add.ptr457, %if.then449 ], [ %incdec.ptr461, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dst.5781 = phi ptr [ %add.ptr454, %if.then449 ], [ %incdec.ptr462, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.5780 = phi i32 [ %after.0, %if.then449 ], [ %dec464, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr461 = getelementptr inbounds i8, ptr %src.1782, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %126 = load ptr, ptr %src.1782, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr462 = getelementptr inbounds i8, ptr %dst.5781, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %126, ptr %dst.5781, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec464 = add nsw i32 %i.5780, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool459.not = icmp eq i32 %dec464, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool459.not, label %if.end468.loopexit, label %for.body460 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %src.1782 = phi ptr [ %add.ptr457, %if.then449 ], [ %incdec.ptr461, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dst.5781 = phi ptr [ %add.ptr454, %if.then449 ], [ %incdec.ptr462, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.5780 = phi i32 [ %after.0, %if.then449 ], [ %dec464, %for.body460 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr461 = getelementptr inbounds i8, ptr %src.1782, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %126 = load ptr, ptr %src.1782, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr462 = getelementptr inbounds i8, ptr %dst.5781, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr %126, ptr %dst.5781, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec464 = add nsw i32 %i.5780, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool459.not = icmp eq i32 %dec464, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool459.not, label %if.end468.loopexit, label %for.body460 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967300, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 4294967300, RTCostB: 6442450942
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_pp_splice at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then449>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %after.0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-8>
    EMIT vp<%6> = ptradd ir<%add.ptr457>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-8>
    EMIT vp<%9> = ptradd ir<%add.ptr454>, vp<%8>
    vp<%10> = vector-pointer (reverse) vp<%6>
    WIDEN ir<%126> = load vp<%10>
    vp<%11> = vector-pointer (reverse) vp<%9>
    WIDEN store vp<%11>, ir<%126>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end468.loopexit>, scalar.ph

ir-bb<if.end468.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %96 = load ptr, ptr %src.0796, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %96, ptr %dst.3795, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %96 = load ptr, ptr %src.0796, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %96, ptr %dst.3795, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %96 = load ptr, ptr %src.0796, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %96, ptr %dst.3795, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %96 = load ptr, ptr %src.0796, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %96, ptr %dst.3795, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body317.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %offset.2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%src.0796> = WIDEN-POINTER-INDUCTION ir<%arrayidx311>, -8
    EMIT ir<%dst.3795> = WIDEN-POINTER-INDUCTION ir<%add.ptr313>, -8
    WIDEN-INDUCTION %i.3794 = phi %dec321, %offset.2, ir<-1>
    CLONE ir<%incdec.ptr318> = getelementptr inbounds ir<%src.0796>, ir<-8>
    CLONE ir<%96> = load ir<%src.0796>
    CLONE ir<%incdec.ptr319> = getelementptr inbounds ir<%dst.3795>, ir<-8>
    CLONE store ir<%96>, ir<%dst.3795>
    CLONE ir<%dec321> = add nsw ir<%i.3794>, ir<-1>
    CLONE ir<%cmp315> = icmp ugt ir<%i.3794>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end323.loopexit>, scalar.ph

ir-bb<if.end323.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body317.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %offset.2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%src.0796> = WIDEN-POINTER-INDUCTION ir<%arrayidx311>, -8
    EMIT ir<%dst.3795> = WIDEN-POINTER-INDUCTION ir<%add.ptr313>, -8
    WIDEN-INDUCTION %i.3794 = phi %dec321, %offset.2, ir<-1>
    CLONE ir<%incdec.ptr318> = getelementptr inbounds ir<%src.0796>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%src.0796>
    WIDEN ir<%96> = load vp<%4>
    CLONE ir<%incdec.ptr319> = getelementptr inbounds ir<%dst.3795>, ir<-8>
    vp<%5> = vector-pointer (reverse) ir<%dst.3795>
    WIDEN store vp<%5>, ir<%96>
    CLONE ir<%dec321> = add nsw ir<%i.3794>, ir<-1>
    CLONE ir<%cmp315> = icmp ugt ir<%i.3794>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end323.loopexit>, scalar.ph

ir-bb<if.end323.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body317.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %offset.2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%src.0796> = WIDEN-POINTER-INDUCTION ir<%arrayidx311>, -8
    EMIT ir<%dst.3795> = WIDEN-POINTER-INDUCTION ir<%add.ptr313>, -8
    WIDEN-INDUCTION %i.3794 = phi %dec321, %offset.2, ir<-1>
    CLONE ir<%incdec.ptr318> = getelementptr inbounds ir<%src.0796>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%src.0796>
    WIDEN ir<%96> = load vp<%4>
    CLONE ir<%incdec.ptr319> = getelementptr inbounds ir<%dst.3795>, ir<-8>
    vp<%5> = vector-pointer (reverse) ir<%dst.3795>
    WIDEN store vp<%5>, ir<%96>
    CLONE ir<%dec321> = add nsw ir<%i.3794>, ir<-1>
    CLONE ir<%cmp315> = icmp ugt ir<%i.3794>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end323.loopexit>, scalar.ph

ir-bb<if.end323.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %src.0796 = phi ptr [ %incdec.ptr318, %for.body317 ], [ %arrayidx311, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dst.3795 = phi ptr [ %incdec.ptr319, %for.body317 ], [ %add.ptr313, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.3794 = phi i32 [ %dec321, %for.body317 ], [ %offset.2, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr318 = getelementptr inbounds i8, ptr %src.0796, i64 -8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %96 = load ptr, ptr %src.0796, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr319 = getelementptr inbounds i8, ptr %dst.3795, i64 -8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %96, ptr %dst.3795, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec321 = add nsw i32 %i.3794, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp315 = icmp ugt i32 %i.3794, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp315, label %for.body317, label %if.end323.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %src.0796 = phi ptr [ %incdec.ptr318, %for.body317 ], [ %arrayidx311, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dst.3795 = phi ptr [ %incdec.ptr319, %for.body317 ], [ %add.ptr313, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.3794 = phi i32 [ %dec321, %for.body317 ], [ %offset.2, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr318 = getelementptr inbounds i8, ptr %src.0796, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %96 = load ptr, ptr %src.0796, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr319 = getelementptr inbounds i8, ptr %dst.3795, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %96, ptr %dst.3795, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec321 = add nsw i32 %i.3794, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp315 = icmp ugt i32 %i.3794, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp315, label %for.body317, label %if.end323.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 21474836474, RTCostB: 17179869180
A is not scalable.	B is not scalable.	
RTCostA: 21474836474, RTCostB: 17179869180

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %src.0796 = phi ptr [ %incdec.ptr318, %for.body317 ], [ %arrayidx311, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dst.3795 = phi ptr [ %incdec.ptr319, %for.body317 ], [ %add.ptr313, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.3794 = phi i32 [ %dec321, %for.body317 ], [ %offset.2, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr318 = getelementptr inbounds i8, ptr %src.0796, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   %96 = load ptr, ptr %src.0796, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr319 = getelementptr inbounds i8, ptr %dst.3795, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr %96, ptr %dst.3795, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec321 = add nsw i32 %i.3794, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp315 = icmp ugt i32 %i.3794, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp315, label %for.body317, label %if.end323.loopexit of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 23622320118, RTCostB: 17179869180
A is not scalable.	B is not scalable.	
RTCostA: 23622320118, RTCostB: 17179869180

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %src.0796 = phi ptr [ %incdec.ptr318, %for.body317 ], [ %arrayidx311, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dst.3795 = phi ptr [ %incdec.ptr319, %for.body317 ], [ %add.ptr313, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.3794 = phi i32 [ %dec321, %for.body317 ], [ %offset.2, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr318 = getelementptr inbounds i8, ptr %src.0796, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %96 = load ptr, ptr %src.0796, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr319 = getelementptr inbounds i8, ptr %dst.3795, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %96, ptr %dst.3795, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec321 = add nsw i32 %i.3794, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp315 = icmp ugt i32 %i.3794, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp315, label %for.body317, label %if.end323.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901886, RTCostB: 17179869180
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901886, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %src.0796 = phi ptr [ %incdec.ptr318, %for.body317 ], [ %arrayidx311, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dst.3795 = phi ptr [ %incdec.ptr319, %for.body317 ], [ %add.ptr313, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.3794 = phi i32 [ %dec321, %for.body317 ], [ %offset.2, %for.body317.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr318 = getelementptr inbounds i8, ptr %src.0796, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %96 = load ptr, ptr %src.0796, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr319 = getelementptr inbounds i8, ptr %dst.3795, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr %96, ptr %dst.3795, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec321 = add nsw i32 %i.3794, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp315 = icmp ugt i32 %i.3794, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp315, label %for.body317, label %if.end323.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934596, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 8589934596, RTCostB: 12884901886
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_pp_splice at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body317.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %offset.2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-8>
    EMIT vp<%6> = ptradd ir<%arrayidx311>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-8>
    EMIT vp<%9> = ptradd ir<%add.ptr313>, vp<%8>
    vp<%10> = vector-pointer (reverse) vp<%6>
    WIDEN ir<%116> = load vp<%10>
    vp<%11> = vector-pointer (reverse) vp<%9>
    WIDEN store vp<%11>, ir<%116>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end323.loopexit>, scalar.ph

ir-bb<if.end323.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx362, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx362, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx362, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %arrayidx362, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end357>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (trunc i64 ((8 + (-1 * (ptrtoint ptr %mark.0 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32)) + %length.1)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.4797 = phi %sub358, %dec360, ir<-1>
    CLONE ir<%dec360> = add nsw ir<%i.4797>, ir<-1>
    CLONE ir<%idxprom361> = zext nneg ir<%dec360>
    CLONE ir<%arrayidx362> = getelementptr inbounds ir<%dst.4>, ir<%idxprom361>
    CLONE store ir<@PL_sv_undef>, ir<%arrayidx362>
    CLONE ir<%tobool359.not> = icmp eq ir<%dec360>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end357>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (trunc i64 ((8 + (-1 * (ptrtoint ptr %mark.0 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32)) + %length.1)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.4797 = phi %sub358, %dec360, ir<-1>
    CLONE ir<%dec360> = add nsw ir<%i.4797>, ir<-1>
    CLONE ir<%idxprom361> = zext nneg ir<%dec360>
    CLONE ir<%arrayidx362> = getelementptr inbounds ir<%dst.4>, ir<%idxprom361>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx362>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%tobool359.not> = icmp eq ir<%dec360>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_splice' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end357>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (trunc i64 ((8 + (-1 * (ptrtoint ptr %mark.0 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32)) + %length.1)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.4797 = phi %sub358, %dec360, ir<-1>
    CLONE ir<%dec360> = add nsw ir<%i.4797>, ir<-1>
    CLONE ir<%idxprom361> = zext nneg ir<%dec360>
    CLONE ir<%arrayidx362> = getelementptr inbounds ir<%dst.4>, ir<%idxprom361>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx362>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%tobool359.not> = icmp eq ir<%dec360>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.4797 = phi i32 [ %sub358, %if.end357 ], [ %dec360, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec360 = add nsw i32 %i.4797, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom361 = zext nneg i32 %dec360 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx362 = getelementptr inbounds ptr, ptr %dst.4, i64 %idxprom361 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx362, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool359.not = icmp eq i32 %dec360, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool359.not, label %while.end, label %while.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.4797 = phi i32 [ %sub358, %if.end357 ], [ %dec360, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec360 = add nsw i32 %i.4797, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom361 = zext nneg i32 %dec360 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx362 = getelementptr inbounds ptr, ptr %dst.4, i64 %idxprom361 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx362, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool359.not = icmp eq i32 %dec360, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool359.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.4797 = phi i32 [ %sub358, %if.end357 ], [ %dec360, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec360 = add nsw i32 %i.4797, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %idxprom361 = zext nneg i32 %dec360 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx362 = getelementptr inbounds ptr, ptr %dst.4, i64 %idxprom361 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx362, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool359.not = icmp eq i32 %dec360, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool359.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 13
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 26, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.4797 = phi i32 [ %sub358, %if.end357 ], [ %dec360, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec360 = add nsw i32 %i.4797, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom361 = zext nneg i32 %dec360 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx362 = getelementptr inbounds ptr, ptr %dst.4, i64 %idxprom361 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx362, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool359.not = icmp eq i32 %dec360, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool359.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 13
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 26
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_splice' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.4797 = phi i32 [ %sub358, %if.end357 ], [ %dec360, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec360 = add nsw i32 %i.4797, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom361 = zext nneg i32 %dec360 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx362 = getelementptr inbounds ptr, ptr %dst.4, i64 %idxprom361 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %arrayidx362, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool359.not = icmp eq i32 %dec360, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool359.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: vscale x 1, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_pp_splice at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end357>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (trunc i64 ((8 + (-1 * (ptrtoint ptr %mark.0 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32)) + %length.1)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%sub358> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%dec360> = add nsw vp<%5>, ir<-1>
    CLONE ir<%idxprom361> = zext nneg ir<%dec360>
    CLONE ir<%arrayidx362> = getelementptr inbounds ir<%dst.4>, ir<%idxprom361>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx362>
    WIDEN store vp<%6>, ir<@PL_sv_undef>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 48
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %8 = load ptr, ptr %mark.0171, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load ptr, ptr %sp.0170, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %9, ptr %mark.0171, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %8, ptr %sp.0170, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %8 = load ptr, ptr %mark.0171, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load ptr, ptr %sp.0170, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %9, ptr %mark.0171, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %8, ptr %sp.0170, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %8 = load ptr, ptr %mark.0171, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load ptr, ptr %sp.0170, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %9, ptr %mark.0171, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %8, ptr %sp.0170, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %8 = load ptr, ptr %mark.0171, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load ptr, ptr %sp.0170, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %9, ptr %mark.0171, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %8, ptr %sp.0170, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_pp_reverse' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-16 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (1 umin (-16 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %3 to i64))<nsw> + (ptrtoint ptr %1 to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %3 to i64))<nsw> + (ptrtoint ptr %1 to i64)))) /u 16) + (1 umin (-16 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %3 to i64))<nsw> + (ptrtoint ptr %1 to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%mark.0171> = WIDEN-POINTER-INDUCTION ir<%mark.0168>, 8
    EMIT ir<%sp.0170> = WIDEN-POINTER-INDUCTION ir<%0>, -8
    CLONE ir<%8> = load ir<%mark.0171>
    CLONE ir<%9> = load ir<%sp.0170>
    CLONE store ir<%9>, ir<%mark.0171>
    CLONE ir<%incdec.ptr12> = getelementptr inbounds ir<%sp.0170>, ir<-8>
    CLONE store ir<%8>, ir<%sp.0170>
    CLONE ir<%mark.0> = getelementptr inbounds ir<%mark.0171>, ir<8>
    CLONE ir<%cmp9> = icmp ult ir<%mark.0>, ir<%incdec.ptr12>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end107.loopexit>, scalar.ph

ir-bb<if.end107.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_reverse' from pp.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-16 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (1 umin (-16 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %3 to i64))<nsw> + (ptrtoint ptr %1 to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %3 to i64))<nsw> + (ptrtoint ptr %1 to i64)))) /u 16) + (1 umin (-16 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %3 to i64))<nsw> + (ptrtoint ptr %1 to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%mark.0171> = WIDEN-POINTER-INDUCTION ir<%mark.0168>, 8
    EMIT ir<%sp.0170> = WIDEN-POINTER-INDUCTION ir<%0>, -8
    vp<%4> = vector-pointer ir<%mark.0171>
    WIDEN ir<%8> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%sp.0170>
    WIDEN ir<%9> = load vp<%5>
    vp<%6> = vector-pointer ir<%mark.0171>
    WIDEN store vp<%6>, ir<%9>
    CLONE ir<%incdec.ptr12> = getelementptr inbounds ir<%sp.0170>, ir<-8>
    vp<%7> = vector-pointer (reverse) ir<%sp.0170>
    WIDEN store vp<%7>, ir<%8>
    CLONE ir<%mark.0> = getelementptr inbounds ir<%mark.0171>, ir<8>
    CLONE ir<%cmp9> = icmp ult ir<%mark.0>, ir<%incdec.ptr12>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end107.loopexit>, scalar.ph

ir-bb<if.end107.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_reverse' from pp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-16 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (1 umin (-16 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %3 to i64))<nsw> + (ptrtoint ptr %1 to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %3 to i64))<nsw> + (ptrtoint ptr %1 to i64)))) /u 16) + (1 umin (-16 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %3 to i64))<nsw> + (ptrtoint ptr %1 to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%mark.0171> = WIDEN-POINTER-INDUCTION ir<%mark.0168>, 8
    EMIT ir<%sp.0170> = WIDEN-POINTER-INDUCTION ir<%0>, -8
    vp<%4> = vector-pointer ir<%mark.0171>
    WIDEN ir<%8> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%sp.0170>
    WIDEN ir<%9> = load vp<%5>
    vp<%6> = vector-pointer ir<%mark.0171>
    WIDEN store vp<%6>, ir<%9>
    CLONE ir<%incdec.ptr12> = getelementptr inbounds ir<%sp.0170>, ir<-8>
    vp<%7> = vector-pointer (reverse) ir<%sp.0170>
    WIDEN store vp<%7>, ir<%8>
    CLONE ir<%mark.0> = getelementptr inbounds ir<%mark.0171>, ir<8>
    CLONE ir<%cmp9> = icmp ult ir<%mark.0>, ir<%incdec.ptr12>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end107.loopexit>, scalar.ph

ir-bb<if.end107.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_reverse' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %mark.0171 = phi ptr [ %mark.0, %while.body ], [ %mark.0168, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sp.0170 = phi ptr [ %incdec.ptr12, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %8 = load ptr, ptr %mark.0171, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load ptr, ptr %sp.0170, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %9, ptr %mark.0171, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr12 = getelementptr inbounds i8, ptr %sp.0170, i64 -8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %8, ptr %sp.0170, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %mark.0 = getelementptr inbounds i8, ptr %mark.0171, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp9 = icmp ult ptr %mark.0, %incdec.ptr12 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp9, label %while.body, label %if.end107.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'Perl_pp_reverse' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %mark.0171 = phi ptr [ %mark.0, %while.body ], [ %mark.0168, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sp.0170 = phi ptr [ %incdec.ptr12, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %8 = load ptr, ptr %mark.0171, align 8 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %9 = load ptr, ptr %sp.0170, align 8 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %9, ptr %mark.0171, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr12 = getelementptr inbounds i8, ptr %sp.0170, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %8, ptr %sp.0170, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %mark.0 = getelementptr inbounds i8, ptr %mark.0171, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp9 = icmp ult ptr %mark.0, %incdec.ptr12 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp9, label %while.body, label %if.end107.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 10
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'Perl_pp_reverse' from pp.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %mark.0171 = phi ptr [ %mark.0, %while.body ], [ %mark.0168, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sp.0170 = phi ptr [ %incdec.ptr12, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %8 = load ptr, ptr %mark.0171, align 8 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   %9 = load ptr, ptr %sp.0170, align 8 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %9, ptr %mark.0171, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr12 = getelementptr inbounds i8, ptr %sp.0170, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr %8, ptr %sp.0170, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %mark.0 = getelementptr inbounds i8, ptr %mark.0171, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp9 = icmp ult ptr %mark.0, %incdec.ptr12 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp9, label %while.body, label %if.end107.loopexit of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 20
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'Perl_pp_reverse' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %mark.0171 = phi ptr [ %mark.0, %while.body ], [ %mark.0168, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sp.0170 = phi ptr [ %incdec.ptr12, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %8 = load ptr, ptr %mark.0171, align 8 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %9 = load ptr, ptr %sp.0170, align 8 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %9, ptr %mark.0171, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr12 = getelementptr inbounds i8, ptr %sp.0170, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %8, ptr %sp.0170, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %mark.0 = getelementptr inbounds i8, ptr %mark.0171, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp9 = icmp ult ptr %mark.0, %incdec.ptr12 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp9, label %while.body, label %if.end107.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_reverse' from pp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %mark.0171 = phi ptr [ %mark.0, %while.body ], [ %mark.0168, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sp.0170 = phi ptr [ %incdec.ptr12, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %8 = load ptr, ptr %mark.0171, align 8 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %9 = load ptr, ptr %sp.0170, align 8 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %9, ptr %mark.0171, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr12 = getelementptr inbounds i8, ptr %sp.0170, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr %8, ptr %sp.0170, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %mark.0 = getelementptr inbounds i8, ptr %mark.0171, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp9 = icmp ult ptr %mark.0, %incdec.ptr12 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp9, label %while.body, label %if.end107.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: vscale x 1, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_pp_reverse at line: pp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-16 + (-8 * (sext i32 %5 to i64))<nsw> + (-1 * (1 umin (-16 + (-8 * (sext i32 %5 to i64))<nsw> + (-1 * (ptrtoint ptr %2 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %5 to i64))<nsw> + (ptrtoint ptr %2 to i64))))))<nuw><nsw> + (-1 * (ptrtoint ptr %2 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %5 to i64))<nsw> + (ptrtoint ptr %2 to i64)))) /u 16) + (1 umin (-16 + (-8 * (sext i32 %5 to i64))<nsw> + (-1 * (ptrtoint ptr %2 to i64)) + ((-8 + (ptrtoint ptr %0 to i64)) umax (16 + (8 * (sext i32 %5 to i64))<nsw> + (ptrtoint ptr %2 to i64))))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%mark.0168>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-8>
    EMIT vp<%9> = ptradd ir<%0>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%25> = load vp<%10>
    vp<%11> = vector-pointer (reverse) vp<%9>
    WIDEN ir<%26> = load vp<%11>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%26>
    vp<%13> = vector-pointer (reverse) vp<%9>
    WIDEN store vp<%13>, ir<%25>
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%16>
Successor(s): ir-bb<if.end107.loopexit>, scalar.ph

ir-bb<if.end107.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 9
Loops Analyzed: 53
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o pp_ctl.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         pp_ctl.c
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %60 = load i8, ptr %f.11557, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %60, ptr %t.21558, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%t.21558> = WIDEN-POINTER-INDUCTION ir<%t.1>, 1
    EMIT ir<%f.11557> = WIDEN-POINTER-INDUCTION ir<%f.0>, 1
    WIDEN-INDUCTION %arg.01556 = phi %dec, %35, ir<-1>
    CLONE ir<%dec> = add nsw ir<%arg.01556>, ir<-1>
    CLONE ir<%incdec.ptr162> = getelementptr inbounds ir<%f.11557>, ir<1>
    CLONE ir<%60> = load ir<%f.11557>
    CLONE ir<%incdec.ptr163> = getelementptr inbounds ir<%t.21558>, ir<1>
    CLONE store ir<%60>, ir<%t.21558>
    CLONE ir<%tobool161.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog1085.loopexit>, scalar.ph

ir-bb<sw.epilog1085.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr162.lcssa = ir<%incdec.ptr162>
Live-out ptr %incdec.ptr163.lcssa = ir<%incdec.ptr163>
}

========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%t.21558> = WIDEN-POINTER-INDUCTION ir<%t.1>, 1
    EMIT ir<%f.11557> = WIDEN-POINTER-INDUCTION ir<%f.0>, 1
    WIDEN-INDUCTION %arg.01556 = phi %dec, %35, ir<-1>
    CLONE ir<%dec> = add nsw ir<%arg.01556>, ir<-1>
    CLONE ir<%incdec.ptr162> = getelementptr inbounds ir<%f.11557>, ir<1>
    vp<%4> = vector-pointer ir<%f.11557>
    WIDEN ir<%60> = load vp<%4>
    CLONE ir<%incdec.ptr163> = getelementptr inbounds ir<%t.21558>, ir<1>
    vp<%5> = vector-pointer ir<%t.21558>
    WIDEN store vp<%5>, ir<%60>
    CLONE ir<%tobool161.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog1085.loopexit>, scalar.ph

ir-bb<sw.epilog1085.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr162.lcssa = ir<%incdec.ptr162>
Live-out ptr %incdec.ptr163.lcssa = ir<%incdec.ptr163>
}

========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%t.21558> = WIDEN-POINTER-INDUCTION ir<%t.1>, 1
    EMIT ir<%f.11557> = WIDEN-POINTER-INDUCTION ir<%f.0>, 1
    WIDEN-INDUCTION %arg.01556 = phi %dec, %35, ir<-1>
    CLONE ir<%dec> = add nsw ir<%arg.01556>, ir<-1>
    CLONE ir<%incdec.ptr162> = getelementptr inbounds ir<%f.11557>, ir<1>
    vp<%4> = vector-pointer ir<%f.11557>
    WIDEN ir<%60> = load vp<%4>
    CLONE ir<%incdec.ptr163> = getelementptr inbounds ir<%t.21558>, ir<1>
    vp<%5> = vector-pointer ir<%t.21558>
    WIDEN store vp<%5>, ir<%60>
    CLONE ir<%tobool161.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog1085.loopexit>, scalar.ph

ir-bb<sw.epilog1085.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr162.lcssa = ir<%incdec.ptr162>
Live-out ptr %incdec.ptr163.lcssa = ir<%incdec.ptr163>
}


-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 2147483672, RTCostB: 17179869180
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483672, RTCostB: 4294967304
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1073741880, RTCostB: 17179869180
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741880, RTCostB: 2147483672
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 805306486, RTCostB: 17179869180
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 805306486, RTCostB: 1073741880
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 805306486

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 805306486

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2147483672, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483672, RTCostB: 805306486

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741880, RTCostB: 17179869180
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741880, RTCostB: 805306486

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %t.21558 = phi ptr [ %incdec.ptr163, %while.body ], [ %t.1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %f.11557 = phi ptr [ %incdec.ptr162, %while.body ], [ %f.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arg.01556 = phi i32 [ %dec, %while.body ], [ %35, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i32 %arg.01556, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr162 = getelementptr inbounds i8, ptr %f.11557, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %60 = load i8, ptr %f.11557, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr163 = getelementptr inbounds i8, ptr %t.21558, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %60, ptr %t.21558, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool161.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool161.not, label %sw.epilog1085.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 805306486, RTCostB: 17179869180
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 805306486, RTCostB: 805306486
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_pp_formline at line: pp_ctl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%t.1>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%f.0>, vp<%6>
    CLONE ir<%incdec.ptr162> = getelementptr inbounds vp<%7>, ir<1>
    vp<%8> = vector-pointer vp<%7>
    WIDEN ir<%63> = load vp<%8>
    CLONE ir<%incdec.ptr163> = getelementptr inbounds vp<%5>, ir<1>
    vp<%9> = vector-pointer vp<%5>
    WIDEN store vp<%9>, ir<%63>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<sw.epilog1085.loopexit>, scalar.ph

ir-bb<sw.epilog1085.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr162.lcssa = ir<%incdec.ptr162>
Live-out ptr %incdec.ptr163.lcssa = ir<%incdec.ptr163>
}
================ Final VPlan ================

@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %179 = load i8, ptr %s.151522, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select1457, ptr %t.161523, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body686.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %144 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%t.161523> = WIDEN-POINTER-INDUCTION ir<%t.0>, 1
    EMIT ir<%s.151522> = WIDEN-POINTER-INDUCTION ir<%item.0>, 1
    WIDEN-INDUCTION %arg.41521 = phi %dec684, %144, ir<-1>
    CLONE ir<%dec684> = add nsw ir<%arg.41521>, ir<-1>
    CLONE ir<%incdec.ptr687> = getelementptr inbounds ir<%s.151522>, ir<1>
    CLONE ir<%179> = load ir<%s.151522>
    CLONE ir<%incdec.ptr688> = getelementptr inbounds ir<%t.161523>, ir<1>
    CLONE ir<%spec.select1457> = call @llvm.umax.i8(ir<%179>, ir<32>)
    CLONE store ir<%spec.select1457>, ir<%t.161523>
    CLONE ir<%tobool685.not> = icmp eq ir<%dec684>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog1085.loopexit1635>, scalar.ph

ir-bb<sw.epilog1085.loopexit1635>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr688.lcssa = ir<%incdec.ptr688>
}

========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body686.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %144 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%t.161523> = WIDEN-POINTER-INDUCTION ir<%t.0>, 1
    EMIT ir<%s.151522> = WIDEN-POINTER-INDUCTION ir<%item.0>, 1
    WIDEN-INDUCTION %arg.41521 = phi %dec684, %144, ir<-1>
    CLONE ir<%dec684> = add nsw ir<%arg.41521>, ir<-1>
    CLONE ir<%incdec.ptr687> = getelementptr inbounds ir<%s.151522>, ir<1>
    vp<%4> = vector-pointer ir<%s.151522>
    WIDEN ir<%179> = load vp<%4>
    CLONE ir<%incdec.ptr688> = getelementptr inbounds ir<%t.161523>, ir<1>
    WIDEN-CALL ir<%spec.select1457> = call @llvm.umax.i8(ir<%179>, ir<32>) (using vector intrinsic)
    vp<%5> = vector-pointer ir<%t.161523>
    WIDEN store vp<%5>, ir<%spec.select1457>
    CLONE ir<%tobool685.not> = icmp eq ir<%dec684>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog1085.loopexit1635>, scalar.ph

ir-bb<sw.epilog1085.loopexit1635>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr688.lcssa = ir<%incdec.ptr688>
}

========== Loop: Perl_pp_formline' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body686.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %144 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%t.161523> = WIDEN-POINTER-INDUCTION ir<%t.0>, 1
    EMIT ir<%s.151522> = WIDEN-POINTER-INDUCTION ir<%item.0>, 1
    WIDEN-INDUCTION %arg.41521 = phi %dec684, %144, ir<-1>
    CLONE ir<%dec684> = add nsw ir<%arg.41521>, ir<-1>
    CLONE ir<%incdec.ptr687> = getelementptr inbounds ir<%s.151522>, ir<1>
    vp<%4> = vector-pointer ir<%s.151522>
    WIDEN ir<%179> = load vp<%4>
    CLONE ir<%incdec.ptr688> = getelementptr inbounds ir<%t.161523>, ir<1>
    WIDEN-CALL ir<%spec.select1457> = call @llvm.umax.i8(ir<%179>, ir<32>) (using vector intrinsic)
    vp<%5> = vector-pointer ir<%t.161523>
    WIDEN store vp<%5>, ir<%spec.select1457>
    CLONE ir<%tobool685.not> = icmp eq ir<%dec684>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog1085.loopexit1635>, scalar.ph

ir-bb<sw.epilog1085.loopexit1635>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr688.lcssa = ir<%incdec.ptr688>
}


-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 21474836475
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 21474836475
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 21474836475
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 10737418240
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 2684354590, RTCostB: 21474836475
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354590, RTCostB: 5368709130
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1342177350, RTCostB: 21474836475
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1342177350, RTCostB: 2684354590
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 32 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1073741971, RTCostB: 21474836475
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741971, RTCostB: 1342177350
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 21474836475
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10737418240, RTCostB: 1073741971

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 21474836475
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709130, RTCostB: 1073741971

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2684354590, RTCostB: 21474836475
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354590, RTCostB: 1073741971

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177350, RTCostB: 21474836475
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177350, RTCostB: 1073741971

-----------------Function that is being costed:'Perl_pp_formline' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %t.161523 = phi ptr [ %incdec.ptr688, %while.body686 ], [ %t.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.151522 = phi ptr [ %incdec.ptr687, %while.body686 ], [ %item.0, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arg.41521 = phi i32 [ %dec684, %while.body686 ], [ %144, %while.body686.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec684 = add nsw i32 %arg.41521, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr687 = getelementptr inbounds i8, ptr %s.151522, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %179 = load i8, ptr %s.151522, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr688 = getelementptr inbounds i8, ptr %t.161523, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %spec.select1457 = call i8 @llvm.umax.i8(i8 %179, i8 32) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %spec.select1457, ptr %t.161523, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool685.not = icmp eq i32 %dec684, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool685.not, label %sw.epilog1085.loopexit1635, label %while.body686 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741971, RTCostB: 21474836475
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741971, RTCostB: 1073741971
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_pp_formline at line: pp_ctl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body686.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %144 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%t.0>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%item.0>, vp<%6>
    vp<%8> = vector-pointer vp<%7>
    WIDEN ir<%182> = load vp<%8>
    CLONE ir<%incdec.ptr688> = getelementptr inbounds vp<%5>, ir<1>
    WIDEN-CALL ir<%spec.select1457> = call @llvm.umax.i8(ir<%182>, ir<32>) (using vector intrinsic)
    vp<%9> = vector-pointer vp<%5>
    WIDEN store vp<%9>, ir<%spec.select1457>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<sw.epilog1085.loopexit1635>, scalar.ph

ir-bb<sw.epilog1085.loopexit1635>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr688.lcssa = ir<%incdec.ptr688>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %19 = load ptr, ptr %src.0193, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %19, ptr %dst.0194, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %19 = load ptr, ptr %src.0193, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %19, ptr %dst.0194, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %19 = load ptr, ptr %src.0193, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %19, ptr %dst.0194, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %19 = load ptr, ptr %src.0193, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %19, ptr %dst.0194, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((trunc i64 (((-1 * (ptrtoint ptr %12 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * %10)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%dst.0194> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, -8
    EMIT ir<%src.0193> = WIDEN-POINTER-INDUCTION ir<%sp.0>, -8
    WIDEN-INDUCTION %count.0192 = phi %dec, %conv42, ir<-1>
    CLONE ir<%dec> = add nsw ir<%count.0192>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%src.0193>, ir<-8>
    CLONE ir<%19> = load ir<%src.0193>
    CLONE ir<%incdec.ptr59> = getelementptr inbounds ir<%dst.0194>, ir<-8>
    CLONE store ir<%19>, ir<%dst.0194>
    CLONE ir<%tobool58.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end60.loopexit>, scalar.ph

ir-bb<if.end60.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((trunc i64 (((-1 * (ptrtoint ptr %12 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * %10)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dst.0194> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, -8
    EMIT ir<%src.0193> = WIDEN-POINTER-INDUCTION ir<%sp.0>, -8
    WIDEN-INDUCTION %count.0192 = phi %dec, %conv42, ir<-1>
    CLONE ir<%dec> = add nsw ir<%count.0192>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%src.0193>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%src.0193>
    WIDEN ir<%19> = load vp<%4>
    CLONE ir<%incdec.ptr59> = getelementptr inbounds ir<%dst.0194>, ir<-8>
    vp<%5> = vector-pointer (reverse) ir<%dst.0194>
    WIDEN store vp<%5>, ir<%19>
    CLONE ir<%tobool58.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end60.loopexit>, scalar.ph

ir-bb<if.end60.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((trunc i64 (((-1 * (ptrtoint ptr %12 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * %10)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%dst.0194> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, -8
    EMIT ir<%src.0193> = WIDEN-POINTER-INDUCTION ir<%sp.0>, -8
    WIDEN-INDUCTION %count.0192 = phi %dec, %conv42, ir<-1>
    CLONE ir<%dec> = add nsw ir<%count.0192>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%src.0193>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%src.0193>
    WIDEN ir<%19> = load vp<%4>
    CLONE ir<%incdec.ptr59> = getelementptr inbounds ir<%dst.0194>, ir<-8>
    vp<%5> = vector-pointer (reverse) ir<%dst.0194>
    WIDEN store vp<%5>, ir<%19>
    CLONE ir<%tobool58.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end60.loopexit>, scalar.ph

ir-bb<if.end60.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dst.0194 = phi ptr [ %incdec.ptr59, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %src.0193 = phi ptr [ %incdec.ptr, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %count.0192 = phi i32 [ %dec, %while.body ], [ %conv42, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %count.0192, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %src.0193, i64 -8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %19 = load ptr, ptr %src.0193, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr59 = getelementptr inbounds i8, ptr %dst.0194, i64 -8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %19, ptr %dst.0194, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool58.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool58.not, label %if.end60.loopexit, label %while.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dst.0194 = phi ptr [ %incdec.ptr59, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %src.0193 = phi ptr [ %incdec.ptr, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %count.0192 = phi i32 [ %dec, %while.body ], [ %conv42, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %count.0192, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %src.0193, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %19 = load ptr, ptr %src.0193, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr59 = getelementptr inbounds i8, ptr %dst.0194, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %19, ptr %dst.0194, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool58.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool58.not, label %if.end60.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 21474836474, RTCostB: 17179869180
A is not scalable.	B is not scalable.	
RTCostA: 21474836474, RTCostB: 17179869180

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dst.0194 = phi ptr [ %incdec.ptr59, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %src.0193 = phi ptr [ %incdec.ptr, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %count.0192 = phi i32 [ %dec, %while.body ], [ %conv42, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %count.0192, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %src.0193, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   %19 = load ptr, ptr %src.0193, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr59 = getelementptr inbounds i8, ptr %dst.0194, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr %19, ptr %dst.0194, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool58.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool58.not, label %if.end60.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 23622320118, RTCostB: 17179869180
A is not scalable.	B is not scalable.	
RTCostA: 23622320118, RTCostB: 17179869180

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dst.0194 = phi ptr [ %incdec.ptr59, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %src.0193 = phi ptr [ %incdec.ptr, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %count.0192 = phi i32 [ %dec, %while.body ], [ %conv42, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %count.0192, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %src.0193, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %19 = load ptr, ptr %src.0193, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr59 = getelementptr inbounds i8, ptr %dst.0194, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %19, ptr %dst.0194, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool58.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool58.not, label %if.end60.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901886, RTCostB: 17179869180
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901886, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dst.0194 = phi ptr [ %incdec.ptr59, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %src.0193 = phi ptr [ %incdec.ptr, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %count.0192 = phi i32 [ %dec, %while.body ], [ %conv42, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %count.0192, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %src.0193, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %19 = load ptr, ptr %src.0193, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr59 = getelementptr inbounds i8, ptr %dst.0194, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr %19, ptr %dst.0194, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool58.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool58.not, label %if.end60.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934596, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 8589934596, RTCostB: 12884901886
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_pp_mapwhile at line: pp_ctl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((trunc i64 (((-1 * (ptrtoint ptr %12 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * %10)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-8>
    EMIT vp<%6> = ptradd ir<%add.ptr>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-8>
    EMIT vp<%9> = ptradd ir<%sp.0>, vp<%8>
    vp<%10> = vector-pointer (reverse) vp<%9>
    WIDEN ir<%35> = load vp<%10>
    vp<%11> = vector-pointer (reverse) vp<%6>
    WIDEN store vp<%11>, ir<%35>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end60.loopexit>, scalar.ph

ir-bb<if.end60.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store ptr @PL_sv_undef, ptr %dst.2196, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %dst.2196, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %dst.2196, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr @PL_sv_undef, ptr %dst.2196, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body89.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((trunc i64 (((-1 * (ptrtoint ptr %4 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * (1 umin ((trunc i64 (((-1 * (ptrtoint ptr %4 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * %6))))<nuw><nsw> + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%sp.4198> = WIDEN-POINTER-INDUCTION ir<%sp.1>, -8
    WIDEN-INDUCTION %items.1197 = phi %dec86, %conv21, ir<-1>
    EMIT ir<%dst.2196> = WIDEN-POINTER-INDUCTION ir<%add.ptr65>, -8
    CLONE ir<%dec86> = add nsw ir<%items.1197>, ir<-1>
    CLONE ir<%incdec.ptr90> = getelementptr inbounds ir<%sp.4198>, ir<-8>
    CLONE ir<%incdec.ptr91> = getelementptr inbounds ir<%dst.2196>, ir<-8>
    CLONE store ir<@PL_sv_undef>, ir<%dst.2196>
    CLONE ir<%cmp87> = icmp ugt ir<%items.1197>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end94.loopexit209>, scalar.ph

ir-bb<if.end94.loopexit209>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr90.lcssa = ir<%incdec.ptr90>
}

========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body89.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((trunc i64 (((-1 * (ptrtoint ptr %4 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * (1 umin ((trunc i64 (((-1 * (ptrtoint ptr %4 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * %6))))<nuw><nsw> + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%sp.4198> = WIDEN-POINTER-INDUCTION ir<%sp.1>, -8
    WIDEN-INDUCTION %items.1197 = phi %dec86, %conv21, ir<-1>
    EMIT ir<%dst.2196> = WIDEN-POINTER-INDUCTION ir<%add.ptr65>, -8
    CLONE ir<%dec86> = add nsw ir<%items.1197>, ir<-1>
    CLONE ir<%incdec.ptr90> = getelementptr inbounds ir<%sp.4198>, ir<-8>
    CLONE ir<%incdec.ptr91> = getelementptr inbounds ir<%dst.2196>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%dst.2196>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%cmp87> = icmp ugt ir<%items.1197>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end94.loopexit209>, scalar.ph

ir-bb<if.end94.loopexit209>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr90.lcssa = ir<%incdec.ptr90>
}

========== Loop: Perl_pp_mapwhile' from pp_ctl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body89.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((trunc i64 (((-1 * (ptrtoint ptr %4 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * (1 umin ((trunc i64 (((-1 * (ptrtoint ptr %4 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * %6))))<nuw><nsw> + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%sp.4198> = WIDEN-POINTER-INDUCTION ir<%sp.1>, -8
    WIDEN-INDUCTION %items.1197 = phi %dec86, %conv21, ir<-1>
    EMIT ir<%dst.2196> = WIDEN-POINTER-INDUCTION ir<%add.ptr65>, -8
    CLONE ir<%dec86> = add nsw ir<%items.1197>, ir<-1>
    CLONE ir<%incdec.ptr90> = getelementptr inbounds ir<%sp.4198>, ir<-8>
    CLONE ir<%incdec.ptr91> = getelementptr inbounds ir<%dst.2196>, ir<-8>
    vp<%4> = vector-pointer (reverse) ir<%dst.2196>
    WIDEN store vp<%4>, ir<@PL_sv_undef>
    CLONE ir<%cmp87> = icmp ugt ir<%items.1197>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end94.loopexit209>, scalar.ph

ir-bb<if.end94.loopexit209>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr90.lcssa = ir<%incdec.ptr90>
}


-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sp.4198 = phi ptr [ %incdec.ptr90, %while.body89 ], [ %sp.1, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %items.1197 = phi i32 [ %dec86, %while.body89 ], [ %conv21, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dst.2196 = phi ptr [ %incdec.ptr91, %while.body89 ], [ %add.ptr65, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec86 = add nsw i32 %items.1197, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr90 = getelementptr inbounds i8, ptr %sp.4198, i64 -8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr91 = getelementptr inbounds i8, ptr %dst.2196, i64 -8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr @PL_sv_undef, ptr %dst.2196, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp87 = icmp ugt i32 %items.1197, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp87, label %while.body89, label %if.end94.loopexit209 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sp.4198 = phi ptr [ %incdec.ptr90, %while.body89 ], [ %sp.1, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %items.1197 = phi i32 [ %dec86, %while.body89 ], [ %conv21, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dst.2196 = phi ptr [ %incdec.ptr91, %while.body89 ], [ %add.ptr65, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec86 = add nsw i32 %items.1197, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr90 = getelementptr inbounds i8, ptr %sp.4198, i64 -8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr91 = getelementptr inbounds i8, ptr %dst.2196, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr @PL_sv_undef, ptr %dst.2196, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp87 = icmp ugt i32 %items.1197, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp87, label %while.body89, label %if.end94.loopexit209 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901885, RTCostB: 12884901885
A is not scalable.	B is not scalable.	
RTCostA: 12884901885, RTCostB: 12884901885

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sp.4198 = phi ptr [ %incdec.ptr90, %while.body89 ], [ %sp.1, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %items.1197 = phi i32 [ %dec86, %while.body89 ], [ %conv21, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dst.2196 = phi ptr [ %incdec.ptr91, %while.body89 ], [ %add.ptr65, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec86 = add nsw i32 %items.1197, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr90 = getelementptr inbounds i8, ptr %sp.4198, i64 -8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr91 = getelementptr inbounds i8, ptr %dst.2196, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr @PL_sv_undef, ptr %dst.2196, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp87 = icmp ugt i32 %items.1197, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp87, label %while.body89, label %if.end94.loopexit209 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901885, RTCostB: 12884901885
A is not scalable.	B is not scalable.	
RTCostA: 12884901885, RTCostB: 12884901885

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sp.4198 = phi ptr [ %incdec.ptr90, %while.body89 ], [ %sp.1, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %items.1197 = phi i32 [ %dec86, %while.body89 ], [ %conv21, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dst.2196 = phi ptr [ %incdec.ptr91, %while.body89 ], [ %add.ptr65, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec86 = add nsw i32 %items.1197, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr90 = getelementptr inbounds i8, ptr %sp.4198, i64 -8 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr91 = getelementptr inbounds i8, ptr %dst.2196, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr @PL_sv_undef, ptr %dst.2196, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp87 = icmp ugt i32 %items.1197, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp87, label %while.body89, label %if.end94.loopexit209 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934591, RTCostB: 12884901885
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934591, RTCostB: 12884901885
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_mapwhile' from pp_ctl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sp.4198 = phi ptr [ %incdec.ptr90, %while.body89 ], [ %sp.1, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %items.1197 = phi i32 [ %dec86, %while.body89 ], [ %conv21, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dst.2196 = phi ptr [ %incdec.ptr91, %while.body89 ], [ %add.ptr65, %while.body89.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec86 = add nsw i32 %items.1197, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr90 = getelementptr inbounds i8, ptr %sp.4198, i64 -8 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr91 = getelementptr inbounds i8, ptr %dst.2196, i64 -8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr @PL_sv_undef, ptr %dst.2196, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp87 = icmp ugt i32 %items.1197, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp87, label %while.body89, label %if.end94.loopexit209 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709124, RTCostB: 12884901885
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 5368709124, RTCostB: 8589934591
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_pp_mapwhile at line: pp_ctl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body89.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((trunc i64 (((-1 * (ptrtoint ptr %4 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * (1 umin ((trunc i64 (((-1 * (ptrtoint ptr %4 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) + (-1 * %6))))<nuw><nsw> + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-8>
    EMIT vp<%6> = ptradd ir<%sp.1>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-8>
    EMIT vp<%9> = ptradd ir<%add.ptr65>, vp<%8>
    CLONE ir<%incdec.ptr90> = getelementptr inbounds vp<%6>, ir<-8>
    vp<%10> = vector-pointer (reverse) vp<%9>
    WIDEN store vp<%10>, ir<@PL_sv_undef>
    EMIT vp<%11> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<if.end94.loopexit209>, scalar.ph

ir-bb<if.end94.loopexit209>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr90.lcssa = ir<%incdec.ptr90>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 31
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o pp_hot.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         pp_hot.c
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %91 = load i8, ptr %incdec.ptr312, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %91, ptr %incdec.ptr313, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_pp_subst' from pp_hot.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then304>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.21154> = WIDEN-POINTER-INDUCTION ir<%add.ptr263>, -1
    WIDEN-INDUCTION %i.01153 = phi %84, %dec, ir<-1>
    EMIT ir<%d.01152> = WIDEN-POINTER-INDUCTION ir<%add.ptr305>, -1
    CLONE ir<%dec> = add nsw ir<%i.01153>, ir<-1>
    CLONE ir<%incdec.ptr312> = getelementptr inbounds ir<%s.21154>, ir<-1>
    CLONE ir<%91> = load ir<%incdec.ptr312>
    CLONE ir<%incdec.ptr313> = getelementptr inbounds ir<%d.01152>, ir<-1>
    CLONE store ir<%91>, ir<%incdec.ptr313>
    CLONE ir<%tobool311.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_subst' from pp_hot.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then304>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.21154> = WIDEN-POINTER-INDUCTION ir<%add.ptr263>, -1
    WIDEN-INDUCTION %i.01153 = phi %84, %dec, ir<-1>
    EMIT ir<%d.01152> = WIDEN-POINTER-INDUCTION ir<%add.ptr305>, -1
    CLONE ir<%dec> = add nsw ir<%i.01153>, ir<-1>
    CLONE ir<%incdec.ptr312> = getelementptr inbounds ir<%s.21154>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr312>
    WIDEN ir<%91> = load vp<%4>
    CLONE ir<%incdec.ptr313> = getelementptr inbounds ir<%d.01152>, ir<-1>
    vp<%5> = vector-pointer (reverse) ir<%incdec.ptr313>
    WIDEN store vp<%5>, ir<%91>
    CLONE ir<%tobool311.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_pp_subst' from pp_hot.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then304>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.21154> = WIDEN-POINTER-INDUCTION ir<%add.ptr263>, -1
    WIDEN-INDUCTION %i.01153 = phi %84, %dec, ir<-1>
    EMIT ir<%d.01152> = WIDEN-POINTER-INDUCTION ir<%add.ptr305>, -1
    CLONE ir<%dec> = add nsw ir<%i.01153>, ir<-1>
    CLONE ir<%incdec.ptr312> = getelementptr inbounds ir<%s.21154>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr312>
    WIDEN ir<%91> = load vp<%4>
    CLONE ir<%incdec.ptr313> = getelementptr inbounds ir<%d.01152>, ir<-1>
    vp<%5> = vector-pointer (reverse) ir<%incdec.ptr313>
    WIDEN store vp<%5>, ir<%91>
    CLONE ir<%tobool311.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 21474836474, RTCostB: 17179869180
A is not scalable.	B is not scalable.	
RTCostA: 21474836474, RTCostB: 17179869180

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709138, RTCostB: 17179869180
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709138, RTCostB: 10737418242
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 2684354610, RTCostB: 17179869180
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354610, RTCostB: 5368709138
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 3221225572, RTCostB: 17179869180
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225572, RTCostB: 2684354610

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901886, RTCostB: 17179869180
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901886, RTCostB: 2684354610

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 2684354610

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3221225494, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225494, RTCostB: 2684354610

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612790, RTCostB: 17179869180
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612790, RTCostB: 2684354610
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_pp_subst' from pp_hot.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.21154 = phi ptr [ %add.ptr263, %if.then304 ], [ %incdec.ptr312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.01153 = phi i32 [ %84, %if.then304 ], [ %dec, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %d.01152 = phi ptr [ %add.ptr305, %if.then304 ], [ %incdec.ptr313, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i32 %i.01153, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr312 = getelementptr inbounds i8, ptr %s.21154, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %91 = load i8, ptr %incdec.ptr312, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr313 = getelementptr inbounds i8, ptr %d.01152, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %91, ptr %incdec.ptr313, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool311.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool311.not, label %while.end, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741940, RTCostB: 17179869180
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741940, RTCostB: 1610612790
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_pp_subst at line: pp_hot.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then304>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    EMIT vp<%6> = ptradd ir<%add.ptr263>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-1>
    EMIT vp<%9> = ptradd ir<%add.ptr305>, vp<%8>
    CLONE ir<%incdec.ptr312> = getelementptr inbounds vp<%6>, ir<-1>
    vp<%10> = vector-pointer (reverse) ir<%incdec.ptr312>
    WIDEN ir<%110> = load vp<%10>
    CLONE ir<%incdec.ptr313> = getelementptr inbounds vp<%9>, ir<-1>
    vp<%11> = vector-pointer (reverse) ir<%incdec.ptr313>
    WIDEN store vp<%11>, ir<%110>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o pp_pack.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         pp_pack.c
@@ Instruction =>  %56 = load i8, ptr %s.addr.62399, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62399, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62399, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load i8, ptr %s.addr.62399, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body368.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-8 + %len.17) to i64) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.addr.62399> = WIDEN-POINTER-INDUCTION ir<%s.addr.1>, 1
    WIDEN-INDUCTION %len.182398 = phi %len.17, %sub374, ir<-8>
    WIDEN-REDUCTION-PHI ir<%cuv.22397> = phi ir<%cuv.1>, ir<%add373>
    CLONE ir<%incdec.ptr369> = getelementptr inbounds ir<%s.addr.62399>, ir<1>
    CLONE ir<%56> = load ir<%s.addr.62399>
    CLONE ir<%idxprom370> = zext ir<%56>
    CLONE ir<%arrayidx371> = getelementptr inbounds ir<%55>, ir<%idxprom370>
    CLONE ir<%57> = load ir<%arrayidx371>
    CLONE ir<%conv372> = zext ir<%57>
    CLONE ir<%add373> = add ir<%cuv.22397>, ir<%conv372>
    CLONE ir<%sub374> = add nsw ir<%len.182398>, ir<-8>
    CLONE ir<%cmp366> = icmp ugt ir<%len.182398>, ir<15>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%cuv.22397>, ir<%add373>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end375.loopexit>, scalar.ph

ir-bb<while.end375.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr369.lcssa = ir<%incdec.ptr369>
Live-out i64 %add373.lcssa = vp<%6>
Live-out i32 %sub374.lcssa = ir<%sub374>
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body368.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-8 + %len.17) to i64) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.addr.62399> = WIDEN-POINTER-INDUCTION ir<%s.addr.1>, 1
    WIDEN-INDUCTION %len.182398 = phi %len.17, %sub374, ir<-8>
    WIDEN-REDUCTION-PHI ir<%cuv.22397> = phi ir<%cuv.1>, ir<%add373>
    CLONE ir<%incdec.ptr369> = getelementptr inbounds ir<%s.addr.62399>, ir<1>
    vp<%4> = vector-pointer ir<%s.addr.62399>
    WIDEN ir<%56> = load vp<%4>
    WIDEN-CAST ir<%idxprom370> = zext  ir<%56> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx371> = getelementptr inbounds ir<%55>, ir<%idxprom370>
    WIDEN ir<%57> = load ir<%arrayidx371>
    WIDEN-CAST ir<%conv372> = zext  ir<%57> to i64
    WIDEN ir<%add373> = add ir<%cuv.22397>, ir<%conv372>
    CLONE ir<%sub374> = add nsw ir<%len.182398>, ir<-8>
    CLONE ir<%cmp366> = icmp ugt ir<%len.182398>, ir<15>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%cuv.22397>, ir<%add373>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end375.loopexit>, scalar.ph

ir-bb<while.end375.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr369.lcssa = ir<%incdec.ptr369>
Live-out i64 %add373.lcssa = vp<%7>
Live-out i32 %sub374.lcssa = ir<%sub374>
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body368.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-8 + %len.17) to i64) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%s.addr.62399> = WIDEN-POINTER-INDUCTION ir<%s.addr.1>, 1
    WIDEN-INDUCTION %len.182398 = phi %len.17, %sub374, ir<-8>
    WIDEN-REDUCTION-PHI ir<%cuv.22397> = phi ir<%cuv.1>, ir<%add373>
    CLONE ir<%incdec.ptr369> = getelementptr inbounds ir<%s.addr.62399>, ir<1>
    vp<%4> = vector-pointer ir<%s.addr.62399>
    WIDEN ir<%56> = load vp<%4>
    WIDEN-CAST ir<%idxprom370> = zext  ir<%56> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx371> = getelementptr inbounds ir<%55>, ir<%idxprom370>
    WIDEN ir<%57> = load ir<%arrayidx371>
    WIDEN-CAST ir<%conv372> = zext  ir<%57> to i64
    WIDEN ir<%add373> = add ir<%cuv.22397>, ir<%conv372>
    CLONE ir<%sub374> = add nsw ir<%len.182398>, ir<-8>
    CLONE ir<%cmp366> = icmp ugt ir<%len.182398>, ir<15>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%cuv.22397>, ir<%add373>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end375.loopexit>, scalar.ph

ir-bb<while.end375.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr369.lcssa = ir<%incdec.ptr369>
Live-out i64 %add373.lcssa = vp<%7>
Live-out i32 %sub374.lcssa = ir<%sub374>
}


-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.addr.62399 = phi ptr [ %s.addr.1, %while.body368.lr.ph ], [ %incdec.ptr369, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.182398 = phi i32 [ %len.17, %while.body368.lr.ph ], [ %sub374, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cuv.22397 = phi i64 [ %cuv.1, %while.body368.lr.ph ], [ %add373, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %s.addr.62399, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %56 = load i8, ptr %s.addr.62399, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom370 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx371 = getelementptr inbounds i8, ptr %55, i64 %idxprom370 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %57 = load i8, ptr %arrayidx371, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv372 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add373 = add i64 %cuv.22397, %conv372 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub374 = add nsw i32 %len.182398, -8 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp366 = icmp ugt i32 %len.182398, 15 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp366, label %while.body368, label %while.end375.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.addr.62399 = phi ptr [ %s.addr.1, %while.body368.lr.ph ], [ %incdec.ptr369, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.182398 = phi i32 [ %len.17, %while.body368.lr.ph ], [ %sub374, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %cuv.22397 = phi i64 [ %cuv.1, %while.body368.lr.ph ], [ %add373, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %s.addr.62399, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %56 = load i8, ptr %s.addr.62399, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom370 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx371 = getelementptr inbounds i8, ptr %55, i64 %idxprom370 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %57 = load i8, ptr %arrayidx371, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv372 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add373 = add i64 %cuv.22397, %conv372 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub374 = add nsw i32 %len.182398, -8 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp366 = icmp ugt i32 %len.182398, 15 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp366, label %while.body368, label %while.end375.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 2147483645, RTCostB: 2684354555
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483645, RTCostB: 2684354555
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.addr.62399 = phi ptr [ %s.addr.1, %while.body368.lr.ph ], [ %incdec.ptr369, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.182398 = phi i32 [ %len.17, %while.body368.lr.ph ], [ %sub374, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %cuv.22397 = phi i64 [ %cuv.1, %while.body368.lr.ph ], [ %add373, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %s.addr.62399, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %56 = load i8, ptr %s.addr.62399, align 1 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom370 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx371 = getelementptr inbounds i8, ptr %55, i64 %idxprom370 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %57 = load i8, ptr %arrayidx371, align 1 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %conv372 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add373 = add i64 %cuv.22397, %conv372 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub374 = add nsw i32 %len.182398, -8 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp366 = icmp ugt i32 %len.182398, 15 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp366, label %while.body368, label %while.end375.loopexit of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 1744830466, RTCostB: 2684354555
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1744830466, RTCostB: 2147483645
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.addr.62399 = phi ptr [ %s.addr.1, %while.body368.lr.ph ], [ %incdec.ptr369, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.182398 = phi i32 [ %len.17, %while.body368.lr.ph ], [ %sub374, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %cuv.22397 = phi i64 [ %cuv.1, %while.body368.lr.ph ], [ %add373, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %s.addr.62399, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %56 = load i8, ptr %s.addr.62399, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom370 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx371 = getelementptr inbounds i8, ptr %55, i64 %idxprom370 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %57 = load i8, ptr %arrayidx371, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv372 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add373 = add i64 %cuv.22397, %conv372 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub374 = add nsw i32 %len.182398, -8 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp366 = icmp ugt i32 %len.182398, 15 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp366, label %while.body368, label %while.end375.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 2147483645, RTCostB: 2684354555
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483645, RTCostB: 1744830466

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.addr.62399 = phi ptr [ %s.addr.1, %while.body368.lr.ph ], [ %incdec.ptr369, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.182398 = phi i32 [ %len.17, %while.body368.lr.ph ], [ %sub374, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %cuv.22397 = phi i64 [ %cuv.1, %while.body368.lr.ph ], [ %add373, %while.body368 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr369 = getelementptr inbounds i8, ptr %s.addr.62399, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %56 = load i8, ptr %s.addr.62399, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %idxprom370 = zext i8 %56 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx371 = getelementptr inbounds i8, ptr %55, i64 %idxprom370 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %57 = load i8, ptr %arrayidx371, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %conv372 = zext i8 %57 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %add373 = add i64 %cuv.22397, %conv372 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub374 = add nsw i32 %len.182398, -8 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp366 = icmp ugt i32 %len.182398, 15 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp366, label %while.body368, label %while.end375.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 1744830466, RTCostB: 2684354555
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1744830466, RTCostB: 1744830466
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_unpack_rec at line: pp_pack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body368.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-8 + %len.17) to i64) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-REDUCTION-PHI ir<%cuv.22397> = phi ir<%cuv.1>, ir<%add373>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%s.addr.1>, vp<%4>
    vp<%6>    = DERIVED-IV ir<%len.17> + vp<%3> * ir<-8>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<-8>
    CLONE ir<%incdec.ptr369> = getelementptr inbounds vp<%5>, ir<1>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%56> = load vp<%8>
    WIDEN-CAST ir<%idxprom370> = zext  ir<%56> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx371> = getelementptr inbounds ir<%55>, ir<%idxprom370>
    WIDEN ir<%57> = load ir<%arrayidx371>
    WIDEN-CAST ir<%conv372> = zext  ir<%57> to i64
    WIDEN ir<%add373> = add ir<%cuv.22397>, ir<%conv372>
    CLONE ir<%sub374> = add nsw vp<%7>, ir<-8>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%cuv.22397>, ir<%add373>
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<while.end375.loopexit>, scalar.ph

ir-bb<while.end375.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr369.lcssa = ir<%incdec.ptr369>
Live-out i64 %add373.lcssa = vp<%11>
Live-out i32 %sub374.lcssa = ir<%sub374>
}
================ Final VPlan ================

@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %152 = load i8, ptr %arrayidx1220, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<65> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%conv1218>, ir<1>
    CLONE ir<%arrayidx1220> = getelementptr inbounds ir<@PL_uuemap>, ir<0>, ir<%indvars.iv>
    CLONE ir<%152> = load ir<%arrayidx1220>
    CLONE ir<%idxprom1221> = zext ir<%152>
    CLONE ir<%arrayidx1222> = getelementptr inbounds ir<@PL_uudmap>, ir<0>, ir<%idxprom1221>
    CLONE store ir<%conv1218>, ir<%arrayidx1222>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<65>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end1225>, scalar.ph

ir-bb<for.end1225>:
No successors

scalar.ph:
No successors
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<65> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%conv1218>, ir<1>
    CLONE ir<%arrayidx1220> = getelementptr inbounds ir<@PL_uuemap>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx1220>
    WIDEN ir<%152> = load vp<%3>
    WIDEN-CAST ir<%idxprom1221> = zext  ir<%152> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1222> = getelementptr inbounds ir<@PL_uudmap>, ir<0>, ir<%idxprom1221>
    WIDEN store ir<%arrayidx1222>, ir<%conv1218>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<65>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1225>, scalar.ph

ir-bb<for.end1225>:
No successors

scalar.ph:
No successors
}

========== Loop: S_unpack_rec' from pp_pack.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<65> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%conv1218>, ir<1>
    CLONE ir<%arrayidx1220> = getelementptr inbounds ir<@PL_uuemap>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx1220>
    WIDEN ir<%152> = load vp<%3>
    WIDEN-CAST ir<%idxprom1221> = zext  ir<%152> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1222> = getelementptr inbounds ir<@PL_uudmap>, ir<0>, ir<%idxprom1221>
    WIDEN store ir<%arrayidx1222>, ir<%conv1218>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<65>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<65>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1225>, scalar.ph

ir-bb<for.end1225>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 196, RTCostB: 260
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 196, RTCostB: 260
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 164, RTCostB: 260
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 164, RTCostB: 196
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 148, RTCostB: 260
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 148, RTCostB: 164
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 8 for VF 16 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF 16 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width 16 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 140, RTCostB: 260
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 140, RTCostB: 148
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 17 for VF 32 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 32 for VF 32 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 16 for VF 32 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width 32 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 140, RTCostB: 260
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 140, RTCostB: 140

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 196, RTCostB: 260
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 196, RTCostB: 140

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 164, RTCostB: 260
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 164, RTCostB: 140

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 148, RTCostB: 260
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 148, RTCostB: 140

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 16 for VF vscale x 8 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width vscale x 8 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 140, RTCostB: 260
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 140, RTCostB: 140
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'S_unpack_rec' from pp_pack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body1217 ], [ 0, %for.body1217.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %conv1218 = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1220 = getelementptr inbounds [65 x i8], ptr @PL_uuemap, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %152 = load i8, ptr %arrayidx1220, align 1 of type:load
LV: Found an estimated cost of 17 for VF vscale x 16 For instruction:   %idxprom1221 = zext i8 %152 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1222 = getelementptr inbounds [256 x i8], ptr @PL_uudmap, i64 0, i64 %idxprom1221 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 32 for VF vscale x 16 For instruction:   store i8 %conv1218, ptr %arrayidx1222, align 1 of type:store
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 65 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end1225, label %for.body1217 of type:br
LV: Vector loop of width vscale x 16 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 140, RTCostB: 260
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 140, RTCostB: 140
LV: Selecting VF: vscale x 8 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 8, UF=1 at function: S_unpack_rec at line: pp_pack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<65> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, 0\l" +
    "  ir<%conv1218>, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx1220> = getelementptr inbounds ir<@PL_uuemap>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx1220>
    WIDEN ir<%152> = load vp<%4>
    WIDEN-CAST ir<%idxprom1221> = zext  ir<%152> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1222> = getelementptr inbounds ir<@PL_uudmap>, ir<0>, ir<%idxprom1221>
    WIDEN store ir<%arrayidx1222>, ir<%conv1218>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<65>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end1225>, scalar.ph

ir-bb<for.end1225>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 38
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o pp_sort.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         pp_sort.c
@@ Instruction =>  %26 = load ptr, ptr %f1.4, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %26, ptr %f2.4, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load ptr, ptr %f1.4, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %26, ptr %f2.4, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %26 = load ptr, ptr %f1.4, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %26, ptr %f2.4, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load ptr, ptr %f1.4, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %26, ptr %f2.4, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then138>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %25 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f1.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr139>, 8
    EMIT ir<%f2.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr140>, 8
    CLONE ir<%incdec.ptr147> = getelementptr inbounds ir<%f1.4>, ir<8>
    CLONE ir<%26> = load ir<%f1.4>
    CLONE ir<%incdec.ptr148> = getelementptr inbounds ir<%f2.4>, ir<8>
    CLONE store ir<%26>, ir<%f2.4>
    CLONE ir<%cmp150> = icmp ult ir<%incdec.ptr147>, ir<%add.ptr145>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end151>, scalar.ph

ir-bb<do.end151>:
No successors

scalar.ph:
No successors
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then138>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %25 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr139>, 8
    EMIT ir<%f2.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr140>, 8
    CLONE ir<%incdec.ptr147> = getelementptr inbounds ir<%f1.4>, ir<8>
    vp<%4> = vector-pointer ir<%f1.4>
    WIDEN ir<%26> = load vp<%4>
    CLONE ir<%incdec.ptr148> = getelementptr inbounds ir<%f2.4>, ir<8>
    vp<%5> = vector-pointer ir<%f2.4>
    WIDEN store vp<%5>, ir<%26>
    CLONE ir<%cmp150> = icmp ult ir<%incdec.ptr147>, ir<%add.ptr145>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end151>, scalar.ph

ir-bb<do.end151>:
No successors

scalar.ph:
No successors
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then138>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %25 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr139>, 8
    EMIT ir<%f2.4> = WIDEN-POINTER-INDUCTION ir<%add.ptr140>, 8
    CLONE ir<%incdec.ptr147> = getelementptr inbounds ir<%f1.4>, ir<8>
    vp<%4> = vector-pointer ir<%f1.4>
    WIDEN ir<%26> = load vp<%4>
    CLONE ir<%incdec.ptr148> = getelementptr inbounds ir<%f2.4>, ir<8>
    vp<%5> = vector-pointer ir<%f2.4>
    WIDEN store vp<%5>, ir<%26>
    CLONE ir<%cmp150> = icmp ult ir<%incdec.ptr147>, ir<%add.ptr145>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end151>, scalar.ph

ir-bb<do.end151>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f1.4 = phi ptr [ %add.ptr139, %if.then138 ], [ %incdec.ptr147, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f2.4 = phi ptr [ %add.ptr140, %if.then138 ], [ %incdec.ptr148, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr147 = getelementptr inbounds i8, ptr %f1.4, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %26 = load ptr, ptr %f1.4, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr148 = getelementptr inbounds i8, ptr %f2.4, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %26, ptr %f2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp150 = icmp ult ptr %incdec.ptr147, %add.ptr145 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp150, label %do.body146, label %do.end151 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f1.4 = phi ptr [ %add.ptr139, %if.then138 ], [ %incdec.ptr147, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f2.4 = phi ptr [ %add.ptr140, %if.then138 ], [ %incdec.ptr148, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr147 = getelementptr inbounds i8, ptr %f1.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %26 = load ptr, ptr %f1.4, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr148 = getelementptr inbounds i8, ptr %f2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %26, ptr %f2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp150 = icmp ult ptr %incdec.ptr147, %add.ptr145 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp150, label %do.body146, label %do.end151 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f1.4 = phi ptr [ %add.ptr139, %if.then138 ], [ %incdec.ptr147, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f2.4 = phi ptr [ %add.ptr140, %if.then138 ], [ %incdec.ptr148, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr147 = getelementptr inbounds i8, ptr %f1.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %26 = load ptr, ptr %f1.4, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr148 = getelementptr inbounds i8, ptr %f2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %26, ptr %f2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp150 = icmp ult ptr %incdec.ptr147, %add.ptr145 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp150, label %do.body146, label %do.end151 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f1.4 = phi ptr [ %add.ptr139, %if.then138 ], [ %incdec.ptr147, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f2.4 = phi ptr [ %add.ptr140, %if.then138 ], [ %incdec.ptr148, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr147 = getelementptr inbounds i8, ptr %f1.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %26 = load ptr, ptr %f1.4, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr148 = getelementptr inbounds i8, ptr %f2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %26, ptr %f2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp150 = icmp ult ptr %incdec.ptr147, %add.ptr145 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp150, label %do.body146, label %do.end151 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f1.4 = phi ptr [ %add.ptr139, %if.then138 ], [ %incdec.ptr147, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f2.4 = phi ptr [ %add.ptr140, %if.then138 ], [ %incdec.ptr148, %do.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr147 = getelementptr inbounds i8, ptr %f1.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %26 = load ptr, ptr %f1.4, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr148 = getelementptr inbounds i8, ptr %f2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %26, ptr %f2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp150 = icmp ult ptr %incdec.ptr147, %add.ptr145 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp150, label %do.body146, label %do.end151 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then138>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %26 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%add.ptr139>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%add.ptr140>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%30> = load vp<%10>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%30>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<do.end151>, scalar.ph

ir-bb<do.end151>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %57 = load ptr, ptr %f1.5, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %57, ptr %f2.5, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load ptr, ptr %f1.5, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %57, ptr %f2.5, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %57 = load ptr, ptr %f1.5, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %57, ptr %f2.5, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load ptr, ptr %f1.5, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %57, ptr %f2.5, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then163>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %56 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f1.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr164>, 8
    EMIT ir<%f2.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr165>, 8
    CLONE ir<%incdec.ptr177> = getelementptr inbounds ir<%f1.5>, ir<8>
    CLONE ir<%57> = load ir<%f1.5>
    CLONE ir<%incdec.ptr178> = getelementptr inbounds ir<%f2.5>, ir<8>
    CLONE store ir<%57>, ir<%f2.5>
    CLONE ir<%cmp180> = icmp ult ir<%incdec.ptr177>, ir<%add.ptr175>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end181>, scalar.ph

ir-bb<do.end181>:
No successors

scalar.ph:
No successors
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then163>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %56 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr164>, 8
    EMIT ir<%f2.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr165>, 8
    CLONE ir<%incdec.ptr177> = getelementptr inbounds ir<%f1.5>, ir<8>
    vp<%4> = vector-pointer ir<%f1.5>
    WIDEN ir<%57> = load vp<%4>
    CLONE ir<%incdec.ptr178> = getelementptr inbounds ir<%f2.5>, ir<8>
    vp<%5> = vector-pointer ir<%f2.5>
    WIDEN store vp<%5>, ir<%57>
    CLONE ir<%cmp180> = icmp ult ir<%incdec.ptr177>, ir<%add.ptr175>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end181>, scalar.ph

ir-bb<do.end181>:
No successors

scalar.ph:
No successors
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then163>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %56 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr164>, 8
    EMIT ir<%f2.5> = WIDEN-POINTER-INDUCTION ir<%add.ptr165>, 8
    CLONE ir<%incdec.ptr177> = getelementptr inbounds ir<%f1.5>, ir<8>
    vp<%4> = vector-pointer ir<%f1.5>
    WIDEN ir<%57> = load vp<%4>
    CLONE ir<%incdec.ptr178> = getelementptr inbounds ir<%f2.5>, ir<8>
    vp<%5> = vector-pointer ir<%f2.5>
    WIDEN store vp<%5>, ir<%57>
    CLONE ir<%cmp180> = icmp ult ir<%incdec.ptr177>, ir<%add.ptr175>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end181>, scalar.ph

ir-bb<do.end181>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f1.5 = phi ptr [ %add.ptr164, %if.then163 ], [ %incdec.ptr177, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f2.5 = phi ptr [ %add.ptr165, %if.then163 ], [ %incdec.ptr178, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr177 = getelementptr inbounds i8, ptr %f1.5, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %57 = load ptr, ptr %f1.5, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr178 = getelementptr inbounds i8, ptr %f2.5, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %57, ptr %f2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp180 = icmp ult ptr %incdec.ptr177, %add.ptr175 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp180, label %do.body176, label %do.end181 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f1.5 = phi ptr [ %add.ptr164, %if.then163 ], [ %incdec.ptr177, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f2.5 = phi ptr [ %add.ptr165, %if.then163 ], [ %incdec.ptr178, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr177 = getelementptr inbounds i8, ptr %f1.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %57 = load ptr, ptr %f1.5, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr178 = getelementptr inbounds i8, ptr %f2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %57, ptr %f2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp180 = icmp ult ptr %incdec.ptr177, %add.ptr175 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp180, label %do.body176, label %do.end181 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f1.5 = phi ptr [ %add.ptr164, %if.then163 ], [ %incdec.ptr177, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f2.5 = phi ptr [ %add.ptr165, %if.then163 ], [ %incdec.ptr178, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr177 = getelementptr inbounds i8, ptr %f1.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %57 = load ptr, ptr %f1.5, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr178 = getelementptr inbounds i8, ptr %f2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %57, ptr %f2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp180 = icmp ult ptr %incdec.ptr177, %add.ptr175 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp180, label %do.body176, label %do.end181 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f1.5 = phi ptr [ %add.ptr164, %if.then163 ], [ %incdec.ptr177, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f2.5 = phi ptr [ %add.ptr165, %if.then163 ], [ %incdec.ptr178, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr177 = getelementptr inbounds i8, ptr %f1.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %57 = load ptr, ptr %f1.5, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr178 = getelementptr inbounds i8, ptr %f2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %57, ptr %f2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp180 = icmp ult ptr %incdec.ptr177, %add.ptr175 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp180, label %do.body176, label %do.end181 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f1.5 = phi ptr [ %add.ptr164, %if.then163 ], [ %incdec.ptr177, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f2.5 = phi ptr [ %add.ptr165, %if.then163 ], [ %incdec.ptr178, %do.body176 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr177 = getelementptr inbounds i8, ptr %f1.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %57 = load ptr, ptr %f1.5, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr178 = getelementptr inbounds i8, ptr %f2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %57, ptr %f2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp180 = icmp ult ptr %incdec.ptr177, %add.ptr175 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp180, label %do.body176, label %do.end181 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then163>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-8 * %offset.1) + (-1 * (ptrtoint ptr %base to i64)) + ((8 + (8 * %offset.1) + (ptrtoint ptr %base to i64)) umax ((-1 * (ptrtoint ptr %aux.0 to i64)) + (ptrtoint ptr %base to i64) + (ptrtoint ptr %56 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%add.ptr164>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%add.ptr165>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%60> = load vp<%10>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%60>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<do.end181>, scalar.ph

ir-bb<do.end181>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %29 = load ptr, ptr %f2.3, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %29, ptr %tp2.4, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %29 = load ptr, ptr %f2.3, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %29, ptr %tp2.4, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %29 = load ptr, ptr %f2.3, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %29, ptr %tp2.4, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %29 = load ptr, ptr %f2.3, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %29, ptr %tp2.4, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body95.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f2.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %13 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f2.3> = WIDEN-POINTER-INDUCTION ir<%f2.0.lcssa>, 8
    EMIT ir<%tp2.4> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr96> = getelementptr inbounds ir<%f2.3>, ir<8>
    CLONE ir<%29> = load ir<%f2.3>
    CLONE ir<%incdec.ptr97> = getelementptr inbounds ir<%tp2.4>, ir<8>
    CLONE store ir<%29>, ir<%tp2.4>
    CLONE ir<%cmp99> = icmp ult ir<%incdec.ptr96>, ir<%add.ptr25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end109.loopexit>, scalar.ph

ir-bb<if.end109.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr97.lcssa = ir<%incdec.ptr97>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body95.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f2.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %13 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f2.3> = WIDEN-POINTER-INDUCTION ir<%f2.0.lcssa>, 8
    EMIT ir<%tp2.4> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr96> = getelementptr inbounds ir<%f2.3>, ir<8>
    vp<%4> = vector-pointer ir<%f2.3>
    WIDEN ir<%29> = load vp<%4>
    CLONE ir<%incdec.ptr97> = getelementptr inbounds ir<%tp2.4>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.4>
    WIDEN store vp<%5>, ir<%29>
    CLONE ir<%cmp99> = icmp ult ir<%incdec.ptr96>, ir<%add.ptr25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end109.loopexit>, scalar.ph

ir-bb<if.end109.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr97.lcssa = ir<%incdec.ptr97>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body95.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f2.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %13 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f2.3> = WIDEN-POINTER-INDUCTION ir<%f2.0.lcssa>, 8
    EMIT ir<%tp2.4> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr96> = getelementptr inbounds ir<%f2.3>, ir<8>
    vp<%4> = vector-pointer ir<%f2.3>
    WIDEN ir<%29> = load vp<%4>
    CLONE ir<%incdec.ptr97> = getelementptr inbounds ir<%tp2.4>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.4>
    WIDEN store vp<%5>, ir<%29>
    CLONE ir<%cmp99> = icmp ult ir<%incdec.ptr96>, ir<%add.ptr25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end109.loopexit>, scalar.ph

ir-bb<if.end109.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr97.lcssa = ir<%incdec.ptr97>
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f2.3 = phi ptr [ %incdec.ptr96, %do.body95 ], [ %f2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tp2.4 = phi ptr [ %incdec.ptr97, %do.body95 ], [ %tp2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr96 = getelementptr inbounds i8, ptr %f2.3, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %29 = load ptr, ptr %f2.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr97 = getelementptr inbounds i8, ptr %tp2.4, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %29, ptr %tp2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp99 = icmp ult ptr %incdec.ptr96, %add.ptr25 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp99, label %do.body95, label %if.end109.loopexit of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f2.3 = phi ptr [ %incdec.ptr96, %do.body95 ], [ %f2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tp2.4 = phi ptr [ %incdec.ptr97, %do.body95 ], [ %tp2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr96 = getelementptr inbounds i8, ptr %f2.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %29 = load ptr, ptr %f2.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr97 = getelementptr inbounds i8, ptr %tp2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %29, ptr %tp2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp99 = icmp ult ptr %incdec.ptr96, %add.ptr25 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp99, label %do.body95, label %if.end109.loopexit of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f2.3 = phi ptr [ %incdec.ptr96, %do.body95 ], [ %f2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %tp2.4 = phi ptr [ %incdec.ptr97, %do.body95 ], [ %tp2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr96 = getelementptr inbounds i8, ptr %f2.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %29 = load ptr, ptr %f2.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr97 = getelementptr inbounds i8, ptr %tp2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %29, ptr %tp2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp99 = icmp ult ptr %incdec.ptr96, %add.ptr25 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp99, label %do.body95, label %if.end109.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f2.3 = phi ptr [ %incdec.ptr96, %do.body95 ], [ %f2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tp2.4 = phi ptr [ %incdec.ptr97, %do.body95 ], [ %tp2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr96 = getelementptr inbounds i8, ptr %f2.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %29 = load ptr, ptr %f2.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr97 = getelementptr inbounds i8, ptr %tp2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %29, ptr %tp2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp99 = icmp ult ptr %incdec.ptr96, %add.ptr25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp99, label %do.body95, label %if.end109.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f2.3 = phi ptr [ %incdec.ptr96, %do.body95 ], [ %f2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tp2.4 = phi ptr [ %incdec.ptr97, %do.body95 ], [ %tp2.0.lcssa, %do.body95.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr96 = getelementptr inbounds i8, ptr %f2.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %29 = load ptr, ptr %f2.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr97 = getelementptr inbounds i8, ptr %tp2.4, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %29, ptr %tp2.4, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp99 = icmp ult ptr %incdec.ptr96, %add.ptr25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp99, label %do.body95, label %if.end109.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body95.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f2.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %13 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%f2.0.lcssa>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%tp2.0.lcssa>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%33> = load vp<%10>
    CLONE ir<%incdec.ptr97> = getelementptr inbounds vp<%9>, ir<8>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%33>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end109.loopexit>, scalar.ph

ir-bb<if.end109.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr97.lcssa = ir<%incdec.ptr97>
}
================ Final VPlan ================

@@ Instruction =>  %56 = load ptr, ptr %f1.3, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %56, ptr %tp2.5, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load ptr, ptr %f1.3, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %56, ptr %tp2.5, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %56 = load ptr, ptr %f1.3, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %56, ptr %tp2.5, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %56 = load ptr, ptr %f1.3, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %56, ptr %tp2.5, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body103.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f1.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %12 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f1.3> = WIDEN-POINTER-INDUCTION ir<%f1.0.lcssa>, 8
    EMIT ir<%tp2.5> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr104> = getelementptr inbounds ir<%f1.3>, ir<8>
    CLONE ir<%56> = load ir<%f1.3>
    CLONE ir<%incdec.ptr105> = getelementptr inbounds ir<%tp2.5>, ir<8>
    CLONE store ir<%56>, ir<%tp2.5>
    CLONE ir<%cmp107> = icmp ult ir<%incdec.ptr104>, ir<%add.ptr21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end109.loopexit409>, scalar.ph

ir-bb<if.end109.loopexit409>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr105.lcssa = ir<%incdec.ptr105>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body103.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f1.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %12 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.3> = WIDEN-POINTER-INDUCTION ir<%f1.0.lcssa>, 8
    EMIT ir<%tp2.5> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr104> = getelementptr inbounds ir<%f1.3>, ir<8>
    vp<%4> = vector-pointer ir<%f1.3>
    WIDEN ir<%56> = load vp<%4>
    CLONE ir<%incdec.ptr105> = getelementptr inbounds ir<%tp2.5>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.5>
    WIDEN store vp<%5>, ir<%56>
    CLONE ir<%cmp107> = icmp ult ir<%incdec.ptr104>, ir<%add.ptr21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end109.loopexit409>, scalar.ph

ir-bb<if.end109.loopexit409>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr105.lcssa = ir<%incdec.ptr105>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body103.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f1.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %12 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.3> = WIDEN-POINTER-INDUCTION ir<%f1.0.lcssa>, 8
    EMIT ir<%tp2.5> = WIDEN-POINTER-INDUCTION ir<%tp2.0.lcssa>, 8
    CLONE ir<%incdec.ptr104> = getelementptr inbounds ir<%f1.3>, ir<8>
    vp<%4> = vector-pointer ir<%f1.3>
    WIDEN ir<%56> = load vp<%4>
    CLONE ir<%incdec.ptr105> = getelementptr inbounds ir<%tp2.5>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.5>
    WIDEN store vp<%5>, ir<%56>
    CLONE ir<%cmp107> = icmp ult ir<%incdec.ptr104>, ir<%add.ptr21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end109.loopexit409>, scalar.ph

ir-bb<if.end109.loopexit409>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr105.lcssa = ir<%incdec.ptr105>
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f1.3 = phi ptr [ %incdec.ptr104, %do.body103 ], [ %f1.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tp2.5 = phi ptr [ %incdec.ptr105, %do.body103 ], [ %tp2.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr104 = getelementptr inbounds i8, ptr %f1.3, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %56 = load ptr, ptr %f1.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %tp2.5, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %56, ptr %tp2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp107 = icmp ult ptr %incdec.ptr104, %add.ptr21 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp107, label %do.body103, label %if.end109.loopexit409 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f1.3 = phi ptr [ %incdec.ptr104, %do.body103 ], [ %f1.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tp2.5 = phi ptr [ %incdec.ptr105, %do.body103 ], [ %tp2.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr104 = getelementptr inbounds i8, ptr %f1.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %56 = load ptr, ptr %f1.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %tp2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %56, ptr %tp2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp107 = icmp ult ptr %incdec.ptr104, %add.ptr21 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp107, label %do.body103, label %if.end109.loopexit409 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f1.3 = phi ptr [ %incdec.ptr104, %do.body103 ], [ %f1.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %tp2.5 = phi ptr [ %incdec.ptr105, %do.body103 ], [ %tp2.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr104 = getelementptr inbounds i8, ptr %f1.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %56 = load ptr, ptr %f1.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %tp2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %56, ptr %tp2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp107 = icmp ult ptr %incdec.ptr104, %add.ptr21 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp107, label %do.body103, label %if.end109.loopexit409 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f1.3 = phi ptr [ %incdec.ptr104, %do.body103 ], [ %f1.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tp2.5 = phi ptr [ %incdec.ptr105, %do.body103 ], [ %tp2.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr104 = getelementptr inbounds i8, ptr %f1.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %56 = load ptr, ptr %f1.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %tp2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %56, ptr %tp2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp107 = icmp ult ptr %incdec.ptr104, %add.ptr21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp107, label %do.body103, label %if.end109.loopexit409 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f1.3 = phi ptr [ %incdec.ptr104, %do.body103 ], [ %f1.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tp2.5 = phi ptr [ %incdec.ptr105, %do.body103 ], [ %tp2.0.lcssa, %do.body103.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr104 = getelementptr inbounds i8, ptr %f1.3, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %56 = load ptr, ptr %f1.3, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %tp2.5, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %56, ptr %tp2.5, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp107 = icmp ult ptr %incdec.ptr104, %add.ptr21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp107, label %do.body103, label %if.end109.loopexit409 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body103.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0.lcssa to i64)) + ((8 + (ptrtoint ptr %f1.0.lcssa to i64)) umax ((-1 * (ptrtoint ptr %list2.0 to i64)) + (ptrtoint ptr %12 to i64) + (ptrtoint ptr %list1.0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%f1.0.lcssa>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%tp2.0.lcssa>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%60> = load vp<%10>
    CLONE ir<%incdec.ptr105> = getelementptr inbounds vp<%9>, ir<8>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%60>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end109.loopexit409>, scalar.ph

ir-bb<if.end109.loopexit409>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr105.lcssa = ir<%incdec.ptr105>
}
================ Final VPlan ================

@@ Instruction =>  %25 = load ptr, ptr %f2.1, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %25, ptr %tp2.1, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %25 = load ptr, ptr %f2.1, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %25, ptr %tp2.1, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %25 = load ptr, ptr %f2.1, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %25, ptr %tp2.1, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %25 = load ptr, ptr %f2.1, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %25, ptr %tp2.1, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body74.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0382 to i64)) + ((8 + (ptrtoint ptr %f2.0382 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f2.1> = WIDEN-POINTER-INDUCTION ir<%f2.0382>, 8
    EMIT ir<%tp2.1> = WIDEN-POINTER-INDUCTION ir<%tp2.0383>, 8
    CLONE ir<%incdec.ptr75> = getelementptr inbounds ir<%f2.1>, ir<8>
    CLONE ir<%25> = load ir<%f2.1>
    CLONE ir<%incdec.ptr76> = getelementptr inbounds ir<%tp2.1>, ir<8>
    CLONE store ir<%25>, ir<%tp2.1>
    CLONE ir<%cmp77> = icmp ult ir<%incdec.ptr75>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr75.lcssa = ir<%incdec.ptr75>
Live-out ptr %incdec.ptr76.lcssa = ir<%incdec.ptr76>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body74.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0382 to i64)) + ((8 + (ptrtoint ptr %f2.0382 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f2.1> = WIDEN-POINTER-INDUCTION ir<%f2.0382>, 8
    EMIT ir<%tp2.1> = WIDEN-POINTER-INDUCTION ir<%tp2.0383>, 8
    CLONE ir<%incdec.ptr75> = getelementptr inbounds ir<%f2.1>, ir<8>
    vp<%4> = vector-pointer ir<%f2.1>
    WIDEN ir<%25> = load vp<%4>
    CLONE ir<%incdec.ptr76> = getelementptr inbounds ir<%tp2.1>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.1>
    WIDEN store vp<%5>, ir<%25>
    CLONE ir<%cmp77> = icmp ult ir<%incdec.ptr75>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr75.lcssa = ir<%incdec.ptr75>
Live-out ptr %incdec.ptr76.lcssa = ir<%incdec.ptr76>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body74.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0382 to i64)) + ((8 + (ptrtoint ptr %f2.0382 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f2.1> = WIDEN-POINTER-INDUCTION ir<%f2.0382>, 8
    EMIT ir<%tp2.1> = WIDEN-POINTER-INDUCTION ir<%tp2.0383>, 8
    CLONE ir<%incdec.ptr75> = getelementptr inbounds ir<%f2.1>, ir<8>
    vp<%4> = vector-pointer ir<%f2.1>
    WIDEN ir<%25> = load vp<%4>
    CLONE ir<%incdec.ptr76> = getelementptr inbounds ir<%tp2.1>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.1>
    WIDEN store vp<%5>, ir<%25>
    CLONE ir<%cmp77> = icmp ult ir<%incdec.ptr75>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr75.lcssa = ir<%incdec.ptr75>
Live-out ptr %incdec.ptr76.lcssa = ir<%incdec.ptr76>
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f2.1 = phi ptr [ %incdec.ptr75, %do.body74 ], [ %f2.0382, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tp2.1 = phi ptr [ %incdec.ptr76, %do.body74 ], [ %tp2.0383, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %f2.1, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %25 = load ptr, ptr %f2.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr76 = getelementptr inbounds i8, ptr %tp2.1, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %25, ptr %tp2.1, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp77 = icmp ult ptr %incdec.ptr75, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp77, label %do.body74, label %do.end of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f2.1 = phi ptr [ %incdec.ptr75, %do.body74 ], [ %f2.0382, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tp2.1 = phi ptr [ %incdec.ptr76, %do.body74 ], [ %tp2.0383, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %f2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %25 = load ptr, ptr %f2.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr76 = getelementptr inbounds i8, ptr %tp2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %25, ptr %tp2.1, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp77 = icmp ult ptr %incdec.ptr75, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp77, label %do.body74, label %do.end of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f2.1 = phi ptr [ %incdec.ptr75, %do.body74 ], [ %f2.0382, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %tp2.1 = phi ptr [ %incdec.ptr76, %do.body74 ], [ %tp2.0383, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %f2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %25 = load ptr, ptr %f2.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr76 = getelementptr inbounds i8, ptr %tp2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %25, ptr %tp2.1, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp77 = icmp ult ptr %incdec.ptr75, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp77, label %do.body74, label %do.end of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f2.1 = phi ptr [ %incdec.ptr75, %do.body74 ], [ %f2.0382, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tp2.1 = phi ptr [ %incdec.ptr76, %do.body74 ], [ %tp2.0383, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %f2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %25 = load ptr, ptr %f2.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr76 = getelementptr inbounds i8, ptr %tp2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %25, ptr %tp2.1, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp77 = icmp ult ptr %incdec.ptr75, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp77, label %do.body74, label %do.end of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f2.1 = phi ptr [ %incdec.ptr75, %do.body74 ], [ %f2.0382, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tp2.1 = phi ptr [ %incdec.ptr76, %do.body74 ], [ %tp2.0383, %do.body74.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %f2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %25 = load ptr, ptr %f2.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr76 = getelementptr inbounds i8, ptr %tp2.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %25, ptr %tp2.1, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp77 = icmp ult ptr %incdec.ptr75, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp77, label %do.body74, label %do.end of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body74.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f2.0382 to i64)) + ((8 + (ptrtoint ptr %f2.0382 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%f2.0382>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%tp2.0383>, vp<%8>
    CLONE ir<%incdec.ptr75> = getelementptr inbounds vp<%6>, ir<8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%29> = load vp<%10>
    CLONE ir<%incdec.ptr76> = getelementptr inbounds vp<%9>, ir<8>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%29>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr75.lcssa = ir<%incdec.ptr75>
Live-out ptr %incdec.ptr76.lcssa = ir<%incdec.ptr76>
}
================ Final VPlan ================

@@ Instruction =>  %52 = load ptr, ptr %f1.1, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %52, ptr %tp2.2, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %52 = load ptr, ptr %f1.1, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %52, ptr %tp2.2, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %52 = load ptr, ptr %f1.1, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %52, ptr %tp2.2, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %52 = load ptr, ptr %f1.1, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %52, ptr %tp2.2, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0381 to i64)) + ((8 + (ptrtoint ptr %f1.0381 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%f1.1> = WIDEN-POINTER-INDUCTION ir<%f1.0381>, 8
    EMIT ir<%tp2.2> = WIDEN-POINTER-INDUCTION ir<%tp2.0383>, 8
    CLONE ir<%incdec.ptr82> = getelementptr inbounds ir<%f1.1>, ir<8>
    CLONE ir<%52> = load ir<%f1.1>
    CLONE ir<%incdec.ptr83> = getelementptr inbounds ir<%tp2.2>, ir<8>
    CLONE store ir<%52>, ir<%tp2.2>
    CLONE ir<%cmp85> = icmp ult ir<%incdec.ptr82>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.end86>, scalar.ph

ir-bb<do.end86>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr82.lcssa = ir<%incdec.ptr82>
Live-out ptr %incdec.ptr83.lcssa = ir<%incdec.ptr83>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0381 to i64)) + ((8 + (ptrtoint ptr %f1.0381 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.1> = WIDEN-POINTER-INDUCTION ir<%f1.0381>, 8
    EMIT ir<%tp2.2> = WIDEN-POINTER-INDUCTION ir<%tp2.0383>, 8
    CLONE ir<%incdec.ptr82> = getelementptr inbounds ir<%f1.1>, ir<8>
    vp<%4> = vector-pointer ir<%f1.1>
    WIDEN ir<%52> = load vp<%4>
    CLONE ir<%incdec.ptr83> = getelementptr inbounds ir<%tp2.2>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.2>
    WIDEN store vp<%5>, ir<%52>
    CLONE ir<%cmp85> = icmp ult ir<%incdec.ptr82>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end86>, scalar.ph

ir-bb<do.end86>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr82.lcssa = ir<%incdec.ptr82>
Live-out ptr %incdec.ptr83.lcssa = ir<%incdec.ptr83>
}

========== Loop: S_mergesortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0381 to i64)) + ((8 + (ptrtoint ptr %f1.0381 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%f1.1> = WIDEN-POINTER-INDUCTION ir<%f1.0381>, 8
    EMIT ir<%tp2.2> = WIDEN-POINTER-INDUCTION ir<%tp2.0383>, 8
    CLONE ir<%incdec.ptr82> = getelementptr inbounds ir<%f1.1>, ir<8>
    vp<%4> = vector-pointer ir<%f1.1>
    WIDEN ir<%52> = load vp<%4>
    CLONE ir<%incdec.ptr83> = getelementptr inbounds ir<%tp2.2>, ir<8>
    vp<%5> = vector-pointer ir<%tp2.2>
    WIDEN store vp<%5>, ir<%52>
    CLONE ir<%cmp85> = icmp ult ir<%incdec.ptr82>, ir<%t.2.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.end86>, scalar.ph

ir-bb<do.end86>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr82.lcssa = ir<%incdec.ptr82>
Live-out ptr %incdec.ptr83.lcssa = ir<%incdec.ptr83>
}


-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %f1.1 = phi ptr [ %incdec.ptr82, %do.body81 ], [ %f1.0381, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tp2.2 = phi ptr [ %incdec.ptr83, %do.body81 ], [ %tp2.0383, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr82 = getelementptr inbounds i8, ptr %f1.1, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %52 = load ptr, ptr %f1.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr83 = getelementptr inbounds i8, ptr %tp2.2, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %52, ptr %tp2.2, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp85 = icmp ult ptr %incdec.ptr82, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp85, label %do.body81, label %do.end86 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %f1.1 = phi ptr [ %incdec.ptr82, %do.body81 ], [ %f1.0381, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tp2.2 = phi ptr [ %incdec.ptr83, %do.body81 ], [ %tp2.0383, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr82 = getelementptr inbounds i8, ptr %f1.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %52 = load ptr, ptr %f1.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr83 = getelementptr inbounds i8, ptr %tp2.2, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %52, ptr %tp2.2, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp85 = icmp ult ptr %incdec.ptr82, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp85, label %do.body81, label %do.end86 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %f1.1 = phi ptr [ %incdec.ptr82, %do.body81 ], [ %f1.0381, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %tp2.2 = phi ptr [ %incdec.ptr83, %do.body81 ], [ %tp2.0383, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr82 = getelementptr inbounds i8, ptr %f1.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %52 = load ptr, ptr %f1.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr83 = getelementptr inbounds i8, ptr %tp2.2, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %52, ptr %tp2.2, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp85 = icmp ult ptr %incdec.ptr82, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp85, label %do.body81, label %do.end86 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %f1.1 = phi ptr [ %incdec.ptr82, %do.body81 ], [ %f1.0381, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tp2.2 = phi ptr [ %incdec.ptr83, %do.body81 ], [ %tp2.0383, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr82 = getelementptr inbounds i8, ptr %f1.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %52 = load ptr, ptr %f1.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr83 = getelementptr inbounds i8, ptr %tp2.2, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %52, ptr %tp2.2, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp85 = icmp ult ptr %incdec.ptr82, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp85, label %do.body81, label %do.end86 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'S_mergesortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %f1.1 = phi ptr [ %incdec.ptr82, %do.body81 ], [ %f1.0381, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tp2.2 = phi ptr [ %incdec.ptr83, %do.body81 ], [ %tp2.0383, %do.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr82 = getelementptr inbounds i8, ptr %f1.1, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %52 = load ptr, ptr %f1.1, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr83 = getelementptr inbounds i8, ptr %tp2.2, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %52, ptr %tp2.2, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp85 = icmp ult ptr %incdec.ptr82, %t.2.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp85, label %do.body81, label %do.end86 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_mergesortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %f1.0381 to i64)) + ((8 + (ptrtoint ptr %f1.0381 to i64)) umax (ptrtoint ptr %t.2.lcssa to i64))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%f1.0381>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%tp2.0383>, vp<%8>
    CLONE ir<%incdec.ptr82> = getelementptr inbounds vp<%6>, ir<8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%56> = load vp<%10>
    CLONE ir<%incdec.ptr83> = getelementptr inbounds vp<%9>, ir<8>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%56>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<do.end86>, scalar.ph

ir-bb<do.end86>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr82.lcssa = ir<%incdec.ptr82>
Live-out ptr %incdec.ptr83.lcssa = ir<%incdec.ptr83>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %q.0112, ptr %pp.0113, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %q.0112, ptr %pp.0113, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %q.0112, ptr %pp.0113, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %q.0112, ptr %pp.0113, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_qsortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nmemb> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%pp.0113> = WIDEN-POINTER-INDUCTION ir<%indir.0>, 8
    EMIT ir<%q.0112> = WIDEN-POINTER-INDUCTION ir<%list1>, 8
    WIDEN-INDUCTION %n.0111 = phi %nmemb, %dec, ir<-1>
    CLONE ir<%dec> = add ir<%n.0111>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%q.0112>, ir<8>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%pp.0113>, ir<8>
    CLONE store ir<%q.0112>, ir<%pp.0113>
    CLONE ir<%tobool20.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%nmemb>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: S_qsortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nmemb> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%pp.0113> = WIDEN-POINTER-INDUCTION ir<%indir.0>, 8
    EMIT ir<%q.0112> = WIDEN-POINTER-INDUCTION ir<%list1>, 8
    WIDEN-INDUCTION %n.0111 = phi %nmemb, %dec, ir<-1>
    CLONE ir<%dec> = add ir<%n.0111>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%q.0112>, ir<8>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%pp.0113>, ir<8>
    vp<%3> = vector-pointer ir<%pp.0113>
    WIDEN store vp<%3>, ir<%q.0112>
    CLONE ir<%tobool20.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%nmemb>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: S_qsortsv' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nmemb> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%pp.0113> = WIDEN-POINTER-INDUCTION ir<%indir.0>, 8
    EMIT ir<%q.0112> = WIDEN-POINTER-INDUCTION ir<%list1>, 8
    WIDEN-INDUCTION %n.0111 = phi %nmemb, %dec, ir<-1>
    CLONE ir<%dec> = add ir<%n.0111>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%q.0112>, ir<8>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%pp.0113>, ir<8>
    vp<%3> = vector-pointer ir<%pp.0113>
    WIDEN store vp<%3>, ir<%q.0112>
    CLONE ir<%tobool20.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%nmemb>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_qsortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %pp.0113 = phi ptr [ %indir.0, %if.end19 ], [ %incdec.ptr21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.0112 = phi ptr [ %list1, %if.end19 ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.0111 = phi i64 [ %nmemb, %if.end19 ], [ %dec, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %n.0111, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %q.0112, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %pp.0113, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %q.0112, ptr %pp.0113, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool20.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool20.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_qsortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %pp.0113 = phi ptr [ %indir.0, %if.end19 ], [ %incdec.ptr21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.0112 = phi ptr [ %list1, %if.end19 ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.0111 = phi i64 [ %nmemb, %if.end19 ], [ %dec, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %n.0111, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %q.0112, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %pp.0113, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %q.0112, ptr %pp.0113, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool20.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool20.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_qsortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %pp.0113 = phi ptr [ %indir.0, %if.end19 ], [ %incdec.ptr21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %q.0112 = phi ptr [ %list1, %if.end19 ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n.0111 = phi i64 [ %nmemb, %if.end19 ], [ %dec, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add i64 %n.0111, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %q.0112, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %pp.0113, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %q.0112, ptr %pp.0113, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool20.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool20.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_qsortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %pp.0113 = phi ptr [ %indir.0, %if.end19 ], [ %incdec.ptr21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.0112 = phi ptr [ %list1, %if.end19 ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.0111 = phi i64 [ %nmemb, %if.end19 ], [ %dec, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %n.0111, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %q.0112, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %pp.0113, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %q.0112, ptr %pp.0113, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool20.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool20.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'S_qsortsv' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %pp.0113 = phi ptr [ %indir.0, %if.end19 ], [ %incdec.ptr21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.0112 = phi ptr [ %list1, %if.end19 ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.0111 = phi i64 [ %nmemb, %if.end19 ], [ %dec, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %n.0111, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %q.0112, i64 8 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %pp.0113, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %q.0112, ptr %pp.0113, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool20.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool20.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_qsortsv at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nmemb> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%q.0112> = WIDEN-POINTER-INDUCTION ir<%list1>, 8
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%indir.0>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%q.0112>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%nmemb>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 11
Loops Epilogues Vectorized: 0
================================================
========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body81.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3193.us> = phi ir<%runs.2>, ir<%inc83.us>
    EMIT ir<%p2.3192.us> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5191.us> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    CLONE ir<%add.ptr82.us> = getelementptr inbounds ir<%p2.3192.us>, ir<16>
    CLONE store ir<%add.ptr82.us>, ir<%p2.3192.us>
    CLONE ir<%inc83.us> = add ir<%runs.3193.us>, ir<1>
    CLONE ir<%incdec.ptr86.us> = getelementptr inbounds ir<%q.5191.us>, ir<8>
    CLONE ir<%16> = load ir<%q.5191.us>
    CLONE ir<%17> = load ir<%incdec.ptr86.us>
    CLONE store ir<%17>, ir<%q.5191.us>
    CLONE store ir<%16>, ir<%incdec.ptr86.us>
    CLONE ir<%q.6.us> = getelementptr inbounds ir<%q.5191.us>, ir<16>
    CLONE ir<%cmp79.us> = icmp ult ir<%q.6.us>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3193.us>, ir<%inc83.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end92.loopexit>, scalar.ph

ir-bb<while.end92.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr82.us.lcssa = ir<%add.ptr82.us>
Live-out i64 %inc83.us.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body81.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3193.us> = phi ir<%runs.2>, ir<%inc83.us>
    EMIT ir<%p2.3192.us> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5191.us> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr82.us> = getelementptr inbounds ir<%p2.3192.us>, ir<16>
    WIDEN store ir<%p2.3192.us>, ir<%add.ptr82.us>
    WIDEN ir<%inc83.us> = add ir<%runs.3193.us>, ir<1>
    CLONE ir<%incdec.ptr86.us> = getelementptr inbounds ir<%q.5191.us>, ir<8>
    INTERLEAVE-GROUP with factor 2 at %16, ir<%q.5191.us>
      ir<%16> = load from index 0
      ir<%17> = load from index 1
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%incdec.ptr86.us>
      store ir<%17> to index 0
      store ir<%16> to index 1
    CLONE ir<%q.6.us> = getelementptr inbounds ir<%q.5191.us>, ir<16>
    CLONE ir<%cmp79.us> = icmp ult ir<%q.6.us>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3193.us>, ir<%inc83.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end92.loopexit>, scalar.ph

ir-bb<while.end92.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr82.us.lcssa = ir<%add.ptr82.us>
Live-out i64 %inc83.us.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body81.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3193.us> = phi ir<%runs.2>, ir<%inc83.us>
    EMIT ir<%p2.3192.us> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5191.us> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr82.us> = getelementptr inbounds ir<%p2.3192.us>, ir<16>
    WIDEN store ir<%p2.3192.us>, ir<%add.ptr82.us>
    WIDEN ir<%inc83.us> = add ir<%runs.3193.us>, ir<1>
    CLONE ir<%incdec.ptr86.us> = getelementptr inbounds ir<%q.5191.us>, ir<8>
    INTERLEAVE-GROUP with factor 2 at %16, ir<%q.5191.us>
      ir<%16> = load from index 0
      ir<%17> = load from index 1
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%incdec.ptr86.us>
      store ir<%17> to index 0
      store ir<%16> to index 1
    CLONE ir<%q.6.us> = getelementptr inbounds ir<%q.5191.us>, ir<16>
    CLONE ir<%cmp79.us> = icmp ult ir<%q.6.us>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3193.us>, ir<%inc83.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end92.loopexit>, scalar.ph

ir-bb<while.end92.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr82.us.lcssa = ir<%add.ptr82.us>
Live-out i64 %inc83.us.lcssa = vp<%6>
}


-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %runs.3193.us = phi i64 [ %inc83.us, %while.body81.us ], [ %runs.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p2.3192.us = phi ptr [ %add.ptr82.us, %while.body81.us ], [ %p2.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.5191.us = phi ptr [ %q.6.us, %while.body81.us ], [ %q.4, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr82.us = getelementptr inbounds i8, ptr %p2.3192.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr82.us, ptr %p2.3192.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc83.us = add nsw i64 %runs.3193.us, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr86.us = getelementptr inbounds i8, ptr %q.5191.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %16 = load ptr, ptr %q.5191.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %17 = load ptr, ptr %incdec.ptr86.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %17, ptr %q.5191.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %16, ptr %incdec.ptr86.us, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.6.us = getelementptr inbounds i8, ptr %q.5191.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp79.us = icmp ult ptr %q.6.us, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp79.us, label %while.body81.us, label %while.end92.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %runs.3193.us = phi i64 [ %inc83.us, %while.body81.us ], [ %runs.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p2.3192.us = phi ptr [ %add.ptr82.us, %while.body81.us ], [ %p2.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.5191.us = phi ptr [ %q.6.us, %while.body81.us ], [ %q.4, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr82.us = getelementptr inbounds i8, ptr %p2.3192.us, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %add.ptr82.us, ptr %p2.3192.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc83.us = add nsw i64 %runs.3193.us, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr86.us = getelementptr inbounds i8, ptr %q.5191.us, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   %16 = load ptr, ptr %q.5191.us, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %17 = load ptr, ptr %incdec.ptr86.us, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store ptr %17, ptr %q.5191.us, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   store ptr %16, ptr %incdec.ptr86.us, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.6.us = getelementptr inbounds i8, ptr %q.5191.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp79.us = icmp ult ptr %q.6.us, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp79.us, label %while.body81.us, label %while.end92.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %runs.3193.us = phi i64 [ %inc83.us, %while.body81.us ], [ %runs.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p2.3192.us = phi ptr [ %add.ptr82.us, %while.body81.us ], [ %p2.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %q.5191.us = phi ptr [ %q.6.us, %while.body81.us ], [ %q.4, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr82.us = getelementptr inbounds i8, ptr %p2.3192.us, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %add.ptr82.us, ptr %p2.3192.us, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc83.us = add nsw i64 %runs.3193.us, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr86.us = getelementptr inbounds i8, ptr %q.5191.us, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 4 For instruction:   %16 = load ptr, ptr %q.5191.us, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %17 = load ptr, ptr %incdec.ptr86.us, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store ptr %17, ptr %q.5191.us, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 4 For instruction:   store ptr %16, ptr %incdec.ptr86.us, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %q.6.us = getelementptr inbounds i8, ptr %q.5191.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp79.us = icmp ult ptr %q.6.us, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp79.us, label %while.body81.us, label %while.end92.loopexit of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 17
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 34, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %runs.3193.us = phi i64 [ %inc83.us, %while.body81.us ], [ %runs.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p2.3192.us = phi ptr [ %add.ptr82.us, %while.body81.us ], [ %p2.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.5191.us = phi ptr [ %q.6.us, %while.body81.us ], [ %q.4, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr82.us = getelementptr inbounds i8, ptr %p2.3192.us, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %add.ptr82.us, ptr %p2.3192.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc83.us = add nsw i64 %runs.3193.us, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr86.us = getelementptr inbounds i8, ptr %q.5191.us, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   %16 = load ptr, ptr %q.5191.us, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %17 = load ptr, ptr %incdec.ptr86.us, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store ptr %17, ptr %q.5191.us, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   store ptr %16, ptr %incdec.ptr86.us, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.6.us = getelementptr inbounds i8, ptr %q.5191.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp79.us = icmp ult ptr %q.6.us, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp79.us, label %while.body81.us, label %while.end92.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 14
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 10
B VF: 4, EstimatedWidthB: 4, CostB: 17
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 34

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %runs.3193.us = phi i64 [ %inc83.us, %while.body81.us ], [ %runs.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p2.3192.us = phi ptr [ %add.ptr82.us, %while.body81.us ], [ %p2.2, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.5191.us = phi ptr [ %q.6.us, %while.body81.us ], [ %q.4, %while.body81.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr82.us = getelementptr inbounds i8, ptr %p2.3192.us, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %add.ptr82.us, ptr %p2.3192.us, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc83.us = add nsw i64 %runs.3193.us, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr86.us = getelementptr inbounds i8, ptr %q.5191.us, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF vscale x 2 For instruction:   %16 = load ptr, ptr %q.5191.us, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %17 = load ptr, ptr %incdec.ptr86.us, align 8 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store ptr %17, ptr %q.5191.us, align 8 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF vscale x 2 For instruction:   store ptr %16, ptr %incdec.ptr86.us, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.6.us = getelementptr inbounds i8, ptr %q.5191.us, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp79.us = icmp ult ptr %q.6.us, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp79.us, label %while.body81.us, label %while.end92.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 17
B VF: 4, EstimatedWidthB: 4, CostB: 17
CostA * EstimatedWidthB: 68, CostB * EstimatedWidthA: 68
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 4.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: dynprep at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body81.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%runs.3193.us> = phi ir<%runs.2>, ir<%inc83.us>
    EMIT ir<%p2.3192.us> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<16>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<16>
    EMIT vp<%6> = ptradd ir<%q.4>, vp<%5>
    WIDEN-GEP Var[Inv] ir<%add.ptr82.us> = getelementptr inbounds ir<%p2.3192.us>, ir<16>
    WIDEN store ir<%p2.3192.us>, ir<%add.ptr82.us>
    WIDEN ir<%inc83.us> = add ir<%runs.3193.us>, ir<1>
    CLONE ir<%incdec.ptr86.us> = getelementptr inbounds vp<%6>, ir<8>
    INTERLEAVE-GROUP with factor 2 at %21, vp<%6>
      ir<%21> = load from index 0
      ir<%22> = load from index 1
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%incdec.ptr86.us>
      store ir<%22> to index 0
      store ir<%21> to index 1
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%runs.3193.us>, ir<%inc83.us>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end92.loopexit>, scalar.ph

ir-bb<while.end92.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr82.us.lcssa = ir<%add.ptr82.us>
Live-out i64 %inc83.us.lcssa = vp<%9>
}
================ Final VPlan ================

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3193> = phi ir<%runs.2>, ir<%inc83>
    EMIT ir<%p2.3192> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5191> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    CLONE ir<%add.ptr82> = getelementptr inbounds ir<%p2.3192>, ir<16>
    CLONE store ir<%add.ptr82>, ir<%p2.3192>
    CLONE ir<%inc83> = add ir<%runs.3193>, ir<1>
    CLONE ir<%q.6> = getelementptr inbounds ir<%q.5191>, ir<16>
    CLONE ir<%cmp79> = icmp ult ir<%q.6>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3193>, ir<%inc83>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end92.loopexit205>, scalar.ph

ir-bb<while.end92.loopexit205>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr82.lcssa = ir<%add.ptr82>
Live-out i64 %inc83.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3193> = phi ir<%runs.2>, ir<%inc83>
    EMIT ir<%p2.3192> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5191> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr82> = getelementptr inbounds ir<%p2.3192>, ir<16>
    WIDEN store ir<%p2.3192>, ir<%add.ptr82>
    WIDEN ir<%inc83> = add ir<%runs.3193>, ir<1>
    CLONE ir<%q.6> = getelementptr inbounds ir<%q.5191>, ir<16>
    CLONE ir<%cmp79> = icmp ult ir<%q.6>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3193>, ir<%inc83>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end92.loopexit205>, scalar.ph

ir-bb<while.end92.loopexit205>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr82.lcssa = ir<%add.ptr82>
Live-out i64 %inc83.lcssa = vp<%6>
}

========== Loop: dynprep' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3193> = phi ir<%runs.2>, ir<%inc83>
    EMIT ir<%p2.3192> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    EMIT ir<%q.5191> = WIDEN-POINTER-INDUCTION ir<%q.4>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr82> = getelementptr inbounds ir<%p2.3192>, ir<16>
    WIDEN store ir<%p2.3192>, ir<%add.ptr82>
    WIDEN ir<%inc83> = add ir<%runs.3193>, ir<1>
    CLONE ir<%q.6> = getelementptr inbounds ir<%q.5191>, ir<16>
    CLONE ir<%cmp79> = icmp ult ir<%q.6>, ir<%p.7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3193>, ir<%inc83>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end92.loopexit205>, scalar.ph

ir-bb<while.end92.loopexit205>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr82.lcssa = ir<%add.ptr82>
Live-out i64 %inc83.lcssa = vp<%6>
}


-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %runs.3193 = phi i64 [ %inc83, %while.body81 ], [ %runs.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p2.3192 = phi ptr [ %add.ptr82, %while.body81 ], [ %p2.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.5191 = phi ptr [ %q.6, %while.body81 ], [ %q.4, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr82 = getelementptr inbounds i8, ptr %p2.3192, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr82, ptr %p2.3192, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc83 = add nsw i64 %runs.3193, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %q.6 = getelementptr inbounds i8, ptr %q.5191, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp79 = icmp ult ptr %q.6, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp79, label %while.body81, label %while.end92.loopexit205 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %runs.3193 = phi i64 [ %inc83, %while.body81 ], [ %runs.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p2.3192 = phi ptr [ %add.ptr82, %while.body81 ], [ %p2.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.5191 = phi ptr [ %q.6, %while.body81 ], [ %q.4, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr82 = getelementptr inbounds i8, ptr %p2.3192, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %add.ptr82, ptr %p2.3192, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc83 = add nsw i64 %runs.3193, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %q.6 = getelementptr inbounds i8, ptr %q.5191, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp79 = icmp ult ptr %q.6, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp79, label %while.body81, label %while.end92.loopexit205 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %runs.3193 = phi i64 [ %inc83, %while.body81 ], [ %runs.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p2.3192 = phi ptr [ %add.ptr82, %while.body81 ], [ %p2.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %q.5191 = phi ptr [ %q.6, %while.body81 ], [ %q.4, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr82 = getelementptr inbounds i8, ptr %p2.3192, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %add.ptr82, ptr %p2.3192, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc83 = add nsw i64 %runs.3193, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %q.6 = getelementptr inbounds i8, ptr %q.5191, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp79 = icmp ult ptr %q.6, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp79, label %while.body81, label %while.end92.loopexit205 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %runs.3193 = phi i64 [ %inc83, %while.body81 ], [ %runs.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p2.3192 = phi ptr [ %add.ptr82, %while.body81 ], [ %p2.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.5191 = phi ptr [ %q.6, %while.body81 ], [ %q.4, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr82 = getelementptr inbounds i8, ptr %p2.3192, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %add.ptr82, ptr %p2.3192, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc83 = add nsw i64 %runs.3193, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %q.6 = getelementptr inbounds i8, ptr %q.5191, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp79 = icmp ult ptr %q.6, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp79, label %while.body81, label %while.end92.loopexit205 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'dynprep' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %runs.3193 = phi i64 [ %inc83, %while.body81 ], [ %runs.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p2.3192 = phi ptr [ %add.ptr82, %while.body81 ], [ %p2.2, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.5191 = phi ptr [ %q.6, %while.body81 ], [ %q.4, %while.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr82 = getelementptr inbounds i8, ptr %p2.3192, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %add.ptr82, ptr %p2.3192, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc83 = add nsw i64 %runs.3193, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %q.6 = getelementptr inbounds i8, ptr %q.5191, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp79 = icmp ult ptr %q.6, %p.7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp79, label %while.body81, label %while.end92.loopexit205 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: dynprep at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %q.4 to i64)) + ((16 + (ptrtoint ptr %q.4 to i64)) umax (ptrtoint ptr %p.7 to i64))) /u 16))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%runs.3193> = phi ir<%runs.2>, ir<%inc83>
    EMIT ir<%p2.3192> = WIDEN-POINTER-INDUCTION ir<%p2.2>, 16
    WIDEN-GEP Var[Inv] ir<%add.ptr82> = getelementptr inbounds ir<%p2.3192>, ir<16>
    WIDEN store ir<%p2.3192>, ir<%add.ptr82>
    WIDEN ir<%inc83> = add ir<%runs.3193>, ir<1>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%runs.3193>, ir<%inc83>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end92.loopexit205>, scalar.ph

ir-bb<while.end92.loopexit205>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr82.lcssa = ir<%add.ptr82>
Live-out i64 %inc83.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 9
Loops Analyzed: 25
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %68 = load ptr, ptr %arrayidx478, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %68, ptr %arrayidx481, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %68 = load ptr, ptr %arrayidx478, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %68, ptr %arrayidx481, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %68 = load ptr, ptr %arrayidx478, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %68, ptr %arrayidx481, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %68 = load ptr, ptr %arrayidx478, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %68, ptr %arrayidx481, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: S_qsortsvu' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body476.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %j449.0.lcssa to i64))<nsw> + {(sext i32 %part_left.0 to i64),+,1}<nsw><%for.cond451.preheader>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv932 = phi %indvars.iv.next933, %indvars.iv925, ir<-1>
    CLONE ir<%arrayidx478> = getelementptr inbounds ir<%array>, ir<%indvars.iv932>
    CLONE ir<%68> = load ir<%arrayidx478>
    CLONE ir<%arrayidx481> = getelementptr ir<%arrayidx478>, ir<8>
    CLONE store ir<%68>, ir<%arrayidx481>
    CLONE ir<%indvars.iv.next933> = add nsw ir<%indvars.iv932>, ir<-1>
    CLONE ir<%cmp474.not.not> = icmp sgt ir<%indvars.iv.next933>, ir<%67>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end484.loopexit>, scalar.ph

ir-bb<for.end484.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_qsortsvu' from pp_sort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body476.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %j449.0.lcssa to i64))<nsw> + {(sext i32 %part_left.0 to i64),+,1}<nsw><%for.cond451.preheader>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv932 = phi %indvars.iv.next933, %indvars.iv925, ir<-1>
    CLONE ir<%arrayidx478> = getelementptr inbounds ir<%array>, ir<%indvars.iv932>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx478>
    WIDEN ir<%68> = load vp<%4>
    CLONE ir<%arrayidx481> = getelementptr ir<%arrayidx478>, ir<8>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx481>
    WIDEN store vp<%5>, ir<%68>
    CLONE ir<%indvars.iv.next933> = add nsw ir<%indvars.iv932>, ir<-1>
    CLONE ir<%cmp474.not.not> = icmp sgt ir<%indvars.iv.next933>, ir<%67>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end484.loopexit>, scalar.ph

ir-bb<for.end484.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_qsortsvu' from pp_sort.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body476.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %j449.0.lcssa to i64))<nsw> + {(sext i32 %part_left.0 to i64),+,1}<nsw><%for.cond451.preheader>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv932 = phi %indvars.iv.next933, %indvars.iv925, ir<-1>
    CLONE ir<%arrayidx478> = getelementptr inbounds ir<%array>, ir<%indvars.iv932>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx478>
    WIDEN ir<%68> = load vp<%4>
    CLONE ir<%arrayidx481> = getelementptr ir<%arrayidx478>, ir<8>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx481>
    WIDEN store vp<%5>, ir<%68>
    CLONE ir<%indvars.iv.next933> = add nsw ir<%indvars.iv932>, ir<-1>
    CLONE ir<%cmp474.not.not> = icmp sgt ir<%indvars.iv.next933>, ir<%67>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end484.loopexit>, scalar.ph

ir-bb<for.end484.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_qsortsvu' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv932 = phi i64 [ %indvars.iv.next933, %for.body476 ], [ %indvars.iv925, %for.body476.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx478 = getelementptr inbounds ptr, ptr %array, i64 %indvars.iv932 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %68 = load ptr, ptr %arrayidx478, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx481 = getelementptr i8, ptr %arrayidx478, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %68, ptr %arrayidx481, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next933 = add nsw i64 %indvars.iv932, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp474.not.not = icmp sgt i64 %indvars.iv.next933, %67 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp474.not.not, label %for.body476, label %for.end484.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_qsortsvu' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv932 = phi i64 [ %indvars.iv.next933, %for.body476 ], [ %indvars.iv925, %for.body476.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx478 = getelementptr inbounds ptr, ptr %array, i64 %indvars.iv932 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %68 = load ptr, ptr %arrayidx478, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx481 = getelementptr i8, ptr %arrayidx478, i64 8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %68, ptr %arrayidx481, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next933 = add nsw i64 %indvars.iv932, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp474.not.not = icmp sgt i64 %indvars.iv.next933, %67 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp474.not.not, label %for.body476, label %for.end484.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'S_qsortsvu' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv932 = phi i64 [ %indvars.iv.next933, %for.body476 ], [ %indvars.iv925, %for.body476.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx478 = getelementptr inbounds ptr, ptr %array, i64 %indvars.iv932 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   %68 = load ptr, ptr %arrayidx478, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx481 = getelementptr i8, ptr %arrayidx478, i64 8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr %68, ptr %arrayidx481, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next933 = add nsw i64 %indvars.iv932, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp474.not.not = icmp sgt i64 %indvars.iv.next933, %67 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp474.not.not, label %for.body476, label %for.end484.loopexit of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 22
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 16
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 22
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'S_qsortsvu' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv932 = phi i64 [ %indvars.iv.next933, %for.body476 ], [ %indvars.iv925, %for.body476.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx478 = getelementptr inbounds ptr, ptr %array, i64 %indvars.iv932 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %68 = load ptr, ptr %arrayidx478, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx481 = getelementptr i8, ptr %arrayidx478, i64 8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %68, ptr %arrayidx481, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next933 = add nsw i64 %indvars.iv932, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp474.not.not = icmp sgt i64 %indvars.iv.next933, %67 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp474.not.not, label %for.body476, label %for.end484.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_qsortsvu' from pp_sort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv932 = phi i64 [ %indvars.iv.next933, %for.body476 ], [ %indvars.iv925, %for.body476.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx478 = getelementptr inbounds ptr, ptr %array, i64 %indvars.iv932 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %68 = load ptr, ptr %arrayidx478, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx481 = getelementptr i8, ptr %arrayidx478, i64 8 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr %68, ptr %arrayidx481, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next933 = add nsw i64 %indvars.iv932, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp474.not.not = icmp sgt i64 %indvars.iv.next933, %67 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp474.not.not, label %for.body476, label %for.end484.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: vscale x 1, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_qsortsvu at line: pp_sort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body476.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %j449.0.lcssa to i64))<nsw> + {(sext i32 %part_left.0 to i64),+,1}<nsw><%for.cond451.preheader>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%indvars.iv925> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx478> = getelementptr inbounds ir<%array>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx478>
    WIDEN ir<%68> = load vp<%6>
    CLONE ir<%arrayidx481> = getelementptr ir<%arrayidx478>, ir<8>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx481>
    WIDEN store vp<%7>, ir<%68>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end484.loopexit>, scalar.ph

ir-bb<for.end484.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 10
Loops Analyzed: 30
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o pp_sys.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         pp_sys.c
@@ Instruction =>  %36 = load ptr, ptr %mark.0305, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %36, ptr %incdec.ptr64, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load ptr, ptr %mark.0305, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %36, ptr %incdec.ptr64, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %36 = load ptr, ptr %mark.0305, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %36, ptr %incdec.ptr64, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load ptr, ptr %mark.0305, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %36, ptr %incdec.ptr64, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 ((-8 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%sp.1306> = WIDEN-POINTER-INDUCTION ir<%sp.0>, 8
    EMIT ir<%mark.0305> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.0304 = phi %dec, %conv16, ir<-1>
    CLONE ir<%dec> = add ir<%items.0304>, ir<-1>
    CLONE ir<%incdec.ptr63> = getelementptr inbounds ir<%mark.0305>, ir<8>
    CLONE ir<%36> = load ir<%mark.0305>
    CLONE ir<%incdec.ptr64> = getelementptr inbounds ir<%sp.1306>, ir<8>
    CLONE store ir<%36>, ir<%incdec.ptr64>
    CLONE ir<%tobool62.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr64.lcssa = ir<%incdec.ptr64>
}

========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 ((-8 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%sp.1306> = WIDEN-POINTER-INDUCTION ir<%sp.0>, 8
    EMIT ir<%mark.0305> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.0304 = phi %dec, %conv16, ir<-1>
    CLONE ir<%dec> = add ir<%items.0304>, ir<-1>
    CLONE ir<%incdec.ptr63> = getelementptr inbounds ir<%mark.0305>, ir<8>
    vp<%4> = vector-pointer ir<%mark.0305>
    WIDEN ir<%36> = load vp<%4>
    CLONE ir<%incdec.ptr64> = getelementptr inbounds ir<%sp.1306>, ir<8>
    vp<%5> = vector-pointer ir<%incdec.ptr64>
    WIDEN store vp<%5>, ir<%36>
    CLONE ir<%tobool62.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr64.lcssa = ir<%incdec.ptr64>
}

========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 ((-8 + (-8 * (sext i32 %3 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%sp.1306> = WIDEN-POINTER-INDUCTION ir<%sp.0>, 8
    EMIT ir<%mark.0305> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.0304 = phi %dec, %conv16, ir<-1>
    CLONE ir<%dec> = add ir<%items.0304>, ir<-1>
    CLONE ir<%incdec.ptr63> = getelementptr inbounds ir<%mark.0305>, ir<8>
    vp<%4> = vector-pointer ir<%mark.0305>
    WIDEN ir<%36> = load vp<%4>
    CLONE ir<%incdec.ptr64> = getelementptr inbounds ir<%sp.1306>, ir<8>
    vp<%5> = vector-pointer ir<%incdec.ptr64>
    WIDEN store vp<%5>, ir<%36>
    CLONE ir<%tobool62.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr64.lcssa = ir<%incdec.ptr64>
}


-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sp.1306 = phi ptr [ %incdec.ptr64, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %mark.0305 = phi ptr [ %incdec.ptr63, %while.body ], [ %incdec.ptr11, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %items.0304 = phi i32 [ %dec, %while.body ], [ %conv16, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i32 %items.0304, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr63 = getelementptr inbounds i8, ptr %mark.0305, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %36 = load ptr, ptr %mark.0305, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %sp.1306, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %36, ptr %incdec.ptr64, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool62.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool62.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sp.1306 = phi ptr [ %incdec.ptr64, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %mark.0305 = phi ptr [ %incdec.ptr63, %while.body ], [ %incdec.ptr11, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %items.0304 = phi i32 [ %dec, %while.body ], [ %conv16, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i32 %items.0304, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr63 = getelementptr inbounds i8, ptr %mark.0305, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %36 = load ptr, ptr %mark.0305, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %sp.1306, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %36, ptr %incdec.ptr64, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool62.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool62.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sp.1306 = phi ptr [ %incdec.ptr64, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %mark.0305 = phi ptr [ %incdec.ptr63, %while.body ], [ %incdec.ptr11, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %items.0304 = phi i32 [ %dec, %while.body ], [ %conv16, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add i32 %items.0304, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr63 = getelementptr inbounds i8, ptr %mark.0305, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %36 = load ptr, ptr %mark.0305, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %sp.1306, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %36, ptr %incdec.ptr64, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool62.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool62.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sp.1306 = phi ptr [ %incdec.ptr64, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %mark.0305 = phi ptr [ %incdec.ptr63, %while.body ], [ %incdec.ptr11, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %items.0304 = phi i32 [ %dec, %while.body ], [ %conv16, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i32 %items.0304, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr63 = getelementptr inbounds i8, ptr %mark.0305, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %36 = load ptr, ptr %mark.0305, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %sp.1306, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %36, ptr %incdec.ptr64, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool62.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool62.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 6442450950

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sp.1306 = phi ptr [ %incdec.ptr64, %while.body ], [ %sp.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %mark.0305 = phi ptr [ %incdec.ptr63, %while.body ], [ %incdec.ptr11, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %items.0304 = phi i32 [ %dec, %while.body ], [ %conv16, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i32 %items.0304, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr63 = getelementptr inbounds i8, ptr %mark.0305, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %36 = load ptr, ptr %mark.0305, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr64 = getelementptr inbounds i8, ptr %sp.1306, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %36, ptr %incdec.ptr64, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool62.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool62.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 6442450950
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_pp_tie at line: pp_sys.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 ((-8 + (-8 * (sext i32 %4 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%sp.0>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%incdec.ptr11>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%44> = load vp<%10>
    CLONE ir<%incdec.ptr64> = getelementptr inbounds vp<%6>, ir<8>
    vp<%11> = vector-pointer ir<%incdec.ptr64>
    WIDEN store vp<%11>, ir<%44>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr64.lcssa = ir<%incdec.ptr64>
}
================ Final VPlan ================

@@ Instruction =>  %86 = load ptr, ptr %mark.1309, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %86, ptr %incdec.ptr131, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %86 = load ptr, ptr %mark.1309, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %86, ptr %incdec.ptr131, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %86 = load ptr, ptr %mark.1309, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %86, ptr %incdec.ptr131, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %86 = load ptr, ptr %mark.1309, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %86, ptr %incdec.ptr131, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body129.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 ((-8 + (-8 * (sext i32 %4 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%sp.3310> = WIDEN-POINTER-INDUCTION ir<%sp.2>, 8
    EMIT ir<%mark.1309> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.1308 = phi %dec127, %conv16, ir<-1>
    CLONE ir<%dec127> = add ir<%items.1308>, ir<-1>
    CLONE ir<%incdec.ptr130> = getelementptr inbounds ir<%mark.1309>, ir<8>
    CLONE ir<%86> = load ir<%mark.1309>
    CLONE ir<%incdec.ptr131> = getelementptr inbounds ir<%sp.3310>, ir<8>
    CLONE store ir<%86>, ir<%incdec.ptr131>
    CLONE ir<%tobool128.not> = icmp eq ir<%dec127>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end132.loopexit>, scalar.ph

ir-bb<while.end132.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr131.lcssa = ir<%incdec.ptr131>
}

========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body129.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 ((-8 + (-8 * (sext i32 %4 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%sp.3310> = WIDEN-POINTER-INDUCTION ir<%sp.2>, 8
    EMIT ir<%mark.1309> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.1308 = phi %dec127, %conv16, ir<-1>
    CLONE ir<%dec127> = add ir<%items.1308>, ir<-1>
    CLONE ir<%incdec.ptr130> = getelementptr inbounds ir<%mark.1309>, ir<8>
    vp<%4> = vector-pointer ir<%mark.1309>
    WIDEN ir<%86> = load vp<%4>
    CLONE ir<%incdec.ptr131> = getelementptr inbounds ir<%sp.3310>, ir<8>
    vp<%5> = vector-pointer ir<%incdec.ptr131>
    WIDEN store vp<%5>, ir<%86>
    CLONE ir<%tobool128.not> = icmp eq ir<%dec127>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end132.loopexit>, scalar.ph

ir-bb<while.end132.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr131.lcssa = ir<%incdec.ptr131>
}

========== Loop: Perl_pp_tie' from pp_sys.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body129.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 ((-8 + (-8 * (sext i32 %4 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%sp.3310> = WIDEN-POINTER-INDUCTION ir<%sp.2>, 8
    EMIT ir<%mark.1309> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr11>, 8
    WIDEN-INDUCTION %items.1308 = phi %dec127, %conv16, ir<-1>
    CLONE ir<%dec127> = add ir<%items.1308>, ir<-1>
    CLONE ir<%incdec.ptr130> = getelementptr inbounds ir<%mark.1309>, ir<8>
    vp<%4> = vector-pointer ir<%mark.1309>
    WIDEN ir<%86> = load vp<%4>
    CLONE ir<%incdec.ptr131> = getelementptr inbounds ir<%sp.3310>, ir<8>
    vp<%5> = vector-pointer ir<%incdec.ptr131>
    WIDEN store vp<%5>, ir<%86>
    CLONE ir<%tobool128.not> = icmp eq ir<%dec127>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end132.loopexit>, scalar.ph

ir-bb<while.end132.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr131.lcssa = ir<%incdec.ptr131>
}


-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sp.3310 = phi ptr [ %incdec.ptr131, %while.body129 ], [ %sp.2, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %mark.1309 = phi ptr [ %incdec.ptr130, %while.body129 ], [ %incdec.ptr11, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %items.1308 = phi i32 [ %dec127, %while.body129 ], [ %conv16, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec127 = add i32 %items.1308, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr130 = getelementptr inbounds i8, ptr %mark.1309, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %86 = load ptr, ptr %mark.1309, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %sp.3310, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %86, ptr %incdec.ptr131, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool128.not = icmp eq i32 %dec127, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool128.not, label %while.end132.loopexit, label %while.body129 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sp.3310 = phi ptr [ %incdec.ptr131, %while.body129 ], [ %sp.2, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %mark.1309 = phi ptr [ %incdec.ptr130, %while.body129 ], [ %incdec.ptr11, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %items.1308 = phi i32 [ %dec127, %while.body129 ], [ %conv16, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec127 = add i32 %items.1308, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr130 = getelementptr inbounds i8, ptr %mark.1309, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %86 = load ptr, ptr %mark.1309, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %sp.3310, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %86, ptr %incdec.ptr131, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool128.not = icmp eq i32 %dec127, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool128.not, label %while.end132.loopexit, label %while.body129 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sp.3310 = phi ptr [ %incdec.ptr131, %while.body129 ], [ %sp.2, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %mark.1309 = phi ptr [ %incdec.ptr130, %while.body129 ], [ %incdec.ptr11, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %items.1308 = phi i32 [ %dec127, %while.body129 ], [ %conv16, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec127 = add i32 %items.1308, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr130 = getelementptr inbounds i8, ptr %mark.1309, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %86 = load ptr, ptr %mark.1309, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %sp.3310, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %86, ptr %incdec.ptr131, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool128.not = icmp eq i32 %dec127, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool128.not, label %while.end132.loopexit, label %while.body129 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sp.3310 = phi ptr [ %incdec.ptr131, %while.body129 ], [ %sp.2, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %mark.1309 = phi ptr [ %incdec.ptr130, %while.body129 ], [ %incdec.ptr11, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %items.1308 = phi i32 [ %dec127, %while.body129 ], [ %conv16, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec127 = add i32 %items.1308, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr130 = getelementptr inbounds i8, ptr %mark.1309, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %86 = load ptr, ptr %mark.1309, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %sp.3310, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %86, ptr %incdec.ptr131, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool128.not = icmp eq i32 %dec127, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool128.not, label %while.end132.loopexit, label %while.body129 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 6442450950

-----------------Function that is being costed:'Perl_pp_tie' from pp_sys.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sp.3310 = phi ptr [ %incdec.ptr131, %while.body129 ], [ %sp.2, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %mark.1309 = phi ptr [ %incdec.ptr130, %while.body129 ], [ %incdec.ptr11, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %items.1308 = phi i32 [ %dec127, %while.body129 ], [ %conv16, %while.body129.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec127 = add i32 %items.1308, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr130 = getelementptr inbounds i8, ptr %mark.1309, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %86 = load ptr, ptr %mark.1309, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %sp.3310, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %86, ptr %incdec.ptr131, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool128.not = icmp eq i32 %dec127, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool128.not, label %while.end132.loopexit, label %while.body129 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 6442450950
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: Perl_pp_tie at line: pp_sys.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body129.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 ((-8 + (-8 * (sext i32 %4 to i64))<nsw> + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 8) to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%sp.2>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%incdec.ptr11>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%93> = load vp<%10>
    CLONE ir<%incdec.ptr131> = getelementptr inbounds vp<%6>, ir<8>
    vp<%11> = vector-pointer ir<%incdec.ptr131>
    WIDEN store vp<%11>, ir<%93>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end132.loopexit>, scalar.ph

ir-bb<while.end132.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr131.lcssa = ir<%incdec.ptr131>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o regcomp.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         regcomp.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o regexec.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         regexec.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o run.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         run.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o scope.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         scope.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o sv.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         sv.c
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i8, ptr %incdec.ptr153, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %26, ptr %incdec.ptr154, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then143>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 %offset to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%big.0294> = WIDEN-POINTER-INDUCTION ir<%add.ptr149>, -1
    WIDEN-INDUCTION %i.0293 = phi %conv141, %dec, ir<-1>
    EMIT ir<%midend.1292> = WIDEN-POINTER-INDUCTION ir<%add.ptr144>, -1
    CLONE ir<%dec> = add nsw ir<%i.0293>, ir<-1>
    CLONE ir<%incdec.ptr153> = getelementptr inbounds ir<%big.0294>, ir<-1>
    CLONE ir<%26> = load ir<%incdec.ptr153>
    CLONE ir<%incdec.ptr154> = getelementptr inbounds ir<%midend.1292>, ir<-1>
    CLONE store ir<%26>, ir<%incdec.ptr154>
    CLONE ir<%tobool151.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end155>, scalar.ph

ir-bb<while.end155>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then143>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 %offset to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%big.0294> = WIDEN-POINTER-INDUCTION ir<%add.ptr149>, -1
    WIDEN-INDUCTION %i.0293 = phi %conv141, %dec, ir<-1>
    EMIT ir<%midend.1292> = WIDEN-POINTER-INDUCTION ir<%add.ptr144>, -1
    CLONE ir<%dec> = add nsw ir<%i.0293>, ir<-1>
    CLONE ir<%incdec.ptr153> = getelementptr inbounds ir<%big.0294>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr153>
    WIDEN ir<%26> = load vp<%4>
    CLONE ir<%incdec.ptr154> = getelementptr inbounds ir<%midend.1292>, ir<-1>
    vp<%5> = vector-pointer (reverse) ir<%incdec.ptr154>
    WIDEN store vp<%5>, ir<%26>
    CLONE ir<%tobool151.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end155>, scalar.ph

ir-bb<while.end155>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then143>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 %offset to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%big.0294> = WIDEN-POINTER-INDUCTION ir<%add.ptr149>, -1
    WIDEN-INDUCTION %i.0293 = phi %conv141, %dec, ir<-1>
    EMIT ir<%midend.1292> = WIDEN-POINTER-INDUCTION ir<%add.ptr144>, -1
    CLONE ir<%dec> = add nsw ir<%i.0293>, ir<-1>
    CLONE ir<%incdec.ptr153> = getelementptr inbounds ir<%big.0294>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr153>
    WIDEN ir<%26> = load vp<%4>
    CLONE ir<%incdec.ptr154> = getelementptr inbounds ir<%midend.1292>, ir<-1>
    vp<%5> = vector-pointer (reverse) ir<%incdec.ptr154>
    WIDEN store vp<%5>, ir<%26>
    CLONE ir<%tobool151.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end155>, scalar.ph

ir-bb<while.end155>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 21474836474, RTCostB: 17179869180
A is not scalable.	B is not scalable.	
RTCostA: 21474836474, RTCostB: 17179869180

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709138, RTCostB: 17179869180
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709138, RTCostB: 10737418242
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 2684354610, RTCostB: 17179869180
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354610, RTCostB: 5368709138
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 3221225572, RTCostB: 17179869180
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225572, RTCostB: 2684354610

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901886, RTCostB: 17179869180
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901886, RTCostB: 2684354610

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450950, RTCostB: 2684354610

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3221225494, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225494, RTCostB: 2684354610

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612790, RTCostB: 17179869180
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612790, RTCostB: 2684354610
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %big.0294 = phi ptr [ %add.ptr149, %if.then143 ], [ %incdec.ptr153, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.0293 = phi i32 [ %conv141, %if.then143 ], [ %dec, %while.body152 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %midend.1292 = phi ptr [ %add.ptr144, %if.then143 ], [ %incdec.ptr154, %while.body152 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i32 %i.0293, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr153 = getelementptr inbounds i8, ptr %big.0294, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %26 = load i8, ptr %incdec.ptr153, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr154 = getelementptr inbounds i8, ptr %midend.1292, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %26, ptr %incdec.ptr154, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool151.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool151.not, label %while.end155, label %while.body152 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741940, RTCostB: 17179869180
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741940, RTCostB: 1610612790
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_sv_insert at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then143>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (trunc i64 %offset to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    EMIT vp<%6> = ptradd ir<%add.ptr149>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-1>
    EMIT vp<%9> = ptradd ir<%add.ptr144>, vp<%8>
    CLONE ir<%incdec.ptr153> = getelementptr inbounds vp<%6>, ir<-1>
    vp<%10> = vector-pointer (reverse) ir<%incdec.ptr153>
    WIDEN ir<%47> = load vp<%10>
    CLONE ir<%incdec.ptr154> = getelementptr inbounds vp<%9>, ir<-1>
    vp<%11> = vector-pointer (reverse) ir<%incdec.ptr154>
    WIDEN store vp<%11>, ir<%47>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end155>, scalar.ph

ir-bb<while.end155>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %17 = load i8, ptr %incdec.ptr, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %17, ptr %incdec.ptr69, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (%offset + %len)) + %16)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%bigend.0297> = WIDEN-POINTER-INDUCTION ir<%add.ptr66>, -1
    EMIT ir<%midend.0296> = WIDEN-POINTER-INDUCTION ir<%add.ptr65>, -1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%midend.0296>, ir<-1>
    CLONE ir<%17> = load ir<%incdec.ptr>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%bigend.0297>, ir<-1>
    CLONE store ir<%17>, ir<%incdec.ptr69>
    CLONE ir<%cmp67> = icmp ugt ir<%incdec.ptr>, ir<%add.ptr62>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (%offset + %len)) + %16)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%bigend.0297> = WIDEN-POINTER-INDUCTION ir<%add.ptr66>, -1
    EMIT ir<%midend.0296> = WIDEN-POINTER-INDUCTION ir<%add.ptr65>, -1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%midend.0296>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr>
    WIDEN ir<%17> = load vp<%4>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%bigend.0297>, ir<-1>
    vp<%5> = vector-pointer (reverse) ir<%incdec.ptr69>
    WIDEN store vp<%5>, ir<%17>
    CLONE ir<%cmp67> = icmp ugt ir<%incdec.ptr>, ir<%add.ptr62>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_sv_insert' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (%offset + %len)) + %16)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%bigend.0297> = WIDEN-POINTER-INDUCTION ir<%add.ptr66>, -1
    EMIT ir<%midend.0296> = WIDEN-POINTER-INDUCTION ir<%add.ptr65>, -1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%midend.0296>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr>
    WIDEN ir<%17> = load vp<%4>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%bigend.0297>, ir<-1>
    vp<%5> = vector-pointer (reverse) ir<%incdec.ptr69>
    WIDEN store vp<%5>, ir<%17>
    CLONE ir<%cmp67> = icmp ugt ir<%incdec.ptr>, ir<%add.ptr62>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 9
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 48
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 8, EstimatedWidthB: 8, CostB: 9
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 144
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 23
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 23, CostB * EstimatedWidthA: 96
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 23
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 368, CostB * EstimatedWidthA: 288

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 72

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 144
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_sv_insert' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %bigend.0297 = phi ptr [ %incdec.ptr69, %while.body ], [ %add.ptr66, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %midend.0296 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr65, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %midend.0296, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %17 = load i8, ptr %incdec.ptr, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %bigend.0297, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %17, ptr %incdec.ptr69, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp67 = icmp ugt ptr %incdec.ptr, %add.ptr62 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp67, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_sv_insert at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (%offset + %len)) + %16)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    EMIT vp<%6> = ptradd ir<%add.ptr66>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<-1>
    EMIT vp<%9> = ptradd ir<%add.ptr65>, vp<%8>
    CLONE ir<%incdec.ptr> = getelementptr inbounds vp<%9>, ir<-1>
    vp<%10> = vector-pointer (reverse) ir<%incdec.ptr>
    WIDEN ir<%17> = load vp<%10>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds vp<%6>, ir<-1>
    vp<%11> = vector-pointer (reverse) ir<%incdec.ptr69>
    WIDEN store vp<%11>, ir<%17>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 30
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load ptr, ptr %arrayidx, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr null, ptr %arrayidx, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %9 = load ptr, ptr %arrayidx, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr null, ptr %arrayidx, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %9 = load ptr, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr null, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %9 = load ptr, ptr %arrayidx, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr null, ptr %arrayidx, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: S_sv_del_backref' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i31 (trunc i64 %6 to i31) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %8, %indvars.iv.next, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    CLONE ir<%9> = load ir<%arrayidx>
    CLONE ir<%cmp5> = icmp eq ir<%9>, ir<%sv>
  Successor(s): if.then7

  if.then7:
    CLONE store ir<null>, ir<%arrayidx>, ir<%cmp5>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp5>
    EMIT vp<%5> = or vp<%4>, ir<%cmp5>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_sv_del_backref' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i31 (trunc i64 %6 to i31) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %8, %indvars.iv.next, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%cmp5> = icmp eq ir<%9>, ir<%sv>
  Successor(s): if.then7

  if.then7:
    vp<%5> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%5>, ir<null>, ir<%cmp5>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp5>
    EMIT vp<%7> = or vp<%6>, ir<%cmp5>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_sv_del_backref' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i31 (trunc i64 %6 to i31) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %8, %indvars.iv.next, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%cmp5> = icmp eq ir<%9>, ir<%sv>
  Successor(s): if.then7

  if.then7:
    vp<%5> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%5>, ir<null>, ir<%cmp5>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp5>
    EMIT vp<%7> = or vp<%6>, ir<%cmp5>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %8, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5 = icmp eq ptr %9, %sv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5, label %if.then7, label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr null, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %for.body, label %for.end.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %8, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %9 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5 = icmp eq ptr %9, %sv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5, label %if.then7, label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr null, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 11811160064, RTCostB: 8589934592
A is not scalable.	B is not scalable.	
RTCostA: 11811160064, RTCostB: 8589934592

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %8, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   %9 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp5 = icmp eq ptr %9, %sv of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp5, label %if.then7, label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr null, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 8589934592
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 8589934592

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %8, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %9 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5 = icmp eq ptr %9, %sv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5, label %if.then7, label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr null, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7516192768, RTCostB: 8589934592
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192768, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %8, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %9 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp5 = icmp eq ptr %9, %sv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5, label %if.then7, label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr null, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'S_sv_del_backref' from sv.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 8589934592
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 5368709120, RTCostB: 7516192768
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_sv_del_backref at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i31 (trunc i64 %6 to i31) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%8> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr ir<%5>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN ir<%9> = load vp<%6>
    WIDEN ir<%cmp5> = icmp eq ir<%9>, ir<%sv>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%7>, ir<null>, ir<%cmp5>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 32
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_more_xiv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xiv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xiv.0.idx12 = phi 24, %xiv.0.add, ir<8>
    CLONE ir<%xiv.0.add> = add nuw nsw ir<%xiv.0.idx12>, ir<8>
    CLONE ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xiv.0.add>
    CLONE store ir<%add.ptr1.ptr>, ir<%xiv.0.ptr13>
    CLONE ir<%cmp> = icmp ult ir<%xiv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xiv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xiv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xiv.0.idx12 = phi 24, %xiv.0.add, ir<8>
    WIDEN ir<%xiv.0.add> = add nuw nsw ir<%xiv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xiv.0.add>
    vp<%3> = vector-pointer ir<%xiv.0.ptr13>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xiv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xiv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xiv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xiv.0.idx12 = phi 24, %xiv.0.add, ir<8>
    WIDEN ir<%xiv.0.add> = add nuw nsw ir<%xiv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xiv.0.add>
    vp<%3> = vector-pointer ir<%xiv.0.ptr13>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xiv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}


-----------------Function that is being costed:'S_more_xiv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xiv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xiv.0.idx12 = phi i64 [ 24, %entry ], [ %xiv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xiv.0.add = add nuw nsw i64 %xiv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xiv.0.add of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xiv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_more_xiv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xiv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xiv.0.idx12 = phi i64 [ 24, %entry ], [ %xiv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xiv.0.add = add nuw nsw i64 %xiv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xiv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xiv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 1518
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 1518
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_xiv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xiv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xiv.0.idx12 = phi i64 [ 24, %entry ], [ %xiv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xiv.0.add = add nuw nsw i64 %xiv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xiv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ult i64 %xiv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 636, RTCostB: 1518
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 636, RTCostB: 759
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_more_xiv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xiv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xiv.0.idx12 = phi i64 [ 24, %entry ], [ %xiv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xiv.0.add = add nuw nsw i64 %xiv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xiv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xiv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 1518
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 636

-----------------Function that is being costed:'S_more_xiv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xiv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xiv.0.idx12 = phi i64 [ 24, %entry ], [ %xiv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xiv.0.add = add nuw nsw i64 %xiv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xiv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xiv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xiv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 636, RTCostB: 1518
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 636, RTCostB: 636
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_more_xiv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %xiv.0.idx12 = phi 24, %xiv.0.add, ir<8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%add.ptr.ptr>, vp<%4>
    WIDEN ir<%xiv.0.add> = add nuw nsw ir<%xiv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xiv.0.add>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%add.ptr1.ptr>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 67
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_more_xnv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<505> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xnv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xnv.0.idx12 = phi 32, %xnv.0.add, ir<8>
    CLONE ir<%xnv.0.add> = add nuw nsw ir<%xnv.0.idx12>, ir<8>
    CLONE ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xnv.0.add>
    CLONE store ir<%add.ptr1.ptr>, ir<%xnv.0.ptr13>
    CLONE ir<%cmp> = icmp ult ir<%xnv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<505>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xnv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<505> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xnv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xnv.0.idx12 = phi 32, %xnv.0.add, ir<8>
    WIDEN ir<%xnv.0.add> = add nuw nsw ir<%xnv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xnv.0.add>
    vp<%3> = vector-pointer ir<%xnv.0.ptr13>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xnv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<505>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xnv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<505> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xnv.0.ptr13> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xnv.0.idx12 = phi 32, %xnv.0.add, ir<8>
    WIDEN ir<%xnv.0.add> = add nuw nsw ir<%xnv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xnv.0.add>
    vp<%3> = vector-pointer ir<%xnv.0.ptr13>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xnv.0.idx12>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<505>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}


-----------------Function that is being costed:'S_more_xnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xnv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xnv.0.idx12 = phi i64 [ 32, %entry ], [ %xnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xnv.0.add = add nuw nsw i64 %xnv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xnv.0.add of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xnv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_more_xnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xnv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xnv.0.idx12 = phi i64 [ 32, %entry ], [ %xnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xnv.0.add = add nuw nsw i64 %xnv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xnv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xnv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 1515
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 1515
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_xnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xnv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xnv.0.idx12 = phi i64 [ 32, %entry ], [ %xnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xnv.0.add = add nuw nsw i64 %xnv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xnv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ult i64 %xnv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 633, RTCostB: 1515
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 633, RTCostB: 759
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_more_xnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xnv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xnv.0.idx12 = phi i64 [ 32, %entry ], [ %xnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xnv.0.add = add nuw nsw i64 %xnv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xnv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xnv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 1515
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 633

-----------------Function that is being costed:'S_more_xnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xnv.0.ptr13 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xnv.0.idx12 = phi i64 [ 32, %entry ], [ %xnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xnv.0.add = add nuw nsw i64 %xnv.0.idx12, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xnv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xnv.0.ptr13, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xnv.0.idx12, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 633, RTCostB: 1515
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 633, RTCostB: 633
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_more_xnv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<505> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %xnv.0.idx12 = phi 32, %xnv.0.add, ir<8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%add.ptr.ptr>, vp<%4>
    WIDEN ir<%xnv.0.add> = add nuw nsw ir<%xnv.0.idx12>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xnv.0.add>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%add.ptr1.ptr>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<505>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 68
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: S_more_xrv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xrv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xrv.0.idx13 = phi 24, %xrv.0.add, ir<8>
    CLONE ir<%xrv.0.add> = add nuw nsw ir<%xrv.0.idx13>, ir<8>
    CLONE ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xrv.0.add>
    CLONE store ir<%add.ptr1.ptr>, ir<%xrv.0.ptr14>
    CLONE ir<%cmp> = icmp ult ir<%xrv.0.idx13>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xrv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xrv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xrv.0.idx13 = phi 24, %xrv.0.add, ir<8>
    WIDEN ir<%xrv.0.add> = add nuw nsw ir<%xrv.0.idx13>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xrv.0.add>
    vp<%3> = vector-pointer ir<%xrv.0.ptr14>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xrv.0.idx13>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}

========== Loop: S_more_xrv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%xrv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%add.ptr.ptr>, 8
    WIDEN-INDUCTION %xrv.0.idx13 = phi 24, %xrv.0.add, ir<8>
    WIDEN ir<%xrv.0.add> = add nuw nsw ir<%xrv.0.idx13>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xrv.0.add>
    vp<%3> = vector-pointer ir<%xrv.0.ptr14>
    WIDEN store vp<%3>, ir<%add.ptr1.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xrv.0.idx13>, ir<4064>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}


-----------------Function that is being costed:'S_more_xrv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xrv.0.ptr14 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xrv.0.idx13 = phi i64 [ 24, %entry ], [ %xrv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xrv.0.add = add nuw nsw i64 %xrv.0.idx13, 8 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xrv.0.add of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xrv.0.idx13, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_more_xrv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xrv.0.ptr14 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xrv.0.idx13 = phi i64 [ 24, %entry ], [ %xrv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xrv.0.add = add nuw nsw i64 %xrv.0.idx13, 8 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xrv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xrv.0.idx13, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 1518
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 1518
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_xrv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xrv.0.ptr14 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xrv.0.idx13 = phi i64 [ 24, %entry ], [ %xrv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xrv.0.add = add nuw nsw i64 %xrv.0.idx13, 8 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xrv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ult i64 %xrv.0.idx13, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 636, RTCostB: 1518
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 636, RTCostB: 759
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_more_xrv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xrv.0.ptr14 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xrv.0.idx13 = phi i64 [ 24, %entry ], [ %xrv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xrv.0.add = add nuw nsw i64 %xrv.0.idx13, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xrv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xrv.0.idx13, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 1518
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 759, RTCostB: 636

-----------------Function that is being costed:'S_more_xrv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xrv.0.ptr14 = phi ptr [ %add.ptr.ptr, %entry ], [ %add.ptr1.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xrv.0.idx13 = phi i64 [ 24, %entry ], [ %xrv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xrv.0.add = add nuw nsw i64 %xrv.0.idx13, 8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr1.ptr = getelementptr inbounds i8, ptr %call, i64 %xrv.0.add of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %add.ptr1.ptr, ptr %xrv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xrv.0.idx13, 4064 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 636, RTCostB: 1518
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 636, RTCostB: 636
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_more_xrv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<506> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %xrv.0.idx13 = phi 24, %xrv.0.add, ir<8>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<8>
    EMIT vp<%5> = ptradd ir<%add.ptr.ptr>, vp<%4>
    WIDEN ir<%xrv.0.add> = add nuw nsw ir<%xrv.0.idx13>, ir<8>
    WIDEN-GEP Inv[Var] ir<%add.ptr1.ptr> = getelementptr inbounds ir<%call>, ir<%xrv.0.add>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%add.ptr1.ptr>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<506>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr1.ptr.lcssa = ir<%add.ptr1.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 69
Loops Epilogues Vectorized: 0
================================================
========== Loop: S_more_xpv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %xpv.0.idx13 = phi 24, %xpv.0.add, ir<24>
    CLONE ir<%xpv.0.add> = add nuw nsw ir<%xpv.0.idx13>, ir<24>
    CLONE ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpv.0.add>
    CLONE store ir<%add.ptr.ptr>, ir<%xpv.0.ptr14>
    CLONE ir<%cmp> = icmp ult ir<%xpv.0.idx13>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_xpv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %xpv.0.idx13 = phi 24, %xpv.0.add, ir<24>
    WIDEN ir<%xpv.0.add> = add nuw nsw ir<%xpv.0.idx13>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpv.0.add>
    WIDEN store ir<%xpv.0.ptr14>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xpv.0.idx13>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_xpv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %xpv.0.idx13 = phi 24, %xpv.0.add, ir<24>
    WIDEN ir<%xpv.0.add> = add nuw nsw ir<%xpv.0.idx13>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpv.0.add>
    WIDEN store ir<%xpv.0.ptr14>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xpv.0.idx13>, ir<4032>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}


-----------------Function that is being costed:'S_more_xpv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xpv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xpv.0.idx13 = phi i64 [ 24, %entry ], [ %xpv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xpv.0.add = add nuw nsw i64 %xpv.0.idx13, 24 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpv.0.add of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr.ptr, ptr %xpv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xpv.0.idx13, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_more_xpv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xpv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xpv.0.idx13 = phi i64 [ 24, %entry ], [ %xpv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xpv.0.add = add nuw nsw i64 %xpv.0.idx13, 24 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %add.ptr.ptr, ptr %xpv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xpv.0.idx13, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 336, RTCostB: 504
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 336, RTCostB: 504
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_xpv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xpv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xpv.0.idx13 = phi i64 [ 24, %entry ], [ %xpv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xpv.0.add = add nuw nsw i64 %xpv.0.idx13, 24 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %add.ptr.ptr, ptr %xpv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ult i64 %xpv.0.idx13, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 504
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 336
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_more_xpv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xpv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xpv.0.idx13 = phi i64 [ 24, %entry ], [ %xpv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xpv.0.add = add nuw nsw i64 %xpv.0.idx13, 24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %add.ptr.ptr, ptr %xpv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xpv.0.idx13, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 336, RTCostB: 504
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 336, RTCostB: 294

-----------------Function that is being costed:'S_more_xpv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xpv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xpv.0.idx13 = phi i64 [ 24, %entry ], [ %xpv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xpv.0.add = add nuw nsw i64 %xpv.0.idx13, 24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %add.ptr.ptr, ptr %xpv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xpv.0.idx13, 4032 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 504
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 294, RTCostB: 294
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_more_xpv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<168> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 24
    WIDEN-INDUCTION %xpv.0.idx13 = phi 24, %xpv.0.add, ir<24>
    WIDEN ir<%xpv.0.add> = add nuw nsw ir<%xpv.0.idx13>, ir<24>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpv.0.add>
    WIDEN store ir<%xpv.0.ptr14>, ir<%add.ptr.ptr>
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<168>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 70
Loops Epilogues Vectorized: 0
================================================
========== Loop: S_more_xpviv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<125> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpviv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 32
    WIDEN-INDUCTION %xpviv.0.idx13 = phi 32, %xpviv.0.add, ir<32>
    CLONE ir<%xpviv.0.add> = add nuw nsw ir<%xpviv.0.idx13>, ir<32>
    CLONE ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpviv.0.add>
    CLONE store ir<%add.ptr.ptr>, ir<%xpviv.0.ptr14>
    CLONE ir<%cmp> = icmp ult ir<%xpviv.0.idx13>, ir<4000>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<125>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_xpviv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<125> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpviv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 32
    WIDEN-INDUCTION %xpviv.0.idx13 = phi 32, %xpviv.0.add, ir<32>
    WIDEN ir<%xpviv.0.add> = add nuw nsw ir<%xpviv.0.idx13>, ir<32>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpviv.0.add>
    WIDEN store ir<%xpviv.0.ptr14>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xpviv.0.idx13>, ir<4000>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<125>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_xpviv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<125> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpviv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 32
    WIDEN-INDUCTION %xpviv.0.idx13 = phi 32, %xpviv.0.add, ir<32>
    WIDEN ir<%xpviv.0.add> = add nuw nsw ir<%xpviv.0.idx13>, ir<32>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpviv.0.add>
    WIDEN store ir<%xpviv.0.ptr14>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xpviv.0.idx13>, ir<4000>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<125>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}


-----------------Function that is being costed:'S_more_xpviv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xpviv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xpviv.0.idx13 = phi i64 [ 32, %entry ], [ %xpviv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xpviv.0.add = add nuw nsw i64 %xpviv.0.idx13, 32 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpviv.0.add of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr.ptr, ptr %xpviv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xpviv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_more_xpviv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xpviv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xpviv.0.idx13 = phi i64 [ 32, %entry ], [ %xpviv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xpviv.0.add = add nuw nsw i64 %xpviv.0.idx13, 32 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpviv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %add.ptr.ptr, ptr %xpviv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xpviv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 251, RTCostB: 375
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 251, RTCostB: 375
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_xpviv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xpviv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xpviv.0.idx13 = phi i64 [ 32, %entry ], [ %xpviv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xpviv.0.add = add nuw nsw i64 %xpviv.0.idx13, 32 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpviv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %add.ptr.ptr, ptr %xpviv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ult i64 %xpviv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 220, RTCostB: 375
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 220, RTCostB: 251
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_more_xpviv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xpviv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xpviv.0.idx13 = phi i64 [ 32, %entry ], [ %xpviv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xpviv.0.add = add nuw nsw i64 %xpviv.0.idx13, 32 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpviv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %add.ptr.ptr, ptr %xpviv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xpviv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 251, RTCostB: 375
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 251, RTCostB: 220

-----------------Function that is being costed:'S_more_xpviv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xpviv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xpviv.0.idx13 = phi i64 [ 32, %entry ], [ %xpviv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xpviv.0.add = add nuw nsw i64 %xpviv.0.idx13, 32 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpviv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %add.ptr.ptr, ptr %xpviv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xpviv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 220, RTCostB: 375
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 220, RTCostB: 220
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_more_xpviv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<125> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpviv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 32
    WIDEN-INDUCTION %xpviv.0.idx13 = phi 32, %xpviv.0.add, ir<32>
    WIDEN ir<%xpviv.0.add> = add nuw nsw ir<%xpviv.0.idx13>, ir<32>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpviv.0.add>
    WIDEN store ir<%xpviv.0.ptr14>, ir<%add.ptr.ptr>
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<125>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 71
Loops Epilogues Vectorized: 0
================================================
========== Loop: S_more_xpvnv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<100> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpvnv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 40
    WIDEN-INDUCTION %xpvnv.0.idx13 = phi 40, %xpvnv.0.add, ir<40>
    CLONE ir<%xpvnv.0.add> = add nuw nsw ir<%xpvnv.0.idx13>, ir<40>
    CLONE ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpvnv.0.add>
    CLONE store ir<%add.ptr.ptr>, ir<%xpvnv.0.ptr14>
    CLONE ir<%cmp> = icmp ult ir<%xpvnv.0.idx13>, ir<4000>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<100>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_xpvnv' from sv.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<100> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpvnv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 40
    WIDEN-INDUCTION %xpvnv.0.idx13 = phi 40, %xpvnv.0.add, ir<40>
    WIDEN ir<%xpvnv.0.add> = add nuw nsw ir<%xpvnv.0.idx13>, ir<40>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpvnv.0.add>
    WIDEN store ir<%xpvnv.0.ptr14>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xpvnv.0.idx13>, ir<4000>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<100>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}

========== Loop: S_more_xpvnv' from sv.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<100> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpvnv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 40
    WIDEN-INDUCTION %xpvnv.0.idx13 = phi 40, %xpvnv.0.add, ir<40>
    WIDEN ir<%xpvnv.0.add> = add nuw nsw ir<%xpvnv.0.idx13>, ir<40>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpvnv.0.add>
    WIDEN store ir<%xpvnv.0.ptr14>, ir<%add.ptr.ptr>
    CLONE ir<%cmp> = icmp ult ir<%xpvnv.0.idx13>, ir<4000>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<100>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}


-----------------Function that is being costed:'S_more_xpvnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xpvnv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %xpvnv.0.idx13 = phi i64 [ 40, %entry ], [ %xpvnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %xpvnv.0.add = add nuw nsw i64 %xpvnv.0.idx13, 40 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpvnv.0.add of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr.ptr, ptr %xpvnv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult i64 %xpvnv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_more_xpvnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xpvnv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %xpvnv.0.idx13 = phi i64 [ 40, %entry ], [ %xpvnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %xpvnv.0.add = add nuw nsw i64 %xpvnv.0.idx13, 40 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpvnv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %add.ptr.ptr, ptr %xpvnv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult i64 %xpvnv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 200, RTCostB: 300
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 200, RTCostB: 300
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_more_xpvnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xpvnv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %xpvnv.0.idx13 = phi i64 [ 40, %entry ], [ %xpvnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %xpvnv.0.add = add nuw nsw i64 %xpvnv.0.idx13, 40 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpvnv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %add.ptr.ptr, ptr %xpvnv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ult i64 %xpvnv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 175, RTCostB: 300
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 175, RTCostB: 200
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_more_xpvnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xpvnv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %xpvnv.0.idx13 = phi i64 [ 40, %entry ], [ %xpvnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %xpvnv.0.add = add nuw nsw i64 %xpvnv.0.idx13, 40 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpvnv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %add.ptr.ptr, ptr %xpvnv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult i64 %xpvnv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 200, RTCostB: 300
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 200, RTCostB: 175

-----------------Function that is being costed:'S_more_xpvnv' from sv.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xpvnv.0.ptr14 = phi ptr [ %incdec.ptr.ptr, %entry ], [ %add.ptr.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %xpvnv.0.idx13 = phi i64 [ 40, %entry ], [ %xpvnv.0.add, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %xpvnv.0.add = add nuw nsw i64 %xpvnv.0.idx13, 40 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr.ptr = getelementptr inbounds i8, ptr %call, i64 %xpvnv.0.add of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %add.ptr.ptr, ptr %xpvnv.0.ptr14, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult i64 %xpvnv.0.idx13, 4000 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 175, RTCostB: 300
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 175, RTCostB: 175
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: S_more_xpvnv at line: sv.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<100> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    EMIT ir<%xpvnv.0.ptr14> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr>, 40
    WIDEN-INDUCTION %xpvnv.0.idx13 = phi 40, %xpvnv.0.add, ir<40>
    WIDEN ir<%xpvnv.0.add> = add nuw nsw ir<%xpvnv.0.idx13>, ir<40>
    WIDEN-GEP Inv[Var] ir<%add.ptr.ptr> = getelementptr inbounds ir<%call>, ir<%xpvnv.0.add>
    WIDEN store ir<%xpvnv.0.ptr14>, ir<%add.ptr.ptr>
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<100>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end>, scalar.ph

ir-bb<while.end>:
No successors

scalar.ph:
No successors

Live-out ptr %add.ptr.ptr.lcssa = ir<%add.ptr.ptr>
}
================ Final VPlan ================

================================================
Loops Vectorized: 9
Loops Analyzed: 72
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o taint.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         taint.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o toke.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         toke.c
@@ Instruction =>  %106 = load i8, ptr %c531.01439, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c531.01439, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c531.01439, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c531.01439, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c531.01439, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %c531.01439, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body537.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %104 to i64)) + (ptrtoint ptr %d.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%c531.01439> = WIDEN-POINTER-INDUCTION ir<%104>, 1
    WIDEN-REDUCTION-PHI ir<%hicount.01438> = phi ir<0>, ir<%spec.select1357>
    CLONE ir<%106> = load ir<%c531.01439>
    CLONE ir<%.lobit> = lshr ir<%106>, ir<7>
    CLONE ir<%inc542> = zext nneg ir<%.lobit>
    CLONE ir<%spec.select1357> = add ir<%hicount.01438>, ir<%inc542>
    CLONE ir<%incdec.ptr545> = getelementptr inbounds ir<%c531.01439>, ir<1>
    CLONE ir<%exitcond1497.not> = icmp eq ir<%incdec.ptr545>, ir<%d.6>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hicount.01438>, ir<%spec.select1357>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end546>, scalar.ph

ir-bb<for.end546>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select1357.lcssa = vp<%6>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body537.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %104 to i64)) + (ptrtoint ptr %d.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%c531.01439> = WIDEN-POINTER-INDUCTION ir<%104>, 1
    WIDEN-REDUCTION-PHI ir<%hicount.01438> = phi ir<0>, ir<%spec.select1357>
    vp<%4> = vector-pointer ir<%c531.01439>
    WIDEN ir<%106> = load vp<%4>
    WIDEN ir<%.lobit> = lshr ir<%106>, ir<7>
    WIDEN-CAST ir<%inc542> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select1357> = add ir<%hicount.01438>, ir<%inc542>
    CLONE ir<%incdec.ptr545> = getelementptr inbounds ir<%c531.01439>, ir<1>
    CLONE ir<%exitcond1497.not> = icmp eq ir<%incdec.ptr545>, ir<%d.6>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hicount.01438>, ir<%spec.select1357>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end546>, scalar.ph

ir-bb<for.end546>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select1357.lcssa = vp<%7>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body537.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %104 to i64)) + (ptrtoint ptr %d.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%c531.01439> = WIDEN-POINTER-INDUCTION ir<%104>, 1
    WIDEN-REDUCTION-PHI ir<%hicount.01438> = phi ir<0>, ir<%spec.select1357>
    vp<%4> = vector-pointer ir<%c531.01439>
    WIDEN ir<%106> = load vp<%4>
    WIDEN ir<%.lobit> = lshr ir<%106>, ir<7>
    WIDEN-CAST ir<%inc542> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select1357> = add ir<%hicount.01438>, ir<%inc542>
    CLONE ir<%incdec.ptr545> = getelementptr inbounds ir<%c531.01439>, ir<1>
    CLONE ir<%exitcond1497.not> = icmp eq ir<%incdec.ptr545>, ir<%d.6>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hicount.01438>, ir<%spec.select1357>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end546>, scalar.ph

ir-bb<for.end546>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select1357.lcssa = vp<%7>
}


-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %c531.01439 = phi ptr [ %incdec.ptr545, %for.body537 ], [ %104, %for.body537.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hicount.01438 = phi i32 [ %spec.select1357, %for.body537 ], [ 0, %for.body537.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %106 = load i8, ptr %c531.01439, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc542 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select1357 = add nuw nsw i32 %hicount.01438, %inc542 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr545 = getelementptr inbounds i8, ptr %c531.01439, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1497.not = icmp eq ptr %incdec.ptr545, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1497.not, label %for.end546, label %for.body537 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %c531.01439 = phi ptr [ %incdec.ptr545, %for.body537 ], [ %104, %for.body537.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hicount.01438 = phi i32 [ %spec.select1357, %for.body537 ], [ 0, %for.body537.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %106 = load i8, ptr %c531.01439, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc542 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1357 = add nuw nsw i32 %hicount.01438, %inc542 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr545 = getelementptr inbounds i8, ptr %c531.01439, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1497.not = icmp eq ptr %incdec.ptr545, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1497.not, label %for.end546, label %for.body537 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %c531.01439 = phi ptr [ %incdec.ptr545, %for.body537 ], [ %104, %for.body537.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hicount.01438 = phi i32 [ %spec.select1357, %for.body537 ], [ 0, %for.body537.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %106 = load i8, ptr %c531.01439, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc542 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select1357 = add nuw nsw i32 %hicount.01438, %inc542 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr545 = getelementptr inbounds i8, ptr %c531.01439, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1497.not = icmp eq ptr %incdec.ptr545, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1497.not, label %for.end546, label %for.body537 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %c531.01439 = phi ptr [ %incdec.ptr545, %for.body537 ], [ %104, %for.body537.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %hicount.01438 = phi i32 [ %spec.select1357, %for.body537 ], [ 0, %for.body537.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %106 = load i8, ptr %c531.01439, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 2 for VF 8 For instruction:   %inc542 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select1357 = add nuw nsw i32 %hicount.01438, %inc542 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr545 = getelementptr inbounds i8, ptr %c531.01439, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1497.not = icmp eq ptr %incdec.ptr545, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1497.not, label %for.end546, label %for.body537 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %c531.01439 = phi ptr [ %incdec.ptr545, %for.body537 ], [ %104, %for.body537.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hicount.01438 = phi i32 [ %spec.select1357, %for.body537 ], [ 0, %for.body537.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %106 = load i8, ptr %c531.01439, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc542 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select1357 = add nuw nsw i32 %hicount.01438, %inc542 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr545 = getelementptr inbounds i8, ptr %c531.01439, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1497.not = icmp eq ptr %incdec.ptr545, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1497.not, label %for.end546, label %for.body537 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %c531.01439 = phi ptr [ %incdec.ptr545, %for.body537 ], [ %104, %for.body537.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hicount.01438 = phi i32 [ %spec.select1357, %for.body537 ], [ 0, %for.body537.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %106 = load i8, ptr %c531.01439, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc542 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select1357 = add nuw nsw i32 %hicount.01438, %inc542 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr545 = getelementptr inbounds i8, ptr %c531.01439, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1497.not = icmp eq ptr %incdec.ptr545, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1497.not, label %for.end546, label %for.body537 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %c531.01439 = phi ptr [ %incdec.ptr545, %for.body537 ], [ %104, %for.body537.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %hicount.01438 = phi i32 [ %spec.select1357, %for.body537 ], [ 0, %for.body537.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %106 = load i8, ptr %c531.01439, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %.lobit = lshr i8 %106, 7 of type:lshr
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %inc542 = zext nneg i8 %.lobit to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %spec.select1357 = add nuw nsw i32 %hicount.01438, %inc542 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr545 = getelementptr inbounds i8, ptr %c531.01439, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1497.not = icmp eq ptr %incdec.ptr545, %d.6 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1497.not, label %for.end546, label %for.body537 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: S_scan_const at line: toke.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body537.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %104 to i64)) + (ptrtoint ptr %d.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%hicount.01438> = phi ir<0>, ir<%spec.select1357>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%104>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%106> = load vp<%6>
    WIDEN ir<%.lobit> = lshr ir<%106>, ir<7>
    WIDEN-CAST ir<%inc542> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select1357> = add ir<%hicount.01438>, ir<%inc542>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hicount.01438>, ir<%spec.select1357>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end546>, scalar.ph

ir-bb<for.end546>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select1357.lcssa = vp<%9>
}
================ Final VPlan ================

@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv74, ptr %d.11435, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((zext i8 %22 to i32) + (-1 * (zext i8 %21 to i32))<nsw>) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%d.11435> = WIDEN-POINTER-INDUCTION ir<%add.ptr61>, 1
    WIDEN-INDUCTION %i.01434 = phi %inc, %conv62, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.01434 = phi %inc, %conv62\l" +
    "  ir<%conv74>, ir<1>
    CLONE ir<%incdec.ptr75> = getelementptr inbounds ir<%d.11435>, ir<1>
    CLONE store ir<%conv74>, ir<%d.11435>
    CLONE ir<%inc> = add nuw nsw ir<%i.01434>, ir<1>
    CLONE ir<%exitcond1494.not> = icmp eq ir<%i.01434>, ir<%conv63>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.backedge.loopexit>, scalar.ph

ir-bb<while.cond.backedge.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr75.lcssa = ir<%incdec.ptr75>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((zext i8 %22 to i32) + (-1 * (zext i8 %21 to i32))<nsw>) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%d.11435> = WIDEN-POINTER-INDUCTION ir<%add.ptr61>, 1
    WIDEN-INDUCTION %i.01434 = phi %inc, %conv62, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.01434 = phi %inc, %conv62\l" +
    "  ir<%conv74>, ir<1>
    CLONE ir<%incdec.ptr75> = getelementptr inbounds ir<%d.11435>, ir<1>
    vp<%4> = vector-pointer ir<%d.11435>
    WIDEN store vp<%4>, ir<%conv74>
    WIDEN ir<%inc> = add nuw nsw ir<%i.01434>, ir<1>
    CLONE ir<%exitcond1494.not> = icmp eq ir<%i.01434>, ir<%conv63>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.backedge.loopexit>, scalar.ph

ir-bb<while.cond.backedge.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr75.lcssa = ir<%incdec.ptr75>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((zext i8 %22 to i32) + (-1 * (zext i8 %21 to i32))<nsw>) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%d.11435> = WIDEN-POINTER-INDUCTION ir<%add.ptr61>, 1
    WIDEN-INDUCTION %i.01434 = phi %inc, %conv62, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.01434 = phi %inc, %conv62\l" +
    "  ir<%conv74>, ir<1>
    CLONE ir<%incdec.ptr75> = getelementptr inbounds ir<%d.11435>, ir<1>
    vp<%4> = vector-pointer ir<%d.11435>
    WIDEN store vp<%4>, ir<%conv74>
    WIDEN ir<%inc> = add nuw nsw ir<%i.01434>, ir<1>
    CLONE ir<%exitcond1494.not> = icmp eq ir<%i.01434>, ir<%conv63>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.backedge.loopexit>, scalar.ph

ir-bb<while.cond.backedge.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr75.lcssa = ir<%incdec.ptr75>
}


-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 2 for VF 8 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 4 for VF 16 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 8 for VF 32 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 96
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 11
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 176, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 44

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 88

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 176

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %d.11435 = phi ptr [ %incdec.ptr75, %for.body ], [ %add.ptr61, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.01434 = phi i32 [ %inc, %for.body ], [ %conv62, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %conv74 = trunc nuw i32 %i.01434 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr75 = getelementptr inbounds i8, ptr %d.11435, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %conv74, ptr %d.11435, align 1 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %inc = add nuw nsw i32 %i.01434, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond1494.not = icmp eq i32 %i.01434, %conv63 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond1494.not, label %while.cond.backedge.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 11
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 352, CostB * EstimatedWidthA: 352
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: S_scan_const at line: toke.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((zext i8 %22 to i32) + (-1 * (zext i8 %21 to i32))<nsw>) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION\l" +
    "  %i.01434 = phi %inc, %conv62\l" +
    "  ir<%conv74>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%add.ptr61>, vp<%4>
    CLONE ir<%incdec.ptr75> = getelementptr inbounds vp<%5>, ir<1>
    vp<%6> = vector-pointer vp<%5>
    WIDEN store vp<%6>, ir<%conv74>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.cond.backedge.loopexit>, scalar.ph

ir-bb<while.cond.backedge.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr75.lcssa = ir<%incdec.ptr75>
}
================ Final VPlan ================

@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i8, ptr %incdec.ptr35, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %16, ptr %e.01432, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body38.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %call33 to i64)) + (ptrtoint ptr %d.01451 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%e.01432> = WIDEN-POINTER-INDUCTION ir<%d.01451>, -1
    CLONE ir<%incdec.ptr35> = getelementptr inbounds ir<%e.01432>, ir<-1>
    CLONE ir<%16> = load ir<%incdec.ptr35>
    CLONE store ir<%16>, ir<%e.01432>
    CLONE ir<%cmp36> = icmp ugt ir<%incdec.ptr35>, ir<%call33>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body38.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %call33 to i64)) + (ptrtoint ptr %d.01451 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%e.01432> = WIDEN-POINTER-INDUCTION ir<%d.01451>, -1
    CLONE ir<%incdec.ptr35> = getelementptr inbounds ir<%e.01432>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr35>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%e.01432>
    WIDEN store vp<%5>, ir<%16>
    CLONE ir<%cmp36> = icmp ugt ir<%incdec.ptr35>, ir<%call33>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body38.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %call33 to i64)) + (ptrtoint ptr %d.01451 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%e.01432> = WIDEN-POINTER-INDUCTION ir<%d.01451>, -1
    CLONE ir<%incdec.ptr35> = getelementptr inbounds ir<%e.01432>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%incdec.ptr35>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%e.01432>
    WIDEN store vp<%5>, ir<%16>
    CLONE ir<%cmp36> = icmp ugt ir<%incdec.ptr35>, ir<%call33>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 9
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 48
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 9
B VF: 8, EstimatedWidthB: 8, CostB: 9
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 144
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 23
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 23, CostB * EstimatedWidthA: 96
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 23
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 368, CostB * EstimatedWidthA: 288

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 72

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 144
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %e.01432 = phi ptr [ %incdec.ptr35, %while.body38 ], [ %d.01451, %while.body38.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr35 = getelementptr inbounds i8, ptr %e.01432, i64 -1 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %16 = load i8, ptr %incdec.ptr35, align 1 of type:load
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %16, ptr %e.01432, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp36 = icmp ugt ptr %incdec.ptr35, %call33 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp36, label %while.body38, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 7
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: S_scan_const at line: toke.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body38.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %call33 to i64)) + (ptrtoint ptr %d.01451 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    EMIT vp<%6> = ptradd ir<%d.01451>, vp<%5>
    CLONE ir<%incdec.ptr35> = getelementptr inbounds vp<%6>, ir<-1>
    vp<%7> = vector-pointer (reverse) ir<%incdec.ptr35>
    WIDEN ir<%16> = load vp<%7>
    vp<%8> = vector-pointer (reverse) vp<%6>
    WIDEN store vp<%8>, ir<%16>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %79 = load i8, ptr %s.21421, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %79, ptr %d.41420, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body198.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i1 %cmp190.not to i64) + (-1 * (ptrtoint ptr %s.01452 to i64)) + (ptrtoint ptr %regparse.0.lcssa to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.21421> = WIDEN-POINTER-INDUCTION ir<%s.01452>, 1
    EMIT ir<%d.41420> = WIDEN-POINTER-INDUCTION ir<%d.01451>, 1
    CLONE ir<%incdec.ptr199> = getelementptr inbounds ir<%s.21421>, ir<1>
    CLONE ir<%79> = load ir<%s.21421>
    CLONE ir<%incdec.ptr200> = getelementptr inbounds ir<%d.41420>, ir<1>
    CLONE store ir<%79>, ir<%d.41420>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr199>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end327thread-pre-split.loopexit1548>, scalar.ph

ir-bb<if.end327thread-pre-split.loopexit1548>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr199.lcssa = ir<%incdec.ptr199>
Live-out ptr %incdec.ptr200.lcssa = ir<%incdec.ptr200>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body198.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i1 %cmp190.not to i64) + (-1 * (ptrtoint ptr %s.01452 to i64)) + (ptrtoint ptr %regparse.0.lcssa to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.21421> = WIDEN-POINTER-INDUCTION ir<%s.01452>, 1
    EMIT ir<%d.41420> = WIDEN-POINTER-INDUCTION ir<%d.01451>, 1
    CLONE ir<%incdec.ptr199> = getelementptr inbounds ir<%s.21421>, ir<1>
    vp<%4> = vector-pointer ir<%s.21421>
    WIDEN ir<%79> = load vp<%4>
    CLONE ir<%incdec.ptr200> = getelementptr inbounds ir<%d.41420>, ir<1>
    vp<%5> = vector-pointer ir<%d.41420>
    WIDEN store vp<%5>, ir<%79>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr199>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end327thread-pre-split.loopexit1548>, scalar.ph

ir-bb<if.end327thread-pre-split.loopexit1548>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr199.lcssa = ir<%incdec.ptr199>
Live-out ptr %incdec.ptr200.lcssa = ir<%incdec.ptr200>
}

========== Loop: S_scan_const' from toke.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body198.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i1 %cmp190.not to i64) + (-1 * (ptrtoint ptr %s.01452 to i64)) + (ptrtoint ptr %regparse.0.lcssa to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%s.21421> = WIDEN-POINTER-INDUCTION ir<%s.01452>, 1
    EMIT ir<%d.41420> = WIDEN-POINTER-INDUCTION ir<%d.01451>, 1
    CLONE ir<%incdec.ptr199> = getelementptr inbounds ir<%s.21421>, ir<1>
    vp<%4> = vector-pointer ir<%s.21421>
    WIDEN ir<%79> = load vp<%4>
    CLONE ir<%incdec.ptr200> = getelementptr inbounds ir<%d.41420>, ir<1>
    vp<%5> = vector-pointer ir<%d.41420>
    WIDEN store vp<%5>, ir<%79>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr199>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end327thread-pre-split.loopexit1548>, scalar.ph

ir-bb<if.end327thread-pre-split.loopexit1548>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr199.lcssa = ir<%incdec.ptr199>
Live-out ptr %incdec.ptr200.lcssa = ir<%incdec.ptr200>
}


-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'S_scan_const' from toke.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.21421 = phi ptr [ %incdec.ptr199, %while.body198 ], [ %s.01452, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %d.41420 = phi ptr [ %incdec.ptr200, %while.body198 ], [ %d.01451, %while.body198.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr199 = getelementptr inbounds i8, ptr %s.21421, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %79 = load i8, ptr %s.21421, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr200 = getelementptr inbounds i8, ptr %d.41420, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %79, ptr %d.41420, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr199, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %if.end327thread-pre-split.loopexit1548, label %while.body198 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: S_scan_const at line: toke.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body198.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i1 %cmp190.not to i64) + (-1 * (ptrtoint ptr %s.01452 to i64)) + (ptrtoint ptr %regparse.0.lcssa to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%s.01452>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%d.01451>, vp<%6>
    CLONE ir<%incdec.ptr199> = getelementptr inbounds vp<%5>, ir<1>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%82> = load vp<%8>
    CLONE ir<%incdec.ptr200> = getelementptr inbounds vp<%7>, ir<1>
    vp<%9> = vector-pointer vp<%7>
    WIDEN store vp<%9>, ir<%82>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end327thread-pre-split.loopexit1548>, scalar.ph

ir-bb<if.end327thread-pre-split.loopexit1548>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr199.lcssa = ir<%incdec.ptr199>
Live-out ptr %incdec.ptr200.lcssa = ir<%incdec.ptr200>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 65
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o universal.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         universal.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o utf8.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         utf8.c
========== Loop: Perl_utf16_to_utf8_reversed' from utf8.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((sext i32 %bytelen to i64) + (ptrtoint ptr %p to i64)))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.014> = WIDEN-POINTER-INDUCTION ir<%p>, 2
    CLONE ir<%0> = load ir<%s.014>
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<%s.014>, ir<1>
    CLONE ir<%1> = load ir<%arrayidx1>
    CLONE store ir<%1>, ir<%s.014>
    CLONE store ir<%0>, ir<%arrayidx1>
    CLONE ir<%add.ptr4> = getelementptr inbounds ir<%s.014>, ir<2>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr4>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_utf16_to_utf8_reversed' from utf8.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((sext i32 %bytelen to i64) + (ptrtoint ptr %p to i64)))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.014> = WIDEN-POINTER-INDUCTION ir<%p>, 2
    INTERLEAVE-GROUP with factor 2 at %0, ir<%s.014>
      ir<%0> = load from index 0
      ir<%1> = load from index 1
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<%s.014>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx1>
      store ir<%1> to index 0
      store ir<%0> to index 1
    CLONE ir<%add.ptr4> = getelementptr inbounds ir<%s.014>, ir<2>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr4>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: Perl_utf16_to_utf8_reversed' from utf8.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((sext i32 %bytelen to i64) + (ptrtoint ptr %p to i64)))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%s.014> = WIDEN-POINTER-INDUCTION ir<%p>, 2
    INTERLEAVE-GROUP with factor 2 at %0, ir<%s.014>
      ir<%0> = load from index 0
      ir<%1> = load from index 1
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<%s.014>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx1>
      store ir<%1> to index 0
      store ir<%0> to index 1
    CLONE ir<%add.ptr4> = getelementptr inbounds ir<%s.014>, ir<2>
    CLONE ir<%cmp> = icmp ult ir<%add.ptr4>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 4 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 8 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 16 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 16 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 16 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 32 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 32 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 32 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 32 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 160
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 11
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 176, CostB * EstimatedWidthA: 224
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 44

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 88

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF vscale x 8 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF vscale x 8 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 224, CostB * EstimatedWidthA: 176

-----------------Function that is being costed:'Perl_utf16_to_utf8_reversed' from utf8.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %s.014 = phi ptr [ %add.ptr4, %while.body ], [ %p, %while.body.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF vscale x 16 For instruction:   %0 = load i8, ptr %s.014, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1 = getelementptr inbounds i8, ptr %s.014, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %1 = load i8, ptr %arrayidx1, align 1 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   store i8 %1, ptr %s.014, align 1 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF vscale x 16 For instruction:   store i8 %0, ptr %arrayidx1, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %add.ptr4 = getelementptr inbounds i8, ptr %s.014, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp = icmp ult ptr %add.ptr4, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 11
B VF: 32, EstimatedWidthB: 32, CostB: 11
CostA * EstimatedWidthB: 352, CostB * EstimatedWidthA: 352
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_utf16_to_utf8_reversed at line: utf8.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %p to i64)) + ((2 + (ptrtoint ptr %p to i64)) umax ((sext i32 %bytelen to i64) + (ptrtoint ptr %p to i64)))) /u 2))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<2>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<2>
    EMIT vp<%6> = ptradd ir<%p>, vp<%5>
    INTERLEAVE-GROUP with factor 2 at %0, vp<%6>
      ir<%0> = load from index 0
      ir<%1> = load from index 1
    CLONE ir<%arrayidx1> = getelementptr inbounds vp<%6>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx1>
      store ir<%1> to index 0
      store ir<%0> to index 1
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o util.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         util.c
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %from.addr.121.us, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %0, ptr %to.addr.222.us, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: Perl_repeatcpy' from util.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%to.addr.222.us> = WIDEN-POINTER-INDUCTION ir<%to.addr.125.us>, 1
    EMIT ir<%from.addr.121.us> = WIDEN-POINTER-INDUCTION ir<%from>, 1
    WIDEN-INDUCTION %todo.020.us = phi %len, %dec9.us, ir<-1>
    CLONE ir<%incdec.ptr7.us> = getelementptr inbounds ir<%from.addr.121.us>, ir<1>
    CLONE ir<%0> = load ir<%from.addr.121.us>
    CLONE ir<%incdec.ptr8.us> = getelementptr inbounds ir<%to.addr.222.us>, ir<1>
    CLONE store ir<%0>, ir<%to.addr.222.us>
    CLONE ir<%dec9.us> = add nsw ir<%todo.020.us>, ir<-1>
    CLONE ir<%cmp6.us> = icmp sgt ir<%todo.020.us>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr8.us.lcssa = ir<%incdec.ptr8.us>
}

========== Loop: Perl_repeatcpy' from util.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%to.addr.222.us> = WIDEN-POINTER-INDUCTION ir<%to.addr.125.us>, 1
    EMIT ir<%from.addr.121.us> = WIDEN-POINTER-INDUCTION ir<%from>, 1
    WIDEN-INDUCTION %todo.020.us = phi %len, %dec9.us, ir<-1>
    CLONE ir<%incdec.ptr7.us> = getelementptr inbounds ir<%from.addr.121.us>, ir<1>
    vp<%4> = vector-pointer ir<%from.addr.121.us>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%incdec.ptr8.us> = getelementptr inbounds ir<%to.addr.222.us>, ir<1>
    vp<%5> = vector-pointer ir<%to.addr.222.us>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%dec9.us> = add nsw ir<%todo.020.us>, ir<-1>
    CLONE ir<%cmp6.us> = icmp sgt ir<%todo.020.us>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr8.us.lcssa = ir<%incdec.ptr8.us>
}

========== Loop: Perl_repeatcpy' from util.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%to.addr.222.us> = WIDEN-POINTER-INDUCTION ir<%to.addr.125.us>, 1
    EMIT ir<%from.addr.121.us> = WIDEN-POINTER-INDUCTION ir<%from>, 1
    WIDEN-INDUCTION %todo.020.us = phi %len, %dec9.us, ir<-1>
    CLONE ir<%incdec.ptr7.us> = getelementptr inbounds ir<%from.addr.121.us>, ir<1>
    vp<%4> = vector-pointer ir<%from.addr.121.us>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%incdec.ptr8.us> = getelementptr inbounds ir<%to.addr.222.us>, ir<1>
    vp<%5> = vector-pointer ir<%to.addr.222.us>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%dec9.us> = add nsw ir<%todo.020.us>, ir<-1>
    CLONE ir<%cmp6.us> = icmp sgt ir<%todo.020.us>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr8.us.lcssa = ir<%incdec.ptr8.us>
}


-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 4294967296
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 8589934588
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 2147483656
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 536870968, RTCostB: 8589934588
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 536870968, RTCostB: 1073741848
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 402653302, RTCostB: 8589934588
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 402653302, RTCostB: 536870968
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 402653302

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 402653302

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 402653302

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 536870968, RTCostB: 8589934588
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 536870968, RTCostB: 402653302

-----------------Function that is being costed:'Perl_repeatcpy' from util.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %to.addr.222.us = phi ptr [ %to.addr.125.us, %for.cond.preheader.us ], [ %incdec.ptr8.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %from.addr.121.us = phi ptr [ %from, %for.cond.preheader.us ], [ %incdec.ptr7.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %todo.020.us = phi i32 [ %len, %for.cond.preheader.us ], [ %dec9.us, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr7.us = getelementptr inbounds i8, ptr %from.addr.121.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %0 = load i8, ptr %from.addr.121.us, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr8.us = getelementptr inbounds i8, ptr %to.addr.222.us, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %0, ptr %to.addr.222.us, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec9.us = add nsw i32 %todo.020.us, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp6.us = icmp sgt i32 %todo.020.us, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp6.us, label %for.body.us, label %for.cond.while.cond2.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 402653302, RTCostB: 8589934588
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 402653302, RTCostB: 402653302
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: Perl_repeatcpy at line: util.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %len to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%to.addr.125.us>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%from>, vp<%6>
    vp<%8> = vector-pointer vp<%7>
    WIDEN ir<%4> = load vp<%8>
    CLONE ir<%incdec.ptr8.us> = getelementptr inbounds vp<%5>, ir<1>
    vp<%9> = vector-pointer vp<%5>
    WIDEN store vp<%9>, ir<%4>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond.while.cond2.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr8.us.lcssa = ir<%incdec.ptr8.us>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 29
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o xsutils.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         xsutils.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o Base64.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         Base64.c
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %26 = load i8, ptr %c.0206, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %26, ptr %r.1205, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %25)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%c.0206> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.1205> = WIDEN-POINTER-INDUCTION ir<%r.0209>, 1
    CLONE ir<%incdec.ptr73> = getelementptr inbounds ir<%c.0206>, ir<1>
    CLONE ir<%26> = load ir<%c.0206>
    CLONE ir<%incdec.ptr74> = getelementptr inbounds ir<%r.1205>, ir<1>
    CLONE store ir<%26>, ir<%r.1205>
    CLONE ir<%cmp71> = icmp ult ir<%incdec.ptr73>, ir<%add.ptr70>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end75.loopexit>, scalar.ph

ir-bb<if.end75.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr74.lcssa = ir<%incdec.ptr74>
}

========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %25)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%c.0206> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.1205> = WIDEN-POINTER-INDUCTION ir<%r.0209>, 1
    CLONE ir<%incdec.ptr73> = getelementptr inbounds ir<%c.0206>, ir<1>
    vp<%4> = vector-pointer ir<%c.0206>
    WIDEN ir<%26> = load vp<%4>
    CLONE ir<%incdec.ptr74> = getelementptr inbounds ir<%r.1205>, ir<1>
    vp<%5> = vector-pointer ir<%r.1205>
    WIDEN store vp<%5>, ir<%26>
    CLONE ir<%cmp71> = icmp ult ir<%incdec.ptr73>, ir<%add.ptr70>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end75.loopexit>, scalar.ph

ir-bb<if.end75.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr74.lcssa = ir<%incdec.ptr74>
}

========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %25)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%c.0206> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.1205> = WIDEN-POINTER-INDUCTION ir<%r.0209>, 1
    CLONE ir<%incdec.ptr73> = getelementptr inbounds ir<%c.0206>, ir<1>
    vp<%4> = vector-pointer ir<%c.0206>
    WIDEN ir<%26> = load vp<%4>
    CLONE ir<%incdec.ptr74> = getelementptr inbounds ir<%r.1205>, ir<1>
    vp<%5> = vector-pointer ir<%r.1205>
    WIDEN store vp<%5>, ir<%26>
    CLONE ir<%cmp71> = icmp ult ir<%incdec.ptr73>, ir<%add.ptr70>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end75.loopexit>, scalar.ph

ir-bb<if.end75.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr74.lcssa = ir<%incdec.ptr74>
}


-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %c.0206 = phi ptr [ %incdec.ptr73, %while.body ], [ %eol.0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %r.1205 = phi ptr [ %incdec.ptr74, %while.body ], [ %r.0209, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr73 = getelementptr inbounds i8, ptr %c.0206, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %26 = load i8, ptr %c.0206, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr74 = getelementptr inbounds i8, ptr %r.1205, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %26, ptr %r.1205, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp71 = icmp ult ptr %incdec.ptr73, %add.ptr70 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp71, label %while.body, label %if.end75.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: XS_MIME__Base64_encode_base64 at line: Base64.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %26)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%eol.0>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%r.0209>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%30> = load vp<%8>
    CLONE ir<%incdec.ptr74> = getelementptr inbounds vp<%7>, ir<1>
    vp<%9> = vector-pointer vp<%7>
    WIDEN store vp<%9>, ir<%30>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end75.loopexit>, scalar.ph

ir-bb<if.end75.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr74.lcssa = ir<%incdec.ptr74>
}
================ Final VPlan ================

@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %57 = load i8, ptr %c137.0215, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %57, ptr %r.4214, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body143.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %56)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%c137.0215> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.4214> = WIDEN-POINTER-INDUCTION ir<%r.0.lcssa>, 1
    CLONE ir<%incdec.ptr144> = getelementptr inbounds ir<%c137.0215>, ir<1>
    CLONE ir<%57> = load ir<%c137.0215>
    CLONE ir<%incdec.ptr145> = getelementptr inbounds ir<%r.4214>, ir<1>
    CLONE store ir<%57>, ir<%r.4214>
    CLONE ir<%cmp141> = icmp ult ir<%incdec.ptr144>, ir<%add.ptr139>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end147.loopexit>, scalar.ph

ir-bb<if.end147.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr145.lcssa = ir<%incdec.ptr145>
}

========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body143.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %56)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%c137.0215> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.4214> = WIDEN-POINTER-INDUCTION ir<%r.0.lcssa>, 1
    CLONE ir<%incdec.ptr144> = getelementptr inbounds ir<%c137.0215>, ir<1>
    vp<%4> = vector-pointer ir<%c137.0215>
    WIDEN ir<%57> = load vp<%4>
    CLONE ir<%incdec.ptr145> = getelementptr inbounds ir<%r.4214>, ir<1>
    vp<%5> = vector-pointer ir<%r.4214>
    WIDEN store vp<%5>, ir<%57>
    CLONE ir<%cmp141> = icmp ult ir<%incdec.ptr144>, ir<%add.ptr139>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end147.loopexit>, scalar.ph

ir-bb<if.end147.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr145.lcssa = ir<%incdec.ptr145>
}

========== Loop: XS_MIME__Base64_encode_base64' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body143.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %56)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%c137.0215> = WIDEN-POINTER-INDUCTION ir<%eol.0>, 1
    EMIT ir<%r.4214> = WIDEN-POINTER-INDUCTION ir<%r.0.lcssa>, 1
    CLONE ir<%incdec.ptr144> = getelementptr inbounds ir<%c137.0215>, ir<1>
    vp<%4> = vector-pointer ir<%c137.0215>
    WIDEN ir<%57> = load vp<%4>
    CLONE ir<%incdec.ptr145> = getelementptr inbounds ir<%r.4214>, ir<1>
    vp<%5> = vector-pointer ir<%r.4214>
    WIDEN store vp<%5>, ir<%57>
    CLONE ir<%cmp141> = icmp ult ir<%incdec.ptr144>, ir<%add.ptr139>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end147.loopexit>, scalar.ph

ir-bb<if.end147.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr145.lcssa = ir<%incdec.ptr145>
}


-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'XS_MIME__Base64_encode_base64' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %c137.0215 = phi ptr [ %incdec.ptr144, %while.body143 ], [ %eol.0, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %r.4214 = phi ptr [ %incdec.ptr145, %while.body143 ], [ %r.0.lcssa, %while.body143.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr144 = getelementptr inbounds i8, ptr %c137.0215, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %57 = load i8, ptr %c137.0215, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr145 = getelementptr inbounds i8, ptr %r.4214, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %57, ptr %r.4214, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp141 = icmp ult ptr %incdec.ptr144, %add.ptr139 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp141, label %while.body143, label %if.end147.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: XS_MIME__Base64_encode_base64 at line: Base64.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body143.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %eol.0 to i64)) + ((1 + (ptrtoint ptr %eol.0 to i64)) umax ((ptrtoint ptr %eol.0 to i64) + %56)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%eol.0>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%r.0.lcssa>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%60> = load vp<%8>
    CLONE ir<%incdec.ptr145> = getelementptr inbounds vp<%7>, ir<1>
    vp<%9> = vector-pointer vp<%7>
    WIDEN store vp<%9>, ir<%60>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end147.loopexit>, scalar.ph

ir-bb<if.end147.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr145.lcssa = ir<%incdec.ptr145>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load i8, ptr %whitespace.2303, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %20, ptr %r.1304, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body59.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.0310 to i64)) + (ptrtoint ptr %str.0312 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.1304> = WIDEN-POINTER-INDUCTION ir<%r.0311>, 1
    EMIT ir<%whitespace.2303> = WIDEN-POINTER-INDUCTION ir<%whitespace.0310>, 1
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%whitespace.2303>, ir<1>
    CLONE ir<%20> = load ir<%whitespace.2303>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%r.1304>, ir<1>
    CLONE store ir<%20>, ir<%r.1304>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr60>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end62.loopexit>, scalar.ph

ir-bb<if.end62.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr61.lcssa = ir<%incdec.ptr61>
}

========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body59.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.0310 to i64)) + (ptrtoint ptr %str.0312 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%r.1304> = WIDEN-POINTER-INDUCTION ir<%r.0311>, 1
    EMIT ir<%whitespace.2303> = WIDEN-POINTER-INDUCTION ir<%whitespace.0310>, 1
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%whitespace.2303>, ir<1>
    vp<%4> = vector-pointer ir<%whitespace.2303>
    WIDEN ir<%20> = load vp<%4>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%r.1304>, ir<1>
    vp<%5> = vector-pointer ir<%r.1304>
    WIDEN store vp<%5>, ir<%20>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr60>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end62.loopexit>, scalar.ph

ir-bb<if.end62.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr61.lcssa = ir<%incdec.ptr61>
}

========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body59.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.0310 to i64)) + (ptrtoint ptr %str.0312 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%r.1304> = WIDEN-POINTER-INDUCTION ir<%r.0311>, 1
    EMIT ir<%whitespace.2303> = WIDEN-POINTER-INDUCTION ir<%whitespace.0310>, 1
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%whitespace.2303>, ir<1>
    vp<%4> = vector-pointer ir<%whitespace.2303>
    WIDEN ir<%20> = load vp<%4>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%r.1304>, ir<1>
    vp<%5> = vector-pointer ir<%r.1304>
    WIDEN store vp<%5>, ir<%20>
    CLONE ir<%exitcond.not> = icmp eq ir<%incdec.ptr60>, ir<%scevgep>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end62.loopexit>, scalar.ph

ir-bb<if.end62.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr61.lcssa = ir<%incdec.ptr61>
}


-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %r.1304 = phi ptr [ %incdec.ptr61, %while.body59 ], [ %r.0311, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %whitespace.2303 = phi ptr [ %incdec.ptr60, %while.body59 ], [ %whitespace.0310, %while.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %whitespace.2303, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %20 = load i8, ptr %whitespace.2303, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %r.1304, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %20, ptr %r.1304, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq ptr %incdec.ptr60, %scevgep of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %if.end62.loopexit, label %while.body59 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: XS_MIME__QuotedPrint_decode_qp at line: Base64.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body59.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.0310 to i64)) + (ptrtoint ptr %str.0312 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%r.0311>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%whitespace.0310>, vp<%6>
    vp<%8> = vector-pointer vp<%7>
    WIDEN ir<%23> = load vp<%8>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds vp<%5>, ir<1>
    vp<%9> = vector-pointer vp<%5>
    WIDEN store vp<%9>, ir<%23>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end62.loopexit>, scalar.ph

ir-bb<if.end62.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr61.lcssa = ir<%incdec.ptr61>
}
================ Final VPlan ================

@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i8, ptr %whitespace.5317, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %47, ptr %r.5318, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body196.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.4 to i64)) + (ptrtoint ptr %str.2 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.5318> = WIDEN-POINTER-INDUCTION ir<%r.4.lcssa>, 1
    EMIT ir<%whitespace.5317> = WIDEN-POINTER-INDUCTION ir<%whitespace.4.lcssa>, 1
    CLONE ir<%incdec.ptr197> = getelementptr inbounds ir<%whitespace.5317>, ir<1>
    CLONE ir<%47> = load ir<%whitespace.5317>
    CLONE ir<%incdec.ptr198> = getelementptr inbounds ir<%r.5318>, ir<1>
    CLONE store ir<%47>, ir<%r.5318>
    CLONE ir<%exitcond334.not> = icmp eq ir<%incdec.ptr197>, ir<%scevgep333>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end200.loopexit>, scalar.ph

ir-bb<if.end200.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr198.lcssa = ir<%incdec.ptr198>
}

========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body196.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.4 to i64)) + (ptrtoint ptr %str.2 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%r.5318> = WIDEN-POINTER-INDUCTION ir<%r.4.lcssa>, 1
    EMIT ir<%whitespace.5317> = WIDEN-POINTER-INDUCTION ir<%whitespace.4.lcssa>, 1
    CLONE ir<%incdec.ptr197> = getelementptr inbounds ir<%whitespace.5317>, ir<1>
    vp<%4> = vector-pointer ir<%whitespace.5317>
    WIDEN ir<%47> = load vp<%4>
    CLONE ir<%incdec.ptr198> = getelementptr inbounds ir<%r.5318>, ir<1>
    vp<%5> = vector-pointer ir<%r.5318>
    WIDEN store vp<%5>, ir<%47>
    CLONE ir<%exitcond334.not> = icmp eq ir<%incdec.ptr197>, ir<%scevgep333>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end200.loopexit>, scalar.ph

ir-bb<if.end200.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr198.lcssa = ir<%incdec.ptr198>
}

========== Loop: XS_MIME__QuotedPrint_decode_qp' from Base64.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body196.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.4 to i64)) + (ptrtoint ptr %str.2 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%r.5318> = WIDEN-POINTER-INDUCTION ir<%r.4.lcssa>, 1
    EMIT ir<%whitespace.5317> = WIDEN-POINTER-INDUCTION ir<%whitespace.4.lcssa>, 1
    CLONE ir<%incdec.ptr197> = getelementptr inbounds ir<%whitespace.5317>, ir<1>
    vp<%4> = vector-pointer ir<%whitespace.5317>
    WIDEN ir<%47> = load vp<%4>
    CLONE ir<%incdec.ptr198> = getelementptr inbounds ir<%r.5318>, ir<1>
    vp<%5> = vector-pointer ir<%r.5318>
    WIDEN store vp<%5>, ir<%47>
    CLONE ir<%exitcond334.not> = icmp eq ir<%incdec.ptr197>, ir<%scevgep333>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end200.loopexit>, scalar.ph

ir-bb<if.end200.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr198.lcssa = ir<%incdec.ptr198>
}


-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'XS_MIME__QuotedPrint_decode_qp' from Base64.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %r.5318 = phi ptr [ %incdec.ptr198, %while.body196 ], [ %r.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %whitespace.5317 = phi ptr [ %incdec.ptr197, %while.body196 ], [ %whitespace.4.lcssa, %while.body196.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr197 = getelementptr inbounds i8, ptr %whitespace.5317, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %47 = load i8, ptr %whitespace.5317, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr198 = getelementptr inbounds i8, ptr %r.5318, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %47, ptr %r.5318, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond334.not = icmp eq ptr %incdec.ptr197, %scevgep333 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond334.not, label %if.end200.loopexit, label %while.body196 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 5
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: XS_MIME__QuotedPrint_decode_qp at line: Base64.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body196.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %whitespace.4 to i64)) + (ptrtoint ptr %str.2 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%r.4.lcssa>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%whitespace.4.lcssa>, vp<%6>
    vp<%8> = vector-pointer vp<%7>
    WIDEN ir<%50> = load vp<%8>
    CLONE ir<%incdec.ptr198> = getelementptr inbounds vp<%5>, ir<1>
    vp<%9> = vector-pointer vp<%5>
    WIDEN store vp<%9>, ir<%50>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end200.loopexit>, scalar.ph

ir-bb<if.end200.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr198.lcssa = ir<%incdec.ptr198>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o Cwd.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         Cwd.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o Dumper.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         Dumper.c
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %.pre, ptr %arrayidx30, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: sv_x' from Dumper.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * (1 smin %n)) + %n) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %conv, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %conv, %indvars.iv.next\l" +
    "  ir<%6>, ir<-1>
    CLONE ir<%dec> = add ir<%indvars.iv>, ir<4294967295>
    CLONE ir<%idxprom29> = and ir<%dec>, ir<4294967295>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%add.ptr>, ir<%idxprom29>
    CLONE store ir<%.pre>, ir<%arrayidx30>
    CLONE ir<%cmp26> = icmp sgt ir<%6>, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end39.loopexit>, scalar.ph

ir-bb<if.end39.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sv_x' from Dumper.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * (1 smin %n)) + %n) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %conv, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %conv, %indvars.iv.next\l" +
    "  ir<%6>, ir<-1>
    CLONE ir<%dec> = add ir<%indvars.iv>, ir<4294967295>
    CLONE ir<%idxprom29> = and ir<%dec>, ir<4294967295>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%add.ptr>, ir<%idxprom29>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx30>
    WIDEN store vp<%4>, ir<%.pre>
    CLONE ir<%cmp26> = icmp sgt ir<%6>, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end39.loopexit>, scalar.ph

ir-bb<if.end39.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sv_x' from Dumper.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * (1 smin %n)) + %n) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %conv, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %conv, %indvars.iv.next\l" +
    "  ir<%6>, ir<-1>
    CLONE ir<%dec> = add ir<%indvars.iv>, ir<4294967295>
    CLONE ir<%idxprom29> = and ir<%dec>, ir<4294967295>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%add.ptr>, ir<%idxprom29>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx30>
    WIDEN store vp<%4>, ir<%.pre>
    CLONE ir<%cmp26> = icmp sgt ir<%6>, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end39.loopexit>, scalar.ph

ir-bb<if.end39.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 8589934589, RTCostB: 10737418235
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934589, RTCostB: 10737418235
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967303, RTCostB: 10737418235
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967303, RTCostB: 8589934589
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483675, RTCostB: 10737418235
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483675, RTCostB: 4294967303
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1073741891, RTCostB: 10737418235
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741891, RTCostB: 2147483675
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF 32 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1006633100, RTCostB: 10737418235
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1006633100, RTCostB: 1073741891
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 10737418235
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 1006633100

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 10737418235
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 1006633100

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612765, RTCostB: 10737418235
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612765, RTCostB: 1006633100

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 805306437, RTCostB: 10737418235
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 805306437, RTCostB: 1006633100
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 32

-----------------Function that is being costed:'sv_x' from Dumper.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %conv, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %6 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %idxprom29 = and i64 %dec, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx30 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom29 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %.pre, ptr %arrayidx30, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp26 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp26, label %while.body, label %if.end39.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 469762196, RTCostB: 10737418235
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 469762196, RTCostB: 805306437
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: sv_x at line: Dumper.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * (1 smin %n)) + %n) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%conv> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%dec> = add vp<%5>, ir<4294967295>
    CLONE ir<%idxprom29> = and ir<%dec>, ir<4294967295>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%add.ptr>, ir<%idxprom29>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx30>
    WIDEN store vp<%6>, ir<%.pre>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end39.loopexit>, scalar.ph

ir-bb<if.end39.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o HiRes.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         HiRes.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o IO.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         IO.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o Peek.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         Peek.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o attrs.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         attrs.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o poll.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         poll.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o stdio.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         stdio.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o DynaLoader.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         DynaLoader.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o MD5.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         MD5.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o Storable.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         Storable.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o Parser.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         Parser.c
@@ Instruction =>  %69 = load i8, ptr %ent_start.0451, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %69, ptr %incdec.ptr282448450, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %69 = load i8, ptr %ent_start.0451, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %69, ptr %incdec.ptr282448450, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %69 = load i8, ptr %ent_start.0451, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %69, ptr %incdec.ptr282448450, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %69 = load i8, ptr %ent_start.0451, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %69, ptr %incdec.ptr282448450, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: decode_entities' from Parser.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body280.preheader>:
  EMIT vp<%2> = EXPAND SCEV ({(-1 + (-1 * (ptrtoint ptr %s.promoted to i64))),+,-1}<nw><%while.cond> + (ptrtoint ptr %.pre469495 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%ent_start.0451> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr.lcssa>, 1
    EMIT ir<%incdec.ptr282448450> = WIDEN-POINTER-INDUCTION ir<%t.promoted447>, 1
    CLONE ir<%incdec.ptr281> = getelementptr inbounds ir<%ent_start.0451>, ir<1>
    CLONE ir<%69> = load ir<%ent_start.0451>
    CLONE ir<%incdec.ptr282> = getelementptr inbounds ir<%incdec.ptr282448450>, ir<1>
    CLONE store ir<%incdec.ptr282>, ir<%t>
    CLONE store ir<%69>, ir<%incdec.ptr282448450>
    CLONE ir<%cmp278> = icmp ult ir<%incdec.ptr281>, ir<%.pre469495>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end284.loopexit>, scalar.ph

ir-bb<if.end284.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr282.lcssa = ir<%incdec.ptr282>
}

========== Loop: decode_entities' from Parser.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body280.preheader>:
  EMIT vp<%2> = EXPAND SCEV ({(-1 + (-1 * (ptrtoint ptr %s.promoted to i64))),+,-1}<nw><%while.cond> + (ptrtoint ptr %.pre469495 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%ent_start.0451> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr.lcssa>, 1
    EMIT ir<%incdec.ptr282448450> = WIDEN-POINTER-INDUCTION ir<%t.promoted447>, 1
    CLONE ir<%incdec.ptr281> = getelementptr inbounds ir<%ent_start.0451>, ir<1>
    vp<%4> = vector-pointer ir<%ent_start.0451>
    WIDEN ir<%69> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr282> = getelementptr inbounds ir<%incdec.ptr282448450>, ir<1>
    WIDEN store ir<%t>, ir<%incdec.ptr282>
    vp<%5> = vector-pointer ir<%incdec.ptr282448450>
    WIDEN store vp<%5>, ir<%69>
    CLONE ir<%cmp278> = icmp ult ir<%incdec.ptr281>, ir<%.pre469495>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end284.loopexit>, scalar.ph

ir-bb<if.end284.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr282.lcssa = ir<%incdec.ptr282>
}

========== Loop: decode_entities' from Parser.c==========
========== VPlan for Vector Factor Range: 4 to 8==========
VPlan 'Initial VPlan for VF={4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body280.preheader>:
  EMIT vp<%2> = EXPAND SCEV ({(-1 + (-1 * (ptrtoint ptr %s.promoted to i64))),+,-1}<nw><%while.cond> + (ptrtoint ptr %.pre469495 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%ent_start.0451> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr.lcssa>, 1
    EMIT ir<%incdec.ptr282448450> = WIDEN-POINTER-INDUCTION ir<%t.promoted447>, 1
    CLONE ir<%incdec.ptr281> = getelementptr inbounds ir<%ent_start.0451>, ir<1>
    vp<%4> = vector-pointer ir<%ent_start.0451>
    WIDEN ir<%69> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr282> = getelementptr inbounds ir<%incdec.ptr282448450>, ir<1>
    REPLICATE store ir<%incdec.ptr282>, ir<%t>
    vp<%5> = vector-pointer ir<%incdec.ptr282448450>
    WIDEN store vp<%5>, ir<%69>
    CLONE ir<%cmp278> = icmp ult ir<%incdec.ptr281>, ir<%.pre469495>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end284.loopexit>, scalar.ph

ir-bb<if.end284.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr282.lcssa = ir<%incdec.ptr282>
}

========== Loop: decode_entities' from Parser.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body280.preheader>:
  EMIT vp<%2> = EXPAND SCEV ({(-1 + (-1 * (ptrtoint ptr %s.promoted to i64))),+,-1}<nw><%while.cond> + (ptrtoint ptr %.pre469495 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%ent_start.0451> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr.ptr.lcssa>, 1
    EMIT ir<%incdec.ptr282448450> = WIDEN-POINTER-INDUCTION ir<%t.promoted447>, 1
    CLONE ir<%incdec.ptr281> = getelementptr inbounds ir<%ent_start.0451>, ir<1>
    vp<%4> = vector-pointer ir<%ent_start.0451>
    WIDEN ir<%69> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr282> = getelementptr inbounds ir<%incdec.ptr282448450>, ir<1>
    REPLICATE store ir<%incdec.ptr282>, ir<%t>
    vp<%5> = vector-pointer ir<%incdec.ptr282448450>
    WIDEN store vp<%5>, ir<%69>
    CLONE ir<%cmp278> = icmp ult ir<%incdec.ptr281>, ir<%.pre469495>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end284.loopexit>, scalar.ph

ir-bb<if.end284.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr282.lcssa = ir<%incdec.ptr282>
}


-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %69 = load i8, ptr %ent_start.0451, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %69, ptr %incdec.ptr282448450, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre469495 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %69 = load i8, ptr %ent_start.0451, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %69, ptr %incdec.ptr282448450, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre469495 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %69 = load i8, ptr %ent_start.0451, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3 for VF 4 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %69, ptr %incdec.ptr282448450, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre469495 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %69 = load i8, ptr %ent_start.0451, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %69, ptr %incdec.ptr282448450, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre469495 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'decode_entities' from Parser.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ent_start.0451 = phi ptr [ %incdec.ptr281, %while.body280 ], [ %incdec.ptr.ptr.lcssa, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr282448450 = phi ptr [ %incdec.ptr282, %while.body280 ], [ %t.promoted447, %while.body280.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr281 = getelementptr inbounds i8, ptr %ent_start.0451, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %69 = load i8, ptr %ent_start.0451, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr282 = getelementptr inbounds i8, ptr %incdec.ptr282448450, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr %incdec.ptr282, ptr %t, align 8 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %69, ptr %incdec.ptr282448450, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp278 = icmp ult ptr %incdec.ptr281, %.pre469495 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp278, label %while.body280, label %if.end284.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: decode_entities at line: Parser.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body280.preheader>:
  EMIT vp<%2> = EXPAND SCEV ({(-1 + (-1 * (ptrtoint ptr %s.promoted to i64))),+,-1}<nw><%while.cond> + (ptrtoint ptr %.pre469495 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%incdec.ptr282448450> = WIDEN-POINTER-INDUCTION ir<%t.promoted447>, 1
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%incdec.ptr.ptr.lcssa>, vp<%4>
    vp<%6> = vector-pointer vp<%5>
    WIDEN ir<%73> = load vp<%6>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr282> = getelementptr inbounds ir<%incdec.ptr282448450>, ir<1>
    REPLICATE store ir<%incdec.ptr282>, ir<%t>
    vp<%7> = vector-pointer ir<%incdec.ptr282448450>
    WIDEN store vp<%7>, ir<%73>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end284.loopexit>, scalar.ph

ir-bb<if.end284.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr282.lcssa = ir<%incdec.ptr282>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o specrand.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         specrand.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o Hostname.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         Hostname.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o Opcode.o -DSPEC_CPU -DNDEBUG -DPERL_CORE   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89         Opcode.c
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %10 = load i8, ptr %arrayidx11, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %not, ptr %arrayidx11, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: XS_Opcode_invert_opset' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%7> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %len.040 = phi %dec, %7, ir<-1>
    CLONE ir<%dec> = add ir<%len.040>, ir<-1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%9>, ir<%dec>
    CLONE ir<%10> = load ir<%arrayidx11>
    CLONE ir<%not> = xor ir<%10>, ir<-1>
    CLONE store ir<%not>, ir<%arrayidx11>
    CLONE ir<%cmp9.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%7>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XS_Opcode_invert_opset' from Opcode.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%7> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %len.040 = phi %dec, %7, ir<-1>
    CLONE ir<%dec> = add ir<%len.040>, ir<-1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%9>, ir<%dec>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN ir<%10> = load vp<%3>
    WIDEN ir<%not> = xor ir<%10>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN store vp<%4>, ir<%not>
    CLONE ir<%cmp9.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%7>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: XS_Opcode_invert_opset' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%7> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %len.040 = phi %dec, %7, ir<-1>
    CLONE ir<%dec> = add ir<%len.040>, ir<-1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%9>, ir<%dec>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN ir<%10> = load vp<%3>
    WIDEN ir<%not> = xor ir<%10>, ir<-1>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN store vp<%4>, ir<%not>
    CLONE ir<%cmp9.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%7>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 10
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 11
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 88
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 11
B VF: 8, EstimatedWidthB: 8, CostB: 11
CostA * EstimatedWidthB: 88, CostB * EstimatedWidthA: 176
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 26
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 26, CostB * EstimatedWidthA: 160
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 26
B VF: 16, EstimatedWidthB: 16, CostB: 11
CostA * EstimatedWidthB: 416, CostB * EstimatedWidthA: 352

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 11
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 11
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 44

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 11
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 88

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 11
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 176
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'XS_Opcode_invert_opset' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %len.040 = phi i64 [ %dec, %while.body ], [ %7, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add i64 %len.040, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx11 = getelementptr inbounds i8, ptr %9, i64 %dec of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %10 = load i8, ptr %arrayidx11, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %not = xor i8 %10, -1 of type:xor
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %not, ptr %arrayidx11, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp9.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp9.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 224
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: XS_Opcode_invert_opset at line: Opcode.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%7> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3>    = DERIVED-IV ir<%7> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec> = add vp<%4>, ir<-1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%9>, ir<%dec>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%not> = xor ir<%10>, ir<-1>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN store vp<%6>, ir<%not>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%7>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 1
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %11 = load i8, ptr %arrayidx56, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %12 = load i8, ptr %arrayidx58, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %or60111, ptr %arrayidx58, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %dec116.in = phi %dec116, %8, ir<-1>
    CLONE ir<%dec116> = add ir<%dec116.in>, ir<-1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%10>, ir<%dec116>
    CLONE ir<%11> = load ir<%arrayidx56>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%bitmap>, ir<%dec116>
    CLONE ir<%12> = load ir<%arrayidx58>
    CLONE ir<%or60111> = or ir<%12>, ir<%11>
    CLONE store ir<%or60111>, ir<%arrayidx58>
    CLONE ir<%cmp54.not> = icmp eq ir<%dec116>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.end81.loopexit122>, scalar.ph

ir-bb<if.end81.loopexit122>:
No successors

scalar.ph:
No successors
}

========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %dec116.in = phi %dec116, %8, ir<-1>
    CLONE ir<%dec116> = add ir<%dec116.in>, ir<-1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%10>, ir<%dec116>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx56>
    WIDEN ir<%11> = load vp<%3>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%bitmap>, ir<%dec116>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN ir<%12> = load vp<%4>
    WIDEN ir<%or60111> = or ir<%12>, ir<%11>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN store vp<%5>, ir<%or60111>
    CLONE ir<%cmp54.not> = icmp eq ir<%dec116>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end81.loopexit122>, scalar.ph

ir-bb<if.end81.loopexit122>:
No successors

scalar.ph:
No successors
}

========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %dec116.in = phi %dec116, %8, ir<-1>
    CLONE ir<%dec116> = add ir<%dec116.in>, ir<-1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%10>, ir<%dec116>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx56>
    WIDEN ir<%11> = load vp<%3>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%bitmap>, ir<%dec116>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN ir<%12> = load vp<%4>
    WIDEN ir<%or60111> = or ir<%12>, ir<%11>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN store vp<%5>, ir<%or60111>
    CLONE ir<%cmp54.not> = icmp eq ir<%dec116>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end81.loopexit122>, scalar.ph

ir-bb<if.end81.loopexit122>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 15
B VF: 4, EstimatedWidthB: 4, CostB: 15
CostA * EstimatedWidthB: 60, CostB * EstimatedWidthA: 120
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 15
B VF: 8, EstimatedWidthB: 8, CostB: 15
CostA * EstimatedWidthB: 120, CostB * EstimatedWidthA: 240
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width 32 costs: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 37
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 37, CostB * EstimatedWidthA: 192
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 37
B VF: 16, EstimatedWidthB: 16, CostB: 15
CostA * EstimatedWidthB: 592, CostB * EstimatedWidthA: 480

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 15
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 30

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 15
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 60

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 15
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 120

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 15
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 240
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dec116.in = phi i64 [ %dec116, %while.body ], [ %8, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec116 = add i64 %dec116.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx56 = getelementptr inbounds i8, ptr %10, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %11 = load i8, ptr %arrayidx56, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx58 = getelementptr inbounds i8, ptr %bitmap, i64 %dec116 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %12 = load i8, ptr %arrayidx58, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %or60111 = or i8 %12, %11 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %or60111, ptr %arrayidx58, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp54.not = icmp eq i64 %dec116, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp54.not, label %if.end81.loopexit122, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 13
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 9
CostA * EstimatedWidthB: 208, CostB * EstimatedWidthA: 288
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: set_opset_bits at line: Opcode.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<%8> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec116> = add vp<%4>, ir<-1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%10>, ir<%dec116>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx56>
    WIDEN ir<%11> = load vp<%5>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%bitmap>, ir<%dec116>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN ir<%12> = load vp<%6>
    WIDEN ir<%or60111> = or ir<%12>, ir<%11>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx58>
    WIDEN store vp<%7>, ir<%or60111>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end81.loopexit122>, scalar.ph

ir-bb<if.end81.loopexit122>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %44 = load i8, ptr %arrayidx68, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %45 = load i8, ptr %arrayidx71, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %and73, ptr %arrayidx71, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %dec64119.in = phi %dec64119, %8, ir<-1>
    CLONE ir<%dec64119> = add ir<%dec64119.in>, ir<-1>
    CLONE ir<%arrayidx68> = getelementptr inbounds ir<%10>, ir<%dec64119>
    CLONE ir<%44> = load ir<%arrayidx68>
    CLONE ir<%not70> = xor ir<%44>, ir<-1>
    CLONE ir<%arrayidx71> = getelementptr inbounds ir<%bitmap>, ir<%dec64119>
    CLONE ir<%45> = load ir<%arrayidx71>
    CLONE ir<%and73> = and ir<%45>, ir<%not70>
    CLONE store ir<%and73>, ir<%arrayidx71>
    CLONE ir<%cmp65.not> = icmp eq ir<%dec64119>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.end81.loopexit>, scalar.ph

ir-bb<if.end81.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %dec64119.in = phi %dec64119, %8, ir<-1>
    CLONE ir<%dec64119> = add ir<%dec64119.in>, ir<-1>
    CLONE ir<%arrayidx68> = getelementptr inbounds ir<%10>, ir<%dec64119>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx68>
    WIDEN ir<%44> = load vp<%3>
    WIDEN ir<%not70> = xor ir<%44>, ir<-1>
    CLONE ir<%arrayidx71> = getelementptr inbounds ir<%bitmap>, ir<%dec64119>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN ir<%45> = load vp<%4>
    WIDEN ir<%and73> = and ir<%45>, ir<%not70>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN store vp<%5>, ir<%and73>
    CLONE ir<%cmp65.not> = icmp eq ir<%dec64119>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end81.loopexit>, scalar.ph

ir-bb<if.end81.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: set_opset_bits' from Opcode.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %dec64119.in = phi %dec64119, %8, ir<-1>
    CLONE ir<%dec64119> = add ir<%dec64119.in>, ir<-1>
    CLONE ir<%arrayidx68> = getelementptr inbounds ir<%10>, ir<%dec64119>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx68>
    WIDEN ir<%44> = load vp<%3>
    WIDEN ir<%not70> = xor ir<%44>, ir<-1>
    CLONE ir<%arrayidx71> = getelementptr inbounds ir<%bitmap>, ir<%dec64119>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN ir<%45> = load vp<%4>
    WIDEN ir<%and73> = and ir<%45>, ir<%not70>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN store vp<%5>, ir<%and73>
    CLONE ir<%cmp65.not> = icmp eq ir<%dec64119>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end81.loopexit>, scalar.ph

ir-bb<if.end81.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 16
B VF: 4, EstimatedWidthB: 4, CostB: 16
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width 16 costs: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 16
B VF: 8, EstimatedWidthB: 8, CostB: 16
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 256
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width 32 costs: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 39
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 39, CostB * EstimatedWidthA: 224
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 39
B VF: 16, EstimatedWidthB: 16, CostB: 16
CostA * EstimatedWidthB: 624, CostB * EstimatedWidthA: 512

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 1 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 14
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 16
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 16
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 64

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 16
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 128

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 112
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 16
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 256
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'set_opset_bits' from Opcode.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %dec64119.in = phi i64 [ %dec64119, %while.body67 ], [ %8, %while.body67.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec64119 = add i64 %dec64119.in, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx68 = getelementptr inbounds i8, ptr %10, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %44 = load i8, ptr %arrayidx68, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %not70 = xor i8 %44, -1 of type:xor
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx71 = getelementptr inbounds i8, ptr %bitmap, i64 %dec64119 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   %45 = load i8, ptr %arrayidx71, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %and73 = and i8 %45, %not70 of type:and
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %and73, ptr %arrayidx71, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp65.not = icmp eq i64 %dec64119, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp65.not, label %if.end81.loopexit, label %while.body67 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 224
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 15
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 240, CostB * EstimatedWidthA: 320
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: set_opset_bits at line: Opcode.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%8> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<%8> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%dec64119> = add vp<%4>, ir<-1>
    CLONE ir<%arrayidx68> = getelementptr inbounds ir<%10>, ir<%dec64119>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx68>
    WIDEN ir<%44> = load vp<%5>
    WIDEN ir<%not70> = xor ir<%44>, ir<-1>
    CLONE ir<%arrayidx71> = getelementptr inbounds ir<%bitmap>, ir<%dec64119>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN ir<%45> = load vp<%6>
    WIDEN ir<%and73> = and ir<%45>, ir<%not70>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx71>
    WIDEN store vp<%7>, ir<%and73>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<%8>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end81.loopexit>, scalar.ph

ir-bb<if.end81.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration    -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -fno-slp-vectorize  -mrvv-vector-bits=128  -mllvm -print-module-scope -mllvm -print-after=loop-vectorize -mllvm -filter-print-funcs=Perl_av_extend -fno-strict-aliasing  -fno-inline-functions  -DSPEC_CPU_LP64 -DSPEC_CPU_LINUX_X64 -std=gnu89        av.o deb.o doio.o doop.o dump.o globals.o gv.o hv.o locale.o mg.o numeric.o op.o pad.o perl.o perlapi.o perlio.o perlmain.o perly.o pp.o pp_ctl.o pp_hot.o pp_pack.o pp_sort.o pp_sys.o regcomp.o regexec.o run.o scope.o sv.o taint.o toke.o universal.o utf8.o util.o xsutils.o Base64.o Cwd.o Dumper.o HiRes.o IO.o Peek.o attrs.o poll.o stdio.o DynaLoader.o MD5.o Storable.o Parser.o specrand.o Hostname.o Opcode.o             -lm        -o perlbench
