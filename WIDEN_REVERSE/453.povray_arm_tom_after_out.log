/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o atmosph.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           atmosph.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o bbox.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           bbox.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o bcyl.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           bcyl.cpp
========== Loop: _ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx44> = getelementptr inbounds ir<%10>, ir<%indvars.iv>
    CLONE store ir<0>, ir<%arrayidx44>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv39>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit196>, scalar.ph

ir-bb<if.end.loopexit196>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%arrayidx44> = getelementptr inbounds ir<%10>, ir<%indvars.iv>
    REPLICATE store ir<0>, ir<%arrayidx44>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv39>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit196>, scalar.ph

ir-bb<if.end.loopexit196>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx44> = getelementptr inbounds ir<%10>, ir<%indvars.iv>
    REPLICATE store ir<0>, ir<%arrayidx44>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv39>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit196>, scalar.ph

ir-bb<if.end.loopexit196>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx44> = getelementptr inbounds ir<%10>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx44>, ir<0>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv39>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit196>, scalar.ph

ir-bb<if.end.loopexit196>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body41.lr.ph ], [ %indvars.iv.next, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx44 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %10, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx44, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv39 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit196, label %for.body41 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body41.lr.ph ], [ %indvars.iv.next, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx44 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %10, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 0, ptr %arrayidx44, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv39 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit196, label %for.body41 of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body41.lr.ph ], [ %indvars.iv.next, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx44 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %10, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 0, ptr %arrayidx44, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv39 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit196, label %for.body41 of type:br
LV: Vector loop of width 4 costs: 4

-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body41.lr.ph ], [ %indvars.iv.next, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx44 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %10, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx44, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv39 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit196, label %for.body41 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 131068

-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body41.lr.ph ], [ %indvars.iv.next, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx44 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %10, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx44, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv39 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit196, label %for.body41 of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 352225, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: 352225, RTCostB: 131068

-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body41.lr.ph ], [ %indvars.iv.next, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx44 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %10, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx44, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv39 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit196, label %for.body41 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 344008, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: 344008, RTCostB: 131068
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_ at line: bcyl.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx44> = getelementptr inbounds ir<%10>, vp<%4>
    CLONE store ir<0>, ir<%arrayidx44>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit196>, scalar.ph

ir-bb<if.end.loopexit196>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv186 = phi 0, %indvars.iv.next187, ir<1>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%16>, ir<%indvars.iv186>
    CLONE ir<%18> = load ir<%arrayidx21>
    CLONE ir<%19> = load ir<%arrayidx22>
    CLONE ir<%sub> = fsub ir<%18>, ir<%19>
    CLONE ir<%20> = load ir<%arrayidx17>
    CLONE ir<%div> = fdiv ir<%sub>, ir<%20>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>
    CLONE store ir<1>, ir<%arrayidx25>
    CLONE ir<%d29> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>, ir<1>
    CLONE store ir<%div>, ir<%d29>
    CLONE ir<%21> = call @llvm.fmuladd.f64(ir<%2>, ir<%div>, ir<%mul10>)
    CLONE ir<%22> = call @llvm.fmuladd.f64(ir<%div>, ir<%21>, ir<%6>)
    CLONE ir<%w> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>, ir<2>
    CLONE store ir<%22>, ir<%w>
    CLONE ir<%indvars.iv.next187> = add nuw nsw ir<%indvars.iv186>, ir<1>
    CLONE ir<%exitcond190.not> = icmp eq ir<%indvars.iv.next187>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv186 = phi 0, %indvars.iv.next187, ir<1>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%16>, ir<%indvars.iv186>
    vp<%4> = vector-pointer ir<%arrayidx21>
    WIDEN ir<%18> = load vp<%4>
    CLONE ir<%19> = load ir<%arrayidx22>
    WIDEN ir<%sub> = fsub ir<%18>, ir<%19>
    CLONE ir<%20> = load ir<%arrayidx17>
    WIDEN ir<%div> = fdiv ir<%sub>, ir<%20>
    REPLICATE ir<%arrayidx25> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>
    REPLICATE store ir<1>, ir<%arrayidx25>
    REPLICATE ir<%d29> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>, ir<1>
    REPLICATE store ir<%div>, ir<%d29>
    WIDEN-CALL ir<%21> = call @llvm.fmuladd.f64(ir<%2>, ir<%div>, ir<%mul10>) (using vector intrinsic)
    WIDEN-CALL ir<%22> = call @llvm.fmuladd.f64(ir<%div>, ir<%21>, ir<%6>) (using vector intrinsic)
    REPLICATE ir<%w> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>, ir<2>
    REPLICATE store ir<%22>, ir<%w>
    REPLICATE ir<%indvars.iv.next187> = add nuw nsw ir<%indvars.iv186>, ir<1>
    CLONE ir<%exitcond190.not> = icmp eq ir<%indvars.iv.next187>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv186 = phi 0, %indvars.iv.next187, ir<1>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%16>, ir<%indvars.iv186>
    vp<%4> = vector-pointer ir<%arrayidx21>
    WIDEN ir<%18> = load vp<%4>
    CLONE ir<%19> = load ir<%arrayidx22>
    WIDEN ir<%sub> = fsub ir<%18>, ir<%19>
    CLONE ir<%20> = load ir<%arrayidx17>
    WIDEN ir<%div> = fdiv ir<%sub>, ir<%20>
    WIDEN-GEP Inv[Var] ir<%arrayidx25> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>
    REPLICATE store ir<1>, ir<%arrayidx25>
    WIDEN-GEP Inv[Var][Inv] ir<%d29> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>, ir<1>
    REPLICATE store ir<%div>, ir<%d29>
    WIDEN-CALL ir<%21> = call @llvm.fmuladd.f64(ir<%2>, ir<%div>, ir<%mul10>) (using vector intrinsic)
    WIDEN-CALL ir<%22> = call @llvm.fmuladd.f64(ir<%div>, ir<%21>, ir<%6>) (using vector intrinsic)
    WIDEN-GEP Inv[Var][Inv] ir<%w> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>, ir<2>
    REPLICATE store ir<%22>, ir<%w>
    WIDEN ir<%indvars.iv.next187> = add nuw nsw ir<%indvars.iv186>, ir<1>
    CLONE ir<%exitcond190.not> = icmp eq ir<%indvars.iv.next187>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv186 = phi 0, %indvars.iv.next187, ir<1>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%16>, ir<%indvars.iv186>
    vp<%4> = vector-pointer ir<%arrayidx21>
    WIDEN ir<%18> = load vp<%4>
    CLONE ir<%19> = load ir<%arrayidx22>
    WIDEN ir<%sub> = fsub ir<%18>, ir<%19>
    CLONE ir<%20> = load ir<%arrayidx17>
    WIDEN ir<%div> = fdiv ir<%sub>, ir<%20>
    WIDEN-GEP Inv[Var] ir<%arrayidx25> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>
    WIDEN store ir<%arrayidx25>, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%d29> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>, ir<1>
    WIDEN store ir<%d29>, ir<%div>
    WIDEN-CALL ir<%21> = call @llvm.fmuladd.f64(ir<%2>, ir<%div>, ir<%mul10>) (using vector intrinsic)
    WIDEN-CALL ir<%22> = call @llvm.fmuladd.f64(ir<%div>, ir<%21>, ir<%6>) (using vector intrinsic)
    WIDEN-GEP Inv[Var][Inv] ir<%w> = getelementptr inbounds ir<%17>, ir<%indvars.iv186>, ir<2>
    WIDEN store ir<%w>, ir<%22>
    WIDEN ir<%indvars.iv.next187> = add nuw nsw ir<%indvars.iv186>, ir<1>
    CLONE ir<%exitcond190.not> = icmp eq ir<%indvars.iv.next187>, ir<%conv>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv186 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next187, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %16, i64 %indvars.iv186 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load double, ptr %arrayidx22, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = fsub double %18, %19 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   %20 = load double, ptr %arrayidx17, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv double %sub, %20 of type:fdiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx25 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %arrayidx25, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d29 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div, ptr %d29, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %2, double %div, double %mul10) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %div, double %21, double %6) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %w = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186, i32 2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %22, ptr %w, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next187 = add nuw nsw i64 %indvars.iv186, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond190.not = icmp eq i64 %indvars.iv.next187, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond190.not, label %if.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 19.
-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv186 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next187, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %16, i64 %indvars.iv186 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %19 = load double, ptr %arrayidx22, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = fsub double %18, %19 of type:fsub
LV: Found an estimated cost of 2 for VF 2 For instruction:   %20 = load double, ptr %arrayidx17, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv double %sub, %20 of type:fdiv
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx25 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 1, ptr %arrayidx25, align 8, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 2 For instruction:   store double %div, ptr %d29, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %2, double %div, double %mul10) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %div, double %21, double %6) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %w = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 20 for VF 2 For instruction:   store double %22, ptr %w, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next187 = add nuw nsw i64 %indvars.iv186, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond190.not = icmp eq i64 %indvars.iv.next187, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond190.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 20
A is not scalable.	B is not scalable.	
RTCostA: 655339, RTCostB: 622573
A is not scalable.	B is not scalable.	
RTCostA: 655339, RTCostB: 622573

-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv186 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next187, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %16, i64 %indvars.iv186 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %19 = load double, ptr %arrayidx22, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub = fsub double %18, %19 of type:fsub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %20 = load double, ptr %arrayidx17, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 4 for VF 4 For instruction:   %div = fdiv double %sub, %20 of type:fdiv
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx25 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 1, ptr %arrayidx25, align 8, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 4 For instruction:   store double %div, ptr %d29, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 4 for VF 4 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %2, double %div, double %mul10) of type:call
LV: Found an estimated cost of 4 for VF 4 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %div, double %21, double %6) of type:call
LV: Found an estimated cost of 0 for VF 4 For instruction:   %w = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 40 for VF 4 For instruction:   store double %22, ptr %w, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next187 = add nuw nsw i64 %indvars.iv186, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond190.not = icmp eq i64 %indvars.iv.next187, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond190.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 19
A is not scalable.	B is not scalable.	
RTCostA: 638955, RTCostB: 622573
A is not scalable.	B is not scalable.	
RTCostA: 638955, RTCostB: 622573

-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv186 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next187, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %16, i64 %indvars.iv186 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %19 = load double, ptr %arrayidx22, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = fsub double %18, %19 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %20 = load double, ptr %arrayidx17, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv double %sub, %20 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx25 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %arrayidx25, align 8, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store double %div, ptr %d29, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %2, double %div, double %mul10) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %div, double %21, double %6) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %w = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186, i32 2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %22, ptr %w, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next187 = add nuw nsw i64 %indvars.iv186, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond190.not = icmp eq i64 %indvars.iv.next187, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond190.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 622573
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 622573

-----------------Function that is being costed:'_ZN3povL24intersect_bound_elementsEPNS_11BCyl_StructEPdS2_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv186 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next187, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %16, i64 %indvars.iv186 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %18 = load double, ptr %arrayidx21, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %19 = load double, ptr %arrayidx22, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = fsub double %18, %19 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %20 = load double, ptr %arrayidx17, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv double %sub, %20 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx25 = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 1, ptr %arrayidx25, align 8, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store double %div, ptr %d29, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %2, double %div, double %mul10) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %div, double %21, double %6) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %w = getelementptr inbounds %"struct.pov::BCyl_Intersection_Struct", ptr %17, i64 %indvars.iv186, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   store double %22, ptr %w, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next187 = add nuw nsw i64 %indvars.iv186, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond190.not = icmp eq i64 %indvars.iv.next187, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond190.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 34
A is scalable.	B is not scalable.	
RTCostA: 1122224, RTCostB: 622573
A is scalable.	B is not scalable.	
RTCostA: 1122224, RTCostB: 622573
LV: Selecting VF: 1 With Cost: 19.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 0
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %31 = load double, ptr %arrayidx165, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %31, ptr %arrayidx168, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %31 = load double, ptr %arrayidx165, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %31, ptr %arrayidx168, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %31 = load double, ptr %arrayidx165, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %31, ptr %arrayidx168, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body163.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nh.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv379 = phi 0, %indvars.iv.next380, ir<1>
    CLONE ir<%arrayidx165> = getelementptr inbounds ir<%call45>, ir<%indvars.iv379>
    CLONE ir<%31> = load ir<%arrayidx165>
    CLONE ir<%arrayidx168> = getelementptr inbounds ir<%28>, ir<%indvars.iv379>
    CLONE store ir<%31>, ir<%arrayidx168>
    CLONE ir<%indvars.iv.next380> = add nuw nsw ir<%indvars.iv379>, ir<1>
    CLONE ir<%exitcond383.not> = icmp eq ir<%indvars.iv.next380>, ir<%wide.trip.count382>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end171.loopexit>, scalar.ph

ir-bb<for.end171.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body163.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nh.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv379 = phi 0, %indvars.iv.next380, ir<1>
    CLONE ir<%arrayidx165> = getelementptr inbounds ir<%call45>, ir<%indvars.iv379>
    vp<%4> = vector-pointer ir<%arrayidx165>
    WIDEN ir<%31> = load vp<%4>
    CLONE ir<%arrayidx168> = getelementptr inbounds ir<%28>, ir<%indvars.iv379>
    vp<%5> = vector-pointer ir<%arrayidx168>
    WIDEN store vp<%5>, ir<%31>
    CLONE ir<%indvars.iv.next380> = add nuw nsw ir<%indvars.iv379>, ir<1>
    CLONE ir<%exitcond383.not> = icmp eq ir<%indvars.iv.next380>, ir<%wide.trip.count382>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end171.loopexit>, scalar.ph

ir-bb<for.end171.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body163.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nh.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv379 = phi 0, %indvars.iv.next380, ir<1>
    CLONE ir<%arrayidx165> = getelementptr inbounds ir<%call45>, ir<%indvars.iv379>
    vp<%4> = vector-pointer ir<%arrayidx165>
    WIDEN ir<%31> = load vp<%4>
    CLONE ir<%arrayidx168> = getelementptr inbounds ir<%28>, ir<%indvars.iv379>
    vp<%5> = vector-pointer ir<%arrayidx168>
    WIDEN store vp<%5>, ir<%31>
    CLONE ir<%indvars.iv.next380> = add nuw nsw ir<%indvars.iv379>, ir<1>
    CLONE ir<%exitcond383.not> = icmp eq ir<%indvars.iv.next380>, ir<%wide.trip.count382>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end171.loopexit>, scalar.ph

ir-bb<for.end171.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv379 = phi i64 [ 0, %for.body163.lr.ph ], [ %indvars.iv.next380, %for.body163 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx165 = getelementptr inbounds double, ptr %call45, i64 %indvars.iv379 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %31 = load double, ptr %arrayidx165, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx168 = getelementptr inbounds double, ptr %28, i64 %indvars.iv379 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %31, ptr %arrayidx168, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next380 = add nuw nsw i64 %indvars.iv379, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next380, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond383.not, label %for.end171.loopexit, label %for.body163 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv379 = phi i64 [ 0, %for.body163.lr.ph ], [ %indvars.iv.next380, %for.body163 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx165 = getelementptr inbounds double, ptr %call45, i64 %indvars.iv379 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %31 = load double, ptr %arrayidx165, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx168 = getelementptr inbounds double, ptr %28, i64 %indvars.iv379 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %31, ptr %arrayidx168, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next380 = add nuw nsw i64 %indvars.iv379, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next380, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond383.not, label %for.end171.loopexit, label %for.body163 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv379 = phi i64 [ 0, %for.body163.lr.ph ], [ %indvars.iv.next380, %for.body163 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx165 = getelementptr inbounds double, ptr %call45, i64 %indvars.iv379 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %31 = load double, ptr %arrayidx165, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx168 = getelementptr inbounds double, ptr %28, i64 %indvars.iv379 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %31, ptr %arrayidx168, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next380 = add nuw nsw i64 %indvars.iv379, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next380, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond383.not, label %for.end171.loopexit, label %for.body163 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967298

-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv379 = phi i64 [ 0, %for.body163.lr.ph ], [ %indvars.iv.next380, %for.body163 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx165 = getelementptr inbounds double, ptr %call45, i64 %indvars.iv379 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %31 = load double, ptr %arrayidx165, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx168 = getelementptr inbounds double, ptr %28, i64 %indvars.iv379 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %31, ptr %arrayidx168, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next380 = add nuw nsw i64 %indvars.iv379, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond383.not = icmp eq i64 %indvars.iv.next380, %wide.trip.count382 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond383.not, label %for.end171.loopexit, label %for.body163 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov11Create_BCylEiPdS0_S0_S0_ at line: bcyl.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body163.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %nh.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx165> = getelementptr inbounds ir<%call45>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx165>
    WIDEN ir<%36> = load vp<%5>
    CLONE ir<%arrayidx168> = getelementptr inbounds ir<%28>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx168>
    WIDEN store vp<%6>, ir<%36>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end171.loopexit>, scalar.ph

ir-bb<for.end171.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body177.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %63 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv384 = phi 0, %indvars.iv.next385, ir<1>
    CLONE ir<%arrayidx179> = getelementptr inbounds ir<%call23>, ir<%indvars.iv384>
    CLONE ir<%65> = load ir<%arrayidx179>
    CLONE ir<%conv180> = trunc ir<%65>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>
    CLONE store ir<%conv180>, ir<%arrayidx183>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<%call27>, ir<%indvars.iv384>
    CLONE ir<%66> = load ir<%arrayidx185>
    CLONE ir<%conv186> = trunc ir<%66>
    CLONE ir<%r2> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<1>
    CLONE store ir<%conv186>, ir<%r2>
    CLONE ir<%arrayidx191> = getelementptr inbounds ir<%call31>, ir<%indvars.iv384>
    CLONE ir<%67> = load ir<%arrayidx191>
    CLONE ir<%conv192> = trunc ir<%67>
    CLONE ir<%h1> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<2>
    CLONE store ir<%conv192>, ir<%h1>
    CLONE ir<%arrayidx197> = getelementptr inbounds ir<%call35>, ir<%indvars.iv384>
    CLONE ir<%68> = load ir<%arrayidx197>
    CLONE ir<%conv198> = trunc ir<%68>
    CLONE ir<%h2> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<3>
    CLONE store ir<%conv198>, ir<%h2>
    CLONE ir<%indvars.iv.next385> = add nuw nsw ir<%indvars.iv384>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next385>, ir<%wide.trip.count387>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end204.loopexit>, scalar.ph

ir-bb<for.end204.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body177.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %63 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv384 = phi 0, %indvars.iv.next385, ir<1>
    CLONE ir<%arrayidx179> = getelementptr inbounds ir<%call23>, ir<%indvars.iv384>
    vp<%4> = vector-pointer ir<%arrayidx179>
    WIDEN ir<%65> = load vp<%4>
    WIDEN-CAST ir<%conv180> = trunc  ir<%65> to i16
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<%call27>, ir<%indvars.iv384>
    vp<%5> = vector-pointer ir<%arrayidx185>
    WIDEN ir<%66> = load vp<%5>
    WIDEN-CAST ir<%conv186> = trunc  ir<%66> to i16
    CLONE ir<%r2> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<1>
    CLONE ir<%arrayidx191> = getelementptr inbounds ir<%call31>, ir<%indvars.iv384>
    vp<%6> = vector-pointer ir<%arrayidx191>
    WIDEN ir<%67> = load vp<%6>
    WIDEN-CAST ir<%conv192> = trunc  ir<%67> to i16
    CLONE ir<%h1> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<2>
    CLONE ir<%arrayidx197> = getelementptr inbounds ir<%call35>, ir<%indvars.iv384>
    vp<%7> = vector-pointer ir<%arrayidx197>
    WIDEN ir<%68> = load vp<%7>
    WIDEN-CAST ir<%conv198> = trunc  ir<%68> to i16
    CLONE ir<%h2> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<3>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%h2>
      store ir<%conv180> to index 0
      store ir<%conv186> to index 1
      store ir<%conv192> to index 2
      store ir<%conv198> to index 3
    CLONE ir<%indvars.iv.next385> = add nuw nsw ir<%indvars.iv384>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next385>, ir<%wide.trip.count387>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end204.loopexit>, scalar.ph

ir-bb<for.end204.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body177.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %63 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv384 = phi 0, %indvars.iv.next385, ir<1>
    CLONE ir<%arrayidx179> = getelementptr inbounds ir<%call23>, ir<%indvars.iv384>
    vp<%4> = vector-pointer ir<%arrayidx179>
    WIDEN ir<%65> = load vp<%4>
    WIDEN-CAST ir<%conv180> = trunc  ir<%65> to i16
    WIDEN-GEP Inv[Var] ir<%arrayidx183> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>
    REPLICATE store ir<%conv180>, ir<%arrayidx183>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<%call27>, ir<%indvars.iv384>
    vp<%5> = vector-pointer ir<%arrayidx185>
    WIDEN ir<%66> = load vp<%5>
    WIDEN-CAST ir<%conv186> = trunc  ir<%66> to i16
    WIDEN-GEP Inv[Var][Inv] ir<%r2> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<1>
    REPLICATE store ir<%conv186>, ir<%r2>
    CLONE ir<%arrayidx191> = getelementptr inbounds ir<%call31>, ir<%indvars.iv384>
    vp<%6> = vector-pointer ir<%arrayidx191>
    WIDEN ir<%67> = load vp<%6>
    WIDEN-CAST ir<%conv192> = trunc  ir<%67> to i16
    WIDEN-GEP Inv[Var][Inv] ir<%h1> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<2>
    REPLICATE store ir<%conv192>, ir<%h1>
    CLONE ir<%arrayidx197> = getelementptr inbounds ir<%call35>, ir<%indvars.iv384>
    vp<%7> = vector-pointer ir<%arrayidx197>
    WIDEN ir<%68> = load vp<%7>
    WIDEN-CAST ir<%conv198> = trunc  ir<%68> to i16
    WIDEN-GEP Inv[Var][Inv] ir<%h2> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<3>
    REPLICATE store ir<%conv198>, ir<%h2>
    WIDEN ir<%indvars.iv.next385> = add nuw nsw ir<%indvars.iv384>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next385>, ir<%wide.trip.count387>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end204.loopexit>, scalar.ph

ir-bb<for.end204.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body177.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %63 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv384 = phi 0, %indvars.iv.next385, ir<1>
    CLONE ir<%arrayidx179> = getelementptr inbounds ir<%call23>, ir<%indvars.iv384>
    vp<%4> = vector-pointer ir<%arrayidx179>
    WIDEN ir<%65> = load vp<%4>
    WIDEN-CAST ir<%conv180> = trunc  ir<%65> to i16
    WIDEN-GEP Inv[Var] ir<%arrayidx183> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>
    WIDEN store ir<%arrayidx183>, ir<%conv180>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<%call27>, ir<%indvars.iv384>
    vp<%5> = vector-pointer ir<%arrayidx185>
    WIDEN ir<%66> = load vp<%5>
    WIDEN-CAST ir<%conv186> = trunc  ir<%66> to i16
    WIDEN-GEP Inv[Var][Inv] ir<%r2> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<1>
    WIDEN store ir<%r2>, ir<%conv186>
    CLONE ir<%arrayidx191> = getelementptr inbounds ir<%call31>, ir<%indvars.iv384>
    vp<%6> = vector-pointer ir<%arrayidx191>
    WIDEN ir<%67> = load vp<%6>
    WIDEN-CAST ir<%conv192> = trunc  ir<%67> to i16
    WIDEN-GEP Inv[Var][Inv] ir<%h1> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<2>
    WIDEN store ir<%h1>, ir<%conv192>
    CLONE ir<%arrayidx197> = getelementptr inbounds ir<%call35>, ir<%indvars.iv384>
    vp<%7> = vector-pointer ir<%arrayidx197>
    WIDEN ir<%68> = load vp<%7>
    WIDEN-CAST ir<%conv198> = trunc  ir<%68> to i16
    WIDEN-GEP Inv[Var][Inv] ir<%h2> = getelementptr inbounds ir<%64>, ir<%indvars.iv384>, ir<3>
    WIDEN store ir<%h2>, ir<%conv198>
    WIDEN ir<%indvars.iv.next385> = add nuw nsw ir<%indvars.iv384>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next385>, ir<%wide.trip.count387>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end204.loopexit>, scalar.ph

ir-bb<for.end204.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv384 = phi i64 [ 0, %for.body177.lr.ph ], [ %indvars.iv.next385, %for.body177 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx179 = getelementptr inbounds i32, ptr %call23, i64 %indvars.iv384 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv180 = trunc i32 %65 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx183 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv180, ptr %arrayidx183, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %call27, i64 %indvars.iv384 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv186 = trunc i32 %66 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r2 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv186, ptr %r2, align 2, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx191 = getelementptr inbounds i32, ptr %call31, i64 %indvars.iv384 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv192 = trunc i32 %67 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %h1 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384, i32 2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv192, ptr %h1, align 2, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx197 = getelementptr inbounds i32, ptr %call35, i64 %indvars.iv384 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv198 = trunc i32 %68 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %h2 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384, i32 3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv198, ptr %h2, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next385 = add nuw nsw i64 %indvars.iv384, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next385, %wide.trip.count387 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond388.not, label %for.end204.loopexit, label %for.body177 of type:br
LV: Scalar loop costs: 18.
-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv384 = phi i64 [ 0, %for.body177.lr.ph ], [ %indvars.iv.next385, %for.body177 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx179 = getelementptr inbounds i32, ptr %call23, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv180 = trunc i32 %65 to i16 of type:trunc
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i16 %conv180, ptr %arrayidx183, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %call27, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv186 = trunc i32 %66 to i16 of type:trunc
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i16 %conv186, ptr %r2, align 2, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx191 = getelementptr inbounds i32, ptr %call31, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv192 = trunc i32 %67 to i16 of type:trunc
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i16 %conv192, ptr %h1, align 2, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx197 = getelementptr inbounds i32, ptr %call35, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv198 = trunc i32 %68 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %h2 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384, i32 3 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 33 for VF 2 For instruction:   store i16 %conv198, ptr %h2, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next385 = add nuw nsw i64 %indvars.iv384, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next385, %wide.trip.count387 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond388.not, label %for.end204.loopexit, label %for.body177 of type:br
LV: Vector loop of width 2 costs: 19
A is not scalable.	B is not scalable.	
RTCostA: 41875931115, RTCostB: 38654705646
A is not scalable.	B is not scalable.	
RTCostA: 41875931115, RTCostB: 38654705646

-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv384 = phi i64 [ 0, %for.body177.lr.ph ], [ %indvars.iv.next385, %for.body177 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx179 = getelementptr inbounds i32, ptr %call23, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv180 = trunc i32 %65 to i16 of type:trunc
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i16 %conv180, ptr %arrayidx183, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %call27, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv186 = trunc i32 %66 to i16 of type:trunc
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i16 %conv186, ptr %r2, align 2, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx191 = getelementptr inbounds i32, ptr %call31, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv192 = trunc i32 %67 to i16 of type:trunc
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i16 %conv192, ptr %h1, align 2, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx197 = getelementptr inbounds i32, ptr %call35, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv198 = trunc i32 %68 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %h2 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384, i32 3 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i16 %conv198, ptr %h2, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next385 = add nuw nsw i64 %indvars.iv384, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next385, %wide.trip.count387 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond388.not, label %for.end204.loopexit, label %for.body177 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192808, RTCostB: 38654705646
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192808, RTCostB: 38654705646
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv384 = phi i64 [ 0, %for.body177.lr.ph ], [ %indvars.iv.next385, %for.body177 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx179 = getelementptr inbounds i32, ptr %call23, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv180 = trunc i32 %65 to i16 of type:trunc
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i16 %conv180, ptr %arrayidx183, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %call27, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv186 = trunc i32 %66 to i16 of type:trunc
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i16 %conv186, ptr %r2, align 2, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx191 = getelementptr inbounds i32, ptr %call31, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv192 = trunc i32 %67 to i16 of type:trunc
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i16 %conv192, ptr %h1, align 2, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx197 = getelementptr inbounds i32, ptr %call35, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv198 = trunc i32 %68 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %h2 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384, i32 3 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i16 %conv198, ptr %h2, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next385 = add nuw nsw i64 %indvars.iv384, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next385, %wide.trip.count387 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond388.not, label %for.end204.loopexit, label %for.body177 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4831838316, RTCostB: 38654705646
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4831838316, RTCostB: 7516192808
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv384 = phi i64 [ 0, %for.body177.lr.ph ], [ %indvars.iv.next385, %for.body177 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx179 = getelementptr inbounds i32, ptr %call23, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv180 = trunc i32 %65 to i16 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i16 %conv180, ptr %arrayidx183, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %call27, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv186 = trunc i32 %66 to i16 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i16 %conv186, ptr %r2, align 2, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx191 = getelementptr inbounds i32, ptr %call31, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv192 = trunc i32 %67 to i16 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i16 %conv192, ptr %h1, align 2, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx197 = getelementptr inbounds i32, ptr %call35, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv198 = trunc i32 %68 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %h2 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %conv198, ptr %h2, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next385 = add nuw nsw i64 %indvars.iv384, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next385, %wide.trip.count387 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond388.not, label %for.end204.loopexit, label %for.body177 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705646
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4831838316

-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv384 = phi i64 [ 0, %for.body177.lr.ph ], [ %indvars.iv.next385, %for.body177 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx179 = getelementptr inbounds i32, ptr %call23, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv180 = trunc i32 %65 to i16 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i16 %conv180, ptr %arrayidx183, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %call27, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv186 = trunc i32 %66 to i16 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i16 %conv186, ptr %r2, align 2, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx191 = getelementptr inbounds i32, ptr %call31, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv192 = trunc i32 %67 to i16 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i16 %conv192, ptr %h1, align 2, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx197 = getelementptr inbounds i32, ptr %call35, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv198 = trunc i32 %68 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %h2 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384, i32 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   store i16 %conv198, ptr %h2, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next385 = add nuw nsw i64 %indvars.iv384, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next385, %wide.trip.count387 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond388.not, label %for.end204.loopexit, label %for.body177 of type:br
LV: Vector loop of width vscale x 2 costs: 43
A is scalable.	B is not scalable.	
RTCostA: 93415538568, RTCostB: 38654705646
A is scalable.	B is not scalable.	
RTCostA: 93415538568, RTCostB: 4831838316

-----------------Function that is being costed:'_ZN3pov11Create_BCylEiPdS0_S0_S0_' from bcyl.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv384 = phi i64 [ 0, %for.body177.lr.ph ], [ %indvars.iv.next385, %for.body177 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx179 = getelementptr inbounds i32, ptr %call23, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %65 = load i32, ptr %arrayidx179, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv180 = trunc i32 %65 to i16 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i16 %conv180, ptr %arrayidx183, align 2, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %call27, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %66 = load i32, ptr %arrayidx185, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv186 = trunc i32 %66 to i16 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i16 %conv186, ptr %r2, align 2, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx191 = getelementptr inbounds i32, ptr %call31, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %67 = load i32, ptr %arrayidx191, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv192 = trunc i32 %67 to i16 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i16 %conv192, ptr %h1, align 2, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx197 = getelementptr inbounds i32, ptr %call35, i64 %indvars.iv384 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %68 = load i32, ptr %arrayidx197, align 4, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv198 = trunc i32 %68 to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %h2 = getelementptr inbounds %"struct.pov::BCyl_Entry_Struct", ptr %64, i64 %indvars.iv384, i32 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 324 for VF vscale x 4 For instruction:   store i16 %conv198, ptr %h2, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next385 = add nuw nsw i64 %indvars.iv384, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next385, %wide.trip.count387 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond388.not, label %for.end204.loopexit, label %for.body177 of type:br
LV: Vector loop of width vscale x 4 costs: 41
A is scalable.	B is not scalable.	
RTCostA: 89925877551, RTCostB: 38654705646
A is scalable.	B is not scalable.	
RTCostA: 89925877551, RTCostB: 4831838316
LV: Selecting VF: 8 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=8, UF=1 at function: _ZN3pov11Create_BCylEiPdS0_S0_S0_ at line: bcyl.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body177.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %63 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx179> = getelementptr inbounds ir<%call23>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx179>
    WIDEN ir<%65> = load vp<%5>
    WIDEN-CAST ir<%conv180> = trunc  ir<%65> to i16
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<%call27>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx185>
    WIDEN ir<%66> = load vp<%6>
    WIDEN-CAST ir<%conv186> = trunc  ir<%66> to i16
    CLONE ir<%arrayidx191> = getelementptr inbounds ir<%call31>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx191>
    WIDEN ir<%67> = load vp<%7>
    WIDEN-CAST ir<%conv192> = trunc  ir<%67> to i16
    CLONE ir<%arrayidx197> = getelementptr inbounds ir<%call35>, vp<%4>
    vp<%8> = vector-pointer ir<%arrayidx197>
    WIDEN ir<%68> = load vp<%8>
    WIDEN-CAST ir<%conv198> = trunc  ir<%68> to i16
    CLONE ir<%h2> = getelementptr inbounds ir<%64>, vp<%4>, ir<3>
    INTERLEAVE-GROUP with factor 4 at <badref>, ir<%h2>
      store ir<%conv180> to index 0
      store ir<%conv186> to index 1
      store ir<%conv192> to index 2
      store ir<%conv198> to index 3
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end204.loopexit>, scalar.ph

ir-bb<for.end204.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o bezier.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           bezier.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o blob.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           blob.cpp
========== Loop: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%bound24> = getelementptr inbounds ir<%4>, ir<%indvars.iv>, ir<1>
    CLONE ir<%7> = load ir<%bound24>
    CLONE ir<%sub> = fsub ir<%7>, ir<%start_dist.0>
    CLONE store ir<%sub>, ir<%bound24>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%bound24> = getelementptr inbounds ir<%4>, ir<%indvars.iv>, ir<1>
    INTERLEAVE-GROUP with factor 3 at %7, ir<%bound24>
      ir<%7> = load from index 0
    WIDEN ir<%sub> = fsub ir<%7>, ir<%start_dist.0>
    REPLICATE store ir<%sub>, ir<%bound24>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%bound24> = getelementptr inbounds ir<%4>, ir<%indvars.iv>, ir<1>
    REPLICATE ir<%7> = load ir<%bound24>
    WIDEN ir<%sub> = fsub ir<%7>, ir<%start_dist.0>
    REPLICATE store ir<%sub>, ir<%bound24>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%bound24> = getelementptr inbounds ir<%4>, ir<%indvars.iv>, ir<1>
    WIDEN ir<%7> = load ir<%bound24>
    WIDEN ir<%sub> = fsub ir<%7>, ir<%start_dist.0>
    WIDEN store ir<%bound24>, ir<%sub>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bound24 = getelementptr inbounds %"struct.pov::Blob_Interval_Struct", ptr %4, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load double, ptr %bound24, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = fsub double %7, %start_dist.0 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub, ptr %bound24, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bound24 = getelementptr inbounds %"struct.pov::Blob_Interval_Struct", ptr %4, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   %7 = load double, ptr %bound24, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = fsub double %7, %start_dist.0 of type:fsub
LV: Decision: Scalarize
LV: Found an estimated cost of 10 for VF 2 For instruction:   store double %sub, ptr %bound24, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 17179869175, RTCostB: 15032385529
A is not scalable.	B is not scalable.	
RTCostA: 17179869175, RTCostB: 15032385529

-----------------Function that is being costed:'_ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bound24 = getelementptr inbounds %"struct.pov::Blob_Interval_Struct", ptr %4, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load double, ptr %bound24, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = fsub double %7, %start_dist.0 of type:fsub
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %sub, ptr %bound24, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529

-----------------Function that is being costed:'_ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bound24 = getelementptr inbounds %"struct.pov::Blob_Interval_Struct", ptr %4, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %7 = load double, ptr %bound24, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = fsub double %7, %start_dist.0 of type:fsub
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double %sub, ptr %bound24, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 45634027456, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: 45634027456, RTCostB: 15032385529
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE at line: blob.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%bound24> = getelementptr inbounds ir<%4>, vp<%4>, ir<1>
    CLONE ir<%7> = load ir<%bound24>
    CLONE ir<%sub> = fsub ir<%7>, ir<%start_dist.0>
    CLONE store ir<%sub>, ir<%bound24>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body49.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv745 = phi 0, %indvars.iv.next746, ir<1>
    CLONE ir<%bound52> = getelementptr inbounds ir<%4>, ir<%indvars.iv745>, ir<1>
    CLONE ir<%19> = load ir<%bound52>
    CLONE ir<%div> = fdiv ir<%19>, ir<%max_bound.0.lcssa>
    CLONE store ir<%div>, ir<%bound52>
    CLONE ir<%indvars.iv.next746> = add nuw nsw ir<%indvars.iv745>, ir<1>
    CLONE ir<%exitcond749.not> = icmp eq ir<%indvars.iv.next746>, ir<%wide.trip.count748>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end57.loopexit>, scalar.ph

ir-bb<if.end57.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body49.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv745 = phi 0, %indvars.iv.next746, ir<1>
    REPLICATE ir<%bound52> = getelementptr inbounds ir<%4>, ir<%indvars.iv745>, ir<1>
    INTERLEAVE-GROUP with factor 3 at %19, ir<%bound52>
      ir<%19> = load from index 0
    WIDEN ir<%div> = fdiv ir<%19>, ir<%max_bound.0.lcssa>
    REPLICATE store ir<%div>, ir<%bound52>
    REPLICATE ir<%indvars.iv.next746> = add nuw nsw ir<%indvars.iv745>, ir<1>
    CLONE ir<%exitcond749.not> = icmp eq ir<%indvars.iv.next746>, ir<%wide.trip.count748>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body49.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv745 = phi 0, %indvars.iv.next746, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%bound52> = getelementptr inbounds ir<%4>, ir<%indvars.iv745>, ir<1>
    REPLICATE ir<%19> = load ir<%bound52>
    WIDEN ir<%div> = fdiv ir<%19>, ir<%max_bound.0.lcssa>
    REPLICATE store ir<%div>, ir<%bound52>
    WIDEN ir<%indvars.iv.next746> = add nuw nsw ir<%indvars.iv745>, ir<1>
    CLONE ir<%exitcond749.not> = icmp eq ir<%indvars.iv.next746>, ir<%wide.trip.count748>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body49.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv745 = phi 0, %indvars.iv.next746, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%bound52> = getelementptr inbounds ir<%4>, ir<%indvars.iv745>, ir<1>
    WIDEN ir<%19> = load ir<%bound52>
    WIDEN ir<%div> = fdiv ir<%19>, ir<%max_bound.0.lcssa>
    WIDEN store ir<%bound52>, ir<%div>
    WIDEN ir<%indvars.iv.next746> = add nuw nsw ir<%indvars.iv745>, ir<1>
    CLONE ir<%exitcond749.not> = icmp eq ir<%indvars.iv.next746>, ir<%wide.trip.count748>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body49.preheader ], [ %indvars.iv.next746, %for.body49 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bound52 = getelementptr inbounds %"struct.pov::Blob_Interval_Struct", ptr %4, i64 %indvars.iv745, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load double, ptr %bound52, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv double %19, %max_bound.0.lcssa of type:fdiv
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div, ptr %bound52, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond749.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count748 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond749.not, label %if.end57.loopexit, label %for.body49 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'_ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body49.preheader ], [ %indvars.iv.next746, %for.body49 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bound52 = getelementptr inbounds %"struct.pov::Blob_Interval_Struct", ptr %4, i64 %indvars.iv745, i32 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   %19 = load double, ptr %bound52, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv double %19, %max_bound.0.lcssa of type:fdiv
LV: Decision: Scalarize
LV: Found an estimated cost of 10 for VF 2 For instruction:   store double %div, ptr %bound52, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond749.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count748 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond749.not, label %if.end57.loopexit, label %for.body49 of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 18253610999, RTCostB: 17179869176
A is not scalable.	B is not scalable.	
RTCostA: 18253610999, RTCostB: 17179869176

-----------------Function that is being costed:'_ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body49.preheader ], [ %indvars.iv.next746, %for.body49 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bound52 = getelementptr inbounds %"struct.pov::Blob_Interval_Struct", ptr %4, i64 %indvars.iv745, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %19 = load double, ptr %bound52, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv double %19, %max_bound.0.lcssa of type:fdiv
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %div, ptr %bound52, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond749.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count748 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond749.not, label %if.end57.loopexit, label %for.body49 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176

-----------------Function that is being costed:'_ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body49.preheader ], [ %indvars.iv.next746, %for.body49 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bound52 = getelementptr inbounds %"struct.pov::Blob_Interval_Struct", ptr %4, i64 %indvars.iv745, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %19 = load double, ptr %bound52, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv double %19, %max_bound.0.lcssa of type:fdiv
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double %div, ptr %bound52, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond749.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count748 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond749.not, label %if.end57.loopexit, label %for.body49 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 46170898370, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 46170898370, RTCostB: 17179869176
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL22All_Blob_IntersectionsEPNS_13Object_StructEPNS_10Ray_StructEPNS_13istack_structE at line: blob.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body49.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%bound52> = getelementptr inbounds ir<%4>, vp<%4>, ir<1>
    CLONE ir<%19> = load ir<%bound52>
    CLONE ir<%div> = fdiv ir<%19>, ir<%max_bound.0.lcssa>
    CLONE store ir<%div>, ir<%bound52>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end57.loopexit>, scalar.ph

ir-bb<if.end57.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body99.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %count.0190 to i64) + (zext i32 %count.1.v to i64))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%21>, ir<1>
    CLONE ir<%index> = getelementptr inbounds ir<%7>, ir<%indvars.iv>, ir<1>
    CLONE store ir<%21>, ir<%index>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond200.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end105.loopexit>, scalar.ph

ir-bb<for.end105.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body99.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %count.0190 to i64) + (zext i32 %count.1.v to i64))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%21>, ir<1>
    REPLICATE ir<%index> = getelementptr inbounds ir<%7>, ir<%indvars.iv>, ir<1>
    REPLICATE store ir<%21>, ir<%index>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond200.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end105.loopexit>, scalar.ph

ir-bb<for.end105.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body99.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %count.0190 to i64) + (zext i32 %count.1.v to i64))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%21>, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%index> = getelementptr inbounds ir<%7>, ir<%indvars.iv>, ir<1>
    REPLICATE store ir<%21>, ir<%index>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond200.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end105.loopexit>, scalar.ph

ir-bb<for.end105.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body99.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %count.0190 to i64) + (zext i32 %count.1.v to i64))<nuw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%21>, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%index> = getelementptr inbounds ir<%7>, ir<%indvars.iv>, ir<1>
    WIDEN store ir<%index>, ir<%21>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond200.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end105.loopexit>, scalar.ph

ir-bb<for.end105.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body99.lr.ph ], [ %indvars.iv.next, %for.body99 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %index = getelementptr inbounds %"struct.pov::Blob_Element_Struct", ptr %7, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %21 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %21, ptr %index, align 4, !tbaa !34 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond200.not, label %for.end105.loopexit, label %for.body99 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body99.lr.ph ], [ %indvars.iv.next, %for.body99 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %index = getelementptr inbounds %"struct.pov::Blob_Element_Struct", ptr %7, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %21 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i32 %21, ptr %index, align 4, !tbaa !34 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond200.not, label %for.end105.loopexit, label %for.body99 of type:br
LV: Vector loop of width 2 costs: 16

-----------------Function that is being costed:'_ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body99.lr.ph ], [ %indvars.iv.next, %for.body99 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %index = getelementptr inbounds %"struct.pov::Blob_Element_Struct", ptr %7, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %21 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i32 %21, ptr %index, align 4, !tbaa !34 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond200.not, label %for.end105.loopexit, label %for.body99 of type:br
LV: Vector loop of width 4 costs: 15

-----------------Function that is being costed:'_ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body99.lr.ph ], [ %indvars.iv.next, %for.body99 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %index = getelementptr inbounds %"struct.pov::Blob_Element_Struct", ptr %7, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %21 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %21, ptr %index, align 4, !tbaa !34 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond200.not, label %for.end105.loopexit, label %for.body99 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934600
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934600

-----------------Function that is being costed:'_ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body99.lr.ph ], [ %indvars.iv.next, %for.body99 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %index = getelementptr inbounds %"struct.pov::Blob_Element_Struct", ptr %7, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %21 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %21, ptr %index, align 4, !tbaa !34 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond200.not, label %for.end105.loopexit, label %for.body99 of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449224, RTCostB: 8589934600
A is scalable.	B is not scalable.	
RTCostA: 23085449224, RTCostB: 8589934600

-----------------Function that is being costed:'_ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body99.lr.ph ], [ %indvars.iv.next, %for.body99 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %index = getelementptr inbounds %"struct.pov::Blob_Element_Struct", ptr %7, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %21 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %21, ptr %index, align 4, !tbaa !34 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond200.not, label %for.end105.loopexit, label %for.body99 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 22548578312, RTCostB: 8589934600
A is scalable.	B is not scalable.	
RTCostA: 22548578312, RTCostB: 8589934600
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3pov9Make_BlobEPNS_11Blob_StructEdPNS_16Blob_List_StructEi at line: blob.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body99.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %count.0190 to i64) + (zext i32 %count.1.v to i64))<nuw>
No successors

vector.ph:
  SCALAR-CAST vp<%3> = trunc ir<1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    SCALAR-CAST vp<%6> = trunc vp<%4> to i32
    vp<%7> = SCALAR-STEPS vp<%6>, vp<%3>
    CLONE ir<%index> = getelementptr inbounds ir<%7>, vp<%5>, ir<1>
    CLONE store vp<%7>, ir<%index>
    EMIT vp<%8> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end105.loopexit>, scalar.ph

ir-bb<for.end105.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %36 = load double, ptr %arrayidx65, align 8, !tbaa !30 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load double, ptr %arrayidx65, align 8, !tbaa !30 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %36 = load double, ptr %arrayidx65, align 8, !tbaa !30 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond61.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %34 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv140 = phi 0, %indvars.iv.next141, ir<1>
    WIDEN-REDUCTION-PHI ir<%sum.0131> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx65> = getelementptr inbounds ir<%35>, ir<%indvars.iv140>
    CLONE ir<%36> = load ir<%arrayidx65>
    CLONE ir<%add> = fadd ir<%sum.0131>, ir<%36>
    CLONE ir<%indvars.iv.next141> = add nuw nsw ir<%indvars.iv140>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next141>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%sum.0131> + reduce.fadd (ir<%36>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%sum.0131>, ir<%add>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end68>, scalar.ph

ir-bb<for.end68>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%6>
}

========== Loop: _ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond61.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %34 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv140 = phi 0, %indvars.iv.next141, ir<1>
    WIDEN-REDUCTION-PHI ir<%sum.0131> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx65> = getelementptr inbounds ir<%35>, ir<%indvars.iv140>
    vp<%4> = vector-pointer ir<%arrayidx65>
    WIDEN ir<%36> = load vp<%4>
    WIDEN ir<%add> = fadd ir<%sum.0131>, ir<%36>
    CLONE ir<%indvars.iv.next141> = add nuw nsw ir<%indvars.iv140>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next141>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%sum.0131> + reduce.fadd (ir<%36>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.0131>, ir<%add>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end68>, scalar.ph

ir-bb<for.end68>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%7>
}

========== Loop: _ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond61.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %34 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv140 = phi 0, %indvars.iv.next141, ir<1>
    WIDEN-REDUCTION-PHI ir<%sum.0131> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx65> = getelementptr inbounds ir<%35>, ir<%indvars.iv140>
    vp<%4> = vector-pointer ir<%arrayidx65>
    WIDEN ir<%36> = load vp<%4>
    WIDEN ir<%add> = fadd ir<%sum.0131>, ir<%36>
    CLONE ir<%indvars.iv.next141> = add nuw nsw ir<%indvars.iv140>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next141>, ir<%wide.trip.count>
    REDUCE ir<%add>.1 = ir<%sum.0131> + reduce.fadd (ir<%36>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%sum.0131>, ir<%add>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end68>, scalar.ph

ir-bb<for.end68>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%7>
}


-----------------Function that is being costed:'_ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv140 = phi i64 [ 0, %for.cond61.preheader ], [ %indvars.iv.next141, %for.body63 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum.0131 = phi double [ 0.000000e+00, %for.cond61.preheader ], [ %add, %for.body63 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx65 = getelementptr inbounds double, ptr %35, i64 %indvars.iv140 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %36 = load double, ptr %arrayidx65, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = fadd double %sum.0131, %36 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next141 = add nuw nsw i64 %indvars.iv140, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next141, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end68, label %for.body63 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'_ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv140 = phi i64 [ 0, %for.cond61.preheader ], [ %indvars.iv.next141, %for.body63 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sum.0131 = phi double [ 0.000000e+00, %for.cond61.preheader ], [ %add, %for.body63 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx65 = getelementptr inbounds double, ptr %35, i64 %indvars.iv140 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %36 = load double, ptr %arrayidx65, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add = fadd double %sum.0131, %36 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next141 = add nuw nsw i64 %indvars.iv140, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next141, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end68, label %for.body63 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676412, RTCostB: 10737418235
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676412, RTCostB: 10737418235
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv140 = phi i64 [ 0, %for.cond61.preheader ], [ %indvars.iv.next141, %for.body63 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sum.0131 = phi double [ 0.000000e+00, %for.cond61.preheader ], [ %add, %for.body63 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx65 = getelementptr inbounds double, ptr %35, i64 %indvars.iv140 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %36 = load double, ptr %arrayidx65, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = fadd double %sum.0131, %36 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next141 = add nuw nsw i64 %indvars.iv140, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next141, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end68, label %for.body63 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 9663676412

-----------------Function that is being costed:'_ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv140 = phi i64 [ 0, %for.cond61.preheader ], [ %indvars.iv.next141, %for.body63 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sum.0131 = phi double [ 0.000000e+00, %for.cond61.preheader ], [ %add, %for.body63 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx65 = getelementptr inbounds double, ptr %35, i64 %indvars.iv140 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %36 = load double, ptr %arrayidx65, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add = fadd double %sum.0131, %36 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next141 = add nuw nsw i64 %indvars.iv140, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next141, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end68, label %for.body63 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096392, RTCostB: 10737418235
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096392, RTCostB: 9663676412
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_ at line: blob.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond61.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %34 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%sum.0131> = phi ir<0.000000e+00>, ir<%add>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx65> = getelementptr inbounds ir<%35>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx65>
    WIDEN ir<%36> = load vp<%5>
    REDUCE ir<%add> = ir<%sum.0131> + reduce.fadd (ir<%36>)
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%sum.0131>, ir<%add>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end68>, scalar.ph

ir-bb<for.end68>:
No successors

scalar.ph:
No successors

Live-out double %add.lcssa = vp<%8>
}
================ Final VPlan ================

@@ Instruction =>  %58 = load double, ptr %arrayidx75, align 8, !tbaa !30 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx75, align 8, !tbaa !30 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load double, ptr %arrayidx75, align 8, !tbaa !30 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %mul, ptr %arrayidx75, align 8, !tbaa !30 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %58 = load double, ptr %arrayidx75, align 8, !tbaa !30 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx75, align 8, !tbaa !30 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body73.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %34 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv143 = phi 0, %indvars.iv.next144, ir<1>
    CLONE ir<%arrayidx75> = getelementptr inbounds ir<%35>, ir<%indvars.iv143>
    CLONE ir<%58> = load ir<%arrayidx75>
    CLONE ir<%mul> = fmul ir<%div>, ir<%58>
    CLONE store ir<%mul>, ir<%arrayidx75>
    CLONE ir<%indvars.iv.next144> = add nuw nsw ir<%indvars.iv143>, ir<1>
    CLONE ir<%exitcond147.not> = icmp eq ir<%indvars.iv.next144>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end80.loopexit>, scalar.ph

ir-bb<if.end80.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body73.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %34 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv143 = phi 0, %indvars.iv.next144, ir<1>
    CLONE ir<%arrayidx75> = getelementptr inbounds ir<%35>, ir<%indvars.iv143>
    vp<%4> = vector-pointer ir<%arrayidx75>
    WIDEN ir<%58> = load vp<%4>
    WIDEN ir<%mul> = fmul ir<%div>, ir<%58>
    vp<%5> = vector-pointer ir<%arrayidx75>
    WIDEN store vp<%5>, ir<%mul>
    CLONE ir<%indvars.iv.next144> = add nuw nsw ir<%indvars.iv143>, ir<1>
    CLONE ir<%exitcond147.not> = icmp eq ir<%indvars.iv.next144>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end80.loopexit>, scalar.ph

ir-bb<if.end80.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body73.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %34 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv143 = phi 0, %indvars.iv.next144, ir<1>
    CLONE ir<%arrayidx75> = getelementptr inbounds ir<%35>, ir<%indvars.iv143>
    vp<%4> = vector-pointer ir<%arrayidx75>
    WIDEN ir<%58> = load vp<%4>
    WIDEN ir<%mul> = fmul ir<%div>, ir<%58>
    vp<%5> = vector-pointer ir<%arrayidx75>
    WIDEN store vp<%5>, ir<%mul>
    CLONE ir<%indvars.iv.next144> = add nuw nsw ir<%indvars.iv143>, ir<1>
    CLONE ir<%exitcond147.not> = icmp eq ir<%indvars.iv.next144>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end80.loopexit>, scalar.ph

ir-bb<if.end80.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv143 = phi i64 [ 0, %for.body73.lr.ph ], [ %indvars.iv.next144, %for.body73 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx75 = getelementptr inbounds double, ptr %35, i64 %indvars.iv143 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %58 = load double, ptr %arrayidx75, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul double %div, %58 of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul, ptr %arrayidx75, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next144 = add nuw nsw i64 %indvars.iv143, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond147.not = icmp eq i64 %indvars.iv.next144, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond147.not, label %if.end80.loopexit, label %for.body73 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'_ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv143 = phi i64 [ 0, %for.body73.lr.ph ], [ %indvars.iv.next144, %for.body73 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx75 = getelementptr inbounds double, ptr %35, i64 %indvars.iv143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %58 = load double, ptr %arrayidx75, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul double %div, %58 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %mul, ptr %arrayidx75, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next144 = add nuw nsw i64 %indvars.iv143, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond147.not = icmp eq i64 %indvars.iv.next144, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond147.not, label %if.end80.loopexit, label %for.body73 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450946, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv143 = phi i64 [ 0, %for.body73.lr.ph ], [ %indvars.iv.next144, %for.body73 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx75 = getelementptr inbounds double, ptr %35, i64 %indvars.iv143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %58 = load double, ptr %arrayidx75, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul double %div, %58 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul, ptr %arrayidx75, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next144 = add nuw nsw i64 %indvars.iv143, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond147.not = icmp eq i64 %indvars.iv.next144, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond147.not, label %if.end80.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450946

-----------------Function that is being costed:'_ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_' from blob.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv143 = phi i64 [ 0, %for.body73.lr.ph ], [ %indvars.iv.next144, %for.body73 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx75 = getelementptr inbounds double, ptr %35, i64 %indvars.iv143 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %58 = load double, ptr %arrayidx75, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul double %div, %58 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %mul, ptr %arrayidx75, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next144 = add nuw nsw i64 %indvars.iv143, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond147.not = icmp eq i64 %indvars.iv.next144, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond147.not, label %if.end80.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 6442450946
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov23Determine_Blob_TexturesEPNS_11Blob_StructEPdPiPPNS_14Texture_StructES2_ at line: blob.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body73.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %34 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx75> = getelementptr inbounds ir<%35>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx75>
    WIDEN ir<%58> = load vp<%5>
    WIDEN ir<%mul> = fmul ir<%div>, ir<%58>
    vp<%6> = vector-pointer ir<%arrayidx75>
    WIDEN store vp<%6>, ir<%mul>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end80.loopexit>, scalar.ph

ir-bb<if.end80.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 20
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o boxes.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           boxes.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o bsphere.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           bsphere.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o camera.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           camera.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o chi2.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           chi2.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o colour.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           colour.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o colutils.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           colutils.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o cones.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           cones.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o csg.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           csg.cpp
@@ Instruction =>  store double %div, ptr %arrayidx, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %div, ptr %arrayidx, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %div, ptr %arrayidx, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov22Determine_CSG_TexturesEPNS_10CSG_StructEPdPiPPNS_14Texture_StructES2_' from csg.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    CLONE store ir<%div>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Determine_CSG_TexturesEPNS_10CSG_StructEPdPiPPNS_14Texture_StructES2_' from csg.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%div>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Determine_CSG_TexturesEPNS_10CSG_StructEPdPiPPNS_14Texture_StructES2_' from csg.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%div>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov22Determine_CSG_TexturesEPNS_10CSG_StructEPdPiPPNS_14Texture_StructES2_' from csg.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3pov22Determine_CSG_TexturesEPNS_10CSG_StructEPdPiPPNS_14Texture_StructES2_' from csg.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %div, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov22Determine_CSG_TexturesEPNS_10CSG_StructEPdPiPPNS_14Texture_StructES2_' from csg.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %div, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225473

-----------------Function that is being costed:'_ZN3pov22Determine_CSG_TexturesEPNS_10CSG_StructEPdPiPPNS_14Texture_StructES2_' from csg.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %div, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov22Determine_CSG_TexturesEPNS_10CSG_StructEPdPiPPNS_14Texture_StructES2_ at line: csg.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%div>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 18
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o defaultplatformbase.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           defaultplatformbase.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o defaultrenderfrontend.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           defaultrenderfrontend.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o discs.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           discs.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o express.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           express.cpp
@@ Instruction =>  %128 = load double, ptr %arrayidx601, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %cond604, ptr %arrayidx601, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %128 = load double, ptr %arrayidx601, align 8, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %cond604, ptr %arrayidx601, align 8, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %128 = load double, ptr %arrayidx601, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %cond604, ptr %arrayidx601, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body599.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %127 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx601> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    CLONE ir<%128> = load ir<%arrayidx601>
    CLONE ir<%129> = call @llvm.fabs.f64(ir<%128>)
    CLONE ir<%cmp602> = fcmp ogt ir<%129>, ir<0x3E7AD7F29ABCAF48>
    CLONE ir<%cond604> = select ir<%cmp602>, ir<0.000000e+00>, ir<1.000000e+00>
    CLONE store ir<%cond604>, ir<%arrayidx601>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end663.loopexit988>, scalar.ph

ir-bb<while.end663.loopexit988>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body599.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %127 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx601> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx601>
    WIDEN ir<%128> = load vp<%4>
    WIDEN-CALL ir<%129> = call @llvm.fabs.f64(ir<%128>) (using vector intrinsic)
    WIDEN ir<%cmp602> = fcmp ogt ir<%129>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-SELECT ir<%cond604> = select ir<%cmp602>, ir<0.000000e+00>, ir<1.000000e+00>
    vp<%5> = vector-pointer ir<%arrayidx601>
    WIDEN store vp<%5>, ir<%cond604>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end663.loopexit988>, scalar.ph

ir-bb<while.end663.loopexit988>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body599.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %127 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx601> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx601>
    WIDEN ir<%128> = load vp<%4>
    WIDEN-CALL ir<%129> = call @llvm.fabs.f64(ir<%128>) (using vector intrinsic)
    WIDEN ir<%cmp602> = fcmp ogt ir<%129>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-SELECT ir<%cond604> = select ir<%cmp602>, ir<0.000000e+00>, ir<1.000000e+00>
    vp<%5> = vector-pointer ir<%arrayidx601>
    WIDEN store vp<%5>, ir<%cond604>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end663.loopexit988>, scalar.ph

ir-bb<while.end663.loopexit988>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body599.preheader ], [ %indvars.iv.next, %for.body599 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx601 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %128 = load double, ptr %arrayidx601, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %129 = call double @llvm.fabs.f64(double %128) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp602 = fcmp ogt double %129, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cond604 = select i1 %cmp602, double 0.000000e+00, double 1.000000e+00 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %cond604, ptr %arrayidx601, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %while.end663.loopexit988, label %for.body599 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body599.preheader ], [ %indvars.iv.next, %for.body599 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx601 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %128 = load double, ptr %arrayidx601, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %129 = call double @llvm.fabs.f64(double %128) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp602 = fcmp ogt double %129, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cond604 = select i1 %cmp602, double 0.000000e+00, double 1.000000e+00 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %cond604, ptr %arrayidx601, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %while.end663.loopexit988, label %for.body599 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192770, RTCostB: 19327352823
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192770, RTCostB: 19327352823
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body599.preheader ], [ %indvars.iv.next, %for.body599 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx601 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %128 = load double, ptr %arrayidx601, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %129 = call double @llvm.fabs.f64(double %128) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp602 = fcmp ogt double %129, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cond604 = select i1 %cmp602, double 0.000000e+00, double 1.000000e+00 of type:select
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %cond604, ptr %arrayidx601, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %while.end663.loopexit988, label %for.body599 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192770

-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body599.preheader ], [ %indvars.iv.next, %for.body599 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx601 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %128 = load double, ptr %arrayidx601, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %129 = call double @llvm.fabs.f64(double %128) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp602 = fcmp ogt double %129, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cond604 = select i1 %cmp602, double 0.000000e+00, double 1.000000e+00 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %cond604, ptr %arrayidx601, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %while.end663.loopexit988, label %for.body599 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967315, RTCostB: 19327352823
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967315, RTCostB: 7516192770
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL16Parse_Num_FactorEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body599.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %127 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx601> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx601>
    WIDEN ir<%128> = load vp<%5>
    WIDEN-CALL ir<%129> = call @llvm.fabs.f64(ir<%128>) (using vector intrinsic)
    WIDEN ir<%cmp602> = fcmp ogt ir<%129>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-SELECT ir<%cond604> = select ir<%cmp602>, ir<0.000000e+00>, ir<1.000000e+00>
    vp<%6> = vector-pointer ir<%arrayidx601>
    WIDEN store vp<%6>, ir<%cond604>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end663.loopexit988>, scalar.ph

ir-bb<while.end663.loopexit988>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %125 = load double, ptr %arrayidx588, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %fneg, ptr %arrayidx588, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %125 = load double, ptr %arrayidx588, align 8, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %fneg, ptr %arrayidx588, align 8, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %125 = load double, ptr %arrayidx588, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %fneg, ptr %arrayidx588, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body586.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv926 = phi 0, %indvars.iv.next927, ir<1>
    CLONE ir<%arrayidx588> = getelementptr inbounds ir<%Express>, ir<%indvars.iv926>
    CLONE ir<%125> = load ir<%arrayidx588>
    CLONE ir<%fneg> = fneg ir<%125>
    CLONE store ir<%fneg>, ir<%arrayidx588>
    CLONE ir<%indvars.iv.next927> = add nuw nsw ir<%indvars.iv926>, ir<1>
    CLONE ir<%exitcond930.not> = icmp eq ir<%indvars.iv.next927>, ir<%wide.trip.count929>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end663.loopexit987>, scalar.ph

ir-bb<while.end663.loopexit987>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body586.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv926 = phi 0, %indvars.iv.next927, ir<1>
    CLONE ir<%arrayidx588> = getelementptr inbounds ir<%Express>, ir<%indvars.iv926>
    vp<%4> = vector-pointer ir<%arrayidx588>
    WIDEN ir<%125> = load vp<%4>
    WIDEN ir<%fneg> = fneg ir<%125>
    vp<%5> = vector-pointer ir<%arrayidx588>
    WIDEN store vp<%5>, ir<%fneg>
    CLONE ir<%indvars.iv.next927> = add nuw nsw ir<%indvars.iv926>, ir<1>
    CLONE ir<%exitcond930.not> = icmp eq ir<%indvars.iv.next927>, ir<%wide.trip.count929>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end663.loopexit987>, scalar.ph

ir-bb<while.end663.loopexit987>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body586.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv926 = phi 0, %indvars.iv.next927, ir<1>
    CLONE ir<%arrayidx588> = getelementptr inbounds ir<%Express>, ir<%indvars.iv926>
    vp<%4> = vector-pointer ir<%arrayidx588>
    WIDEN ir<%125> = load vp<%4>
    WIDEN ir<%fneg> = fneg ir<%125>
    vp<%5> = vector-pointer ir<%arrayidx588>
    WIDEN store vp<%5>, ir<%fneg>
    CLONE ir<%indvars.iv.next927> = add nuw nsw ir<%indvars.iv926>, ir<1>
    CLONE ir<%exitcond930.not> = icmp eq ir<%indvars.iv.next927>, ir<%wide.trip.count929>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end663.loopexit987>, scalar.ph

ir-bb<while.end663.loopexit987>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv926 = phi i64 [ 0, %for.body586.preheader ], [ %indvars.iv.next927, %for.body586 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx588 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv926 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %125 = load double, ptr %arrayidx588, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %fneg = fneg double %125 of type:fneg
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %fneg, ptr %arrayidx588, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next927 = add nuw nsw i64 %indvars.iv926, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond930.not = icmp eq i64 %indvars.iv.next927, %wide.trip.count929 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond930.not, label %while.end663.loopexit987, label %for.body586 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv926 = phi i64 [ 0, %for.body586.preheader ], [ %indvars.iv.next927, %for.body586 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx588 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv926 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %125 = load double, ptr %arrayidx588, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %fneg = fneg double %125 of type:fneg
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %fneg, ptr %arrayidx588, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next927 = add nuw nsw i64 %indvars.iv926, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond930.not = icmp eq i64 %indvars.iv.next927, %wide.trip.count929 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond930.not, label %while.end663.loopexit987, label %for.body586 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709122, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709122, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv926 = phi i64 [ 0, %for.body586.preheader ], [ %indvars.iv.next927, %for.body586 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx588 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv926 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %125 = load double, ptr %arrayidx588, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %fneg = fneg double %125 of type:fneg
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %fneg, ptr %arrayidx588, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next927 = add nuw nsw i64 %indvars.iv926, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond930.not = icmp eq i64 %indvars.iv.next927, %wide.trip.count929 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond930.not, label %while.end663.loopexit987, label %for.body586 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709122

-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv926 = phi i64 [ 0, %for.body586.preheader ], [ %indvars.iv.next927, %for.body586 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx588 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv926 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %125 = load double, ptr %arrayidx588, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %fneg = fneg double %125 of type:fneg
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %fneg, ptr %arrayidx588, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next927 = add nuw nsw i64 %indvars.iv926, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond930.not = icmp eq i64 %indvars.iv.next927, %wide.trip.count929 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond930.not, label %while.end663.loopexit987, label %for.body586 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354576, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354576, RTCostB: 5368709122
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL16Parse_Num_FactorEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body586.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx588> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx588>
    WIDEN ir<%125> = load vp<%5>
    WIDEN ir<%fneg> = fneg ir<%125>
    vp<%6> = vector-pointer ir<%arrayidx588>
    WIDEN store vp<%6>, ir<%fneg>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end663.loopexit987>, scalar.ph

ir-bb<while.end663.loopexit987>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store double %call509, ptr %arrayidx514, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %call509, ptr %arrayidx514, align 8, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %call509, ptr %arrayidx514, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body512.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv950 = phi 0, %indvars.iv.next951, ir<1>
    CLONE ir<%arrayidx514> = getelementptr inbounds ir<%Express>, ir<%indvars.iv950>
    CLONE store ir<%call509>, ir<%arrayidx514>
    CLONE ir<%indvars.iv.next951> = add nuw nsw ir<%indvars.iv950>, ir<1>
    CLONE ir<%exitcond954.not> = icmp eq ir<%indvars.iv.next951>, ir<%wide.trip.count953>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end663.loopexit986>, scalar.ph

ir-bb<while.end663.loopexit986>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body512.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv950 = phi 0, %indvars.iv.next951, ir<1>
    CLONE ir<%arrayidx514> = getelementptr inbounds ir<%Express>, ir<%indvars.iv950>
    vp<%4> = vector-pointer ir<%arrayidx514>
    WIDEN store vp<%4>, ir<%call509>
    CLONE ir<%indvars.iv.next951> = add nuw nsw ir<%indvars.iv950>, ir<1>
    CLONE ir<%exitcond954.not> = icmp eq ir<%indvars.iv.next951>, ir<%wide.trip.count953>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end663.loopexit986>, scalar.ph

ir-bb<while.end663.loopexit986>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body512.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv950 = phi 0, %indvars.iv.next951, ir<1>
    CLONE ir<%arrayidx514> = getelementptr inbounds ir<%Express>, ir<%indvars.iv950>
    vp<%4> = vector-pointer ir<%arrayidx514>
    WIDEN store vp<%4>, ir<%call509>
    CLONE ir<%indvars.iv.next951> = add nuw nsw ir<%indvars.iv950>, ir<1>
    CLONE ir<%exitcond954.not> = icmp eq ir<%indvars.iv.next951>, ir<%wide.trip.count953>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end663.loopexit986>, scalar.ph

ir-bb<while.end663.loopexit986>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv950 = phi i64 [ 0, %for.body512.preheader ], [ %indvars.iv.next951, %for.body512 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx514 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv950 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %call509, ptr %arrayidx514, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next951 = add nuw nsw i64 %indvars.iv950, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond954.not = icmp eq i64 %indvars.iv.next951, %wide.trip.count953 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond954.not, label %while.end663.loopexit986, label %for.body512 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv950 = phi i64 [ 0, %for.body512.preheader ], [ %indvars.iv.next951, %for.body512 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx514 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv950 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %call509, ptr %arrayidx514, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next951 = add nuw nsw i64 %indvars.iv950, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond954.not = icmp eq i64 %indvars.iv.next951, %wide.trip.count953 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond954.not, label %while.end663.loopexit986, label %for.body512 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv950 = phi i64 [ 0, %for.body512.preheader ], [ %indvars.iv.next951, %for.body512 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx514 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv950 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %call509, ptr %arrayidx514, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next951 = add nuw nsw i64 %indvars.iv950, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond954.not = icmp eq i64 %indvars.iv.next951, %wide.trip.count953 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond954.not, label %while.end663.loopexit986, label %for.body512 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225473

-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv950 = phi i64 [ 0, %for.body512.preheader ], [ %indvars.iv.next951, %for.body512 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx514 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv950 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %call509, ptr %arrayidx514, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next951 = add nuw nsw i64 %indvars.iv950, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond954.not = icmp eq i64 %indvars.iv.next951, %wide.trip.count953 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond954.not, label %while.end663.loopexit986, label %for.body512 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL16Parse_Num_FactorEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body512.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx514> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx514>
    WIDEN store vp<%5>, ir<%call509>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end663.loopexit986>, scalar.ph

ir-bb<while.end663.loopexit986>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store double %78, ptr %arrayidx329, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %78, ptr %arrayidx329, align 8, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %78, ptr %arrayidx329, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv959 = phi 0, %indvars.iv.next960, ir<1>
    CLONE ir<%arrayidx329> = getelementptr inbounds ir<%Express>, ir<%indvars.iv959>
    CLONE store ir<%78>, ir<%arrayidx329>
    CLONE ir<%indvars.iv.next960> = add nuw nsw ir<%indvars.iv959>, ir<1>
    CLONE ir<%exitcond963.not> = icmp eq ir<%indvars.iv.next960>, ir<%wide.trip.count962>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end663.loopexit>, scalar.ph

ir-bb<while.end663.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv959 = phi 0, %indvars.iv.next960, ir<1>
    CLONE ir<%arrayidx329> = getelementptr inbounds ir<%Express>, ir<%indvars.iv959>
    vp<%4> = vector-pointer ir<%arrayidx329>
    WIDEN store vp<%4>, ir<%78>
    CLONE ir<%indvars.iv.next960> = add nuw nsw ir<%indvars.iv959>, ir<1>
    CLONE ir<%exitcond963.not> = icmp eq ir<%indvars.iv.next960>, ir<%wide.trip.count962>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end663.loopexit>, scalar.ph

ir-bb<while.end663.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Num_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv959 = phi 0, %indvars.iv.next960, ir<1>
    CLONE ir<%arrayidx329> = getelementptr inbounds ir<%Express>, ir<%indvars.iv959>
    vp<%4> = vector-pointer ir<%arrayidx329>
    WIDEN store vp<%4>, ir<%78>
    CLONE ir<%indvars.iv.next960> = add nuw nsw ir<%indvars.iv959>, ir<1>
    CLONE ir<%exitcond963.not> = icmp eq ir<%indvars.iv.next960>, ir<%wide.trip.count962>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end663.loopexit>, scalar.ph

ir-bb<while.end663.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv959 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next960, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx329 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv959 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %78, ptr %arrayidx329, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next960 = add nuw nsw i64 %indvars.iv959, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond963.not = icmp eq i64 %indvars.iv.next960, %wide.trip.count962 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond963.not, label %while.end663.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv959 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next960, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx329 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv959 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %78, ptr %arrayidx329, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next960 = add nuw nsw i64 %indvars.iv959, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond963.not = icmp eq i64 %indvars.iv.next960, %wide.trip.count962 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond963.not, label %while.end663.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv959 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next960, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx329 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv959 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %78, ptr %arrayidx329, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next960 = add nuw nsw i64 %indvars.iv959, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond963.not = icmp eq i64 %indvars.iv.next960, %wide.trip.count962 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond963.not, label %while.end663.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225473

-----------------Function that is being costed:'_ZN3povL16Parse_Num_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv959 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next960, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx329 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv959 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %78, ptr %arrayidx329, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next960 = add nuw nsw i64 %indvars.iv959, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond963.not = icmp eq i64 %indvars.iv.next960, %wide.trip.count962 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond963.not, label %while.end663.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL16Parse_Num_FactorEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx329> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx329>
    WIDEN store vp<%5>, ir<%78>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end663.loopexit>, scalar.ph

ir-bb<while.end663.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %5 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %add, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %add, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %5 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %add, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv53 = phi 0, %indvars.iv.next54, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv53>
    CLONE ir<%5> = load ir<%arrayidx>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, ir<%indvars.iv53>
    CLONE ir<%6> = load ir<%arrayidx4>
    CLONE ir<%add> = fadd ir<%5>, ir<%6>
    CLONE store ir<%add>, ir<%arrayidx4>
    CLONE ir<%indvars.iv.next54> = add nuw nsw ir<%indvars.iv53>, ir<1>
    CLONE ir<%exitcond57.not> = icmp eq ir<%indvars.iv.next54>, ir<%wide.trip.count56>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv53 = phi 0, %indvars.iv.next54, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv53>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%4>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, ir<%indvars.iv53>
    vp<%5> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%6> = load vp<%5>
    WIDEN ir<%add> = fadd ir<%5>, ir<%6>
    vp<%6> = vector-pointer ir<%arrayidx4>
    WIDEN store vp<%6>, ir<%add>
    CLONE ir<%indvars.iv.next54> = add nuw nsw ir<%indvars.iv53>, ir<1>
    CLONE ir<%exitcond57.not> = icmp eq ir<%indvars.iv.next54>, ir<%wide.trip.count56>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv53 = phi 0, %indvars.iv.next54, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv53>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%4>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, ir<%indvars.iv53>
    vp<%5> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%6> = load vp<%5>
    WIDEN ir<%add> = fadd ir<%5>, ir<%6>
    vp<%6> = vector-pointer ir<%arrayidx4>
    WIDEN store vp<%6>, ir<%add>
    CLONE ir<%indvars.iv.next54> = add nuw nsw ir<%indvars.iv53>, ir<1>
    CLONE ir<%exitcond57.not> = icmp eq ir<%indvars.iv.next54>, ir<%wide.trip.count56>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv53 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next54, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv53 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv53 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = fadd double %5, %6 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %add, ptr %arrayidx4, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next54 = add nuw nsw i64 %indvars.iv53, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond57.not = icmp eq i64 %indvars.iv.next54, %wide.trip.count56 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond57.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv53 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next54, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv53 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv53 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = fadd double %5, %6 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %add, ptr %arrayidx4, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next54 = add nuw nsw i64 %indvars.iv53, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond57.not = icmp eq i64 %indvars.iv.next54, %wide.trip.count56 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond57.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv53 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next54, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv53 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv53 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = fadd double %5, %6 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %add, ptr %arrayidx4, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next54 = add nuw nsw i64 %indvars.iv53, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond57.not = icmp eq i64 %indvars.iv.next54, %wide.trip.count56 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond57.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450947

-----------------Function that is being costed:'_ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv53 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next54, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv53 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv53 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add = fadd double %5, %6 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %add, ptr %arrayidx4, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next54 = add nuw nsw i64 %indvars.iv53, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond57.not = icmp eq i64 %indvars.iv.next54, %wide.trip.count56 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond57.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 19327352823
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 6442450947
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL16Parse_Rel_FactorEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Local_Express>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%5>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%6> = load vp<%6>
    WIDEN ir<%add> = fadd ir<%5>, ir<%6>
    vp<%7> = vector-pointer ir<%arrayidx4>
    WIDEN store vp<%7>, ir<%add>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %40 = load double, ptr %arrayidx16, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load double, ptr %arrayidx18, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %sub, ptr %arrayidx18, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load double, ptr %arrayidx16, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %41 = load double, ptr %arrayidx18, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %sub, ptr %arrayidx18, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %40 = load double, ptr %arrayidx16, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load double, ptr %arrayidx18, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %sub, ptr %arrayidx18, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body14.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv>
    CLONE ir<%40> = load ir<%arrayidx16>
    CLONE ir<%arrayidx18> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    CLONE ir<%41> = load ir<%arrayidx18>
    CLONE ir<%sub> = fsub ir<%41>, ir<%40>
    CLONE store ir<%sub>, ir<%arrayidx18>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit61>, scalar.ph

ir-bb<sw.epilog.loopexit61>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body14.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx16>
    WIDEN ir<%40> = load vp<%4>
    CLONE ir<%arrayidx18> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx18>
    WIDEN ir<%41> = load vp<%5>
    WIDEN ir<%sub> = fsub ir<%41>, ir<%40>
    vp<%6> = vector-pointer ir<%arrayidx18>
    WIDEN store vp<%6>, ir<%sub>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit61>, scalar.ph

ir-bb<sw.epilog.loopexit61>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body14.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx16>
    WIDEN ir<%40> = load vp<%4>
    CLONE ir<%arrayidx18> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx18>
    WIDEN ir<%41> = load vp<%5>
    WIDEN ir<%sub> = fsub ir<%41>, ir<%40>
    vp<%6> = vector-pointer ir<%arrayidx18>
    WIDEN store vp<%6>, ir<%sub>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit61>, scalar.ph

ir-bb<sw.epilog.loopexit61>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body14.preheader ], [ %indvars.iv.next, %for.body14 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx16 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %40 = load double, ptr %arrayidx16, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx18 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %41 = load double, ptr %arrayidx18, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = fsub double %41, %40 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub, ptr %arrayidx18, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit61, label %for.body14 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body14.preheader ], [ %indvars.iv.next, %for.body14 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx16 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %40 = load double, ptr %arrayidx16, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx18 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %41 = load double, ptr %arrayidx18, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = fsub double %41, %40 of type:fsub
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %sub, ptr %arrayidx18, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit61, label %for.body14 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body14.preheader ], [ %indvars.iv.next, %for.body14 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx16 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %40 = load double, ptr %arrayidx16, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx18 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %41 = load double, ptr %arrayidx18, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = fsub double %41, %40 of type:fsub
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %sub, ptr %arrayidx18, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit61, label %for.body14 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 6442450947

-----------------Function that is being costed:'_ZN3povL16Parse_Rel_FactorEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body14.preheader ], [ %indvars.iv.next, %for.body14 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx16 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %40 = load double, ptr %arrayidx16, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx18 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %41 = load double, ptr %arrayidx18, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = fsub double %41, %40 of type:fsub
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %sub, ptr %arrayidx18, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit61, label %for.body14 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 19327352823
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 6442450947
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL16Parse_Rel_FactorEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body14.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%Local_Express>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx16>
    WIDEN ir<%40> = load vp<%5>
    CLONE ir<%arrayidx18> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx18>
    WIDEN ir<%41> = load vp<%6>
    WIDEN ir<%sub> = fsub ir<%41>, ir<%40>
    vp<%7> = vector-pointer ir<%arrayidx18>
    WIDEN store vp<%7>, ir<%sub>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit61>, scalar.ph

ir-bb<sw.epilog.loopexit61>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 11
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body31.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv238 = phi 0, %indvars.iv.next239, ir<1>
    CLONE ir<%arrayidx33> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv238>
    CLONE ir<%5> = load ir<%arrayidx33>
    CLONE ir<%conv34> = fptrunc ir<%5>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv238>
    CLONE store ir<%conv34>, ir<%arrayidx36>
    CLONE ir<%indvars.iv.next239> = add nuw nsw ir<%indvars.iv238>, ir<1>
    CLONE ir<%exitcond242.not> = icmp eq ir<%indvars.iv.next239>, ir<%wide.trip.count241>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog145.loopexit>, scalar.ph

ir-bb<sw.epilog145.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body31.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv238 = phi 0, %indvars.iv.next239, ir<1>
    CLONE ir<%arrayidx33> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv238>
    vp<%4> = vector-pointer ir<%arrayidx33>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-CAST ir<%conv34> = fptrunc  ir<%5> to float
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv238>
    vp<%5> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%5>, ir<%conv34>
    CLONE ir<%indvars.iv.next239> = add nuw nsw ir<%indvars.iv238>, ir<1>
    CLONE ir<%exitcond242.not> = icmp eq ir<%indvars.iv.next239>, ir<%wide.trip.count241>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit>, scalar.ph

ir-bb<sw.epilog145.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body31.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv238 = phi 0, %indvars.iv.next239, ir<1>
    CLONE ir<%arrayidx33> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv238>
    vp<%4> = vector-pointer ir<%arrayidx33>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-CAST ir<%conv34> = fptrunc  ir<%5> to float
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv238>
    vp<%5> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%5>, ir<%conv34>
    CLONE ir<%indvars.iv.next239> = add nuw nsw ir<%indvars.iv238>, ir<1>
    CLONE ir<%exitcond242.not> = icmp eq ir<%indvars.iv.next239>, ir<%wide.trip.count241>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit>, scalar.ph

ir-bb<sw.epilog145.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv238 = phi i64 [ 0, %for.body31.preheader ], [ %indvars.iv.next239, %for.body31 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx33 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv34 = fptrunc double %5 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx36 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv238 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond242.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count241 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond242.not, label %sw.epilog145.loopexit, label %for.body31 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv238 = phi i64 [ 0, %for.body31.preheader ], [ %indvars.iv.next239, %for.body31 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx33 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv34 = fptrunc double %5 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx36 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond242.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count241 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond242.not, label %sw.epilog145.loopexit, label %for.body31 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv238 = phi i64 [ 0, %for.body31.preheader ], [ %indvars.iv.next239, %for.body31 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx33 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv34 = fptrunc double %5 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx36 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond242.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count241 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond242.not, label %sw.epilog145.loopexit, label %for.body31 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv238 = phi i64 [ 0, %for.body31.preheader ], [ %indvars.iv.next239, %for.body31 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx33 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv34 = fptrunc double %5 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx36 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond242.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count241 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond242.not, label %sw.epilog145.loopexit, label %for.body31 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv238 = phi i64 [ 0, %for.body31.preheader ], [ %indvars.iv.next239, %for.body31 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx33 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load double, ptr %arrayidx33, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv34 = fptrunc double %5 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx36 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv238 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv34, ptr %arrayidx36, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next239 = add nuw nsw i64 %indvars.iv238, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond242.not = icmp eq i64 %indvars.iv.next239, %wide.trip.count241 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond242.not, label %sw.epilog145.loopexit, label %for.body31 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov12Parse_ColourEPf at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body31.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx33> = getelementptr inbounds ir<%Express>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx33>
    WIDEN ir<%5> = load vp<%5>
    WIDEN-CAST ir<%conv34> = fptrunc  ir<%5> to float
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%Colour>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%6>, ir<%conv34>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog145.loopexit>, scalar.ph

ir-bb<sw.epilog145.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body52.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %33 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv233 = phi 0, %indvars.iv.next234, ir<1>
    CLONE ir<%arrayidx54> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv233>
    CLONE ir<%34> = load ir<%arrayidx54>
    CLONE ir<%conv55> = fptrunc ir<%34>
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv233>
    CLONE store ir<%conv55>, ir<%arrayidx57>
    CLONE ir<%indvars.iv.next234> = add nuw nsw ir<%indvars.iv233>, ir<1>
    CLONE ir<%exitcond237.not> = icmp eq ir<%indvars.iv.next234>, ir<%wide.trip.count236>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog145.loopexit254>, scalar.ph

ir-bb<sw.epilog145.loopexit254>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body52.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %33 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv233 = phi 0, %indvars.iv.next234, ir<1>
    CLONE ir<%arrayidx54> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv233>
    vp<%4> = vector-pointer ir<%arrayidx54>
    WIDEN ir<%34> = load vp<%4>
    WIDEN-CAST ir<%conv55> = fptrunc  ir<%34> to float
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv233>
    vp<%5> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%5>, ir<%conv55>
    CLONE ir<%indvars.iv.next234> = add nuw nsw ir<%indvars.iv233>, ir<1>
    CLONE ir<%exitcond237.not> = icmp eq ir<%indvars.iv.next234>, ir<%wide.trip.count236>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit254>, scalar.ph

ir-bb<sw.epilog145.loopexit254>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body52.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %33 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv233 = phi 0, %indvars.iv.next234, ir<1>
    CLONE ir<%arrayidx54> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv233>
    vp<%4> = vector-pointer ir<%arrayidx54>
    WIDEN ir<%34> = load vp<%4>
    WIDEN-CAST ir<%conv55> = fptrunc  ir<%34> to float
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv233>
    vp<%5> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%5>, ir<%conv55>
    CLONE ir<%indvars.iv.next234> = add nuw nsw ir<%indvars.iv233>, ir<1>
    CLONE ir<%exitcond237.not> = icmp eq ir<%indvars.iv.next234>, ir<%wide.trip.count236>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit254>, scalar.ph

ir-bb<sw.epilog145.loopexit254>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv233 = phi i64 [ 0, %for.body52.preheader ], [ %indvars.iv.next234, %for.body52 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx54 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv233 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv55 = fptrunc double %34 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx57 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv233 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next234 = add nuw nsw i64 %indvars.iv233, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond237.not = icmp eq i64 %indvars.iv.next234, %wide.trip.count236 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond237.not, label %sw.epilog145.loopexit254, label %for.body52 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv233 = phi i64 [ 0, %for.body52.preheader ], [ %indvars.iv.next234, %for.body52 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx54 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv233 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv55 = fptrunc double %34 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx57 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv233 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next234 = add nuw nsw i64 %indvars.iv233, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond237.not = icmp eq i64 %indvars.iv.next234, %wide.trip.count236 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond237.not, label %sw.epilog145.loopexit254, label %for.body52 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv233 = phi i64 [ 0, %for.body52.preheader ], [ %indvars.iv.next234, %for.body52 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx54 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv233 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv55 = fptrunc double %34 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx57 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv233 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next234 = add nuw nsw i64 %indvars.iv233, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond237.not = icmp eq i64 %indvars.iv.next234, %wide.trip.count236 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond237.not, label %sw.epilog145.loopexit254, label %for.body52 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv233 = phi i64 [ 0, %for.body52.preheader ], [ %indvars.iv.next234, %for.body52 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx54 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv233 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv55 = fptrunc double %34 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx57 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv233 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next234 = add nuw nsw i64 %indvars.iv233, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond237.not = icmp eq i64 %indvars.iv.next234, %wide.trip.count236 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond237.not, label %sw.epilog145.loopexit254, label %for.body52 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv233 = phi i64 [ 0, %for.body52.preheader ], [ %indvars.iv.next234, %for.body52 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx54 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv233 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %34 = load double, ptr %arrayidx54, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv55 = fptrunc double %34 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx57 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv233 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv55, ptr %arrayidx57, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next234 = add nuw nsw i64 %indvars.iv233, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond237.not = icmp eq i64 %indvars.iv.next234, %wide.trip.count236 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond237.not, label %sw.epilog145.loopexit254, label %for.body52 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov12Parse_ColourEPf at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body52.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %33 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx54> = getelementptr inbounds ir<%Express>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx54>
    WIDEN ir<%34> = load vp<%5>
    WIDEN-CAST ir<%conv55> = fptrunc  ir<%34> to float
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<%Colour>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%6>, ir<%conv55>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog145.loopexit254>, scalar.ph

ir-bb<sw.epilog145.loopexit254>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body73.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %62 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv228 = phi 0, %indvars.iv.next229, ir<1>
    CLONE ir<%arrayidx75> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv228>
    CLONE ir<%63> = load ir<%arrayidx75>
    CLONE ir<%conv76> = fptrunc ir<%63>
    CLONE ir<%arrayidx78> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv228>
    CLONE store ir<%conv76>, ir<%arrayidx78>
    CLONE ir<%indvars.iv.next229> = add nuw nsw ir<%indvars.iv228>, ir<1>
    CLONE ir<%exitcond232.not> = icmp eq ir<%indvars.iv.next229>, ir<%wide.trip.count231>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end81.loopexit>, scalar.ph

ir-bb<for.end81.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body73.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %62 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv228 = phi 0, %indvars.iv.next229, ir<1>
    CLONE ir<%arrayidx75> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv228>
    vp<%4> = vector-pointer ir<%arrayidx75>
    WIDEN ir<%63> = load vp<%4>
    WIDEN-CAST ir<%conv76> = fptrunc  ir<%63> to float
    CLONE ir<%arrayidx78> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv228>
    vp<%5> = vector-pointer ir<%arrayidx78>
    WIDEN store vp<%5>, ir<%conv76>
    CLONE ir<%indvars.iv.next229> = add nuw nsw ir<%indvars.iv228>, ir<1>
    CLONE ir<%exitcond232.not> = icmp eq ir<%indvars.iv.next229>, ir<%wide.trip.count231>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end81.loopexit>, scalar.ph

ir-bb<for.end81.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body73.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %62 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv228 = phi 0, %indvars.iv.next229, ir<1>
    CLONE ir<%arrayidx75> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv228>
    vp<%4> = vector-pointer ir<%arrayidx75>
    WIDEN ir<%63> = load vp<%4>
    WIDEN-CAST ir<%conv76> = fptrunc  ir<%63> to float
    CLONE ir<%arrayidx78> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv228>
    vp<%5> = vector-pointer ir<%arrayidx78>
    WIDEN store vp<%5>, ir<%conv76>
    CLONE ir<%indvars.iv.next229> = add nuw nsw ir<%indvars.iv228>, ir<1>
    CLONE ir<%exitcond232.not> = icmp eq ir<%indvars.iv.next229>, ir<%wide.trip.count231>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end81.loopexit>, scalar.ph

ir-bb<for.end81.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv228 = phi i64 [ 0, %for.body73.preheader ], [ %indvars.iv.next229, %for.body73 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx75 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv228 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv76 = fptrunc double %63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx78 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv228 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next229 = add nuw nsw i64 %indvars.iv228, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond232.not = icmp eq i64 %indvars.iv.next229, %wide.trip.count231 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond232.not, label %for.end81.loopexit, label %for.body73 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv228 = phi i64 [ 0, %for.body73.preheader ], [ %indvars.iv.next229, %for.body73 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx75 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv228 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv76 = fptrunc double %63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx78 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv228 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next229 = add nuw nsw i64 %indvars.iv228, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond232.not = icmp eq i64 %indvars.iv.next229, %wide.trip.count231 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond232.not, label %for.end81.loopexit, label %for.body73 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv228 = phi i64 [ 0, %for.body73.preheader ], [ %indvars.iv.next229, %for.body73 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx75 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv228 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv76 = fptrunc double %63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx78 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv228 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next229 = add nuw nsw i64 %indvars.iv228, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond232.not = icmp eq i64 %indvars.iv.next229, %wide.trip.count231 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond232.not, label %for.end81.loopexit, label %for.body73 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv228 = phi i64 [ 0, %for.body73.preheader ], [ %indvars.iv.next229, %for.body73 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx75 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv228 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv76 = fptrunc double %63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx78 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv228 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next229 = add nuw nsw i64 %indvars.iv228, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond232.not = icmp eq i64 %indvars.iv.next229, %wide.trip.count231 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond232.not, label %for.end81.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv228 = phi i64 [ 0, %for.body73.preheader ], [ %indvars.iv.next229, %for.body73 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx75 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv228 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %63 = load double, ptr %arrayidx75, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv76 = fptrunc double %63 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx78 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv228 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv76, ptr %arrayidx78, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next229 = add nuw nsw i64 %indvars.iv228, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond232.not = icmp eq i64 %indvars.iv.next229, %wide.trip.count231 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond232.not, label %for.end81.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov12Parse_ColourEPf at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body73.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %62 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx75> = getelementptr inbounds ir<%Express>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx75>
    WIDEN ir<%63> = load vp<%5>
    WIDEN-CAST ir<%conv76> = fptrunc  ir<%63> to float
    CLONE ir<%arrayidx78> = getelementptr inbounds ir<%Colour>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx78>
    WIDEN store vp<%6>, ir<%conv76>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end81.loopexit>, scalar.ph

ir-bb<for.end81.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body97.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %92 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv223 = phi 0, %indvars.iv.next224, ir<1>
    CLONE ir<%arrayidx99> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv223>
    CLONE ir<%93> = load ir<%arrayidx99>
    CLONE ir<%conv100> = fptrunc ir<%93>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv223>
    CLONE store ir<%conv100>, ir<%arrayidx102>
    CLONE ir<%indvars.iv.next224> = add nuw nsw ir<%indvars.iv223>, ir<1>
    CLONE ir<%exitcond227.not> = icmp eq ir<%indvars.iv.next224>, ir<%wide.trip.count226>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog145.loopexit255>, scalar.ph

ir-bb<sw.epilog145.loopexit255>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body97.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %92 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv223 = phi 0, %indvars.iv.next224, ir<1>
    CLONE ir<%arrayidx99> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv223>
    vp<%4> = vector-pointer ir<%arrayidx99>
    WIDEN ir<%93> = load vp<%4>
    WIDEN-CAST ir<%conv100> = fptrunc  ir<%93> to float
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv223>
    vp<%5> = vector-pointer ir<%arrayidx102>
    WIDEN store vp<%5>, ir<%conv100>
    CLONE ir<%indvars.iv.next224> = add nuw nsw ir<%indvars.iv223>, ir<1>
    CLONE ir<%exitcond227.not> = icmp eq ir<%indvars.iv.next224>, ir<%wide.trip.count226>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit255>, scalar.ph

ir-bb<sw.epilog145.loopexit255>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body97.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %92 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv223 = phi 0, %indvars.iv.next224, ir<1>
    CLONE ir<%arrayidx99> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv223>
    vp<%4> = vector-pointer ir<%arrayidx99>
    WIDEN ir<%93> = load vp<%4>
    WIDEN-CAST ir<%conv100> = fptrunc  ir<%93> to float
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv223>
    vp<%5> = vector-pointer ir<%arrayidx102>
    WIDEN store vp<%5>, ir<%conv100>
    CLONE ir<%indvars.iv.next224> = add nuw nsw ir<%indvars.iv223>, ir<1>
    CLONE ir<%exitcond227.not> = icmp eq ir<%indvars.iv.next224>, ir<%wide.trip.count226>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit255>, scalar.ph

ir-bb<sw.epilog145.loopexit255>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv223 = phi i64 [ 0, %for.body97.preheader ], [ %indvars.iv.next224, %for.body97 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx99 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv223 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv100 = fptrunc double %93 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx102 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv223 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next224 = add nuw nsw i64 %indvars.iv223, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond227.not = icmp eq i64 %indvars.iv.next224, %wide.trip.count226 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond227.not, label %sw.epilog145.loopexit255, label %for.body97 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv223 = phi i64 [ 0, %for.body97.preheader ], [ %indvars.iv.next224, %for.body97 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx99 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv223 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv100 = fptrunc double %93 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx102 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv223 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next224 = add nuw nsw i64 %indvars.iv223, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond227.not = icmp eq i64 %indvars.iv.next224, %wide.trip.count226 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond227.not, label %sw.epilog145.loopexit255, label %for.body97 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv223 = phi i64 [ 0, %for.body97.preheader ], [ %indvars.iv.next224, %for.body97 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx99 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv223 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv100 = fptrunc double %93 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx102 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv223 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next224 = add nuw nsw i64 %indvars.iv223, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond227.not = icmp eq i64 %indvars.iv.next224, %wide.trip.count226 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond227.not, label %sw.epilog145.loopexit255, label %for.body97 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv223 = phi i64 [ 0, %for.body97.preheader ], [ %indvars.iv.next224, %for.body97 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx99 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv223 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv100 = fptrunc double %93 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx102 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv223 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next224 = add nuw nsw i64 %indvars.iv223, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond227.not = icmp eq i64 %indvars.iv.next224, %wide.trip.count226 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond227.not, label %sw.epilog145.loopexit255, label %for.body97 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv223 = phi i64 [ 0, %for.body97.preheader ], [ %indvars.iv.next224, %for.body97 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx99 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv223 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %93 = load double, ptr %arrayidx99, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv100 = fptrunc double %93 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx102 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv223 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv100, ptr %arrayidx102, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next224 = add nuw nsw i64 %indvars.iv223, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond227.not = icmp eq i64 %indvars.iv.next224, %wide.trip.count226 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond227.not, label %sw.epilog145.loopexit255, label %for.body97 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov12Parse_ColourEPf at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body97.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %92 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx99> = getelementptr inbounds ir<%Express>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx99>
    WIDEN ir<%93> = load vp<%5>
    WIDEN-CAST ir<%conv100> = fptrunc  ir<%93> to float
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<%Colour>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx102>
    WIDEN store vp<%6>, ir<%conv100>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog145.loopexit255>, scalar.ph

ir-bb<sw.epilog145.loopexit255>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body114.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %121 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv218 = phi 0, %indvars.iv.next219, ir<1>
    CLONE ir<%arrayidx116> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv218>
    CLONE ir<%122> = load ir<%arrayidx116>
    CLONE ir<%conv117> = fptrunc ir<%122>
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv218>
    CLONE store ir<%conv117>, ir<%arrayidx119>
    CLONE ir<%indvars.iv.next219> = add nuw nsw ir<%indvars.iv218>, ir<1>
    CLONE ir<%exitcond222.not> = icmp eq ir<%indvars.iv.next219>, ir<%wide.trip.count221>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog145.loopexit256>, scalar.ph

ir-bb<sw.epilog145.loopexit256>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body114.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %121 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv218 = phi 0, %indvars.iv.next219, ir<1>
    CLONE ir<%arrayidx116> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv218>
    vp<%4> = vector-pointer ir<%arrayidx116>
    WIDEN ir<%122> = load vp<%4>
    WIDEN-CAST ir<%conv117> = fptrunc  ir<%122> to float
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv218>
    vp<%5> = vector-pointer ir<%arrayidx119>
    WIDEN store vp<%5>, ir<%conv117>
    CLONE ir<%indvars.iv.next219> = add nuw nsw ir<%indvars.iv218>, ir<1>
    CLONE ir<%exitcond222.not> = icmp eq ir<%indvars.iv.next219>, ir<%wide.trip.count221>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit256>, scalar.ph

ir-bb<sw.epilog145.loopexit256>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body114.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %121 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv218 = phi 0, %indvars.iv.next219, ir<1>
    CLONE ir<%arrayidx116> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv218>
    vp<%4> = vector-pointer ir<%arrayidx116>
    WIDEN ir<%122> = load vp<%4>
    WIDEN-CAST ir<%conv117> = fptrunc  ir<%122> to float
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv218>
    vp<%5> = vector-pointer ir<%arrayidx119>
    WIDEN store vp<%5>, ir<%conv117>
    CLONE ir<%indvars.iv.next219> = add nuw nsw ir<%indvars.iv218>, ir<1>
    CLONE ir<%exitcond222.not> = icmp eq ir<%indvars.iv.next219>, ir<%wide.trip.count221>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit256>, scalar.ph

ir-bb<sw.epilog145.loopexit256>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv218 = phi i64 [ 0, %for.body114.preheader ], [ %indvars.iv.next219, %for.body114 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx116 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv218 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv117 = fptrunc double %122 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx119 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv218 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next219 = add nuw nsw i64 %indvars.iv218, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond222.not = icmp eq i64 %indvars.iv.next219, %wide.trip.count221 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond222.not, label %sw.epilog145.loopexit256, label %for.body114 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv218 = phi i64 [ 0, %for.body114.preheader ], [ %indvars.iv.next219, %for.body114 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx116 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv218 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv117 = fptrunc double %122 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx119 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv218 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next219 = add nuw nsw i64 %indvars.iv218, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond222.not = icmp eq i64 %indvars.iv.next219, %wide.trip.count221 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond222.not, label %sw.epilog145.loopexit256, label %for.body114 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709122, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709122, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv218 = phi i64 [ 0, %for.body114.preheader ], [ %indvars.iv.next219, %for.body114 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx116 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv218 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv117 = fptrunc double %122 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx119 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv218 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next219 = add nuw nsw i64 %indvars.iv218, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond222.not = icmp eq i64 %indvars.iv.next219, %wide.trip.count221 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond222.not, label %sw.epilog145.loopexit256, label %for.body114 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967309, RTCostB: 15032385529
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967309, RTCostB: 5368709122
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv218 = phi i64 [ 0, %for.body114.preheader ], [ %indvars.iv.next219, %for.body114 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx116 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv218 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv117 = fptrunc double %122 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx119 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv218 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next219 = add nuw nsw i64 %indvars.iv218, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond222.not = icmp eq i64 %indvars.iv.next219, %wide.trip.count221 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond222.not, label %sw.epilog145.loopexit256, label %for.body114 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967309

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv218 = phi i64 [ 0, %for.body114.preheader ], [ %indvars.iv.next219, %for.body114 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx116 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv218 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %122 = load double, ptr %arrayidx116, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv117 = fptrunc double %122 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx119 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv218 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv117, ptr %arrayidx119, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next219 = add nuw nsw i64 %indvars.iv218, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond222.not = icmp eq i64 %indvars.iv.next219, %wide.trip.count221 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond222.not, label %sw.epilog145.loopexit256, label %for.body114 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354576, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354576, RTCostB: 4294967309
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov12Parse_ColourEPf at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body114.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %121 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx116> = getelementptr inbounds ir<%Express>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx116>
    WIDEN ir<%122> = load vp<%5>
    WIDEN-CAST ir<%conv117> = fptrunc  ir<%122> to float
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%Colour>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx119>
    WIDEN store vp<%6>, ir<%conv117>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog145.loopexit256>, scalar.ph

ir-bb<sw.epilog145.loopexit256>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <2 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <4 x float> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x float> -> ttilog -> 
@@ Instruction =>  %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x float> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body135.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx137> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv>
    CLONE ir<%151> = load ir<%arrayidx137>
    CLONE ir<%conv138> = fptrunc ir<%151>
    CLONE ir<%arrayidx140> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv>
    CLONE store ir<%conv138>, ir<%arrayidx140>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog145.loopexit257>, scalar.ph

ir-bb<sw.epilog145.loopexit257>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body135.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx137> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx137>
    WIDEN ir<%151> = load vp<%4>
    WIDEN-CAST ir<%conv138> = fptrunc  ir<%151> to float
    CLONE ir<%arrayidx140> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx140>
    WIDEN store vp<%5>, ir<%conv138>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit257>, scalar.ph

ir-bb<sw.epilog145.loopexit257>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov12Parse_ColourEPf' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body135.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx137> = getelementptr inbounds ir<%Express>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx137>
    WIDEN ir<%151> = load vp<%4>
    WIDEN-CAST ir<%conv138> = fptrunc  ir<%151> to float
    CLONE ir<%arrayidx140> = getelementptr inbounds ir<%Colour>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx140>
    WIDEN store vp<%5>, ir<%conv138>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog145.loopexit257>, scalar.ph

ir-bb<sw.epilog145.loopexit257>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body135.preheader ], [ %indvars.iv.next, %for.body135 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx137 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv138 = fptrunc double %151 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx140 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %sw.epilog145.loopexit257, label %for.body135 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body135.preheader ], [ %indvars.iv.next, %for.body135 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx137 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv138 = fptrunc double %151 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx140 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %sw.epilog145.loopexit257, label %for.body135 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body135.preheader ], [ %indvars.iv.next, %for.body135 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx137 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv138 = fptrunc double %151 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx140 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %sw.epilog145.loopexit257, label %for.body135 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body135.preheader ], [ %indvars.iv.next, %for.body135 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx137 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv138 = fptrunc double %151 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx140 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %sw.epilog145.loopexit257, label %for.body135 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'_ZN3pov12Parse_ColourEPf' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body135.preheader ], [ %indvars.iv.next, %for.body135 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx137 = getelementptr inbounds [5 x double], ptr %Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %151 = load double, ptr %arrayidx137, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv138 = fptrunc double %151 to float of type:fptrunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx140 = getelementptr inbounds float, ptr %Colour, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store float %conv138, ptr %arrayidx140, align 4, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %sw.epilog145.loopexit257, label %for.body135 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov12Parse_ColourEPf at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body135.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %150 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx137> = getelementptr inbounds ir<%Express>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx137>
    WIDEN ir<%151> = load vp<%5>
    WIDEN-CAST ir<%conv138> = fptrunc  ir<%151> to float
    CLONE ir<%arrayidx140> = getelementptr inbounds ir<%Colour>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx140>
    WIDEN store vp<%6>, ir<%conv138>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog145.loopexit257>, scalar.ph

ir-bb<sw.epilog145.loopexit257>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 12
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %4 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load double, ptr %arrayidx3, align 8, !tbaa !17 -> Cost: 8 -> VectorType: <2 x double> -> ttilog -> MaskedMemoryOpCost(8)
@@ Instruction =>  store double %conv, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %6 = load double, ptr %arrayidx3, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %conv, ptr %arrayidx, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %4 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load double, ptr %arrayidx3, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store double %conv, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL13Parse_LogicalEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv54 = phi 0, %indvars.iv.next55, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Express>, ir<%indvars.iv54>
    CLONE ir<%4> = load ir<%arrayidx>
    CLONE ir<%5> = call @llvm.fabs.f64(ir<%4>)
    CLONE ir<%cmp1> = fcmp ogt ir<%5>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): land.rhs

  land.rhs:
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv54>
    CLONE ir<%6> = load ir<%arrayidx3>, ir<%cmp1>
    CLONE ir<%7> = call @llvm.fabs.f64(ir<%6>)
    CLONE ir<%cmp4> = fcmp ogt ir<%7>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): land.end

  land.end:
    EMIT vp<%4> = not ir<%cmp1>
    EMIT vp<%5> = or ir<%cmp1>, vp<%4>
    BLEND ir<%8> = ir<false> ir<%cmp4>/ir<%cmp1>
    CLONE ir<%conv> = uitofp ir<%8>
    CLONE store ir<%conv>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next55> = add nuw nsw ir<%indvars.iv54>, ir<1>
    CLONE ir<%exitcond58.not> = icmp eq ir<%indvars.iv.next55>, ir<%wide.trip.count57>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL13Parse_LogicalEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv54 = phi 0, %indvars.iv.next55, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Express>, ir<%indvars.iv54>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN-CALL ir<%5> = call @llvm.fabs.f64(ir<%4>) (using vector intrinsic)
    WIDEN ir<%cmp1> = fcmp ogt ir<%5>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): land.rhs

  land.rhs:
    CLONE ir<%arrayidx3> = getelementptr ir<%Local_Express>, ir<0>, ir<%indvars.iv54>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN ir<%6> = load vp<%5>, ir<%cmp1>
    WIDEN-CALL ir<%7> = call @llvm.fabs.f64(ir<%6>) (using vector intrinsic)
    WIDEN ir<%cmp4> = fcmp ogt ir<%7>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): land.end

  land.end:
    EMIT vp<%6> = not ir<%cmp1>
    EMIT vp<%7> = or ir<%cmp1>, vp<%6>
    BLEND ir<%8> = ir<false> ir<%cmp4>/ir<%cmp1>
    WIDEN-CAST ir<%conv> = uitofp  ir<%8> to double
    vp<%8> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%8>, ir<%conv>
    CLONE ir<%indvars.iv.next55> = add nuw nsw ir<%indvars.iv54>, ir<1>
    CLONE ir<%exitcond58.not> = icmp eq ir<%indvars.iv.next55>, ir<%wide.trip.count57>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL13Parse_LogicalEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv54 = phi 0, %indvars.iv.next55, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Express>, ir<%indvars.iv54>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN-CALL ir<%5> = call @llvm.fabs.f64(ir<%4>) (using vector intrinsic)
    WIDEN ir<%cmp1> = fcmp ogt ir<%5>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): land.rhs

  land.rhs:
    CLONE ir<%arrayidx3> = getelementptr ir<%Local_Express>, ir<0>, ir<%indvars.iv54>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN ir<%6> = load vp<%5>, ir<%cmp1>
    WIDEN-CALL ir<%7> = call @llvm.fabs.f64(ir<%6>) (using vector intrinsic)
    WIDEN ir<%cmp4> = fcmp ogt ir<%7>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): land.end

  land.end:
    EMIT vp<%6> = not ir<%cmp1>
    EMIT vp<%7> = or ir<%cmp1>, vp<%6>
    BLEND ir<%8> = ir<false> ir<%cmp4>/ir<%cmp1>
    WIDEN-CAST ir<%conv> = uitofp  ir<%8> to double
    vp<%8> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%8>, ir<%conv>
    CLONE ir<%indvars.iv.next55> = add nuw nsw ir<%indvars.iv54>, ir<1>
    CLONE ir<%exitcond58.not> = icmp eq ir<%indvars.iv.next55>, ir<%wide.trip.count57>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next55, %land.end ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Express, i64 %indvars.iv54 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = call double @llvm.fabs.f64(double %4) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1 = fcmp ogt double %5, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1, label %land.rhs, label %land.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv54 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load double, ptr %arrayidx3, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %7 = call double @llvm.fabs.f64(double %6) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp4 = fcmp ogt double %7, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %land.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %8 = phi i1 [ false, %for.body ], [ %cmp4, %land.rhs ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv = uitofp i1 %8 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %conv, ptr %arrayidx, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond58.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next55, %land.end ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Express, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = call double @llvm.fabs.f64(double %4) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1 = fcmp ogt double %5, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp1, label %land.rhs, label %land.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 8 for VF 2 For instruction:   %6 = load double, ptr %arrayidx3, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %7 = call double @llvm.fabs.f64(double %6) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp4 = fcmp ogt double %7, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %land.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 6 for VF 2 For instruction:   %8 = phi i1 [ false, %for.body ], [ %cmp4, %land.rhs ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv = uitofp i1 %8 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %conv, ptr %arrayidx, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond58.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 24696061940, RTCostB: 23622320117
A is not scalable.	B is not scalable.	
RTCostA: 24696061940, RTCostB: 23622320117

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next55, %land.end ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Express, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = call double @llvm.fabs.f64(double %4) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1 = fcmp ogt double %5, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1, label %land.rhs, label %land.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load double, ptr %arrayidx3, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = call double @llvm.fabs.f64(double %6) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp4 = fcmp ogt double %7, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %land.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %8 = phi i1 [ false, %for.body ], [ %cmp4, %land.rhs ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv = uitofp i1 %8 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %conv, ptr %arrayidx, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond58.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320117
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320117

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv54 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next55, %land.end ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Express, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %5 = call double @llvm.fabs.f64(double %4) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1 = fcmp ogt double %5, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1, label %land.rhs, label %land.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv54 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = load double, ptr %arrayidx3, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %7 = call double @llvm.fabs.f64(double %6) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp4 = fcmp ogt double %7, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %land.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %8 = phi i1 [ false, %for.body ], [ %cmp4, %land.rhs ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv = uitofp i1 %8 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %conv, ptr %arrayidx, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next55 = add nuw nsw i64 %indvars.iv54, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond58.not = icmp eq i64 %indvars.iv.next55, %wide.trip.count57 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond58.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6979321876, RTCostB: 23622320117
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6979321876, RTCostB: 23622320117
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL13Parse_LogicalEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%5>
    WIDEN-CALL ir<%5> = call @llvm.fabs.f64(ir<%4>) (using vector intrinsic)
    WIDEN ir<%cmp1> = fcmp ogt ir<%5>, ir<0x3E7AD7F29ABCAF48>
    CLONE ir<%arrayidx3> = getelementptr ir<%Local_Express>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx3>
    WIDEN ir<%6> = load vp<%6>, ir<%cmp1>
    WIDEN-CALL ir<%7> = call @llvm.fabs.f64(ir<%6>) (using vector intrinsic)
    WIDEN ir<%cmp4> = fcmp ogt ir<%7>, ir<0x3E7AD7F29ABCAF48>
    BLEND ir<%8> = ir<false> ir<%cmp4>/ir<%cmp1>
    WIDEN-CAST ir<%conv> = uitofp  ir<%8> to double
    vp<%7> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%7>, ir<%conv>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %49 = load double, ptr %arrayidx13, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %51 = load double, ptr %arrayidx17, align 8, !tbaa !17 -> Cost: 8 -> VectorType: <2 x double> -> ttilog -> MaskedMemoryOpCost(8)
@@ Instruction =>  store double %conv20, ptr %arrayidx13, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %49 = load double, ptr %arrayidx13, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %51 = load double, ptr %arrayidx17, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %conv20, ptr %arrayidx13, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %49 = load double, ptr %arrayidx13, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %51 = load double, ptr %arrayidx17, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store double %conv20, ptr %arrayidx13, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL13Parse_LogicalEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body11.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %48 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx13> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    CLONE ir<%49> = load ir<%arrayidx13>
    CLONE ir<%50> = call @llvm.fabs.f64(ir<%49>)
    CLONE ir<%cmp14> = fcmp ogt ir<%50>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): lor.rhs

  lor.rhs:
    EMIT vp<%4> = not ir<%cmp14>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv>
    CLONE ir<%51> = load ir<%arrayidx17>, vp<%4>
    CLONE ir<%52> = call @llvm.fabs.f64(ir<%51>)
    CLONE ir<%cmp18> = fcmp ogt ir<%52>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): lor.end

  lor.end:
    EMIT vp<%5> = or vp<%4>, ir<%cmp14>
    BLEND ir<%53> = ir<true> ir<%cmp18>/vp<%4>
    CLONE ir<%conv20> = uitofp ir<%53>
    CLONE store ir<%conv20>, ir<%arrayidx13>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog.loopexit61>, scalar.ph

ir-bb<sw.epilog.loopexit61>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL13Parse_LogicalEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body11.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %48 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx13> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx13>
    WIDEN ir<%49> = load vp<%4>
    WIDEN-CALL ir<%50> = call @llvm.fabs.f64(ir<%49>) (using vector intrinsic)
    WIDEN ir<%cmp14> = fcmp ogt ir<%50>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): lor.rhs

  lor.rhs:
    EMIT vp<%5> = not ir<%cmp14>
    CLONE ir<%arrayidx17> = getelementptr ir<%Local_Express>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx17>
    WIDEN ir<%51> = load vp<%6>, vp<%5>
    WIDEN-CALL ir<%52> = call @llvm.fabs.f64(ir<%51>) (using vector intrinsic)
    WIDEN ir<%cmp18> = fcmp ogt ir<%52>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): lor.end

  lor.end:
    EMIT vp<%7> = or vp<%5>, ir<%cmp14>
    BLEND ir<%53> = ir<true> ir<%cmp18>/vp<%5>
    WIDEN-CAST ir<%conv20> = uitofp  ir<%53> to double
    vp<%8> = vector-pointer ir<%arrayidx13>
    WIDEN store vp<%8>, ir<%conv20>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<sw.epilog.loopexit61>, scalar.ph

ir-bb<sw.epilog.loopexit61>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL13Parse_LogicalEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body11.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %48 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx13> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx13>
    WIDEN ir<%49> = load vp<%4>
    WIDEN-CALL ir<%50> = call @llvm.fabs.f64(ir<%49>) (using vector intrinsic)
    WIDEN ir<%cmp14> = fcmp ogt ir<%50>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): lor.rhs

  lor.rhs:
    EMIT vp<%5> = not ir<%cmp14>
    CLONE ir<%arrayidx17> = getelementptr ir<%Local_Express>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx17>
    WIDEN ir<%51> = load vp<%6>, vp<%5>
    WIDEN-CALL ir<%52> = call @llvm.fabs.f64(ir<%51>) (using vector intrinsic)
    WIDEN ir<%cmp18> = fcmp ogt ir<%52>, ir<0x3E7AD7F29ABCAF48>
  Successor(s): lor.end

  lor.end:
    EMIT vp<%7> = or vp<%5>, ir<%cmp14>
    BLEND ir<%53> = ir<true> ir<%cmp18>/vp<%5>
    WIDEN-CAST ir<%conv20> = uitofp  ir<%53> to double
    vp<%8> = vector-pointer ir<%arrayidx13>
    WIDEN store vp<%8>, ir<%conv20>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<sw.epilog.loopexit61>, scalar.ph

ir-bb<sw.epilog.loopexit61>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body11.preheader ], [ %indvars.iv.next, %lor.end ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx13 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %49 = load double, ptr %arrayidx13, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %50 = call double @llvm.fabs.f64(double %49) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp14 = fcmp ogt double %50, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp14, label %lor.end, label %lor.rhs of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx17 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %51 = load double, ptr %arrayidx17, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %52 = call double @llvm.fabs.f64(double %51) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp18 = fcmp ogt double %52, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %lor.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %53 = phi i1 [ true, %for.body11 ], [ %cmp18, %lor.rhs ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv20 = uitofp i1 %53 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %conv20, ptr %arrayidx13, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit61, label %for.body11 of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body11.preheader ], [ %indvars.iv.next, %lor.end ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx13 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %49 = load double, ptr %arrayidx13, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %50 = call double @llvm.fabs.f64(double %49) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp14 = fcmp ogt double %50, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp14, label %lor.end, label %lor.rhs of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx17 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 8 for VF 2 For instruction:   %51 = load double, ptr %arrayidx17, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %52 = call double @llvm.fabs.f64(double %51) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp18 = fcmp ogt double %52, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %lor.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 6 for VF 2 For instruction:   %53 = phi i1 [ true, %for.body11 ], [ %cmp18, %lor.rhs ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv20 = uitofp i1 %53 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %conv20, ptr %arrayidx13, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit61, label %for.body11 of type:br
LV: Vector loop of width 2 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 24696061940, RTCostB: 23622320117
A is not scalable.	B is not scalable.	
RTCostA: 24696061940, RTCostB: 23622320117

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body11.preheader ], [ %indvars.iv.next, %lor.end ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx13 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %49 = load double, ptr %arrayidx13, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %50 = call double @llvm.fabs.f64(double %49) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp14 = fcmp ogt double %50, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp14, label %lor.end, label %lor.rhs of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx17 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %51 = load double, ptr %arrayidx17, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %52 = call double @llvm.fabs.f64(double %51) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp18 = fcmp ogt double %52, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %lor.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %53 = phi i1 [ true, %for.body11 ], [ %cmp18, %lor.rhs ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv20 = uitofp i1 %53 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %conv20, ptr %arrayidx13, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit61, label %for.body11 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320117
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320117

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body11.preheader ], [ %indvars.iv.next, %lor.end ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx13 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %49 = load double, ptr %arrayidx13, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %50 = call double @llvm.fabs.f64(double %49) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp14 = fcmp ogt double %50, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp14, label %lor.end, label %lor.rhs of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx17 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %51 = load double, ptr %arrayidx17, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %52 = call double @llvm.fabs.f64(double %51) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp18 = fcmp ogt double %52, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %lor.end of type:br

-----------------Function that is being costed:'_ZN3povL13Parse_LogicalEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %53 = phi i1 [ true, %for.body11 ], [ %cmp18, %lor.rhs ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv20 = uitofp i1 %53 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %conv20, ptr %arrayidx13, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit61, label %for.body11 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6979321876, RTCostB: 23622320117
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6979321876, RTCostB: 23622320117
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL13Parse_LogicalEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body11.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %48 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx13> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx13>
    WIDEN ir<%49> = load vp<%5>
    WIDEN-CALL ir<%50> = call @llvm.fabs.f64(ir<%49>) (using vector intrinsic)
    WIDEN ir<%cmp14> = fcmp ogt ir<%50>, ir<0x3E7AD7F29ABCAF48>
    EMIT vp<%6> = not ir<%cmp14>
    CLONE ir<%arrayidx17> = getelementptr ir<%Local_Express>, ir<0>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx17>
    WIDEN ir<%51> = load vp<%7>, vp<%6>
    WIDEN-CALL ir<%52> = call @llvm.fabs.f64(ir<%51>) (using vector intrinsic)
    WIDEN ir<%cmp18> = fcmp ogt ir<%52>, ir<0x3E7AD7F29ABCAF48>
    BLEND ir<%53> = ir<true> ir<%cmp18>/vp<%6>
    WIDEN-CAST ir<%conv20> = uitofp  ir<%53> to double
    vp<%8> = vector-pointer ir<%arrayidx13>
    WIDEN store vp<%8>, ir<%conv20>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<sw.epilog.loopexit61>, scalar.ph

ir-bb<sw.epilog.loopexit61>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 14
Loops Analyzed: 30
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store double %8, ptr %arrayidx4, align 8, !tbaa !10 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %8, ptr %arrayidx4, align 8, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %8, ptr %arrayidx4, align 8, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL15Promote_ExpressEPdPii' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %New_Terms to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    CLONE store ir<%8>, ir<%arrayidx4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end13.loopexit>, scalar.ph

ir-bb<if.end13.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15Promote_ExpressEPdPii' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %New_Terms to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx4>
    WIDEN store vp<%4>, ir<%8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end13.loopexit>, scalar.ph

ir-bb<if.end13.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15Promote_ExpressEPdPii' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %New_Terms to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx4>
    WIDEN store vp<%4>, ir<%8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end13.loopexit>, scalar.ph

ir-bb<if.end13.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL15Promote_ExpressEPdPii' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %8, ptr %arrayidx4, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end13.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL15Promote_ExpressEPdPii' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %8, ptr %arrayidx4, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end13.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225469, RTCostB: 8589934584
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225469, RTCostB: 8589934584
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL15Promote_ExpressEPdPii' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %8, ptr %arrayidx4, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end13.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934584
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225469

-----------------Function that is being costed:'_ZN3povL15Promote_ExpressEPdPii' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %8, ptr %arrayidx4, align 8, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end13.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612741, RTCostB: 8589934584
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612741, RTCostB: 3221225469
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL15Promote_ExpressEPdPii at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %New_Terms to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx4>
    WIDEN store vp<%6>, ir<%8>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end13.loopexit>, scalar.ph

ir-bb<if.end13.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 15
Loops Analyzed: 31
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %4 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load double, ptr %arrayidx2, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %5 = load double, ptr %arrayidx2, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %conv, ptr %arrayidx, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %4 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load double, ptr %arrayidx2, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv221 = phi 0, %indvars.iv.next222, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Express>, ir<%indvars.iv221>
    CLONE ir<%4> = load ir<%arrayidx>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv221>
    CLONE ir<%5> = load ir<%arrayidx2>
    CLONE ir<%cmp3> = fcmp olt ir<%4>, ir<%5>
    CLONE ir<%conv> = uitofp ir<%cmp3>
    CLONE store ir<%conv>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next222> = add nuw nsw ir<%indvars.iv221>, ir<1>
    CLONE ir<%exitcond225.not> = icmp eq ir<%indvars.iv.next222>, ir<%wide.trip.count224>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv221 = phi 0, %indvars.iv.next222, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Express>, ir<%indvars.iv221>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv221>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%5> = load vp<%5>
    WIDEN ir<%cmp3> = fcmp olt ir<%4>, ir<%5>
    WIDEN-CAST ir<%conv> = uitofp  ir<%cmp3> to double
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<%conv>
    CLONE ir<%indvars.iv.next222> = add nuw nsw ir<%indvars.iv221>, ir<1>
    CLONE ir<%exitcond225.not> = icmp eq ir<%indvars.iv.next222>, ir<%wide.trip.count224>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv221 = phi 0, %indvars.iv.next222, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Express>, ir<%indvars.iv221>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv221>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%5> = load vp<%5>
    WIDEN ir<%cmp3> = fcmp olt ir<%4>, ir<%5>
    WIDEN-CAST ir<%conv> = uitofp  ir<%cmp3> to double
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<%conv>
    CLONE ir<%indvars.iv.next222> = add nuw nsw ir<%indvars.iv221>, ir<1>
    CLONE ir<%exitcond225.not> = icmp eq ir<%indvars.iv.next222>, ir<%wide.trip.count224>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv221 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next222, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Express, i64 %indvars.iv221 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv221 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load double, ptr %arrayidx2, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp3 = fcmp olt double %4, %5 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv = uitofp i1 %cmp3 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %conv, ptr %arrayidx, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next222 = add nuw nsw i64 %indvars.iv221, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond225.not = icmp eq i64 %indvars.iv.next222, %wide.trip.count224 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond225.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv221 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next222, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Express, i64 %indvars.iv221 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv221 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = load double, ptr %arrayidx2, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp3 = fcmp olt double %4, %5 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv = uitofp i1 %cmp3 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %conv, ptr %arrayidx, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next222 = add nuw nsw i64 %indvars.iv221, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond225.not = icmp eq i64 %indvars.iv.next222, %wide.trip.count224 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond225.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192771, RTCostB: 21474836470
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192771, RTCostB: 21474836470
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv221 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next222, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Express, i64 %indvars.iv221 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv221 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load double, ptr %arrayidx2, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp3 = fcmp olt double %4, %5 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv = uitofp i1 %cmp3 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %conv, ptr %arrayidx, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next222 = add nuw nsw i64 %indvars.iv221, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond225.not = icmp eq i64 %indvars.iv.next222, %wide.trip.count224 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond225.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836470
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192771

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv221 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next222, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Express, i64 %indvars.iv221 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv221 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load double, ptr %arrayidx2, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp3 = fcmp olt double %4, %5 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv = uitofp i1 %cmp3 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %conv, ptr %arrayidx, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next222 = add nuw nsw i64 %indvars.iv221, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond225.not = icmp eq i64 %indvars.iv.next222, %wide.trip.count224 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond225.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096407, RTCostB: 21474836470
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096407, RTCostB: 7516192771
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL14Parse_Rel_TermEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%Local_Express>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN ir<%5> = load vp<%6>
    WIDEN ir<%cmp3> = fcmp olt ir<%4>, ir<%5>
    WIDEN-CAST ir<%conv> = uitofp  ir<%cmp3> to double
    vp<%7> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%7>, ir<%conv>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %40 = load double, ptr %arrayidx12, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load double, ptr %arrayidx14, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv23, ptr %arrayidx12, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load double, ptr %arrayidx12, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %41 = load double, ptr %arrayidx14, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %conv23, ptr %arrayidx12, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %40 = load double, ptr %arrayidx12, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load double, ptr %arrayidx14, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv23, ptr %arrayidx12, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body10.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv216 = phi 0, %indvars.iv.next217, ir<1>
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%Express>, ir<%indvars.iv216>
    CLONE ir<%40> = load ir<%arrayidx12>
    CLONE ir<%arrayidx14> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv216>
    CLONE ir<%41> = load ir<%arrayidx14>
    CLONE ir<%cmp15> = fcmp ole ir<%40>, ir<%41>
    CLONE ir<%sub> = fsub ir<%40>, ir<%41>
    CLONE ir<%42> = call @llvm.fabs.f64(ir<%sub>)
    CLONE ir<%cmp20> = fcmp ule ir<%42>, ir<0x3E7AD7F29ABCAF48>
    CLONE ir<%43> = select ir<%cmp15>, ir<true>, ir<%cmp20>
    CLONE ir<%conv23> = uitofp ir<%43>
    CLONE store ir<%conv23>, ir<%arrayidx12>
    CLONE ir<%indvars.iv.next217> = add nuw nsw ir<%indvars.iv216>, ir<1>
    CLONE ir<%exitcond220.not> = icmp eq ir<%indvars.iv.next217>, ir<%wide.trip.count219>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit232>, scalar.ph

ir-bb<sw.epilog.loopexit232>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body10.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv216 = phi 0, %indvars.iv.next217, ir<1>
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%Express>, ir<%indvars.iv216>
    vp<%4> = vector-pointer ir<%arrayidx12>
    WIDEN ir<%40> = load vp<%4>
    CLONE ir<%arrayidx14> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv216>
    vp<%5> = vector-pointer ir<%arrayidx14>
    WIDEN ir<%41> = load vp<%5>
    WIDEN ir<%cmp15> = fcmp ole ir<%40>, ir<%41>
    WIDEN ir<%sub> = fsub ir<%40>, ir<%41>
    WIDEN-CALL ir<%42> = call @llvm.fabs.f64(ir<%sub>) (using vector intrinsic)
    WIDEN ir<%cmp20> = fcmp ule ir<%42>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-SELECT ir<%43> = select ir<%cmp15>, ir<true>, ir<%cmp20>
    WIDEN-CAST ir<%conv23> = uitofp  ir<%43> to double
    vp<%6> = vector-pointer ir<%arrayidx12>
    WIDEN store vp<%6>, ir<%conv23>
    CLONE ir<%indvars.iv.next217> = add nuw nsw ir<%indvars.iv216>, ir<1>
    CLONE ir<%exitcond220.not> = icmp eq ir<%indvars.iv.next217>, ir<%wide.trip.count219>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit232>, scalar.ph

ir-bb<sw.epilog.loopexit232>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body10.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv216 = phi 0, %indvars.iv.next217, ir<1>
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%Express>, ir<%indvars.iv216>
    vp<%4> = vector-pointer ir<%arrayidx12>
    WIDEN ir<%40> = load vp<%4>
    CLONE ir<%arrayidx14> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv216>
    vp<%5> = vector-pointer ir<%arrayidx14>
    WIDEN ir<%41> = load vp<%5>
    WIDEN ir<%cmp15> = fcmp ole ir<%40>, ir<%41>
    WIDEN ir<%sub> = fsub ir<%40>, ir<%41>
    WIDEN-CALL ir<%42> = call @llvm.fabs.f64(ir<%sub>) (using vector intrinsic)
    WIDEN ir<%cmp20> = fcmp ule ir<%42>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-SELECT ir<%43> = select ir<%cmp15>, ir<true>, ir<%cmp20>
    WIDEN-CAST ir<%conv23> = uitofp  ir<%43> to double
    vp<%6> = vector-pointer ir<%arrayidx12>
    WIDEN store vp<%6>, ir<%conv23>
    CLONE ir<%indvars.iv.next217> = add nuw nsw ir<%indvars.iv216>, ir<1>
    CLONE ir<%exitcond220.not> = icmp eq ir<%indvars.iv.next217>, ir<%wide.trip.count219>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit232>, scalar.ph

ir-bb<sw.epilog.loopexit232>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv216 = phi i64 [ 0, %for.body10.preheader ], [ %indvars.iv.next217, %for.body10 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx12 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv216 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %40 = load double, ptr %arrayidx12, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx14 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv216 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %41 = load double, ptr %arrayidx14, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp15 = fcmp ole double %40, %41 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = fsub double %40, %41 of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %42 = call double @llvm.fabs.f64(double %sub) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp20 = fcmp ule double %42, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %43 = select i1 %cmp15, i1 true, i1 %cmp20 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv23 = uitofp i1 %43 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %conv23, ptr %arrayidx12, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next217 = add nuw nsw i64 %indvars.iv216, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond220.not = icmp eq i64 %indvars.iv.next217, %wide.trip.count219 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond220.not, label %sw.epilog.loopexit232, label %for.body10 of type:br
LV: Scalar loop costs: 14.
-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv216 = phi i64 [ 0, %for.body10.preheader ], [ %indvars.iv.next217, %for.body10 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx12 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %40 = load double, ptr %arrayidx12, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx14 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %41 = load double, ptr %arrayidx14, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp15 = fcmp ole double %40, %41 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = fsub double %40, %41 of type:fsub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %42 = call double @llvm.fabs.f64(double %sub) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp20 = fcmp ule double %42, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %43 = select i1 %cmp15, i1 true, i1 %cmp20 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv23 = uitofp i1 %43 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %conv23, ptr %arrayidx12, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next217 = add nuw nsw i64 %indvars.iv216, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond220.not = icmp eq i64 %indvars.iv.next217, %wide.trip.count219 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond220.not, label %sw.epilog.loopexit232, label %for.body10 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 11811160067, RTCostB: 30064771058
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 11811160067, RTCostB: 30064771058
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv216 = phi i64 [ 0, %for.body10.preheader ], [ %indvars.iv.next217, %for.body10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx12 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %40 = load double, ptr %arrayidx12, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx14 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %41 = load double, ptr %arrayidx14, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp15 = fcmp ole double %40, %41 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = fsub double %40, %41 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %42 = call double @llvm.fabs.f64(double %sub) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp20 = fcmp ule double %42, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %43 = select i1 %cmp15, i1 true, i1 %cmp20 of type:select
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv23 = uitofp i1 %43 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %conv23, ptr %arrayidx12, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next217 = add nuw nsw i64 %indvars.iv216, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond220.not = icmp eq i64 %indvars.iv.next217, %wide.trip.count219 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond220.not, label %sw.epilog.loopexit232, label %for.body10 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771058
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 11811160067

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv216 = phi i64 [ 0, %for.body10.preheader ], [ %indvars.iv.next217, %for.body10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx12 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %40 = load double, ptr %arrayidx12, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx14 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv216 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %41 = load double, ptr %arrayidx14, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp15 = fcmp ole double %40, %41 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = fsub double %40, %41 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %42 = call double @llvm.fabs.f64(double %sub) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp20 = fcmp ule double %42, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %43 = select i1 %cmp15, i1 true, i1 %cmp20 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv23 = uitofp i1 %43 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %conv23, ptr %arrayidx12, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next217 = add nuw nsw i64 %indvars.iv216, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond220.not = icmp eq i64 %indvars.iv.next217, %wide.trip.count219 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond220.not, label %sw.epilog.loopexit232, label %for.body10 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450974, RTCostB: 30064771058
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450974, RTCostB: 11811160067
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL14Parse_Rel_TermEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body10.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx12> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx12>
    WIDEN ir<%40> = load vp<%5>
    CLONE ir<%arrayidx14> = getelementptr inbounds ir<%Local_Express>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx14>
    WIDEN ir<%41> = load vp<%6>
    WIDEN ir<%cmp15> = fcmp ole ir<%40>, ir<%41>
    WIDEN ir<%sub> = fsub ir<%40>, ir<%41>
    WIDEN-CALL ir<%42> = call @llvm.fabs.f64(ir<%sub>) (using vector intrinsic)
    WIDEN ir<%cmp20> = fcmp ule ir<%42>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-SELECT ir<%43> = select ir<%cmp15>, ir<true>, ir<%cmp20>
    WIDEN-CAST ir<%conv23> = uitofp  ir<%43> to double
    vp<%7> = vector-pointer ir<%arrayidx12>
    WIDEN store vp<%7>, ir<%conv23>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit232>, scalar.ph

ir-bb<sw.epilog.loopexit232>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %86 = load double, ptr %arrayidx35, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %87 = load double, ptr %arrayidx37, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv42, ptr %arrayidx35, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %86 = load double, ptr %arrayidx35, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %87 = load double, ptr %arrayidx37, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %conv42, ptr %arrayidx35, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %86 = load double, ptr %arrayidx35, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %87 = load double, ptr %arrayidx37, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv42, ptr %arrayidx35, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body33.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %85 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv211 = phi 0, %indvars.iv.next212, ir<1>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%Express>, ir<%indvars.iv211>
    CLONE ir<%86> = load ir<%arrayidx35>
    CLONE ir<%arrayidx37> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv211>
    CLONE ir<%87> = load ir<%arrayidx37>
    CLONE ir<%sub38> = fsub ir<%86>, ir<%87>
    CLONE ir<%88> = call @llvm.fabs.f64(ir<%sub38>)
    CLONE ir<%cmp39> = fcmp ule ir<%88>, ir<0x3E7AD7F29ABCAF48>
    CLONE ir<%conv42> = uitofp ir<%cmp39>
    CLONE store ir<%conv42>, ir<%arrayidx35>
    CLONE ir<%indvars.iv.next212> = add nuw nsw ir<%indvars.iv211>, ir<1>
    CLONE ir<%exitcond215.not> = icmp eq ir<%indvars.iv.next212>, ir<%wide.trip.count214>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit233>, scalar.ph

ir-bb<sw.epilog.loopexit233>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body33.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %85 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv211 = phi 0, %indvars.iv.next212, ir<1>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%Express>, ir<%indvars.iv211>
    vp<%4> = vector-pointer ir<%arrayidx35>
    WIDEN ir<%86> = load vp<%4>
    CLONE ir<%arrayidx37> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv211>
    vp<%5> = vector-pointer ir<%arrayidx37>
    WIDEN ir<%87> = load vp<%5>
    WIDEN ir<%sub38> = fsub ir<%86>, ir<%87>
    WIDEN-CALL ir<%88> = call @llvm.fabs.f64(ir<%sub38>) (using vector intrinsic)
    WIDEN ir<%cmp39> = fcmp ule ir<%88>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-CAST ir<%conv42> = uitofp  ir<%cmp39> to double
    vp<%6> = vector-pointer ir<%arrayidx35>
    WIDEN store vp<%6>, ir<%conv42>
    CLONE ir<%indvars.iv.next212> = add nuw nsw ir<%indvars.iv211>, ir<1>
    CLONE ir<%exitcond215.not> = icmp eq ir<%indvars.iv.next212>, ir<%wide.trip.count214>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit233>, scalar.ph

ir-bb<sw.epilog.loopexit233>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body33.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %85 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv211 = phi 0, %indvars.iv.next212, ir<1>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%Express>, ir<%indvars.iv211>
    vp<%4> = vector-pointer ir<%arrayidx35>
    WIDEN ir<%86> = load vp<%4>
    CLONE ir<%arrayidx37> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv211>
    vp<%5> = vector-pointer ir<%arrayidx37>
    WIDEN ir<%87> = load vp<%5>
    WIDEN ir<%sub38> = fsub ir<%86>, ir<%87>
    WIDEN-CALL ir<%88> = call @llvm.fabs.f64(ir<%sub38>) (using vector intrinsic)
    WIDEN ir<%cmp39> = fcmp ule ir<%88>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-CAST ir<%conv42> = uitofp  ir<%cmp39> to double
    vp<%6> = vector-pointer ir<%arrayidx35>
    WIDEN store vp<%6>, ir<%conv42>
    CLONE ir<%indvars.iv.next212> = add nuw nsw ir<%indvars.iv211>, ir<1>
    CLONE ir<%exitcond215.not> = icmp eq ir<%indvars.iv.next212>, ir<%wide.trip.count214>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit233>, scalar.ph

ir-bb<sw.epilog.loopexit233>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv211 = phi i64 [ 0, %for.body33.preheader ], [ %indvars.iv.next212, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx35 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv211 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %86 = load double, ptr %arrayidx35, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx37 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv211 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %87 = load double, ptr %arrayidx37, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub38 = fsub double %86, %87 of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %88 = call double @llvm.fabs.f64(double %sub38) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp39 = fcmp ule double %88, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv42 = uitofp i1 %cmp39 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %conv42, ptr %arrayidx35, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond215.not = icmp eq i64 %indvars.iv.next212, %wide.trip.count214 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond215.not, label %sw.epilog.loopexit233, label %for.body33 of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv211 = phi i64 [ 0, %for.body33.preheader ], [ %indvars.iv.next212, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx35 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv211 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %86 = load double, ptr %arrayidx35, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx37 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv211 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %87 = load double, ptr %arrayidx37, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub38 = fsub double %86, %87 of type:fsub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %88 = call double @llvm.fabs.f64(double %sub38) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp39 = fcmp ule double %88, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv42 = uitofp i1 %cmp39 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %conv42, ptr %arrayidx35, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond215.not = icmp eq i64 %indvars.iv.next212, %wide.trip.count214 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond215.not, label %sw.epilog.loopexit233, label %for.body33 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676419, RTCostB: 25769803764
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676419, RTCostB: 25769803764
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv211 = phi i64 [ 0, %for.body33.preheader ], [ %indvars.iv.next212, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx35 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv211 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %86 = load double, ptr %arrayidx35, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx37 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv211 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %87 = load double, ptr %arrayidx37, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub38 = fsub double %86, %87 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %88 = call double @llvm.fabs.f64(double %sub38) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp39 = fcmp ule double %88, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv42 = uitofp i1 %cmp39 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %conv42, ptr %arrayidx35, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond215.not = icmp eq i64 %indvars.iv.next212, %wide.trip.count214 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond215.not, label %sw.epilog.loopexit233, label %for.body33 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 25769803764
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 9663676419

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv211 = phi i64 [ 0, %for.body33.preheader ], [ %indvars.iv.next212, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx35 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv211 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %86 = load double, ptr %arrayidx35, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx37 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv211 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %87 = load double, ptr %arrayidx37, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub38 = fsub double %86, %87 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %88 = call double @llvm.fabs.f64(double %sub38) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp39 = fcmp ule double %88, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv42 = uitofp i1 %cmp39 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %conv42, ptr %arrayidx35, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next212 = add nuw nsw i64 %indvars.iv211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond215.not = icmp eq i64 %indvars.iv.next212, %wide.trip.count214 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond215.not, label %sw.epilog.loopexit233, label %for.body33 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709146, RTCostB: 25769803764
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709146, RTCostB: 9663676419
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL14Parse_Rel_TermEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body33.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %85 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx35>
    WIDEN ir<%86> = load vp<%5>
    CLONE ir<%arrayidx37> = getelementptr inbounds ir<%Local_Express>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx37>
    WIDEN ir<%87> = load vp<%6>
    WIDEN ir<%sub38> = fsub ir<%86>, ir<%87>
    WIDEN-CALL ir<%88> = call @llvm.fabs.f64(ir<%sub38>) (using vector intrinsic)
    WIDEN ir<%cmp39> = fcmp ule ir<%88>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-CAST ir<%conv42> = uitofp  ir<%cmp39> to double
    vp<%7> = vector-pointer ir<%arrayidx35>
    WIDEN store vp<%7>, ir<%conv42>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit233>, scalar.ph

ir-bb<sw.epilog.loopexit233>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %127 = load double, ptr %arrayidx54, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %128 = load double, ptr %arrayidx56, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv60, ptr %arrayidx54, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %127 = load double, ptr %arrayidx54, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %128 = load double, ptr %arrayidx56, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %conv60, ptr %arrayidx54, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %127 = load double, ptr %arrayidx54, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %128 = load double, ptr %arrayidx56, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv60, ptr %arrayidx54, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body52.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %126 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv206 = phi 0, %indvars.iv.next207, ir<1>
    CLONE ir<%arrayidx54> = getelementptr inbounds ir<%Express>, ir<%indvars.iv206>
    CLONE ir<%127> = load ir<%arrayidx54>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv206>
    CLONE ir<%128> = load ir<%arrayidx56>
    CLONE ir<%sub57> = fsub ir<%127>, ir<%128>
    CLONE ir<%129> = call @llvm.fabs.f64(ir<%sub57>)
    CLONE ir<%cmp58> = fcmp ogt ir<%129>, ir<0x3E7AD7F29ABCAF48>
    CLONE ir<%conv60> = uitofp ir<%cmp58>
    CLONE store ir<%conv60>, ir<%arrayidx54>
    CLONE ir<%indvars.iv.next207> = add nuw nsw ir<%indvars.iv206>, ir<1>
    CLONE ir<%exitcond210.not> = icmp eq ir<%indvars.iv.next207>, ir<%wide.trip.count209>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit234>, scalar.ph

ir-bb<sw.epilog.loopexit234>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body52.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %126 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv206 = phi 0, %indvars.iv.next207, ir<1>
    CLONE ir<%arrayidx54> = getelementptr inbounds ir<%Express>, ir<%indvars.iv206>
    vp<%4> = vector-pointer ir<%arrayidx54>
    WIDEN ir<%127> = load vp<%4>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv206>
    vp<%5> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%128> = load vp<%5>
    WIDEN ir<%sub57> = fsub ir<%127>, ir<%128>
    WIDEN-CALL ir<%129> = call @llvm.fabs.f64(ir<%sub57>) (using vector intrinsic)
    WIDEN ir<%cmp58> = fcmp ogt ir<%129>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-CAST ir<%conv60> = uitofp  ir<%cmp58> to double
    vp<%6> = vector-pointer ir<%arrayidx54>
    WIDEN store vp<%6>, ir<%conv60>
    CLONE ir<%indvars.iv.next207> = add nuw nsw ir<%indvars.iv206>, ir<1>
    CLONE ir<%exitcond210.not> = icmp eq ir<%indvars.iv.next207>, ir<%wide.trip.count209>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit234>, scalar.ph

ir-bb<sw.epilog.loopexit234>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body52.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %126 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv206 = phi 0, %indvars.iv.next207, ir<1>
    CLONE ir<%arrayidx54> = getelementptr inbounds ir<%Express>, ir<%indvars.iv206>
    vp<%4> = vector-pointer ir<%arrayidx54>
    WIDEN ir<%127> = load vp<%4>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv206>
    vp<%5> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%128> = load vp<%5>
    WIDEN ir<%sub57> = fsub ir<%127>, ir<%128>
    WIDEN-CALL ir<%129> = call @llvm.fabs.f64(ir<%sub57>) (using vector intrinsic)
    WIDEN ir<%cmp58> = fcmp ogt ir<%129>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-CAST ir<%conv60> = uitofp  ir<%cmp58> to double
    vp<%6> = vector-pointer ir<%arrayidx54>
    WIDEN store vp<%6>, ir<%conv60>
    CLONE ir<%indvars.iv.next207> = add nuw nsw ir<%indvars.iv206>, ir<1>
    CLONE ir<%exitcond210.not> = icmp eq ir<%indvars.iv.next207>, ir<%wide.trip.count209>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit234>, scalar.ph

ir-bb<sw.epilog.loopexit234>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv206 = phi i64 [ 0, %for.body52.preheader ], [ %indvars.iv.next207, %for.body52 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx54 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv206 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %127 = load double, ptr %arrayidx54, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx56 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv206 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %128 = load double, ptr %arrayidx56, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub57 = fsub double %127, %128 of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %129 = call double @llvm.fabs.f64(double %sub57) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp58 = fcmp ogt double %129, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv60 = uitofp i1 %cmp58 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %conv60, ptr %arrayidx54, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next207 = add nuw nsw i64 %indvars.iv206, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond210.not = icmp eq i64 %indvars.iv.next207, %wide.trip.count209 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond210.not, label %sw.epilog.loopexit234, label %for.body52 of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv206 = phi i64 [ 0, %for.body52.preheader ], [ %indvars.iv.next207, %for.body52 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx54 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv206 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %127 = load double, ptr %arrayidx54, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx56 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv206 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %128 = load double, ptr %arrayidx56, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub57 = fsub double %127, %128 of type:fsub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %129 = call double @llvm.fabs.f64(double %sub57) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp58 = fcmp ogt double %129, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv60 = uitofp i1 %cmp58 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %conv60, ptr %arrayidx54, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next207 = add nuw nsw i64 %indvars.iv206, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond210.not = icmp eq i64 %indvars.iv.next207, %wide.trip.count209 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond210.not, label %sw.epilog.loopexit234, label %for.body52 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676419, RTCostB: 25769803764
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676419, RTCostB: 25769803764
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv206 = phi i64 [ 0, %for.body52.preheader ], [ %indvars.iv.next207, %for.body52 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx54 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv206 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %127 = load double, ptr %arrayidx54, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx56 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv206 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %128 = load double, ptr %arrayidx56, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub57 = fsub double %127, %128 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %129 = call double @llvm.fabs.f64(double %sub57) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp58 = fcmp ogt double %129, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv60 = uitofp i1 %cmp58 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %conv60, ptr %arrayidx54, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next207 = add nuw nsw i64 %indvars.iv206, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond210.not = icmp eq i64 %indvars.iv.next207, %wide.trip.count209 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond210.not, label %sw.epilog.loopexit234, label %for.body52 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 25769803764
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 9663676419

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv206 = phi i64 [ 0, %for.body52.preheader ], [ %indvars.iv.next207, %for.body52 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx54 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv206 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %127 = load double, ptr %arrayidx54, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx56 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv206 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %128 = load double, ptr %arrayidx56, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub57 = fsub double %127, %128 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %129 = call double @llvm.fabs.f64(double %sub57) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp58 = fcmp ogt double %129, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv60 = uitofp i1 %cmp58 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %conv60, ptr %arrayidx54, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next207 = add nuw nsw i64 %indvars.iv206, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond210.not = icmp eq i64 %indvars.iv.next207, %wide.trip.count209 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond210.not, label %sw.epilog.loopexit234, label %for.body52 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709146, RTCostB: 25769803764
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709146, RTCostB: 9663676419
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL14Parse_Rel_TermEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body52.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %126 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx54> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx54>
    WIDEN ir<%127> = load vp<%5>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%Local_Express>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%128> = load vp<%6>
    WIDEN ir<%sub57> = fsub ir<%127>, ir<%128>
    WIDEN-CALL ir<%129> = call @llvm.fabs.f64(ir<%sub57>) (using vector intrinsic)
    WIDEN ir<%cmp58> = fcmp ogt ir<%129>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-CAST ir<%conv60> = uitofp  ir<%cmp58> to double
    vp<%7> = vector-pointer ir<%arrayidx54>
    WIDEN store vp<%7>, ir<%conv60>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit234>, scalar.ph

ir-bb<sw.epilog.loopexit234>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %168 = load double, ptr %arrayidx72, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %169 = load double, ptr %arrayidx74, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv86, ptr %arrayidx72, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %168 = load double, ptr %arrayidx72, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %169 = load double, ptr %arrayidx74, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %conv86, ptr %arrayidx72, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %168 = load double, ptr %arrayidx72, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %169 = load double, ptr %arrayidx74, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv86, ptr %arrayidx72, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body70.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %167 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv201 = phi 0, %indvars.iv.next202, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%Express>, ir<%indvars.iv201>
    CLONE ir<%168> = load ir<%arrayidx72>
    CLONE ir<%arrayidx74> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv201>
    CLONE ir<%169> = load ir<%arrayidx74>
    CLONE ir<%cmp75> = fcmp oge ir<%168>, ir<%169>
    CLONE ir<%sub81> = fsub ir<%168>, ir<%169>
    CLONE ir<%170> = call @llvm.fabs.f64(ir<%sub81>)
    CLONE ir<%cmp82> = fcmp ule ir<%170>, ir<0x3E7AD7F29ABCAF48>
    CLONE ir<%171> = select ir<%cmp75>, ir<true>, ir<%cmp82>
    CLONE ir<%conv86> = uitofp ir<%171>
    CLONE store ir<%conv86>, ir<%arrayidx72>
    CLONE ir<%indvars.iv.next202> = add nuw nsw ir<%indvars.iv201>, ir<1>
    CLONE ir<%exitcond205.not> = icmp eq ir<%indvars.iv.next202>, ir<%wide.trip.count204>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit235>, scalar.ph

ir-bb<sw.epilog.loopexit235>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body70.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %167 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv201 = phi 0, %indvars.iv.next202, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%Express>, ir<%indvars.iv201>
    vp<%4> = vector-pointer ir<%arrayidx72>
    WIDEN ir<%168> = load vp<%4>
    CLONE ir<%arrayidx74> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv201>
    vp<%5> = vector-pointer ir<%arrayidx74>
    WIDEN ir<%169> = load vp<%5>
    WIDEN ir<%cmp75> = fcmp oge ir<%168>, ir<%169>
    WIDEN ir<%sub81> = fsub ir<%168>, ir<%169>
    WIDEN-CALL ir<%170> = call @llvm.fabs.f64(ir<%sub81>) (using vector intrinsic)
    WIDEN ir<%cmp82> = fcmp ule ir<%170>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-SELECT ir<%171> = select ir<%cmp75>, ir<true>, ir<%cmp82>
    WIDEN-CAST ir<%conv86> = uitofp  ir<%171> to double
    vp<%6> = vector-pointer ir<%arrayidx72>
    WIDEN store vp<%6>, ir<%conv86>
    CLONE ir<%indvars.iv.next202> = add nuw nsw ir<%indvars.iv201>, ir<1>
    CLONE ir<%exitcond205.not> = icmp eq ir<%indvars.iv.next202>, ir<%wide.trip.count204>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit235>, scalar.ph

ir-bb<sw.epilog.loopexit235>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body70.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %167 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv201 = phi 0, %indvars.iv.next202, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%Express>, ir<%indvars.iv201>
    vp<%4> = vector-pointer ir<%arrayidx72>
    WIDEN ir<%168> = load vp<%4>
    CLONE ir<%arrayidx74> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv201>
    vp<%5> = vector-pointer ir<%arrayidx74>
    WIDEN ir<%169> = load vp<%5>
    WIDEN ir<%cmp75> = fcmp oge ir<%168>, ir<%169>
    WIDEN ir<%sub81> = fsub ir<%168>, ir<%169>
    WIDEN-CALL ir<%170> = call @llvm.fabs.f64(ir<%sub81>) (using vector intrinsic)
    WIDEN ir<%cmp82> = fcmp ule ir<%170>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-SELECT ir<%171> = select ir<%cmp75>, ir<true>, ir<%cmp82>
    WIDEN-CAST ir<%conv86> = uitofp  ir<%171> to double
    vp<%6> = vector-pointer ir<%arrayidx72>
    WIDEN store vp<%6>, ir<%conv86>
    CLONE ir<%indvars.iv.next202> = add nuw nsw ir<%indvars.iv201>, ir<1>
    CLONE ir<%exitcond205.not> = icmp eq ir<%indvars.iv.next202>, ir<%wide.trip.count204>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit235>, scalar.ph

ir-bb<sw.epilog.loopexit235>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv201 = phi i64 [ 0, %for.body70.preheader ], [ %indvars.iv.next202, %for.body70 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx72 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv201 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %168 = load double, ptr %arrayidx72, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx74 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv201 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %169 = load double, ptr %arrayidx74, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp75 = fcmp oge double %168, %169 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub81 = fsub double %168, %169 of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %170 = call double @llvm.fabs.f64(double %sub81) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp82 = fcmp ule double %170, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %171 = select i1 %cmp75, i1 true, i1 %cmp82 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv86 = uitofp i1 %171 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %conv86, ptr %arrayidx72, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next202 = add nuw nsw i64 %indvars.iv201, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond205.not = icmp eq i64 %indvars.iv.next202, %wide.trip.count204 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond205.not, label %sw.epilog.loopexit235, label %for.body70 of type:br
LV: Scalar loop costs: 14.
-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv201 = phi i64 [ 0, %for.body70.preheader ], [ %indvars.iv.next202, %for.body70 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx72 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv201 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %168 = load double, ptr %arrayidx72, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx74 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv201 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %169 = load double, ptr %arrayidx74, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp75 = fcmp oge double %168, %169 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub81 = fsub double %168, %169 of type:fsub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %170 = call double @llvm.fabs.f64(double %sub81) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp82 = fcmp ule double %170, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %171 = select i1 %cmp75, i1 true, i1 %cmp82 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv86 = uitofp i1 %171 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %conv86, ptr %arrayidx72, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next202 = add nuw nsw i64 %indvars.iv201, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond205.not = icmp eq i64 %indvars.iv.next202, %wide.trip.count204 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond205.not, label %sw.epilog.loopexit235, label %for.body70 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 11811160067, RTCostB: 30064771058
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 11811160067, RTCostB: 30064771058
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv201 = phi i64 [ 0, %for.body70.preheader ], [ %indvars.iv.next202, %for.body70 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx72 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv201 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %168 = load double, ptr %arrayidx72, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx74 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv201 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %169 = load double, ptr %arrayidx74, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp75 = fcmp oge double %168, %169 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub81 = fsub double %168, %169 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %170 = call double @llvm.fabs.f64(double %sub81) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp82 = fcmp ule double %170, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %171 = select i1 %cmp75, i1 true, i1 %cmp82 of type:select
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv86 = uitofp i1 %171 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %conv86, ptr %arrayidx72, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next202 = add nuw nsw i64 %indvars.iv201, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond205.not = icmp eq i64 %indvars.iv.next202, %wide.trip.count204 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond205.not, label %sw.epilog.loopexit235, label %for.body70 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771058
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 11811160067

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv201 = phi i64 [ 0, %for.body70.preheader ], [ %indvars.iv.next202, %for.body70 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx72 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv201 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %168 = load double, ptr %arrayidx72, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx74 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv201 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %169 = load double, ptr %arrayidx74, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp75 = fcmp oge double %168, %169 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub81 = fsub double %168, %169 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %170 = call double @llvm.fabs.f64(double %sub81) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp82 = fcmp ule double %170, 0x3E7AD7F29ABCAF48 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %171 = select i1 %cmp75, i1 true, i1 %cmp82 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv86 = uitofp i1 %171 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %conv86, ptr %arrayidx72, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next202 = add nuw nsw i64 %indvars.iv201, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond205.not = icmp eq i64 %indvars.iv.next202, %wide.trip.count204 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond205.not, label %sw.epilog.loopexit235, label %for.body70 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450974, RTCostB: 30064771058
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450974, RTCostB: 11811160067
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL14Parse_Rel_TermEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body70.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %167 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx72>
    WIDEN ir<%168> = load vp<%5>
    CLONE ir<%arrayidx74> = getelementptr inbounds ir<%Local_Express>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx74>
    WIDEN ir<%169> = load vp<%6>
    WIDEN ir<%cmp75> = fcmp oge ir<%168>, ir<%169>
    WIDEN ir<%sub81> = fsub ir<%168>, ir<%169>
    WIDEN-CALL ir<%170> = call @llvm.fabs.f64(ir<%sub81>) (using vector intrinsic)
    WIDEN ir<%cmp82> = fcmp ule ir<%170>, ir<0x3E7AD7F29ABCAF48>
    WIDEN-SELECT ir<%171> = select ir<%cmp75>, ir<true>, ir<%cmp82>
    WIDEN-CAST ir<%conv86> = uitofp  ir<%171> to double
    vp<%7> = vector-pointer ir<%arrayidx72>
    WIDEN store vp<%7>, ir<%conv86>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit235>, scalar.ph

ir-bb<sw.epilog.loopexit235>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %214 = load double, ptr %arrayidx98, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %215 = load double, ptr %arrayidx100, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv102, ptr %arrayidx98, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %214 = load double, ptr %arrayidx98, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %215 = load double, ptr %arrayidx100, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %conv102, ptr %arrayidx98, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %214 = load double, ptr %arrayidx98, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %215 = load double, ptr %arrayidx100, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %conv102, ptr %arrayidx98, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body96.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %213 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx98> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    CLONE ir<%214> = load ir<%arrayidx98>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv>
    CLONE ir<%215> = load ir<%arrayidx100>
    CLONE ir<%cmp101> = fcmp ogt ir<%214>, ir<%215>
    CLONE ir<%conv102> = uitofp ir<%cmp101>
    CLONE store ir<%conv102>, ir<%arrayidx98>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit236>, scalar.ph

ir-bb<sw.epilog.loopexit236>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body96.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %213 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx98> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx98>
    WIDEN ir<%214> = load vp<%4>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx100>
    WIDEN ir<%215> = load vp<%5>
    WIDEN ir<%cmp101> = fcmp ogt ir<%214>, ir<%215>
    WIDEN-CAST ir<%conv102> = uitofp  ir<%cmp101> to double
    vp<%6> = vector-pointer ir<%arrayidx98>
    WIDEN store vp<%6>, ir<%conv102>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit236>, scalar.ph

ir-bb<sw.epilog.loopexit236>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Rel_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body96.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %213 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx98> = getelementptr inbounds ir<%Express>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx98>
    WIDEN ir<%214> = load vp<%4>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx100>
    WIDEN ir<%215> = load vp<%5>
    WIDEN ir<%cmp101> = fcmp ogt ir<%214>, ir<%215>
    WIDEN-CAST ir<%conv102> = uitofp  ir<%cmp101> to double
    vp<%6> = vector-pointer ir<%arrayidx98>
    WIDEN store vp<%6>, ir<%conv102>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit236>, scalar.ph

ir-bb<sw.epilog.loopexit236>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next, %for.body96 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx98 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %214 = load double, ptr %arrayidx98, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx100 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %215 = load double, ptr %arrayidx100, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp101 = fcmp ogt double %214, %215 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv102 = uitofp i1 %cmp101 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %conv102, ptr %arrayidx98, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit236, label %for.body96 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next, %for.body96 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx98 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %214 = load double, ptr %arrayidx98, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx100 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %215 = load double, ptr %arrayidx100, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp101 = fcmp ogt double %214, %215 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv102 = uitofp i1 %cmp101 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %conv102, ptr %arrayidx98, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit236, label %for.body96 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192771, RTCostB: 21474836470
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192771, RTCostB: 21474836470
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next, %for.body96 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx98 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %214 = load double, ptr %arrayidx98, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx100 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %215 = load double, ptr %arrayidx100, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp101 = fcmp ogt double %214, %215 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv102 = uitofp i1 %cmp101 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %conv102, ptr %arrayidx98, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit236, label %for.body96 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836470
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192771

-----------------Function that is being costed:'_ZN3povL14Parse_Rel_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body96.preheader ], [ %indvars.iv.next, %for.body96 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx98 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %214 = load double, ptr %arrayidx98, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx100 = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %215 = load double, ptr %arrayidx100, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp101 = fcmp ogt double %214, %215 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv102 = uitofp i1 %cmp101 to double of type:uitofp
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %conv102, ptr %arrayidx98, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit236, label %for.body96 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096407, RTCostB: 21474836470
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096407, RTCostB: 7516192771
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL14Parse_Rel_TermEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body96.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %213 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx98> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx98>
    WIDEN ir<%214> = load vp<%5>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<%Local_Express>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx100>
    WIDEN ir<%215> = load vp<%6>
    WIDEN ir<%cmp101> = fcmp ogt ir<%214>, ir<%215>
    WIDEN-CAST ir<%conv102> = uitofp  ir<%cmp101> to double
    vp<%7> = vector-pointer ir<%arrayidx98>
    WIDEN store vp<%7>, ir<%conv102>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit236>, scalar.ph

ir-bb<sw.epilog.loopexit236>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 21
Loops Analyzed: 37
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %5 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %mul, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %5 = load double, ptr %arrayidx, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx4, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL14Parse_Num_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv65 = phi 0, %indvars.iv.next66, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv65>
    CLONE ir<%5> = load ir<%arrayidx>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, ir<%indvars.iv65>
    CLONE ir<%6> = load ir<%arrayidx4>
    CLONE ir<%mul> = fmul ir<%5>, ir<%6>
    CLONE store ir<%mul>, ir<%arrayidx4>
    CLONE ir<%indvars.iv.next66> = add nuw nsw ir<%indvars.iv65>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next66>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Num_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv65 = phi 0, %indvars.iv.next66, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv65>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%4>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, ir<%indvars.iv65>
    vp<%5> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%6> = load vp<%5>
    WIDEN ir<%mul> = fmul ir<%5>, ir<%6>
    vp<%6> = vector-pointer ir<%arrayidx4>
    WIDEN store vp<%6>, ir<%mul>
    CLONE ir<%indvars.iv.next66> = add nuw nsw ir<%indvars.iv65>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next66>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14Parse_Num_TermEPdPi' from express.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv65 = phi 0, %indvars.iv.next66, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Local_Express>, ir<0>, ir<%indvars.iv65>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%4>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, ir<%indvars.iv65>
    vp<%5> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%6> = load vp<%5>
    WIDEN ir<%mul> = fmul ir<%5>, ir<%6>
    vp<%6> = vector-pointer ir<%arrayidx4>
    WIDEN store vp<%6>, ir<%mul>
    CLONE ir<%indvars.iv.next66> = add nuw nsw ir<%indvars.iv65>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next66>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL14Parse_Num_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv65 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next66, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv65 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv65 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul double %5, %6 of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul, ptr %arrayidx4, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next66 = add nuw nsw i64 %indvars.iv65, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next66, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN3povL14Parse_Num_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv65 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next66, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv65 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv65 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul double %5, %6 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %mul, ptr %arrayidx4, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next66 = add nuw nsw i64 %indvars.iv65, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next66, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192771, RTCostB: 21474836470
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192771, RTCostB: 21474836470
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL14Parse_Num_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv65 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next66, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv65 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv65 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul double %5, %6 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul, ptr %arrayidx4, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next66 = add nuw nsw i64 %indvars.iv65, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next66, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836470
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192771

-----------------Function that is being costed:'_ZN3povL14Parse_Num_TermEPdPi' from express.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv65 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next66, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [5 x double], ptr %Local_Express, i64 0, i64 %indvars.iv65 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load double, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %Express, i64 %indvars.iv65 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = load double, ptr %arrayidx4, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul double %5, %6 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %mul, ptr %arrayidx4, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next66 = add nuw nsw i64 %indvars.iv65, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next66, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096407, RTCostB: 21474836470
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096407, RTCostB: 7516192771
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL14Parse_Num_TermEPdPi at line: express.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Local_Express>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%5> = load vp<%5>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%Express>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%6> = load vp<%6>
    WIDEN ir<%mul> = fmul ir<%5>, ir<%6>
    vp<%7> = vector-pointer ir<%arrayidx4>
    WIDEN store vp<%7>, ir<%mul>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 22
Loops Analyzed: 44
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fileinputoutput.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           fileinputoutput.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fncode.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           fncode.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fnintern.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           fnintern.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fnpovfpu.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           fnpovfpu.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fnsyntax.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           fnsyntax.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fpmetric.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           fpmetric.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o fractal.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           fractal.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o function.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           function.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hcmplx.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           hcmplx.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o hfield.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           hfield.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o histogra.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           histogra.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o iff.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           iff.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o image.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           image.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o interior.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           interior.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o isosurf.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           isosurf.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lathe.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           lathe.cpp
MVT: v2f64
@@ Instruction =>  %96 = load double, ptr %arrayidx478, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  store double %99, ptr %arrayidx499, align 8, !tbaa !20 -> Cost: 9 -> VectorType: <2 x double> -> ttilog -> MaskedMemoryOpCost(8)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  %96 = load double, ptr %arrayidx478, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %99, ptr %arrayidx499, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %96 = load double, ptr %arrayidx478, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %99, ptr %arrayidx499, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body476.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call472 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv801 = phi %95, %indvars.iv.next802, ir<-1>
    CLONE ir<%indvars.iv.next802> = add nsw ir<%indvars.iv801>, ir<-1>
    CLONE ir<%arrayidx478> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next802>
    CLONE ir<%96> = load ir<%arrayidx478>
    CLONE ir<%cmp479> = fcmp ult ir<%96>, ir<0.000000e+00>
    CLONE ir<%cmp483> = fcmp ugt ir<%96>, ir<1.000000e+00>
    CLONE ir<%or.cond790> = or ir<%cmp479>, ir<%cmp483>
  Successor(s): if.then484

  if.then484:
    EMIT vp<%4> = not ir<%or.cond790>
    CLONE ir<%97> = call @llvm.fmuladd.f64(ir<%96>, ir<%91>, ir<%92>)
    CLONE ir<%98> = call @llvm.fmuladd.f64(ir<%96>, ir<%97>, ir<%93>)
    CLONE ir<%99> = call @llvm.fmuladd.f64(ir<%96>, ir<%98>, ir<%94>)
    CLONE ir<%arrayidx499> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next802>
    CLONE store ir<%99>, ir<%arrayidx499>, vp<%4>
  Successor(s): if.end500

  if.end500:
    EMIT vp<%5> = or vp<%4>, ir<%or.cond790>
    CLONE ir<%tobool475.not> = icmp eq ir<%indvars.iv.next802>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end502.loopexit>, scalar.ph

ir-bb<if.end502.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body476.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call472 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv801 = phi %95, %indvars.iv.next802, ir<-1>
    CLONE ir<%indvars.iv.next802> = add ir<%indvars.iv801>, ir<-1>
    CLONE ir<%arrayidx478> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next802>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx478>
    WIDEN ir<%96> = load vp<%4>
    WIDEN ir<%cmp479> = fcmp ult ir<%96>, ir<0.000000e+00>
    WIDEN ir<%cmp483> = fcmp ugt ir<%96>, ir<1.000000e+00>
    WIDEN ir<%or.cond790> = or ir<%cmp479>, ir<%cmp483>
  Successor(s): if.then484

  if.then484:
    EMIT vp<%5> = not ir<%or.cond790>
    WIDEN-CALL ir<%97> = call @llvm.fmuladd.f64(ir<%96>, ir<%91>, ir<%92>) (using vector intrinsic)
    WIDEN-CALL ir<%98> = call @llvm.fmuladd.f64(ir<%96>, ir<%97>, ir<%93>) (using vector intrinsic)
    WIDEN-CALL ir<%99> = call @llvm.fmuladd.f64(ir<%96>, ir<%98>, ir<%94>) (using vector intrinsic)
    CLONE ir<%arrayidx499> = getelementptr ir<%y>, ir<0>, ir<%indvars.iv.next802>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx499>
    WIDEN store vp<%6>, ir<%99>, vp<%5>
  Successor(s): if.end500

  if.end500:
    EMIT vp<%7> = or vp<%5>, ir<%or.cond790>
    CLONE ir<%tobool475.not> = icmp eq ir<%indvars.iv.next802>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end502.loopexit>, scalar.ph

ir-bb<if.end502.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body476.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call472 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv801 = phi %95, %indvars.iv.next802, ir<-1>
    CLONE ir<%indvars.iv.next802> = add ir<%indvars.iv801>, ir<-1>
    CLONE ir<%arrayidx478> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next802>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx478>
    WIDEN ir<%96> = load vp<%4>
    WIDEN ir<%cmp479> = fcmp ult ir<%96>, ir<0.000000e+00>
    WIDEN ir<%cmp483> = fcmp ugt ir<%96>, ir<1.000000e+00>
    WIDEN ir<%or.cond790> = or ir<%cmp479>, ir<%cmp483>
  Successor(s): if.then484

  if.then484:
    EMIT vp<%5> = not ir<%or.cond790>
    WIDEN-CALL ir<%97> = call @llvm.fmuladd.f64(ir<%96>, ir<%91>, ir<%92>) (using vector intrinsic)
    WIDEN-CALL ir<%98> = call @llvm.fmuladd.f64(ir<%96>, ir<%97>, ir<%93>) (using vector intrinsic)
    WIDEN-CALL ir<%99> = call @llvm.fmuladd.f64(ir<%96>, ir<%98>, ir<%94>) (using vector intrinsic)
    CLONE ir<%arrayidx499> = getelementptr ir<%y>, ir<0>, ir<%indvars.iv.next802>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx499>
    WIDEN store vp<%6>, ir<%99>, vp<%5>
  Successor(s): if.end500

  if.end500:
    EMIT vp<%7> = or vp<%5>, ir<%or.cond790>
    CLONE ir<%tobool475.not> = icmp eq ir<%indvars.iv.next802>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end502.loopexit>, scalar.ph

ir-bb<if.end502.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv801 = phi i64 [ %95, %while.body476.lr.ph ], [ %indvars.iv.next802, %if.end500 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next802 = add nsw i64 %indvars.iv801, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx478 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next802 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %96 = load double, ptr %arrayidx478, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp479 = fcmp ult double %96, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp483 = fcmp ugt double %96, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond790 = or i1 %cmp479, %cmp483 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond790, label %if.end500, label %if.then484 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %97 = call double @llvm.fmuladd.f64(double %96, double %91, double %92) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %98 = call double @llvm.fmuladd.f64(double %96, double %97, double %93) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %99 = call double @llvm.fmuladd.f64(double %96, double %98, double %94) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx499 = getelementptr inbounds [4 x double], ptr %y, i64 0, i64 %indvars.iv.next802 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %99, ptr %arrayidx499, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end500 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool475.not = icmp eq i64 %indvars.iv.next802, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool475.not, label %if.end502.loopexit, label %while.body476 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv801 = phi i64 [ %95, %while.body476.lr.ph ], [ %indvars.iv.next802, %if.end500 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next802 = add nsw i64 %indvars.iv801, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx478 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next802 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %96 = load double, ptr %arrayidx478, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp479 = fcmp ult double %96, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp483 = fcmp ugt double %96, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond790 = or i1 %cmp479, %cmp483 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %or.cond790, label %if.end500, label %if.then484 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %97 = call double @llvm.fmuladd.f64(double %96, double %91, double %92) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %98 = call double @llvm.fmuladd.f64(double %96, double %97, double %93) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %99 = call double @llvm.fmuladd.f64(double %96, double %98, double %94) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx499 = getelementptr inbounds [4 x double], ptr %y, i64 0, i64 %indvars.iv.next802 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 9 for VF 2 For instruction:   store double %99, ptr %arrayidx499, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end500 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool475.not = icmp eq i64 %indvars.iv.next802, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool475.not, label %if.end502.loopexit, label %while.body476 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv801 = phi i64 [ %95, %while.body476.lr.ph ], [ %indvars.iv.next802, %if.end500 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next802 = add nsw i64 %indvars.iv801, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx478 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next802 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %96 = load double, ptr %arrayidx478, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp479 = fcmp ult double %96, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp483 = fcmp ugt double %96, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.cond790 = or i1 %cmp479, %cmp483 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond790, label %if.end500, label %if.then484 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %97 = call double @llvm.fmuladd.f64(double %96, double %91, double %92) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %98 = call double @llvm.fmuladd.f64(double %96, double %97, double %93) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %99 = call double @llvm.fmuladd.f64(double %96, double %98, double %94) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx499 = getelementptr inbounds [4 x double], ptr %y, i64 0, i64 %indvars.iv.next802 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %99, ptr %arrayidx499, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end500 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool475.not = icmp eq i64 %indvars.iv.next802, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool475.not, label %if.end502.loopexit, label %while.body476 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv801 = phi i64 [ %95, %while.body476.lr.ph ], [ %indvars.iv.next802, %if.end500 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next802 = add nsw i64 %indvars.iv801, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx478 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next802 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %96 = load double, ptr %arrayidx478, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp479 = fcmp ult double %96, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp483 = fcmp ugt double %96, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond790 = or i1 %cmp479, %cmp483 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond790, label %if.end500, label %if.then484 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %97 = call double @llvm.fmuladd.f64(double %96, double %91, double %92) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %98 = call double @llvm.fmuladd.f64(double %96, double %97, double %93) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %99 = call double @llvm.fmuladd.f64(double %96, double %98, double %94) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx499 = getelementptr inbounds [4 x double], ptr %y, i64 0, i64 %indvars.iv.next802 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %99, ptr %arrayidx499, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end500 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool475.not = icmp eq i64 %indvars.iv.next802, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool475.not, label %if.end502.loopexit, label %while.body476 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d at line: lathe.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body476.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call472 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%95> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next802> = add vp<%5>, ir<-1>
    CLONE ir<%arrayidx478> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next802>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx478>
    WIDEN ir<%96> = load vp<%6>
    WIDEN ir<%cmp479> = fcmp ult ir<%96>, ir<0.000000e+00>
    WIDEN ir<%cmp483> = fcmp ugt ir<%96>, ir<1.000000e+00>
    WIDEN ir<%or.cond790> = or ir<%cmp479>, ir<%cmp483>
    EMIT vp<%7> = not ir<%or.cond790>
    WIDEN-CALL ir<%97> = call @llvm.fmuladd.f64(ir<%96>, ir<%91>, ir<%92>) (using vector intrinsic)
    WIDEN-CALL ir<%98> = call @llvm.fmuladd.f64(ir<%96>, ir<%97>, ir<%93>) (using vector intrinsic)
    WIDEN-CALL ir<%99> = call @llvm.fmuladd.f64(ir<%96>, ir<%98>, ir<%94>) (using vector intrinsic)
    CLONE ir<%arrayidx499> = getelementptr ir<%y>, ir<0>, ir<%indvars.iv.next802>
    vp<%8> = vector-pointer (reverse) ir<%arrayidx499>
    WIDEN store vp<%8>, ir<%99>, vp<%7>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end502.loopexit>, scalar.ph

ir-bb<if.end502.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2f64
@@ Instruction =>  %84 = load double, ptr %arrayidx440, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  store double %87, ptr %arrayidx460, align 8, !tbaa !20 -> Cost: 9 -> VectorType: <2 x double> -> ttilog -> MaskedMemoryOpCost(8)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  %84 = load double, ptr %arrayidx440, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %87, ptr %arrayidx460, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %84 = load double, ptr %arrayidx440, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %87, ptr %arrayidx460, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call438 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %83, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx440> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next>
    CLONE ir<%84> = load ir<%arrayidx440>
    CLONE ir<%cmp441> = fcmp ult ir<%84>, ir<0.000000e+00>
    CLONE ir<%cmp444> = fcmp ugt ir<%84>, ir<1.000000e+00>
    CLONE ir<%or.cond> = or ir<%cmp441>, ir<%cmp444>
  Successor(s): if.then445

  if.then445:
    EMIT vp<%4> = not ir<%or.cond>
    CLONE ir<%85> = call @llvm.fmuladd.f64(ir<%84>, ir<%79>, ir<%80>)
    CLONE ir<%86> = call @llvm.fmuladd.f64(ir<%84>, ir<%85>, ir<%81>)
    CLONE ir<%87> = call @llvm.fmuladd.f64(ir<%84>, ir<%86>, ir<%82>)
    CLONE ir<%arrayidx460> = getelementptr inbounds ir<%x>, ir<0>, ir<%indvars.iv.next>
    CLONE store ir<%87>, ir<%arrayidx460>, vp<%4>
  Successor(s): if.end461

  if.end461:
    EMIT vp<%5> = or vp<%4>, ir<%or.cond>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call438 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %83, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx440> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx440>
    WIDEN ir<%84> = load vp<%4>
    WIDEN ir<%cmp441> = fcmp ult ir<%84>, ir<0.000000e+00>
    WIDEN ir<%cmp444> = fcmp ugt ir<%84>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = or ir<%cmp441>, ir<%cmp444>
  Successor(s): if.then445

  if.then445:
    EMIT vp<%5> = not ir<%or.cond>
    WIDEN-CALL ir<%85> = call @llvm.fmuladd.f64(ir<%84>, ir<%79>, ir<%80>) (using vector intrinsic)
    WIDEN-CALL ir<%86> = call @llvm.fmuladd.f64(ir<%84>, ir<%85>, ir<%81>) (using vector intrinsic)
    WIDEN-CALL ir<%87> = call @llvm.fmuladd.f64(ir<%84>, ir<%86>, ir<%82>) (using vector intrinsic)
    CLONE ir<%arrayidx460> = getelementptr ir<%x>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx460>
    WIDEN store vp<%6>, ir<%87>, vp<%5>
  Successor(s): if.end461

  if.end461:
    EMIT vp<%7> = or vp<%5>, ir<%or.cond>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call438 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %83, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx440> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx440>
    WIDEN ir<%84> = load vp<%4>
    WIDEN ir<%cmp441> = fcmp ult ir<%84>, ir<0.000000e+00>
    WIDEN ir<%cmp444> = fcmp ugt ir<%84>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = or ir<%cmp441>, ir<%cmp444>
  Successor(s): if.then445

  if.then445:
    EMIT vp<%5> = not ir<%or.cond>
    WIDEN-CALL ir<%85> = call @llvm.fmuladd.f64(ir<%84>, ir<%79>, ir<%80>) (using vector intrinsic)
    WIDEN-CALL ir<%86> = call @llvm.fmuladd.f64(ir<%84>, ir<%85>, ir<%81>) (using vector intrinsic)
    WIDEN-CALL ir<%87> = call @llvm.fmuladd.f64(ir<%84>, ir<%86>, ir<%82>) (using vector intrinsic)
    CLONE ir<%arrayidx460> = getelementptr ir<%x>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx460>
    WIDEN store vp<%6>, ir<%87>, vp<%5>
  Successor(s): if.end461

  if.end461:
    EMIT vp<%7> = or vp<%5>, ir<%or.cond>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %83, %while.body.lr.ph ], [ %indvars.iv.next, %if.end461 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx440 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %84 = load double, ptr %arrayidx440, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp441 = fcmp ult double %84, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp444 = fcmp ugt double %84, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond = or i1 %cmp441, %cmp444 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond, label %if.end461, label %if.then445 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %85 = call double @llvm.fmuladd.f64(double %84, double %79, double %80) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %86 = call double @llvm.fmuladd.f64(double %84, double %85, double %81) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %87 = call double @llvm.fmuladd.f64(double %84, double %86, double %82) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx460 = getelementptr inbounds [4 x double], ptr %x, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %87, ptr %arrayidx460, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end461 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %83, %while.body.lr.ph ], [ %indvars.iv.next, %if.end461 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx440 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %84 = load double, ptr %arrayidx440, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp441 = fcmp ult double %84, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp444 = fcmp ugt double %84, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond = or i1 %cmp441, %cmp444 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %or.cond, label %if.end461, label %if.then445 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %85 = call double @llvm.fmuladd.f64(double %84, double %79, double %80) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %86 = call double @llvm.fmuladd.f64(double %84, double %85, double %81) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %87 = call double @llvm.fmuladd.f64(double %84, double %86, double %82) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx460 = getelementptr inbounds [4 x double], ptr %x, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 9 for VF 2 For instruction:   store double %87, ptr %arrayidx460, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end461 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %83, %while.body.lr.ph ], [ %indvars.iv.next, %if.end461 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx440 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %84 = load double, ptr %arrayidx440, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp441 = fcmp ult double %84, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp444 = fcmp ugt double %84, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.cond = or i1 %cmp441, %cmp444 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond, label %if.end461, label %if.then445 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %85 = call double @llvm.fmuladd.f64(double %84, double %79, double %80) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %86 = call double @llvm.fmuladd.f64(double %84, double %85, double %81) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %87 = call double @llvm.fmuladd.f64(double %84, double %86, double %82) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx460 = getelementptr inbounds [4 x double], ptr %x, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %87, ptr %arrayidx460, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end461 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %83, %while.body.lr.ph ], [ %indvars.iv.next, %if.end461 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx440 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %84 = load double, ptr %arrayidx440, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp441 = fcmp ult double %84, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp444 = fcmp ugt double %84, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond = or i1 %cmp441, %cmp444 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond, label %if.end461, label %if.then445 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %85 = call double @llvm.fmuladd.f64(double %84, double %79, double %80) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %86 = call double @llvm.fmuladd.f64(double %84, double %85, double %81) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %87 = call double @llvm.fmuladd.f64(double %84, double %86, double %82) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx460 = getelementptr inbounds [4 x double], ptr %x, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %87, ptr %arrayidx460, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end461 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov13Compute_LatheEPNS_12Lathe_StructEPA2_d at line: lathe.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call438 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%83> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add vp<%5>, ir<-1>
    CLONE ir<%arrayidx440> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx440>
    WIDEN ir<%84> = load vp<%6>
    WIDEN ir<%cmp441> = fcmp ult ir<%84>, ir<0.000000e+00>
    WIDEN ir<%cmp444> = fcmp ugt ir<%84>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = or ir<%cmp441>, ir<%cmp444>
    EMIT vp<%7> = not ir<%or.cond>
    WIDEN-CALL ir<%85> = call @llvm.fmuladd.f64(ir<%84>, ir<%79>, ir<%80>) (using vector intrinsic)
    WIDEN-CALL ir<%86> = call @llvm.fmuladd.f64(ir<%84>, ir<%85>, ir<%81>) (using vector intrinsic)
    WIDEN-CALL ir<%87> = call @llvm.fmuladd.f64(ir<%84>, ir<%86>, ir<%82>) (using vector intrinsic)
    CLONE ir<%arrayidx460> = getelementptr ir<%x>, ir<0>, ir<%indvars.iv.next>
    vp<%8> = vector-pointer (reverse) ir<%arrayidx460>
    WIDEN store vp<%8>, ir<%87>, vp<%7>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: v2f64
@@ Instruction =>  %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 -> Cost: 4 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 -> Cost: 4 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call48 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi %27, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%NC.1134> = phi ir<%NC.0137>, ir<%NC.2>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx50> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next>
    CLONE ir<%28> = load ir<%arrayidx50>
    CLONE ir<%cmp51> = fcmp oge ir<%28>, ir<0.000000e+00>
    CLONE ir<%cmp53> = fcmp ole ir<%28>, ir<1.000000e+00>
    CLONE ir<%or.cond> = and ir<%cmp51>, ir<%cmp53>
  Successor(s): if.then54

  if.then54:
    CLONE ir<%29> = load ir<%arrayidx20>, ir<%or.cond>
    CLONE ir<%30> = load ir<%B>, ir<%or.cond>
    CLONE ir<%31> = call @llvm.fmuladd.f64(ir<%28>, ir<%29>, ir<%30>)
    CLONE ir<%32> = load ir<%C>, ir<%or.cond>
    CLONE ir<%33> = call @llvm.fmuladd.f64(ir<%28>, ir<%31>, ir<%32>)
    CLONE ir<%34> = load ir<%D>, ir<%or.cond>
    CLONE ir<%35> = call @llvm.fmuladd.f64(ir<%28>, ir<%33>, ir<%34>)
    CLONE ir<%sub63> = fsub ir<%35>, ir<%sqrt>
    CLONE ir<%cmp64> = fcmp ult ir<%sub63>, ir<0.000000e+00>
  Successor(s): if.then65

  if.then65:
    EMIT vp<%4> = not ir<%cmp64>
    EMIT vp<%5> = logical-and ir<%or.cond>, vp<%4>
    CLONE ir<%inc> = add ir<%NC.1134>, ir<1>
  Successor(s): if.end66

  if.end66:
    EMIT vp<%6> = logical-and ir<%or.cond>, ir<%cmp64>
    EMIT vp<%7> = or vp<%6>, vp<%5>
    EMIT vp<%8> = not ir<%or.cond>
    EMIT vp<%9> = or vp<%7>, vp<%8>
    BLEND ir<%NC.2> = ir<%inc> ir<%NC.1134>/vp<%6> ir<%NC.1134>/vp<%8>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = compute-reduction-result ir<%NC.1134>, ir<%NC.2>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<for.inc.loopexit>, scalar.ph

ir-bb<for.inc.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %NC.2.lcssa = vp<%12>
}

========== Loop: _ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call48 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%11>
    WIDEN-INDUCTION %indvars.iv = phi %27, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%NC.1134> = phi ir<%NC.0137>, ir<%NC.2>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx50> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx50>
    WIDEN ir<%28> = load vp<%4>
    WIDEN ir<%cmp51> = fcmp oge ir<%28>, ir<0.000000e+00>
    WIDEN ir<%cmp53> = fcmp ole ir<%28>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = and ir<%cmp51>, ir<%cmp53>
  Successor(s): if.then54

  if.then54:
    REPLICATE ir<%29> = load ir<%arrayidx20>, ir<%or.cond>
    REPLICATE ir<%30> = load ir<%B>, ir<%or.cond>
    WIDEN-CALL ir<%31> = call @llvm.fmuladd.f64(ir<%28>, ir<%29>, ir<%30>) (using vector intrinsic)
    REPLICATE ir<%32> = load ir<%C>, ir<%or.cond>
    WIDEN-CALL ir<%33> = call @llvm.fmuladd.f64(ir<%28>, ir<%31>, ir<%32>) (using vector intrinsic)
    REPLICATE ir<%34> = load ir<%D>, ir<%or.cond>
    WIDEN-CALL ir<%35> = call @llvm.fmuladd.f64(ir<%28>, ir<%33>, ir<%34>) (using vector intrinsic)
    WIDEN ir<%sub63> = fsub ir<%35>, ir<%sqrt>
    WIDEN ir<%cmp64> = fcmp ult ir<%sub63>, ir<0.000000e+00>
  Successor(s): if.then65

  if.then65:
    EMIT vp<%5> = not ir<%cmp64>
    EMIT vp<%6> = logical-and ir<%or.cond>, vp<%5>
    WIDEN ir<%inc> = add ir<%NC.1134>, ir<1>
  Successor(s): if.end66

  if.end66:
    EMIT vp<%7> = logical-and ir<%or.cond>, ir<%cmp64>
    EMIT vp<%8> = or vp<%7>, vp<%6>
    EMIT vp<%9> = not ir<%or.cond>
    EMIT vp<%10> = or vp<%8>, vp<%9>
    BLEND ir<%NC.2> = ir<%inc> ir<%NC.1134>/vp<%7> ir<%NC.1134>/vp<%9>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%11> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = compute-reduction-result ir<%NC.1134>, ir<%NC.2>
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.inc.loopexit>, scalar.ph

ir-bb<for.inc.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %NC.2.lcssa = vp<%13>
}

========== Loop: _ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call48 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%11>
    WIDEN-INDUCTION %indvars.iv = phi %27, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%NC.1134> = phi ir<%NC.0137>, ir<%NC.2>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx50> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx50>
    WIDEN ir<%28> = load vp<%4>
    WIDEN ir<%cmp51> = fcmp oge ir<%28>, ir<0.000000e+00>
    WIDEN ir<%cmp53> = fcmp ole ir<%28>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = and ir<%cmp51>, ir<%cmp53>
  Successor(s): if.then54

  if.then54:
    REPLICATE ir<%29> = load ir<%arrayidx20>, ir<%or.cond>
    REPLICATE ir<%30> = load ir<%B>, ir<%or.cond>
    WIDEN-CALL ir<%31> = call @llvm.fmuladd.f64(ir<%28>, ir<%29>, ir<%30>) (using vector intrinsic)
    REPLICATE ir<%32> = load ir<%C>, ir<%or.cond>
    WIDEN-CALL ir<%33> = call @llvm.fmuladd.f64(ir<%28>, ir<%31>, ir<%32>) (using vector intrinsic)
    REPLICATE ir<%34> = load ir<%D>, ir<%or.cond>
    WIDEN-CALL ir<%35> = call @llvm.fmuladd.f64(ir<%28>, ir<%33>, ir<%34>) (using vector intrinsic)
    WIDEN ir<%sub63> = fsub ir<%35>, ir<%sqrt>
    WIDEN ir<%cmp64> = fcmp ult ir<%sub63>, ir<0.000000e+00>
  Successor(s): if.then65

  if.then65:
    EMIT vp<%5> = not ir<%cmp64>
    EMIT vp<%6> = logical-and ir<%or.cond>, vp<%5>
    WIDEN ir<%inc> = add ir<%NC.1134>, ir<1>
  Successor(s): if.end66

  if.end66:
    EMIT vp<%7> = logical-and ir<%or.cond>, ir<%cmp64>
    EMIT vp<%8> = or vp<%7>, vp<%6>
    EMIT vp<%9> = not ir<%or.cond>
    EMIT vp<%10> = or vp<%8>, vp<%9>
    BLEND ir<%NC.2> = ir<%inc> ir<%NC.1134>/vp<%7> ir<%NC.1134>/vp<%9>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%11> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = compute-reduction-result ir<%NC.1134>, ir<%NC.2>
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.inc.loopexit>, scalar.ph

ir-bb<for.inc.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %NC.2.lcssa = vp<%13>
}

========== Loop: _ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call48 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%11>
    WIDEN-INDUCTION %indvars.iv = phi %27, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%NC.1134> = phi ir<%NC.0137>, ir<%NC.2>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx50> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx50>
    WIDEN ir<%28> = load vp<%4>
    WIDEN ir<%cmp51> = fcmp oge ir<%28>, ir<0.000000e+00>
    WIDEN ir<%cmp53> = fcmp ole ir<%28>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = and ir<%cmp51>, ir<%cmp53>
  Successor(s): if.then54

  if.then54:
    WIDEN ir<%29> = load ir<%arrayidx20>, ir<%or.cond>
    WIDEN ir<%30> = load ir<%B>, ir<%or.cond>
    WIDEN-CALL ir<%31> = call @llvm.fmuladd.f64(ir<%28>, ir<%29>, ir<%30>) (using vector intrinsic)
    WIDEN ir<%32> = load ir<%C>, ir<%or.cond>
    WIDEN-CALL ir<%33> = call @llvm.fmuladd.f64(ir<%28>, ir<%31>, ir<%32>) (using vector intrinsic)
    WIDEN ir<%34> = load ir<%D>, ir<%or.cond>
    WIDEN-CALL ir<%35> = call @llvm.fmuladd.f64(ir<%28>, ir<%33>, ir<%34>) (using vector intrinsic)
    WIDEN ir<%sub63> = fsub ir<%35>, ir<%sqrt>
    WIDEN ir<%cmp64> = fcmp ult ir<%sub63>, ir<0.000000e+00>
  Successor(s): if.then65

  if.then65:
    EMIT vp<%5> = not ir<%cmp64>
    EMIT vp<%6> = logical-and ir<%or.cond>, vp<%5>
    WIDEN ir<%inc> = add ir<%NC.1134>, ir<1>
  Successor(s): if.end66

  if.end66:
    EMIT vp<%7> = logical-and ir<%or.cond>, ir<%cmp64>
    EMIT vp<%8> = or vp<%7>, vp<%6>
    EMIT vp<%9> = not ir<%or.cond>
    EMIT vp<%10> = or vp<%8>, vp<%9>
    BLEND ir<%NC.2> = ir<%inc> ir<%NC.1134>/vp<%7> ir<%NC.1134>/vp<%9>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%11> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = compute-reduction-result ir<%NC.1134>, ir<%NC.2>
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.inc.loopexit>, scalar.ph

ir-bb<for.inc.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %NC.2.lcssa = vp<%13>
}


-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %27, %while.body.preheader ], [ %indvars.iv.next, %if.end66 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %NC.1134 = phi i32 [ %NC.0137, %while.body.preheader ], [ %NC.2, %if.end66 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx50 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp51 = fcmp oge double %28, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp53 = fcmp ole double %28, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond = and i1 %cmp51, %cmp53 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond, label %if.then54, label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %29 = load double, ptr %arrayidx20, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %30 = load double, ptr %B, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %31 = call double @llvm.fmuladd.f64(double %28, double %29, double %30) of type:call
LV: Found an estimated cost of 2 for VF 1 For instruction:   %32 = load double, ptr %C, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %33 = call double @llvm.fmuladd.f64(double %28, double %31, double %32) of type:call
LV: Found an estimated cost of 2 for VF 1 For instruction:   %34 = load double, ptr %D, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %35 = call double @llvm.fmuladd.f64(double %28, double %33, double %34) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub63 = fsub double %35, %sqrt of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp64 = fcmp ult double %sub63, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp64, label %if.end66, label %if.then65 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %NC.1134, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %NC.2 = phi i32 [ %inc, %if.then65 ], [ %NC.1134, %if.then54 ], [ %NC.1134, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Scalar loop costs: 13.
-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %27, %while.body.preheader ], [ %indvars.iv.next, %if.end66 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %NC.1134 = phi i32 [ %NC.0137, %while.body.preheader ], [ %NC.2, %if.end66 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx50 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp51 = fcmp oge double %28, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp53 = fcmp ole double %28, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond = and i1 %cmp51, %cmp53 of type:and
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %or.cond, label %if.then54, label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %29 = load double, ptr %arrayidx20, align 8, !tbaa !22 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %30 = load double, ptr %B, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %31 = call double @llvm.fmuladd.f64(double %28, double %29, double %30) of type:call
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %32 = load double, ptr %C, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %33 = call double @llvm.fmuladd.f64(double %28, double %31, double %32) of type:call
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %34 = load double, ptr %D, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %35 = call double @llvm.fmuladd.f64(double %28, double %33, double %34) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub63 = fsub double %35, %sqrt of type:fsub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp64 = fcmp ult double %sub63, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp64, label %if.end66, label %if.then65 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %NC.1134, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 12 for VF 2 For instruction:   %NC.2 = phi i32 [ %inc, %if.then65 ], [ %NC.1134, %if.then54 ], [ %NC.1134, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 6000014
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12000029
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 12000029, CostB * EstimatedWidthA: 26
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12000029
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 12000029, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %27, %while.body.preheader ], [ %indvars.iv.next, %if.end66 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %NC.1134 = phi i32 [ %NC.0137, %while.body.preheader ], [ %NC.2, %if.end66 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx50 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp51 = fcmp oge double %28, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp53 = fcmp ole double %28, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond = and i1 %cmp51, %cmp53 of type:and
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %or.cond, label %if.then54, label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %29 = load double, ptr %arrayidx20, align 8, !tbaa !22 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %30 = load double, ptr %B, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 4 for VF 4 For instruction:   %31 = call double @llvm.fmuladd.f64(double %28, double %29, double %30) of type:call
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %32 = load double, ptr %C, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 4 for VF 4 For instruction:   %33 = call double @llvm.fmuladd.f64(double %28, double %31, double %32) of type:call
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %34 = load double, ptr %D, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 4 for VF 4 For instruction:   %35 = call double @llvm.fmuladd.f64(double %28, double %33, double %34) of type:call
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub63 = fsub double %35, %sqrt of type:fsub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp64 = fcmp ult double %sub63, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp64, label %if.end66, label %if.then65 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nsw i32 %NC.1134, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 24 for VF 4 For instruction:   %NC.2 = phi i32 [ %inc, %if.then65 ], [ %NC.1134, %if.then54 ], [ %NC.1134, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 3000015
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12000060
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 12000060, CostB * EstimatedWidthA: 52
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12000060
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 12000060, CostB * EstimatedWidthA: 52

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %27, %while.body.preheader ], [ %indvars.iv.next, %if.end66 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %NC.1134 = phi i32 [ %NC.0137, %while.body.preheader ], [ %NC.2, %if.end66 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx50 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp51 = fcmp oge double %28, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp53 = fcmp ole double %28, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.cond = and i1 %cmp51, %cmp53 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond, label %if.then54, label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %29 = load double, ptr %arrayidx20, align 8, !tbaa !22 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %30 = load double, ptr %B, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %31 = call double @llvm.fmuladd.f64(double %28, double %29, double %30) of type:call
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %32 = load double, ptr %C, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %33 = call double @llvm.fmuladd.f64(double %28, double %31, double %32) of type:call
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %34 = load double, ptr %D, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %35 = call double @llvm.fmuladd.f64(double %28, double %33, double %34) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub63 = fsub double %35, %sqrt of type:fsub
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp64 = fcmp ult double %sub63, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp64, label %if.end66, label %if.then65 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nsw i32 %NC.1134, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %NC.2 = phi i32 [ %inc, %if.then65 ], [ %NC.1134, %if.then54 ], [ %NC.1134, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 26
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %27, %while.body.preheader ], [ %indvars.iv.next, %if.end66 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %NC.1134 = phi i32 [ %NC.0137, %while.body.preheader ], [ %NC.2, %if.end66 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx50 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %28 = load double, ptr %arrayidx50, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp51 = fcmp oge double %28, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp53 = fcmp ole double %28, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond = and i1 %cmp51, %cmp53 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond, label %if.then54, label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %29 = load double, ptr %arrayidx20, align 8, !tbaa !22 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %30 = load double, ptr %B, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %31 = call double @llvm.fmuladd.f64(double %28, double %29, double %30) of type:call
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %32 = load double, ptr %C, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %33 = call double @llvm.fmuladd.f64(double %28, double %31, double %32) of type:call
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %34 = load double, ptr %D, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %35 = call double @llvm.fmuladd.f64(double %28, double %33, double %34) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub63 = fsub double %35, %sqrt of type:fsub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp64 = fcmp ult double %sub63, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp64, label %if.end66, label %if.then65 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %NC.1134, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end66 of type:br

-----------------Function that is being costed:'_ZN3povL12Inside_LatheEPdPNS_13Object_StructE' from lathe.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %NC.2 = phi i32 [ %inc, %if.then65 ], [ %NC.1134, %if.then54 ], [ %NC.1134, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 45
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 182
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 182, CostB * EstimatedWidthA: 52
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 182
B VF: 1, EstimatedWidthB: 1, CostB: 13
CostA * EstimatedWidthB: 182, CostB * EstimatedWidthA: 52
LV: Selecting VF: 1 With Cost: 13.
maxbefore: 2
maxafter: 2
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lbuffer.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           lbuffer.cpp
========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body144.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %31 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx146> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv>
    CLONE ir<%32> = load ir<%arrayidx146>
    CLONE ir<%33> = load ir<%Origin>
    CLONE ir<%sub149> = fsub ir<%32>, ir<%33>
    CLONE ir<%arrayidx151> = getelementptr inbounds ir<%Points>, ir<%indvars.iv>
    CLONE store ir<%sub149>, ir<%arrayidx151>
    CLONE ir<%arrayidx155> = getelementptr inbounds ir<%arrayidx146>, ir<8>
    CLONE ir<%34> = load ir<%arrayidx155>
    CLONE ir<%35> = load ir<%arrayidx156>
    CLONE ir<%sub157> = fsub ir<%34>, ir<%35>
    CLONE ir<%arrayidx160> = getelementptr inbounds ir<%arrayidx151>, ir<8>
    CLONE store ir<%sub157>, ir<%arrayidx160>
    CLONE ir<%arrayidx163> = getelementptr inbounds ir<%arrayidx146>, ir<16>
    CLONE ir<%36> = load ir<%arrayidx163>
    CLONE ir<%37> = load ir<%arrayidx164>
    CLONE ir<%sub165> = fsub ir<%36>, ir<%37>
    CLONE ir<%mul166> = fmul ir<%Direction.0>, ir<%sub165>
    CLONE ir<%arrayidx169> = getelementptr inbounds ir<%arrayidx151>, ir<16>
    CLONE store ir<%mul166>, ir<%arrayidx169>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit273>, scalar.ph

ir-bb<sw.epilog.loopexit273>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body144.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %31 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx146> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv>
    INTERLEAVE-GROUP with factor 3 at %32, ir<%arrayidx146>
      ir<%32> = load from index 0
      ir<%34> = load from index 1
      ir<%36> = load from index 2
    CLONE ir<%33> = load ir<%Origin>
    WIDEN ir<%sub149> = fsub ir<%32>, ir<%33>
    CLONE ir<%arrayidx151> = getelementptr inbounds ir<%Points>, ir<%indvars.iv>
    CLONE ir<%arrayidx155> = getelementptr inbounds ir<%arrayidx146>, ir<8>
    CLONE ir<%35> = load ir<%arrayidx156>
    WIDEN ir<%sub157> = fsub ir<%34>, ir<%35>
    CLONE ir<%arrayidx160> = getelementptr inbounds ir<%arrayidx151>, ir<8>
    CLONE ir<%arrayidx163> = getelementptr inbounds ir<%arrayidx146>, ir<16>
    CLONE ir<%37> = load ir<%arrayidx164>
    WIDEN ir<%sub165> = fsub ir<%36>, ir<%37>
    WIDEN ir<%mul166> = fmul ir<%Direction.0>, ir<%sub165>
    CLONE ir<%arrayidx169> = getelementptr inbounds ir<%arrayidx151>, ir<16>
    INTERLEAVE-GROUP with factor 3 at <badref>, ir<%arrayidx169>
      store ir<%sub149> to index 0
      store ir<%sub157> to index 1
      store ir<%mul166> to index 2
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit273>, scalar.ph

ir-bb<sw.epilog.loopexit273>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body144.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %31 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx146> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv>
    REPLICATE ir<%32> = load ir<%arrayidx146>
    CLONE ir<%33> = load ir<%Origin>
    WIDEN ir<%sub149> = fsub ir<%32>, ir<%33>
    WIDEN-GEP Inv[Var] ir<%arrayidx151> = getelementptr inbounds ir<%Points>, ir<%indvars.iv>
    REPLICATE store ir<%sub149>, ir<%arrayidx151>
    WIDEN-GEP Var[Inv] ir<%arrayidx155> = getelementptr inbounds ir<%arrayidx146>, ir<8>
    REPLICATE ir<%34> = load ir<%arrayidx155>
    CLONE ir<%35> = load ir<%arrayidx156>
    WIDEN ir<%sub157> = fsub ir<%34>, ir<%35>
    WIDEN-GEP Var[Inv] ir<%arrayidx160> = getelementptr inbounds ir<%arrayidx151>, ir<8>
    REPLICATE store ir<%sub157>, ir<%arrayidx160>
    WIDEN-GEP Var[Inv] ir<%arrayidx163> = getelementptr inbounds ir<%arrayidx146>, ir<16>
    REPLICATE ir<%36> = load ir<%arrayidx163>
    CLONE ir<%37> = load ir<%arrayidx164>
    WIDEN ir<%sub165> = fsub ir<%36>, ir<%37>
    WIDEN ir<%mul166> = fmul ir<%Direction.0>, ir<%sub165>
    WIDEN-GEP Var[Inv] ir<%arrayidx169> = getelementptr inbounds ir<%arrayidx151>, ir<16>
    REPLICATE store ir<%mul166>, ir<%arrayidx169>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit273>, scalar.ph

ir-bb<sw.epilog.loopexit273>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body144.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %31 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx146> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv>
    WIDEN ir<%32> = load ir<%arrayidx146>
    CLONE ir<%33> = load ir<%Origin>
    WIDEN ir<%sub149> = fsub ir<%32>, ir<%33>
    WIDEN-GEP Inv[Var] ir<%arrayidx151> = getelementptr inbounds ir<%Points>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx151>, ir<%sub149>
    WIDEN-GEP Var[Inv] ir<%arrayidx155> = getelementptr inbounds ir<%arrayidx146>, ir<8>
    WIDEN ir<%34> = load ir<%arrayidx155>
    CLONE ir<%35> = load ir<%arrayidx156>
    WIDEN ir<%sub157> = fsub ir<%34>, ir<%35>
    WIDEN-GEP Var[Inv] ir<%arrayidx160> = getelementptr inbounds ir<%arrayidx151>, ir<8>
    WIDEN store ir<%arrayidx160>, ir<%sub157>
    WIDEN-GEP Var[Inv] ir<%arrayidx163> = getelementptr inbounds ir<%arrayidx146>, ir<16>
    WIDEN ir<%36> = load ir<%arrayidx163>
    CLONE ir<%37> = load ir<%arrayidx164>
    WIDEN ir<%sub165> = fsub ir<%36>, ir<%37>
    WIDEN ir<%mul166> = fmul ir<%Direction.0>, ir<%sub165>
    WIDEN-GEP Var[Inv] ir<%arrayidx169> = getelementptr inbounds ir<%arrayidx151>, ir<16>
    WIDEN store ir<%arrayidx169>, ir<%mul166>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit273>, scalar.ph

ir-bb<sw.epilog.loopexit273>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body144.lr.ph ], [ %indvars.iv.next, %for.body144 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx146 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %32 = load double, ptr %arrayidx146, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %33 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub149 = fsub double %32, %33 of type:fsub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx151 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub149, ptr %arrayidx151, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx155 = getelementptr inbounds i8, ptr %arrayidx146, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %34 = load double, ptr %arrayidx155, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %35 = load double, ptr %arrayidx156, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub157 = fsub double %34, %35 of type:fsub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx160 = getelementptr inbounds i8, ptr %arrayidx151, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub157, ptr %arrayidx160, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx163 = getelementptr inbounds i8, ptr %arrayidx146, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %36 = load double, ptr %arrayidx163, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %37 = load double, ptr %arrayidx164, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub165 = fsub double %36, %37 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul166 = fmul double %Direction.0, %sub165 of type:fmul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx169 = getelementptr inbounds i8, ptr %arrayidx151, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul166, ptr %arrayidx169, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit273, label %for.body144 of type:br
LV: Scalar loop costs: 25.
-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body144.lr.ph ], [ %indvars.iv.next, %for.body144 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx146 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   %32 = load double, ptr %arrayidx146, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %33 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub149 = fsub double %32, %33 of type:fsub
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx151 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store double %sub149, ptr %arrayidx151, align 8, !tbaa !16 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %34 = load double, ptr %arrayidx155, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %35 = load double, ptr %arrayidx156, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub157 = fsub double %34, %35 of type:fsub
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store double %sub157, ptr %arrayidx160, align 8, !tbaa !16 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %36 = load double, ptr %arrayidx163, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %37 = load double, ptr %arrayidx164, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub165 = fsub double %36, %37 of type:fsub
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul166 = fmul double %Direction.0, %sub165 of type:fmul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx169 = getelementptr inbounds i8, ptr %arrayidx151, i64 16 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   store double %mul166, ptr %arrayidx169, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit273, label %for.body144 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 20401094662, RTCostB: 53687091175
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 20401094662, RTCostB: 53687091175
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body144.lr.ph ], [ %indvars.iv.next, %for.body144 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx146 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %32 = load double, ptr %arrayidx146, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %33 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub149 = fsub double %32, %33 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx151 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store double %sub149, ptr %arrayidx151, align 8, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %34 = load double, ptr %arrayidx155, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %35 = load double, ptr %arrayidx156, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub157 = fsub double %34, %35 of type:fsub
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store double %sub157, ptr %arrayidx160, align 8, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %36 = load double, ptr %arrayidx163, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %37 = load double, ptr %arrayidx164, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub165 = fsub double %36, %37 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul166 = fmul double %Direction.0, %sub165 of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx169 = getelementptr inbounds i8, ptr %arrayidx151, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul166, ptr %arrayidx169, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit273, label %for.body144 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 53687091175
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 20401094662

-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body144.lr.ph ], [ %indvars.iv.next, %for.body144 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx146 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 123 for VF vscale x 2 For instruction:   %32 = load double, ptr %arrayidx146, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %33 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub149 = fsub double %32, %33 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx151 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store double %sub149, ptr %arrayidx151, align 8, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %34 = load double, ptr %arrayidx155, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %35 = load double, ptr %arrayidx156, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub157 = fsub double %34, %35 of type:fsub
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store double %sub157, ptr %arrayidx160, align 8, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %36 = load double, ptr %arrayidx163, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %37 = load double, ptr %arrayidx164, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub165 = fsub double %36, %37 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul166 = fmul double %Direction.0, %sub165 of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx169 = getelementptr inbounds i8, ptr %arrayidx151, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 123 for VF vscale x 2 For instruction:   store double %mul166, ptr %arrayidx169, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %sw.epilog.loopexit273, label %for.body144 of type:br
LV: Vector loop of width vscale x 2 costs: 64
A is scalable.	B is not scalable.	
RTCostA: 139049566024, RTCostB: 53687091175
A is scalable.	B is not scalable.	
RTCostA: 139049566024, RTCostB: 20401094662
LV: Selecting VF: 2 With Cost: 9.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd at line: lbuffer.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body144.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %31 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx146> = getelementptr inbounds ir<%H>, ir<0>, vp<%4>
    INTERLEAVE-GROUP with factor 3 at %33, ir<%arrayidx146>
      ir<%33> = load from index 0
      ir<%35> = load from index 1
      ir<%37> = load from index 2
    CLONE ir<%34> = load ir<%Origin>
    WIDEN ir<%sub149> = fsub ir<%33>, ir<%34>
    CLONE ir<%arrayidx151> = getelementptr inbounds ir<%Points>, vp<%4>
    CLONE ir<%36> = load ir<%arrayidx156>
    WIDEN ir<%sub157> = fsub ir<%35>, ir<%36>
    CLONE ir<%38> = load ir<%arrayidx164>
    WIDEN ir<%sub165> = fsub ir<%37>, ir<%38>
    WIDEN ir<%mul166> = fmul ir<%Direction.0>, ir<%sub165>
    CLONE ir<%arrayidx169> = getelementptr inbounds ir<%arrayidx151>, ir<16>
    INTERLEAVE-GROUP with factor 3 at <badref>, ir<%arrayidx169>
      store ir<%sub149> to index 0
      store ir<%sub157> to index 1
      store ir<%mul166> to index 2
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<sw.epilog.loopexit273>, scalar.ph

ir-bb<sw.epilog.loopexit273>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body112.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %24 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv260 = phi 0, %indvars.iv.next261, ir<1>
    CLONE ir<%arrayidx114> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv260>
    CLONE ir<%25> = load ir<%arrayidx114>
    CLONE ir<%26> = load ir<%Origin>
    CLONE ir<%sub117> = fsub ir<%25>, ir<%26>
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%Points>, ir<%indvars.iv260>
    CLONE store ir<%sub117>, ir<%arrayidx119>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%arrayidx114>, ir<16>
    CLONE ir<%27> = load ir<%arrayidx123>
    CLONE ir<%28> = load ir<%arrayidx124>
    CLONE ir<%sub125> = fsub ir<%27>, ir<%28>
    CLONE ir<%arrayidx128> = getelementptr inbounds ir<%arrayidx119>, ir<8>
    CLONE store ir<%sub125>, ir<%arrayidx128>
    CLONE ir<%arrayidx131> = getelementptr inbounds ir<%arrayidx114>, ir<8>
    CLONE ir<%29> = load ir<%arrayidx131>
    CLONE ir<%30> = load ir<%arrayidx132>
    CLONE ir<%sub133> = fsub ir<%29>, ir<%30>
    CLONE ir<%mul134> = fmul ir<%Direction.0>, ir<%sub133>
    CLONE ir<%arrayidx137> = getelementptr inbounds ir<%arrayidx119>, ir<16>
    CLONE store ir<%mul134>, ir<%arrayidx137>
    CLONE ir<%indvars.iv.next261> = add nuw nsw ir<%indvars.iv260>, ir<1>
    CLONE ir<%exitcond264.not> = icmp eq ir<%indvars.iv.next261>, ir<%wide.trip.count263>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit272>, scalar.ph

ir-bb<sw.epilog.loopexit272>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body112.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %24 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv260 = phi 0, %indvars.iv.next261, ir<1>
    CLONE ir<%arrayidx114> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv260>
    INTERLEAVE-GROUP with factor 3 at %25, ir<%arrayidx114>
      ir<%25> = load from index 0
      ir<%29> = load from index 1
      ir<%27> = load from index 2
    CLONE ir<%26> = load ir<%Origin>
    WIDEN ir<%sub117> = fsub ir<%25>, ir<%26>
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%Points>, ir<%indvars.iv260>
    CLONE ir<%arrayidx123> = getelementptr inbounds ir<%arrayidx114>, ir<16>
    CLONE ir<%28> = load ir<%arrayidx124>
    WIDEN ir<%sub125> = fsub ir<%27>, ir<%28>
    CLONE ir<%arrayidx128> = getelementptr inbounds ir<%arrayidx119>, ir<8>
    CLONE ir<%arrayidx131> = getelementptr inbounds ir<%arrayidx114>, ir<8>
    CLONE ir<%30> = load ir<%arrayidx132>
    WIDEN ir<%sub133> = fsub ir<%29>, ir<%30>
    WIDEN ir<%mul134> = fmul ir<%Direction.0>, ir<%sub133>
    CLONE ir<%arrayidx137> = getelementptr inbounds ir<%arrayidx119>, ir<16>
    INTERLEAVE-GROUP with factor 3 at <badref>, ir<%arrayidx137>
      store ir<%sub117> to index 0
      store ir<%sub125> to index 1
      store ir<%mul134> to index 2
    CLONE ir<%indvars.iv.next261> = add nuw nsw ir<%indvars.iv260>, ir<1>
    CLONE ir<%exitcond264.not> = icmp eq ir<%indvars.iv.next261>, ir<%wide.trip.count263>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit272>, scalar.ph

ir-bb<sw.epilog.loopexit272>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body112.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %24 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv260 = phi 0, %indvars.iv.next261, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx114> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv260>
    REPLICATE ir<%25> = load ir<%arrayidx114>
    CLONE ir<%26> = load ir<%Origin>
    WIDEN ir<%sub117> = fsub ir<%25>, ir<%26>
    WIDEN-GEP Inv[Var] ir<%arrayidx119> = getelementptr inbounds ir<%Points>, ir<%indvars.iv260>
    REPLICATE store ir<%sub117>, ir<%arrayidx119>
    WIDEN-GEP Var[Inv] ir<%arrayidx123> = getelementptr inbounds ir<%arrayidx114>, ir<16>
    REPLICATE ir<%27> = load ir<%arrayidx123>
    CLONE ir<%28> = load ir<%arrayidx124>
    WIDEN ir<%sub125> = fsub ir<%27>, ir<%28>
    WIDEN-GEP Var[Inv] ir<%arrayidx128> = getelementptr inbounds ir<%arrayidx119>, ir<8>
    REPLICATE store ir<%sub125>, ir<%arrayidx128>
    WIDEN-GEP Var[Inv] ir<%arrayidx131> = getelementptr inbounds ir<%arrayidx114>, ir<8>
    REPLICATE ir<%29> = load ir<%arrayidx131>
    CLONE ir<%30> = load ir<%arrayidx132>
    WIDEN ir<%sub133> = fsub ir<%29>, ir<%30>
    WIDEN ir<%mul134> = fmul ir<%Direction.0>, ir<%sub133>
    WIDEN-GEP Var[Inv] ir<%arrayidx137> = getelementptr inbounds ir<%arrayidx119>, ir<16>
    REPLICATE store ir<%mul134>, ir<%arrayidx137>
    WIDEN ir<%indvars.iv.next261> = add nuw nsw ir<%indvars.iv260>, ir<1>
    CLONE ir<%exitcond264.not> = icmp eq ir<%indvars.iv.next261>, ir<%wide.trip.count263>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit272>, scalar.ph

ir-bb<sw.epilog.loopexit272>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body112.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %24 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv260 = phi 0, %indvars.iv.next261, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx114> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv260>
    WIDEN ir<%25> = load ir<%arrayidx114>
    CLONE ir<%26> = load ir<%Origin>
    WIDEN ir<%sub117> = fsub ir<%25>, ir<%26>
    WIDEN-GEP Inv[Var] ir<%arrayidx119> = getelementptr inbounds ir<%Points>, ir<%indvars.iv260>
    WIDEN store ir<%arrayidx119>, ir<%sub117>
    WIDEN-GEP Var[Inv] ir<%arrayidx123> = getelementptr inbounds ir<%arrayidx114>, ir<16>
    WIDEN ir<%27> = load ir<%arrayidx123>
    CLONE ir<%28> = load ir<%arrayidx124>
    WIDEN ir<%sub125> = fsub ir<%27>, ir<%28>
    WIDEN-GEP Var[Inv] ir<%arrayidx128> = getelementptr inbounds ir<%arrayidx119>, ir<8>
    WIDEN store ir<%arrayidx128>, ir<%sub125>
    WIDEN-GEP Var[Inv] ir<%arrayidx131> = getelementptr inbounds ir<%arrayidx114>, ir<8>
    WIDEN ir<%29> = load ir<%arrayidx131>
    CLONE ir<%30> = load ir<%arrayidx132>
    WIDEN ir<%sub133> = fsub ir<%29>, ir<%30>
    WIDEN ir<%mul134> = fmul ir<%Direction.0>, ir<%sub133>
    WIDEN-GEP Var[Inv] ir<%arrayidx137> = getelementptr inbounds ir<%arrayidx119>, ir<16>
    WIDEN store ir<%arrayidx137>, ir<%mul134>
    WIDEN ir<%indvars.iv.next261> = add nuw nsw ir<%indvars.iv260>, ir<1>
    CLONE ir<%exitcond264.not> = icmp eq ir<%indvars.iv.next261>, ir<%wide.trip.count263>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit272>, scalar.ph

ir-bb<sw.epilog.loopexit272>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv260 = phi i64 [ 0, %for.body112.lr.ph ], [ %indvars.iv.next261, %for.body112 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx114 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv260 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %25 = load double, ptr %arrayidx114, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %26 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub117 = fsub double %25, %26 of type:fsub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx119 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv260 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub117, ptr %arrayidx119, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx123 = getelementptr inbounds i8, ptr %arrayidx114, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %27 = load double, ptr %arrayidx123, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %28 = load double, ptr %arrayidx124, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub125 = fsub double %27, %28 of type:fsub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx128 = getelementptr inbounds i8, ptr %arrayidx119, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub125, ptr %arrayidx128, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx131 = getelementptr inbounds i8, ptr %arrayidx114, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %29 = load double, ptr %arrayidx131, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %30 = load double, ptr %arrayidx132, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub133 = fsub double %29, %30 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul134 = fmul double %Direction.0, %sub133 of type:fmul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx137 = getelementptr inbounds i8, ptr %arrayidx119, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul134, ptr %arrayidx137, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next261 = add nuw nsw i64 %indvars.iv260, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next261, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond264.not, label %sw.epilog.loopexit272, label %for.body112 of type:br
LV: Scalar loop costs: 25.
-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv260 = phi i64 [ 0, %for.body112.lr.ph ], [ %indvars.iv.next261, %for.body112 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx114 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv260 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   %25 = load double, ptr %arrayidx114, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %26 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub117 = fsub double %25, %26 of type:fsub
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx119 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv260 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store double %sub117, ptr %arrayidx119, align 8, !tbaa !16 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %27 = load double, ptr %arrayidx123, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %28 = load double, ptr %arrayidx124, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub125 = fsub double %27, %28 of type:fsub
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store double %sub125, ptr %arrayidx128, align 8, !tbaa !16 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %29 = load double, ptr %arrayidx131, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %30 = load double, ptr %arrayidx132, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub133 = fsub double %29, %30 of type:fsub
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul134 = fmul double %Direction.0, %sub133 of type:fmul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx137 = getelementptr inbounds i8, ptr %arrayidx119, i64 16 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   store double %mul134, ptr %arrayidx137, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next261 = add nuw nsw i64 %indvars.iv260, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next261, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond264.not, label %sw.epilog.loopexit272, label %for.body112 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 20401094662, RTCostB: 53687091175
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 20401094662, RTCostB: 53687091175
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv260 = phi i64 [ 0, %for.body112.lr.ph ], [ %indvars.iv.next261, %for.body112 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx114 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv260 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %25 = load double, ptr %arrayidx114, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %26 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub117 = fsub double %25, %26 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx119 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv260 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store double %sub117, ptr %arrayidx119, align 8, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %27 = load double, ptr %arrayidx123, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %28 = load double, ptr %arrayidx124, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub125 = fsub double %27, %28 of type:fsub
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store double %sub125, ptr %arrayidx128, align 8, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %29 = load double, ptr %arrayidx131, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %30 = load double, ptr %arrayidx132, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub133 = fsub double %29, %30 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul134 = fmul double %Direction.0, %sub133 of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx137 = getelementptr inbounds i8, ptr %arrayidx119, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul134, ptr %arrayidx137, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next261 = add nuw nsw i64 %indvars.iv260, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next261, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond264.not, label %sw.epilog.loopexit272, label %for.body112 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 53687091175
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 20401094662

-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv260 = phi i64 [ 0, %for.body112.lr.ph ], [ %indvars.iv.next261, %for.body112 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx114 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv260 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 123 for VF vscale x 2 For instruction:   %25 = load double, ptr %arrayidx114, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %26 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub117 = fsub double %25, %26 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx119 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv260 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store double %sub117, ptr %arrayidx119, align 8, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %27 = load double, ptr %arrayidx123, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %28 = load double, ptr %arrayidx124, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub125 = fsub double %27, %28 of type:fsub
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store double %sub125, ptr %arrayidx128, align 8, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %29 = load double, ptr %arrayidx131, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %30 = load double, ptr %arrayidx132, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub133 = fsub double %29, %30 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul134 = fmul double %Direction.0, %sub133 of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx137 = getelementptr inbounds i8, ptr %arrayidx119, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 123 for VF vscale x 2 For instruction:   store double %mul134, ptr %arrayidx137, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next261 = add nuw nsw i64 %indvars.iv260, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next261, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond264.not, label %sw.epilog.loopexit272, label %for.body112 of type:br
LV: Vector loop of width vscale x 2 costs: 64
A is scalable.	B is not scalable.	
RTCostA: 139049566024, RTCostB: 53687091175
A is scalable.	B is not scalable.	
RTCostA: 139049566024, RTCostB: 20401094662
LV: Selecting VF: 2 With Cost: 9.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd at line: lbuffer.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body112.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %24 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx114> = getelementptr inbounds ir<%H>, ir<0>, vp<%4>
    INTERLEAVE-GROUP with factor 3 at %26, ir<%arrayidx114>
      ir<%26> = load from index 0
      ir<%30> = load from index 1
      ir<%28> = load from index 2
    CLONE ir<%27> = load ir<%Origin>
    WIDEN ir<%sub117> = fsub ir<%26>, ir<%27>
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%Points>, vp<%4>
    CLONE ir<%29> = load ir<%arrayidx124>
    WIDEN ir<%sub125> = fsub ir<%28>, ir<%29>
    CLONE ir<%31> = load ir<%arrayidx132>
    WIDEN ir<%sub133> = fsub ir<%30>, ir<%31>
    WIDEN ir<%mul134> = fmul ir<%Direction.0>, ir<%sub133>
    CLONE ir<%arrayidx137> = getelementptr inbounds ir<%arrayidx119>, ir<16>
    INTERLEAVE-GROUP with factor 3 at <badref>, ir<%arrayidx137>
      store ir<%sub117> to index 0
      store ir<%sub125> to index 1
      store ir<%mul134> to index 2
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<sw.epilog.loopexit272>, scalar.ph

ir-bb<sw.epilog.loopexit272>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body82.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %17 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv265 = phi 0, %indvars.iv.next266, ir<1>
    CLONE ir<%arrayidx84> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv265>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%arrayidx84>, ir<8>
    CLONE ir<%18> = load ir<%arrayidx85>
    CLONE ir<%19> = load ir<%arrayidx86>
    CLONE ir<%sub> = fsub ir<%18>, ir<%19>
    CLONE ir<%arrayidx88> = getelementptr inbounds ir<%Points>, ir<%indvars.iv265>
    CLONE store ir<%sub>, ir<%arrayidx88>
    CLONE ir<%arrayidx92> = getelementptr inbounds ir<%arrayidx84>, ir<16>
    CLONE ir<%20> = load ir<%arrayidx92>
    CLONE ir<%21> = load ir<%arrayidx93>
    CLONE ir<%sub94> = fsub ir<%20>, ir<%21>
    CLONE ir<%arrayidx97> = getelementptr inbounds ir<%arrayidx88>, ir<8>
    CLONE store ir<%sub94>, ir<%arrayidx97>
    CLONE ir<%22> = load ir<%arrayidx84>
    CLONE ir<%23> = load ir<%Origin>
    CLONE ir<%sub102> = fsub ir<%22>, ir<%23>
    CLONE ir<%mul> = fmul ir<%Direction.0>, ir<%sub102>
    CLONE ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx88>, ir<16>
    CLONE store ir<%mul>, ir<%arrayidx105>
    CLONE ir<%indvars.iv.next266> = add nuw nsw ir<%indvars.iv265>, ir<1>
    CLONE ir<%exitcond269.not> = icmp eq ir<%indvars.iv.next266>, ir<%wide.trip.count268>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body82.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %17 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv265 = phi 0, %indvars.iv.next266, ir<1>
    CLONE ir<%arrayidx84> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv265>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%arrayidx84>, ir<8>
    INTERLEAVE-GROUP with factor 3 at %18, ir<%arrayidx85>
      ir<%22> = load from index 0
      ir<%18> = load from index 1
      ir<%20> = load from index 2
    CLONE ir<%19> = load ir<%arrayidx86>
    WIDEN ir<%sub> = fsub ir<%18>, ir<%19>
    CLONE ir<%arrayidx88> = getelementptr inbounds ir<%Points>, ir<%indvars.iv265>
    CLONE ir<%arrayidx92> = getelementptr inbounds ir<%arrayidx84>, ir<16>
    CLONE ir<%21> = load ir<%arrayidx93>
    WIDEN ir<%sub94> = fsub ir<%20>, ir<%21>
    CLONE ir<%arrayidx97> = getelementptr inbounds ir<%arrayidx88>, ir<8>
    CLONE ir<%23> = load ir<%Origin>
    WIDEN ir<%sub102> = fsub ir<%22>, ir<%23>
    WIDEN ir<%mul> = fmul ir<%Direction.0>, ir<%sub102>
    CLONE ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx88>, ir<16>
    INTERLEAVE-GROUP with factor 3 at <badref>, ir<%arrayidx105>
      store ir<%sub> to index 0
      store ir<%sub94> to index 1
      store ir<%mul> to index 2
    CLONE ir<%indvars.iv.next266> = add nuw nsw ir<%indvars.iv265>, ir<1>
    CLONE ir<%exitcond269.not> = icmp eq ir<%indvars.iv.next266>, ir<%wide.trip.count268>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body82.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %17 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv265 = phi 0, %indvars.iv.next266, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx84> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv265>
    WIDEN-GEP Var[Inv] ir<%arrayidx85> = getelementptr inbounds ir<%arrayidx84>, ir<8>
    REPLICATE ir<%18> = load ir<%arrayidx85>
    CLONE ir<%19> = load ir<%arrayidx86>
    WIDEN ir<%sub> = fsub ir<%18>, ir<%19>
    WIDEN-GEP Inv[Var] ir<%arrayidx88> = getelementptr inbounds ir<%Points>, ir<%indvars.iv265>
    REPLICATE store ir<%sub>, ir<%arrayidx88>
    WIDEN-GEP Var[Inv] ir<%arrayidx92> = getelementptr inbounds ir<%arrayidx84>, ir<16>
    REPLICATE ir<%20> = load ir<%arrayidx92>
    CLONE ir<%21> = load ir<%arrayidx93>
    WIDEN ir<%sub94> = fsub ir<%20>, ir<%21>
    WIDEN-GEP Var[Inv] ir<%arrayidx97> = getelementptr inbounds ir<%arrayidx88>, ir<8>
    REPLICATE store ir<%sub94>, ir<%arrayidx97>
    REPLICATE ir<%22> = load ir<%arrayidx84>
    CLONE ir<%23> = load ir<%Origin>
    WIDEN ir<%sub102> = fsub ir<%22>, ir<%23>
    WIDEN ir<%mul> = fmul ir<%Direction.0>, ir<%sub102>
    WIDEN-GEP Var[Inv] ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx88>, ir<16>
    REPLICATE store ir<%mul>, ir<%arrayidx105>
    WIDEN ir<%indvars.iv.next266> = add nuw nsw ir<%indvars.iv265>, ir<1>
    CLONE ir<%exitcond269.not> = icmp eq ir<%indvars.iv.next266>, ir<%wide.trip.count268>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body82.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %17 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv265 = phi 0, %indvars.iv.next266, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx84> = getelementptr inbounds ir<%H>, ir<0>, ir<%indvars.iv265>
    WIDEN-GEP Var[Inv] ir<%arrayidx85> = getelementptr inbounds ir<%arrayidx84>, ir<8>
    WIDEN ir<%18> = load ir<%arrayidx85>
    CLONE ir<%19> = load ir<%arrayidx86>
    WIDEN ir<%sub> = fsub ir<%18>, ir<%19>
    WIDEN-GEP Inv[Var] ir<%arrayidx88> = getelementptr inbounds ir<%Points>, ir<%indvars.iv265>
    WIDEN store ir<%arrayidx88>, ir<%sub>
    WIDEN-GEP Var[Inv] ir<%arrayidx92> = getelementptr inbounds ir<%arrayidx84>, ir<16>
    WIDEN ir<%20> = load ir<%arrayidx92>
    CLONE ir<%21> = load ir<%arrayidx93>
    WIDEN ir<%sub94> = fsub ir<%20>, ir<%21>
    WIDEN-GEP Var[Inv] ir<%arrayidx97> = getelementptr inbounds ir<%arrayidx88>, ir<8>
    WIDEN store ir<%arrayidx97>, ir<%sub94>
    WIDEN ir<%22> = load ir<%arrayidx84>
    CLONE ir<%23> = load ir<%Origin>
    WIDEN ir<%sub102> = fsub ir<%22>, ir<%23>
    WIDEN ir<%mul> = fmul ir<%Direction.0>, ir<%sub102>
    WIDEN-GEP Var[Inv] ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx88>, ir<16>
    WIDEN store ir<%arrayidx105>, ir<%mul>
    WIDEN ir<%indvars.iv.next266> = add nuw nsw ir<%indvars.iv265>, ir<1>
    CLONE ir<%exitcond269.not> = icmp eq ir<%indvars.iv.next266>, ir<%wide.trip.count268>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv265 = phi i64 [ 0, %for.body82.lr.ph ], [ %indvars.iv.next266, %for.body82 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx84 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv265 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx85 = getelementptr inbounds i8, ptr %arrayidx84, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %18 = load double, ptr %arrayidx85, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load double, ptr %arrayidx86, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = fsub double %18, %19 of type:fsub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx88 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv265 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub, ptr %arrayidx88, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx92 = getelementptr inbounds i8, ptr %arrayidx84, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %20 = load double, ptr %arrayidx92, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %21 = load double, ptr %arrayidx93, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub94 = fsub double %20, %21 of type:fsub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx97 = getelementptr inbounds i8, ptr %arrayidx88, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub94, ptr %arrayidx97, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   %22 = load double, ptr %arrayidx84, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %23 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub102 = fsub double %22, %23 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul double %Direction.0, %sub102 of type:fmul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx105 = getelementptr inbounds i8, ptr %arrayidx88, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul, ptr %arrayidx105, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next266 = add nuw nsw i64 %indvars.iv265, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond269.not = icmp eq i64 %indvars.iv.next266, %wide.trip.count268 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond269.not, label %sw.epilog.loopexit, label %for.body82 of type:br
LV: Scalar loop costs: 25.
-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv265 = phi i64 [ 0, %for.body82.lr.ph ], [ %indvars.iv.next266, %for.body82 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx84 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv265 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx85 = getelementptr inbounds i8, ptr %arrayidx84, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   %18 = load double, ptr %arrayidx85, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %19 = load double, ptr %arrayidx86, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = fsub double %18, %19 of type:fsub
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx88 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv265 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store double %sub, ptr %arrayidx88, align 8, !tbaa !16 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %20 = load double, ptr %arrayidx92, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %21 = load double, ptr %arrayidx93, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub94 = fsub double %20, %21 of type:fsub
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store double %sub94, ptr %arrayidx97, align 8, !tbaa !16 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %22 = load double, ptr %arrayidx84, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %23 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub102 = fsub double %22, %23 of type:fsub
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul double %Direction.0, %sub102 of type:fmul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx105 = getelementptr inbounds i8, ptr %arrayidx88, i64 16 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 2 For instruction:   store double %mul, ptr %arrayidx105, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next266 = add nuw nsw i64 %indvars.iv265, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond269.not = icmp eq i64 %indvars.iv.next266, %wide.trip.count268 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond269.not, label %sw.epilog.loopexit, label %for.body82 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 20401094662, RTCostB: 53687091175
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 20401094662, RTCostB: 53687091175
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv265 = phi i64 [ 0, %for.body82.lr.ph ], [ %indvars.iv.next266, %for.body82 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx84 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv265 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx85 = getelementptr inbounds i8, ptr %arrayidx84, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %18 = load double, ptr %arrayidx85, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %19 = load double, ptr %arrayidx86, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = fsub double %18, %19 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx88 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv265 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store double %sub, ptr %arrayidx88, align 8, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %20 = load double, ptr %arrayidx92, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %21 = load double, ptr %arrayidx93, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub94 = fsub double %20, %21 of type:fsub
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store double %sub94, ptr %arrayidx97, align 8, !tbaa !16 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %22 = load double, ptr %arrayidx84, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %23 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub102 = fsub double %22, %23 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul double %Direction.0, %sub102 of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx105 = getelementptr inbounds i8, ptr %arrayidx88, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul, ptr %arrayidx105, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next266 = add nuw nsw i64 %indvars.iv265, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond269.not = icmp eq i64 %indvars.iv.next266, %wide.trip.count268 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond269.not, label %sw.epilog.loopexit, label %for.body82 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 53687091175
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 20401094662

-----------------Function that is being costed:'_ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd' from lbuffer.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv265 = phi i64 [ 0, %for.body82.lr.ph ], [ %indvars.iv.next266, %for.body82 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx84 = getelementptr inbounds [8 x [3 x double]], ptr %H, i64 0, i64 %indvars.iv265 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx85 = getelementptr inbounds i8, ptr %arrayidx84, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 123 for VF vscale x 2 For instruction:   %18 = load double, ptr %arrayidx85, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %19 = load double, ptr %arrayidx86, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = fsub double %18, %19 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx88 = getelementptr inbounds [3 x double], ptr %Points, i64 %indvars.iv265 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store double %sub, ptr %arrayidx88, align 8, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %20 = load double, ptr %arrayidx92, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %21 = load double, ptr %arrayidx93, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub94 = fsub double %20, %21 of type:fsub
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store double %sub94, ptr %arrayidx97, align 8, !tbaa !16 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %22 = load double, ptr %arrayidx84, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %23 = load double, ptr %Origin, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub102 = fsub double %22, %23 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul double %Direction.0, %sub102 of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx105 = getelementptr inbounds i8, ptr %arrayidx88, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 123 for VF vscale x 2 For instruction:   store double %mul, ptr %arrayidx105, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next266 = add nuw nsw i64 %indvars.iv265, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond269.not = icmp eq i64 %indvars.iv.next266, %wide.trip.count268 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond269.not, label %sw.epilog.loopexit, label %for.body82 of type:br
LV: Vector loop of width vscale x 2 costs: 64
A is scalable.	B is not scalable.	
RTCostA: 139049566024, RTCostB: 53687091175
A is scalable.	B is not scalable.	
RTCostA: 139049566024, RTCostB: 20401094662
LV: Selecting VF: 2 With Cost: 9.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: _ZN3povL11calc_pointsEiPNS_13Object_StructEPiPA3_dPd at line: lbuffer.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body82.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %17 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx84> = getelementptr inbounds ir<%H>, ir<0>, vp<%4>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%arrayidx84>, ir<8>
    INTERLEAVE-GROUP with factor 3 at %19, ir<%arrayidx85>
      ir<%23> = load from index 0
      ir<%19> = load from index 1
      ir<%21> = load from index 2
    CLONE ir<%20> = load ir<%arrayidx86>
    WIDEN ir<%sub> = fsub ir<%19>, ir<%20>
    CLONE ir<%arrayidx88> = getelementptr inbounds ir<%Points>, vp<%4>
    CLONE ir<%22> = load ir<%arrayidx93>
    WIDEN ir<%sub94> = fsub ir<%21>, ir<%22>
    CLONE ir<%24> = load ir<%Origin>
    WIDEN ir<%sub102> = fsub ir<%23>, ir<%24>
    WIDEN ir<%mul> = fmul ir<%Direction.0>, ir<%sub102>
    CLONE ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx88>, ir<16>
    INTERLEAVE-GROUP with factor 3 at <badref>, ir<%arrayidx105>
      store ir<%sub> to index 0
      store ir<%sub94> to index 1
      store ir<%mul> to index 2
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<sw.epilog.loopexit>, scalar.ph

ir-bb<sw.epilog.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lightgrp.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           lightgrp.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lighting.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           lighting.cpp
========== Loop: _ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    CLONE store ir<0>, ir<%arrayidx4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%arrayidx4> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    REPLICATE store ir<0>, ir<%arrayidx4>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    REPLICATE store ir<0>, ir<%arrayidx4>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx4>, ir<0>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds %"struct.pov::Light_Tested_Struct", ptr %6, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx4, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds %"struct.pov::Light_Tested_Struct", ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 0, ptr %arrayidx4, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'_ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx4 = getelementptr inbounds %"struct.pov::Light_Tested_Struct", ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 0, ptr %arrayidx4, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 4

-----------------Function that is being costed:'_ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds %"struct.pov::Light_Tested_Struct", ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx4, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588

-----------------Function that is being costed:'_ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds %"struct.pov::Light_Tested_Struct", ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx4, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588

-----------------Function that is being costed:'_ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx4 = getelementptr inbounds %"struct.pov::Light_Tested_Struct", ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx4, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 22548578248, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 22548578248, RTCostB: 8589934588
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3pov25Determine_Apparent_ColourEPNS_10istk_entryEPfPNS_10Ray_StructEd at line: lighting.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%6>, vp<%4>
    CLONE store ir<0>, ir<%arrayidx4>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%Total.031> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%add> = fadd ir<%Total.031>, ir<%3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv>
    REDUCE ir<%add>.1 = ir<%Total.031> + reduce.fadd (ir<%3>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%Total.031>, ir<%add>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond1.preheader>, scalar.ph

ir-bb<for.cond1.preheader>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%6>
}

========== Loop: _ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%Total.031> = phi ir<0.000000e+00>, ir<%add>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    INTERLEAVE-GROUP with factor 8 at %3, ir<%arrayidx>
      ir<%3> = load from index 0
    WIDEN ir<%add> = fadd ir<%Total.031>, ir<%3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv>
    REDUCE ir<%add>.1 = ir<%Total.031> + reduce.fadd (ir<%3>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%Total.031>, ir<%add>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%Total.031> = phi ir<0.000000e+00>, ir<%add>.1
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    REPLICATE ir<%3> = load ir<%arrayidx>
    WIDEN ir<%add> = fadd ir<%Total.031>, ir<%3>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv>
    REDUCE ir<%add>.1 = ir<%Total.031> + reduce.fadd (ir<%3>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%Total.031>, ir<%add>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%Total.031> = phi ir<0.000000e+00>, ir<%add>.1
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    WIDEN ir<%3> = load ir<%arrayidx>
    WIDEN ir<%add> = fadd ir<%Total.031>, ir<%3>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv>
    REDUCE ir<%add>.1 = ir<%Total.031> + reduce.fadd (ir<%3>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%Total.031>, ir<%add>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %Total.031 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Blend_Map_Entry", ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load float, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = fadd float %Total.031, %3 of type:fadd
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond1.preheader, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'_ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %Total.031 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Blend_Map_Entry", ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %3 = load float, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add = fadd float %Total.031, %3 of type:fadd
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond1.preheader, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 196601, RTCostB: 163835
A is not scalable.	B is not scalable.	
RTCostA: 196601, RTCostB: 163835

-----------------Function that is being costed:'_ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %Total.031 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Blend_Map_Entry", ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 10 for VF 4 For instruction:   %3 = load float, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 14 for VF 4 For instruction:   %add = fadd float %Total.031, %3 of type:fadd
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond1.preheader, label %for.body of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 212981, RTCostB: 163835
A is not scalable.	B is not scalable.	
RTCostA: 212981, RTCostB: 163835

-----------------Function that is being costed:'_ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %Total.031 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Blend_Map_Entry", ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load float, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = fadd float %Total.031, %3 of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond1.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 163835
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 163835

-----------------Function that is being costed:'_ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %Total.031 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Blend_Map_Entry", ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %3 = load float, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add = fadd float %Total.031, %3 of type:fadd
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond1.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 384992, RTCostB: 163835
A is scalable.	B is not scalable.	
RTCostA: 384992, RTCostB: 163835

-----------------Function that is being costed:'_ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %Total.031 = phi float [ 0.000000e+00, %for.body.lr.ph ], [ %add, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Blend_Map_Entry", ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %3 = load float, ptr %arrayidx, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %add = fadd float %Total.031, %3 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond1.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 376775, RTCostB: 163835
A is scalable.	B is not scalable.	
RTCostA: 376775, RTCostB: 163835
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL26backtrace_average_texturesEPfPNS_14Texture_StructEPdS3_PNS_10Ray_StructEdPNS_10istk_entryEi at line: lighting.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-REDUCTION-PHI ir<%Total.031> = phi ir<0.000000e+00>, ir<%add>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, vp<%4>
    CLONE ir<%3> = load ir<%arrayidx>
    REDUCE ir<%add> = ir<%Total.031> + reduce.fadd (ir<%3>)
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%Total.031>, ir<%add>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond1.preheader>, scalar.ph

ir-bb<for.cond1.preheader>:
No successors

scalar.ph:
No successors

Live-out float %add.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond7.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx11.us> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    CLONE store ir<-1.000000e+00>, ir<%arrayidx11.us>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond7.for.inc13_crit_edge.us>, scalar.ph

ir-bb<for.cond7.for.inc13_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond7.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%arrayidx11.us> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    REPLICATE store ir<-1.000000e+00>, ir<%arrayidx11.us>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond7.for.inc13_crit_edge.us>, scalar.ph

ir-bb<for.cond7.for.inc13_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond7.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx11.us> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    REPLICATE store ir<-1.000000e+00>, ir<%arrayidx11.us>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond7.for.inc13_crit_edge.us>, scalar.ph

ir-bb<for.cond7.for.inc13_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond7.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx11.us> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx11.us>, ir<-1.000000e+00>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond7.for.inc13_crit_edge.us>, scalar.ph

ir-bb<for.cond7.for.inc13_crit_edge.us>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond7.preheader.us ], [ %indvars.iv.next, %for.body9.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx11.us = getelementptr inbounds [5 x float], ptr %6, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float -1.000000e+00, ptr %arrayidx11.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond7.for.inc13_crit_edge.us, label %for.body9.us of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond7.preheader.us ], [ %indvars.iv.next, %for.body9.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx11.us = getelementptr inbounds [5 x float], ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store float -1.000000e+00, ptr %arrayidx11.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond7.for.inc13_crit_edge.us, label %for.body9.us of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond7.preheader.us ], [ %indvars.iv.next, %for.body9.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx11.us = getelementptr inbounds [5 x float], ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store float -1.000000e+00, ptr %arrayidx11.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond7.for.inc13_crit_edge.us, label %for.body9.us of type:br
LV: Vector loop of width 4 costs: 4

-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond7.preheader.us ], [ %indvars.iv.next, %for.body9.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx11.us = getelementptr inbounds [5 x float], ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float -1.000000e+00, ptr %arrayidx11.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond7.for.inc13_crit_edge.us, label %for.body9.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588

-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond7.preheader.us ], [ %indvars.iv.next, %for.body9.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx11.us = getelementptr inbounds [5 x float], ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store float -1.000000e+00, ptr %arrayidx11.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond7.for.inc13_crit_edge.us, label %for.body9.us of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588

-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond7.preheader.us ], [ %indvars.iv.next, %for.body9.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx11.us = getelementptr inbounds [5 x float], ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store float -1.000000e+00, ptr %arrayidx11.us, align 4, !tbaa !19 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond7.for.inc13_crit_edge.us, label %for.body9.us of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 22548578248, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 22548578248, RTCostB: 8589934588
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii at line: lighting.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond7.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx11.us> = getelementptr inbounds ir<%6>, vp<%4>
    CLONE store ir<-1.000000e+00>, ir<%arrayidx11.us>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond7.for.inc13_crit_edge.us>, scalar.ph

ir-bb<for.cond7.for.inc13_crit_edge.us>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %47 = load ptr, ptr %arrayidx235, align 8, !tbaa !18 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %47, ptr %arrayidx238, align 8, !tbaa !18 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load ptr, ptr %arrayidx235, align 8, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %47, ptr %arrayidx238, align 8, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %47 = load ptr, ptr %arrayidx235, align 8, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %47, ptr %arrayidx238, align 8, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body233.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %45) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv805 = phi 0, %indvars.iv.next806, ir<1>
    CLONE ir<%arrayidx235> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv805>
    CLONE ir<%47> = load ir<%arrayidx235>
    CLONE ir<%arrayidx238> = getelementptr inbounds ir<%Interiors236>, ir<0>, ir<%indvars.iv805>
    CLONE store ir<%47>, ir<%arrayidx238>
    CLONE ir<%indvars.iv.next806> = add nuw nsw ir<%indvars.iv805>, ir<1>
    CLONE ir<%exitcond809.not> = icmp eq ir<%indvars.iv.next806>, ir<%wide.trip.count808>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end241.loopexit>, scalar.ph

ir-bb<for.end241.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body233.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %45) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv805 = phi 0, %indvars.iv.next806, ir<1>
    CLONE ir<%arrayidx235> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv805>
    vp<%4> = vector-pointer ir<%arrayidx235>
    WIDEN ir<%47> = load vp<%4>
    CLONE ir<%arrayidx238> = getelementptr inbounds ir<%Interiors236>, ir<0>, ir<%indvars.iv805>
    vp<%5> = vector-pointer ir<%arrayidx238>
    WIDEN store vp<%5>, ir<%47>
    CLONE ir<%indvars.iv.next806> = add nuw nsw ir<%indvars.iv805>, ir<1>
    CLONE ir<%exitcond809.not> = icmp eq ir<%indvars.iv.next806>, ir<%wide.trip.count808>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end241.loopexit>, scalar.ph

ir-bb<for.end241.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body233.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %45) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv805 = phi 0, %indvars.iv.next806, ir<1>
    CLONE ir<%arrayidx235> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv805>
    vp<%4> = vector-pointer ir<%arrayidx235>
    WIDEN ir<%47> = load vp<%4>
    CLONE ir<%arrayidx238> = getelementptr inbounds ir<%Interiors236>, ir<0>, ir<%indvars.iv805>
    vp<%5> = vector-pointer ir<%arrayidx238>
    WIDEN store vp<%5>, ir<%47>
    CLONE ir<%indvars.iv.next806> = add nuw nsw ir<%indvars.iv805>, ir<1>
    CLONE ir<%exitcond809.not> = icmp eq ir<%indvars.iv.next806>, ir<%wide.trip.count808>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end241.loopexit>, scalar.ph

ir-bb<for.end241.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv805 = phi i64 [ 0, %for.body233.preheader ], [ %indvars.iv.next806, %for.body233 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx235 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv805 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %47 = load ptr, ptr %arrayidx235, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238 = getelementptr inbounds [100 x ptr], ptr %Interiors236, i64 0, i64 %indvars.iv805 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %47, ptr %arrayidx238, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next806 = add nuw nsw i64 %indvars.iv805, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond809.not = icmp eq i64 %indvars.iv.next806, %wide.trip.count808 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond809.not, label %for.end241.loopexit, label %for.body233 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv805 = phi i64 [ 0, %for.body233.preheader ], [ %indvars.iv.next806, %for.body233 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx235 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv805 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %47 = load ptr, ptr %arrayidx235, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238 = getelementptr inbounds [100 x ptr], ptr %Interiors236, i64 0, i64 %indvars.iv805 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %47, ptr %arrayidx238, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next806 = add nuw nsw i64 %indvars.iv805, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond809.not = icmp eq i64 %indvars.iv.next806, %wide.trip.count808 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond809.not, label %for.end241.loopexit, label %for.body233 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 12884901888
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv805 = phi i64 [ 0, %for.body233.preheader ], [ %indvars.iv.next806, %for.body233 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx235 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv805 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %47 = load ptr, ptr %arrayidx235, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238 = getelementptr inbounds [100 x ptr], ptr %Interiors236, i64 0, i64 %indvars.iv805 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %47, ptr %arrayidx238, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next806 = add nuw nsw i64 %indvars.iv805, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond809.not = icmp eq i64 %indvars.iv.next806, %wide.trip.count808 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond809.not, label %for.end241.loopexit, label %for.body233 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901888
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967296

-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv805 = phi i64 [ 0, %for.body233.preheader ], [ %indvars.iv.next806, %for.body233 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx235 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv805 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %47 = load ptr, ptr %arrayidx235, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238 = getelementptr inbounds [100 x ptr], ptr %Interiors236, i64 0, i64 %indvars.iv805 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %47, ptr %arrayidx238, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next806 = add nuw nsw i64 %indvars.iv805, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond809.not = icmp eq i64 %indvars.iv.next806, %wide.trip.count808 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond809.not, label %for.end241.loopexit, label %for.body233 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483648, RTCostB: 12884901888
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483648, RTCostB: 4294967296
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii at line: lighting.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body233.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %46) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx235> = getelementptr inbounds ir<%Interiors>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx235>
    WIDEN ir<%51> = load vp<%5>
    CLONE ir<%arrayidx238> = getelementptr inbounds ir<%Interiors236>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx238>
    WIDEN store vp<%6>, ir<%51>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end241.loopexit>, scalar.ph

ir-bb<for.end241.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %98 = load ptr, ptr %arrayidx425, align 8, !tbaa !18 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %98, ptr %arrayidx428, align 8, !tbaa !18 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %98 = load ptr, ptr %arrayidx425, align 8, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %98, ptr %arrayidx428, align 8, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %98 = load ptr, ptr %arrayidx425, align 8, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %98, ptr %arrayidx428, align 8, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body422.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %96) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv814 = phi 0, %indvars.iv.next815, ir<1>
    CLONE ir<%arrayidx425> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv814>
    CLONE ir<%98> = load ir<%arrayidx425>
    CLONE ir<%arrayidx428> = getelementptr inbounds ir<%Interiors236>, ir<0>, ir<%indvars.iv814>
    CLONE store ir<%98>, ir<%arrayidx428>
    CLONE ir<%indvars.iv.next815> = add nuw nsw ir<%indvars.iv814>, ir<1>
    CLONE ir<%exitcond818.not> = icmp eq ir<%indvars.iv.next815>, ir<%wide.trip.count817>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end431.loopexit>, scalar.ph

ir-bb<for.end431.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body422.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %96) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv814 = phi 0, %indvars.iv.next815, ir<1>
    CLONE ir<%arrayidx425> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv814>
    vp<%4> = vector-pointer ir<%arrayidx425>
    WIDEN ir<%98> = load vp<%4>
    CLONE ir<%arrayidx428> = getelementptr inbounds ir<%Interiors236>, ir<0>, ir<%indvars.iv814>
    vp<%5> = vector-pointer ir<%arrayidx428>
    WIDEN store vp<%5>, ir<%98>
    CLONE ir<%indvars.iv.next815> = add nuw nsw ir<%indvars.iv814>, ir<1>
    CLONE ir<%exitcond818.not> = icmp eq ir<%indvars.iv.next815>, ir<%wide.trip.count817>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end431.loopexit>, scalar.ph

ir-bb<for.end431.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body422.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %96) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv814 = phi 0, %indvars.iv.next815, ir<1>
    CLONE ir<%arrayidx425> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv814>
    vp<%4> = vector-pointer ir<%arrayidx425>
    WIDEN ir<%98> = load vp<%4>
    CLONE ir<%arrayidx428> = getelementptr inbounds ir<%Interiors236>, ir<0>, ir<%indvars.iv814>
    vp<%5> = vector-pointer ir<%arrayidx428>
    WIDEN store vp<%5>, ir<%98>
    CLONE ir<%indvars.iv.next815> = add nuw nsw ir<%indvars.iv814>, ir<1>
    CLONE ir<%exitcond818.not> = icmp eq ir<%indvars.iv.next815>, ir<%wide.trip.count817>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end431.loopexit>, scalar.ph

ir-bb<for.end431.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv814 = phi i64 [ 0, %for.body422.preheader ], [ %indvars.iv.next815, %for.body422 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx425 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv814 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %98 = load ptr, ptr %arrayidx425, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx428 = getelementptr inbounds [100 x ptr], ptr %Interiors236, i64 0, i64 %indvars.iv814 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %98, ptr %arrayidx428, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next815 = add nuw nsw i64 %indvars.iv814, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond818.not = icmp eq i64 %indvars.iv.next815, %wide.trip.count817 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond818.not, label %for.end431.loopexit, label %for.body422 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv814 = phi i64 [ 0, %for.body422.preheader ], [ %indvars.iv.next815, %for.body422 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx425 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv814 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %98 = load ptr, ptr %arrayidx425, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx428 = getelementptr inbounds [100 x ptr], ptr %Interiors236, i64 0, i64 %indvars.iv814 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %98, ptr %arrayidx428, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next815 = add nuw nsw i64 %indvars.iv814, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond818.not = icmp eq i64 %indvars.iv.next815, %wide.trip.count817 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond818.not, label %for.end431.loopexit, label %for.body422 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 12884901888
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv814 = phi i64 [ 0, %for.body422.preheader ], [ %indvars.iv.next815, %for.body422 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx425 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv814 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %98 = load ptr, ptr %arrayidx425, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx428 = getelementptr inbounds [100 x ptr], ptr %Interiors236, i64 0, i64 %indvars.iv814 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %98, ptr %arrayidx428, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next815 = add nuw nsw i64 %indvars.iv814, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond818.not = icmp eq i64 %indvars.iv.next815, %wide.trip.count817 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond818.not, label %for.end431.loopexit, label %for.body422 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901888
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967296

-----------------Function that is being costed:'_ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv814 = phi i64 [ 0, %for.body422.preheader ], [ %indvars.iv.next815, %for.body422 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx425 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv814 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %98 = load ptr, ptr %arrayidx425, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx428 = getelementptr inbounds [100 x ptr], ptr %Interiors236, i64 0, i64 %indvars.iv814 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %98, ptr %arrayidx428, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next815 = add nuw nsw i64 %indvars.iv814, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond818.not = icmp eq i64 %indvars.iv.next815, %wide.trip.count817 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond818.not, label %for.end431.loopexit, label %for.body422 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483648, RTCostB: 12884901888
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483648, RTCostB: 4294967296
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL16block_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_Pfiiiii at line: lighting.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body422.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %97) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx425> = getelementptr inbounds ir<%Interiors>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx425>
    WIDEN ir<%102> = load vp<%5>
    CLONE ir<%arrayidx428> = getelementptr inbounds ir<%Interiors236>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx428>
    WIDEN store vp<%6>, ir<%102>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end431.loopexit>, scalar.ph

ir-bb<for.end431.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 37
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %13 = load ptr, ptr %arrayidx, align 8, !tbaa !21 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %13, ptr %arrayidx60, align 8, !tbaa !21 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load ptr, ptr %arrayidx, align 8, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %13, ptr %arrayidx60, align 8, !tbaa !21 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %13 = load ptr, ptr %arrayidx, align 8, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %13, ptr %arrayidx60, align 8, !tbaa !21 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL19do_light_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %11) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv>
    CLONE ir<%13> = load ir<%arrayidx>
    CLONE ir<%arrayidx60> = getelementptr inbounds ir<%Interiors58>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%13>, ir<%arrayidx60>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL19do_light_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_' from lighting.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %11) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%arrayidx60> = getelementptr inbounds ir<%Interiors58>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx60>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL19do_light_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_' from lighting.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %11) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%arrayidx60> = getelementptr inbounds ir<%Interiors58>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx60>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL19do_light_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %13 = load ptr, ptr %arrayidx, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx60 = getelementptr inbounds [100 x ptr], ptr %Interiors58, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %13, ptr %arrayidx60, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3povL19do_light_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %13 = load ptr, ptr %arrayidx, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx60 = getelementptr inbounds [100 x ptr], ptr %Interiors58, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %13, ptr %arrayidx60, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 12884901888
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL19do_light_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = load ptr, ptr %arrayidx, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx60 = getelementptr inbounds [100 x ptr], ptr %Interiors58, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %13, ptr %arrayidx60, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901888
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967296

-----------------Function that is being costed:'_ZN3povL19do_light_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_' from lighting.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %13 = load ptr, ptr %arrayidx, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx60 = getelementptr inbounds [100 x ptr], ptr %Interiors58, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %13, ptr %arrayidx60, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483648, RTCostB: 12884901888
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483648, RTCostB: 4294967296
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL19do_light_area_lightEPNS_19Light_Source_StructEPdPNS_10Ray_StructES4_S2_ at line: lighting.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %11) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%17> = load vp<%5>
    CLONE ir<%arrayidx60> = getelementptr inbounds ir<%Interiors58>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx60>
    WIDEN store vp<%6>, ir<%17>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 44
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o mathutil.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           mathutil.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o matrices.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           matrices.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o media.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           media.cpp
========== Loop: _ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE' from media.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body42.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %number to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%entry1.0209> = WIDEN-POINTER-INDUCTION ir<%list>, 32
    WIDEN-REDUCTION-PHI ir<%sum.0208> = phi ir<0.000000e+00>, ir<%add46>.1
    WIDEN-INDUCTION %i.1207 = phi 0, %inc49, ir<1>
    CLONE ir<%9> = load ir<%entry1.0209>
    CLONE ir<%tobool44.not> = icmp eq ir<%9>, ir<0>
    CLONE ir<%10> = load ir<%Ratio>
    CLONE ir<%sub> = fsub ir<1.000000e+00>, ir<%10>
    CLONE ir<%cond> = select ir<%tobool44.not>, ir<%sub>, ir<%10>
    CLONE ir<%add46> = fadd ir<%sum.0208>, ir<%cond>
    CLONE ir<%incdec.ptr47> = getelementptr inbounds ir<%entry1.0209>, ir<32>
    CLONE ir<%inc49> = add nuw nsw ir<%i.1207>, ir<1>
    CLONE ir<%exitcond220.not> = icmp eq ir<%inc49>, ir<%number>
    REDUCE ir<%add46>.1 = ir<%sum.0208> + reduce.fadd (ir<%cond>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%sum.0208>, ir<%add46>.1
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond51.preheader>, scalar.ph

ir-bb<for.cond51.preheader>:
No successors

scalar.ph:
No successors

Live-out double %add46.lcssa = vp<%6>
}

========== Loop: _ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE' from media.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body42.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %number to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%entry1.0209> = WIDEN-POINTER-INDUCTION ir<%list>, 32
    WIDEN-REDUCTION-PHI ir<%sum.0208> = phi ir<0.000000e+00>, ir<%add46>.1
    WIDEN-INDUCTION %i.1207 = phi 0, %inc49, ir<1>
    INTERLEAVE-GROUP with factor 8 at %9, ir<%entry1.0209>
      ir<%9> = load from index 0
    WIDEN ir<%tobool44.not> = icmp eq ir<%9>, ir<0>
    CLONE ir<%10> = load ir<%Ratio>
    WIDEN ir<%sub> = fsub ir<1.000000e+00>, ir<%10>
    WIDEN-SELECT ir<%cond> = select ir<%tobool44.not>, ir<%sub>, ir<%10>
    WIDEN ir<%add46> = fadd ir<%sum.0208>, ir<%cond>
    CLONE ir<%incdec.ptr47> = getelementptr inbounds ir<%entry1.0209>, ir<32>
    CLONE ir<%inc49> = add nuw nsw ir<%i.1207>, ir<1>
    CLONE ir<%exitcond220.not> = icmp eq ir<%inc49>, ir<%number>
    REDUCE ir<%add46>.1 = ir<%sum.0208> + reduce.fadd (ir<%cond>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%sum.0208>, ir<%add46>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE' from media.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body42.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %number to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%entry1.0209> = WIDEN-POINTER-INDUCTION ir<%list>, 32
    WIDEN-REDUCTION-PHI ir<%sum.0208> = phi ir<0.000000e+00>, ir<%add46>.1
    WIDEN-INDUCTION %i.1207 = phi 0, %inc49, ir<1>
    REPLICATE ir<%9> = load ir<%entry1.0209>
    WIDEN ir<%tobool44.not> = icmp eq ir<%9>, ir<0>
    CLONE ir<%10> = load ir<%Ratio>
    WIDEN ir<%sub> = fsub ir<1.000000e+00>, ir<%10>
    WIDEN-SELECT ir<%cond> = select ir<%tobool44.not>, ir<%sub>, ir<%10>
    WIDEN ir<%add46> = fadd ir<%sum.0208>, ir<%cond>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr47> = getelementptr inbounds ir<%entry1.0209>, ir<32>
    CLONE ir<%inc49> = add nuw nsw ir<%i.1207>, ir<1>
    CLONE ir<%exitcond220.not> = icmp eq ir<%inc49>, ir<%number>
    REDUCE ir<%add46>.1 = ir<%sum.0208> + reduce.fadd (ir<%cond>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%sum.0208>, ir<%add46>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE' from media.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body42.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %number to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%entry1.0209> = WIDEN-POINTER-INDUCTION ir<%list>, 32
    WIDEN-REDUCTION-PHI ir<%sum.0208> = phi ir<0.000000e+00>, ir<%add46>.1
    WIDEN-INDUCTION %i.1207 = phi 0, %inc49, ir<1>
    WIDEN ir<%9> = load ir<%entry1.0209>
    WIDEN ir<%tobool44.not> = icmp eq ir<%9>, ir<0>
    CLONE ir<%10> = load ir<%Ratio>
    WIDEN ir<%sub> = fsub ir<1.000000e+00>, ir<%10>
    WIDEN-SELECT ir<%cond> = select ir<%tobool44.not>, ir<%sub>, ir<%10>
    WIDEN ir<%add46> = fadd ir<%sum.0208>, ir<%cond>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr47> = getelementptr inbounds ir<%entry1.0209>, ir<32>
    CLONE ir<%inc49> = add nuw nsw ir<%i.1207>, ir<1>
    CLONE ir<%exitcond220.not> = icmp eq ir<%inc49>, ir<%number>
    REDUCE ir<%add46>.1 = ir<%sum.0208> + reduce.fadd (ir<%cond>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%sum.0208>, ir<%add46>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %entry1.0209 = phi ptr [ %list, %for.body42.lr.ph ], [ %incdec.ptr47, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum.0208 = phi double [ 0.000000e+00, %for.body42.lr.ph ], [ %add46, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.1207 = phi i32 [ 0, %for.body42.lr.ph ], [ %inc49, %for.body42 ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i32, ptr %entry1.0209, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool44.not = icmp eq i32 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load double, ptr %Ratio, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = fsub double 1.000000e+00, %10 of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cond = select i1 %tobool44.not, double %sub, double %10 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add46 = fadd double %sum.0208, %cond of type:fadd
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr47 = getelementptr inbounds i8, ptr %entry1.0209, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc49 = add nuw nsw i32 %i.1207, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond220.not = icmp eq i32 %inc49, %number of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond220.not, label %for.cond51.preheader, label %for.body42 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %entry1.0209 = phi ptr [ %list, %for.body42.lr.ph ], [ %incdec.ptr47, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sum.0208 = phi double [ 0.000000e+00, %for.body42.lr.ph ], [ %add46, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.1207 = phi i32 [ 0, %for.body42.lr.ph ], [ %inc49, %for.body42 ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 10 for VF 2 For instruction:   %9 = load i32, ptr %entry1.0209, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool44.not = icmp eq i32 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %10 = load double, ptr %Ratio, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = fsub double 1.000000e+00, %10 of type:fsub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cond = select i1 %tobool44.not, double %sub, double %10 of type:select
LV: Found an estimated cost of 6 for VF 2 For instruction:   %add46 = fadd double %sum.0208, %cond of type:fadd
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr47 = getelementptr inbounds i8, ptr %entry1.0209, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc49 = add nuw nsw i32 %i.1207, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond220.not = icmp eq i32 %inc49, %number of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond220.not, label %for.cond51.preheader, label %for.body42 of type:br
LV: Vector loop of width 2 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 24696061939, RTCostB: 21474836470
A is not scalable.	B is not scalable.	
RTCostA: 24696061939, RTCostB: 21474836470

-----------------Function that is being costed:'_ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %entry1.0209 = phi ptr [ %list, %for.body42.lr.ph ], [ %incdec.ptr47, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sum.0208 = phi double [ 0.000000e+00, %for.body42.lr.ph ], [ %add46, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.1207 = phi i32 [ 0, %for.body42.lr.ph ], [ %inc49, %for.body42 ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 20 for VF 4 For instruction:   %9 = load i32, ptr %entry1.0209, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool44.not = icmp eq i32 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %10 = load double, ptr %Ratio, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub = fsub double 1.000000e+00, %10 of type:fsub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cond = select i1 %tobool44.not, double %sub, double %10 of type:select
LV: Found an estimated cost of 12 for VF 4 For instruction:   %add46 = fadd double %sum.0208, %cond of type:fadd
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr47 = getelementptr inbounds i8, ptr %entry1.0209, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc49 = add nuw nsw i32 %i.1207, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond220.not = icmp eq i32 %inc49, %number of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond220.not, label %for.cond51.preheader, label %for.body42 of type:br
LV: Vector loop of width 4 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 22011707381, RTCostB: 21474836470
A is not scalable.	B is not scalable.	
RTCostA: 22011707381, RTCostB: 21474836470

-----------------Function that is being costed:'_ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %entry1.0209 = phi ptr [ %list, %for.body42.lr.ph ], [ %incdec.ptr47, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sum.0208 = phi double [ 0.000000e+00, %for.body42.lr.ph ], [ %add46, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.1207 = phi i32 [ 0, %for.body42.lr.ph ], [ %inc49, %for.body42 ] of type:phi
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i32, ptr %entry1.0209, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool44.not = icmp eq i32 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %10 = load double, ptr %Ratio, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = fsub double 1.000000e+00, %10 of type:fsub
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cond = select i1 %tobool44.not, double %sub, double %10 of type:select
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add46 = fadd double %sum.0208, %cond of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr47 = getelementptr inbounds i8, ptr %entry1.0209, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc49 = add nuw nsw i32 %i.1207, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond220.not = icmp eq i32 %inc49, %number of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond220.not, label %for.cond51.preheader, label %for.body42 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836470
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836470

-----------------Function that is being costed:'_ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %entry1.0209 = phi ptr [ %list, %for.body42.lr.ph ], [ %incdec.ptr47, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sum.0208 = phi double [ 0.000000e+00, %for.body42.lr.ph ], [ %add46, %for.body42 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.1207 = phi i32 [ 0, %for.body42.lr.ph ], [ %inc49, %for.body42 ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %9 = load i32, ptr %entry1.0209, align 8, !tbaa !23 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool44.not = icmp eq i32 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %10 = load double, ptr %Ratio, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = fsub double 1.000000e+00, %10 of type:fsub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cond = select i1 %tobool44.not, double %sub, double %10 of type:select
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %add46 = fadd double %sum.0208, %cond of type:fadd
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr47 = getelementptr inbounds i8, ptr %entry1.0209, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc49 = add nuw nsw i32 %i.1207, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond220.not = icmp eq i32 %inc49, %number of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond220.not, label %for.cond51.preheader, label %for.body42 of type:br
LV: Vector loop of width vscale x 2 costs: 13
A is scalable.	B is not scalable.	
RTCostA: 27917287402, RTCostB: 21474836470
A is scalable.	B is not scalable.	
RTCostA: 27917287402, RTCostB: 21474836470
LV: Selecting VF: 1 With Cost: 10.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL25set_up_sampling_intervalsEPNS_21Media_Interval_StructEiPNS_19Lit_Interval_StructEPNS_12Media_StructE at line: media.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body42.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %number to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%sum.0208> = phi ir<0.000000e+00>, ir<%add46>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<32>
    EMIT vp<%6> = ptradd ir<%list>, vp<%5>
    CLONE ir<%9> = load vp<%6>
    CLONE ir<%tobool44.not> = icmp eq ir<%9>, ir<0>
    CLONE ir<%10> = load ir<%Ratio>
    CLONE ir<%sub> = fsub ir<1.000000e+00>, ir<%10>
    CLONE ir<%cond> = select ir<%tobool44.not>, ir<%sub>, ir<%10>
    REDUCE ir<%add46> = ir<%sum.0208> + reduce.fadd (ir<%cond>)
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sum.0208>, ir<%add46>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond51.preheader>, scalar.ph

ir-bb<for.cond51.preheader>:
No successors

scalar.ph:
No successors

Live-out double %add46.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN3povL16get_lit_intervalEPiPNS_19Lit_Interval_StructEiPNS_17Light_List_StructEPNS_10istk_entryES4_i' from media.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body126.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %n.3250)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%curr.3234> = WIDEN-POINTER-INDUCTION ir<%Lit_Interval>, 32
    WIDEN-INDUCTION %i.3233 = phi %inc131, 0, ir<1>
    CLONE ir<%s1127> = getelementptr inbounds ir<%curr.3234>, ir<16>
    CLONE ir<%29> = load ir<%s1127>
    CLONE ir<%s0128> = getelementptr inbounds ir<%curr.3234>, ir<8>
    CLONE ir<%30> = load ir<%s0128>
    CLONE ir<%sub> = fsub ir<%29>, ir<%30>
    CLONE ir<%ds> = getelementptr inbounds ir<%curr.3234>, ir<24>
    CLONE store ir<%sub>, ir<%ds>
    CLONE ir<%incdec.ptr129> = getelementptr inbounds ir<%curr.3234>, ir<32>
    CLONE ir<%inc131> = add nuw nsw ir<%i.3233>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%inc131>, ir<%n.3250>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end132.loopexit>, scalar.ph

ir-bb<for.end132.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16get_lit_intervalEPiPNS_19Lit_Interval_StructEiPNS_17Light_List_StructEPNS_10istk_entryES4_i' from media.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body126.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %n.3250)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%curr.3234> = WIDEN-POINTER-INDUCTION ir<%Lit_Interval>, 32
    WIDEN-INDUCTION %i.3233 = phi %inc131, 0, ir<1>
    CLONE ir<%s1127> = getelementptr inbounds ir<%curr.3234>, ir<16>
    INTERLEAVE-GROUP with factor 4 at %29, ir<%s1127>
      ir<%30> = load from index 0
      ir<%29> = load from index 1
    CLONE ir<%s0128> = getelementptr inbounds ir<%curr.3234>, ir<8>
    WIDEN ir<%sub> = fsub ir<%29>, ir<%30>
    REPLICATE ir<%ds> = getelementptr inbounds ir<%curr.3234>, ir<24>
    REPLICATE store ir<%sub>, ir<%ds>
    REPLICATE ir<%incdec.ptr129> = getelementptr inbounds ir<%curr.3234>, ir<32>
    CLONE ir<%inc131> = add nuw nsw ir<%i.3233>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%inc131>, ir<%n.3250>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL16get_lit_intervalEPiPNS_19Lit_Interval_StructEiPNS_17Light_List_StructEPNS_10istk_entryES4_i' from media.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body126.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %n.3250)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%curr.3234> = WIDEN-POINTER-INDUCTION ir<%Lit_Interval>, 32
    WIDEN-INDUCTION %i.3233 = phi %inc131, 0, ir<1>
    WIDEN-GEP Var[Inv] ir<%s1127> = getelementptr inbounds ir<%curr.3234>, ir<16>
    REPLICATE ir<%29> = load ir<%s1127>
    WIDEN-GEP Var[Inv] ir<%s0128> = getelementptr inbounds ir<%curr.3234>, ir<8>
    REPLICATE ir<%30> = load ir<%s0128>
    WIDEN ir<%sub> = fsub ir<%29>, ir<%30>
    WIDEN-GEP Var[Inv] ir<%ds> = getelementptr inbounds ir<%curr.3234>, ir<24>
    REPLICATE store ir<%sub>, ir<%ds>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr129> = getelementptr inbounds ir<%curr.3234>, ir<32>
    CLONE ir<%inc131> = add nuw nsw ir<%i.3233>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%inc131>, ir<%n.3250>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3povL16get_lit_intervalEPiPNS_19Lit_Interval_StructEiPNS_17Light_List_StructEPNS_10istk_entryES4_i' from media.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body126.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %n.3250)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%curr.3234> = WIDEN-POINTER-INDUCTION ir<%Lit_Interval>, 32
    WIDEN-INDUCTION %i.3233 = phi %inc131, 0, ir<1>
    WIDEN-GEP Var[Inv] ir<%s1127> = getelementptr inbounds ir<%curr.3234>, ir<16>
    WIDEN ir<%29> = load ir<%s1127>
    WIDEN-GEP Var[Inv] ir<%s0128> = getelementptr inbounds ir<%curr.3234>, ir<8>
    WIDEN ir<%30> = load ir<%s0128>
    WIDEN ir<%sub> = fsub ir<%29>, ir<%30>
    WIDEN-GEP Var[Inv] ir<%ds> = getelementptr inbounds ir<%curr.3234>, ir<24>
    WIDEN store ir<%ds>, ir<%sub>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr129> = getelementptr inbounds ir<%curr.3234>, ir<32>
    CLONE ir<%inc131> = add nuw nsw ir<%i.3233>, ir<1>
    CLONE ir<%exitcond246.not> = icmp eq ir<%inc131>, ir<%n.3250>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16get_lit_intervalEPiPNS_19Lit_Interval_StructEiPNS_17Light_List_StructEPNS_10istk_entryES4_i' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %curr.3234 = phi ptr [ %incdec.ptr129, %for.body126 ], [ %Lit_Interval, %for.body126.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.3233 = phi i32 [ %inc131, %for.body126 ], [ 0, %for.body126.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s1127 = getelementptr inbounds i8, ptr %curr.3234, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %29 = load double, ptr %s1127, align 8, !tbaa !25 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %s0128 = getelementptr inbounds i8, ptr %curr.3234, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %30 = load double, ptr %s0128, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = fsub double %29, %30 of type:fsub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ds = getelementptr inbounds i8, ptr %curr.3234, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub, ptr %ds, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %curr.3234, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc131 = add nuw nsw i32 %i.3233, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond246.not = icmp eq i32 %inc131, %n.3250 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond246.not, label %for.end132.loopexit, label %for.body126 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3povL16get_lit_intervalEPiPNS_19Lit_Interval_StructEiPNS_17Light_List_StructEPNS_10istk_entryES4_i' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %curr.3234 = phi ptr [ %incdec.ptr129, %for.body126 ], [ %Lit_Interval, %for.body126.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.3233 = phi i32 [ %inc131, %for.body126 ], [ 0, %for.body126.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %s1127 = getelementptr inbounds i8, ptr %curr.3234, i64 16 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %29 = load double, ptr %s1127, align 8, !tbaa !25 of type:load
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   %30 = load double, ptr %s0128, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = fsub double %29, %30 of type:fsub
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ds = getelementptr inbounds i8, ptr %curr.3234, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 10 for VF 2 For instruction:   store double %sub, ptr %ds, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %curr.3234, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc131 = add nuw nsw i32 %i.3233, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond246.not = icmp eq i32 %inc131, %n.3250 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond246.not, label %for.end132.loopexit, label %for.body126 of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 18
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 18
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16get_lit_intervalEPiPNS_19Lit_Interval_StructEiPNS_17Light_List_StructEPNS_10istk_entryES4_i' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %curr.3234 = phi ptr [ %incdec.ptr129, %for.body126 ], [ %Lit_Interval, %for.body126.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.3233 = phi i32 [ %inc131, %for.body126 ], [ 0, %for.body126.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %s1127 = getelementptr inbounds i8, ptr %curr.3234, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %29 = load double, ptr %s1127, align 8, !tbaa !25 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %30 = load double, ptr %s0128, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = fsub double %29, %30 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ds = getelementptr inbounds i8, ptr %curr.3234, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %sub, ptr %ds, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %curr.3234, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc131 = add nuw nsw i32 %i.3233, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond246.not = icmp eq i32 %inc131, %n.3250 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond246.not, label %for.end132.loopexit, label %for.body126 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 17
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 34

-----------------Function that is being costed:'_ZN3povL16get_lit_intervalEPiPNS_19Lit_Interval_StructEiPNS_17Light_List_StructEPNS_10istk_entryES4_i' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %curr.3234 = phi ptr [ %incdec.ptr129, %for.body126 ], [ %Lit_Interval, %for.body126.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.3233 = phi i32 [ %inc131, %for.body126 ], [ 0, %for.body126.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %s1127 = getelementptr inbounds i8, ptr %curr.3234, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   %29 = load double, ptr %s1127, align 8, !tbaa !25 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %30 = load double, ptr %s0128, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = fsub double %29, %30 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ds = getelementptr inbounds i8, ptr %curr.3234, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double %sub, ptr %ds, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr129 = getelementptr inbounds i8, ptr %curr.3234, i64 32 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc131 = add nuw nsw i32 %i.3233, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond246.not = icmp eq i32 %inc131, %n.3250 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond246.not, label %for.end132.loopexit, label %for.body126 of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 126
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 126, CostB * EstimatedWidthA: 36
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 126
B VF: 2, EstimatedWidthB: 2, CostB: 17
CostA * EstimatedWidthB: 252, CostB * EstimatedWidthA: 68
LV: Selecting VF: 2 With Cost: 8.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=2 at function: _ZN3povL16get_lit_intervalEPiPNS_19Lit_Interval_StructEiPNS_17Light_List_StructEPNS_10istk_entryES4_i at line: media.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body126.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %n.3250)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<32>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<32>
    EMIT vp<%6> = ptradd ir<%Lit_Interval>, vp<%5>
    CLONE ir<%s1127> = getelementptr inbounds vp<%6>, ir<16>
    INTERLEAVE-GROUP with factor 4 at %29, ir<%s1127>
      ir<%30> = load from index 0
      ir<%29> = load from index 1
    WIDEN ir<%sub> = fsub ir<%29>, ir<%30>
    REPLICATE ir<%ds> = getelementptr inbounds vp<%6>, ir<24>
    REPLICATE store ir<%sub>, ir<%ds>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 27
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %4 = load double, ptr %arrayidx, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %4, ptr %arrayidx16, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load double, ptr %arrayidx, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %4, ptr %arrayidx16, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %4 = load double, ptr %arrayidx, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %4, ptr %arrayidx16, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov10Copy_MediaEPNS_12Media_StructE' from media.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body12.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%call7>, ir<%indvars.iv>
    CLONE store ir<%4>, ir<%arrayidx16>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov10Copy_MediaEPNS_12Media_StructE' from media.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body12.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%call7>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%5>, ir<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov10Copy_MediaEPNS_12Media_StructE' from media.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body12.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%call7>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%5>, ir<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov10Copy_MediaEPNS_12Media_StructE' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body12.lr.ph ], [ %indvars.iv.next, %for.body12 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx16 = getelementptr inbounds double, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %4, ptr %arrayidx16, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body12 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3pov10Copy_MediaEPNS_12Media_StructE' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body12.lr.ph ], [ %indvars.iv.next, %for.body12 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx16 = getelementptr inbounds double, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %4, ptr %arrayidx16, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body12 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967298, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov10Copy_MediaEPNS_12Media_StructE' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body12.lr.ph ], [ %indvars.iv.next, %for.body12 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx16 = getelementptr inbounds double, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %4, ptr %arrayidx16, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body12 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967298

-----------------Function that is being costed:'_ZN3pov10Copy_MediaEPNS_12Media_StructE' from media.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body12.lr.ph ], [ %indvars.iv.next, %for.body12 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load double, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx16 = getelementptr inbounds double, ptr %call7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %4, ptr %arrayidx16, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body12 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 4294967298
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov10Copy_MediaEPNS_12Media_StructE at line: media.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body12.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%9> = load vp<%5>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%call7>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%6>, ir<%9>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 29
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o mesh.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           mesh.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o messageoutput.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           messageoutput.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o normal.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           normal.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o objects.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           objects.cpp
========== Loop: _ZN3povL13create_istackEv' from objects.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%Object> = getelementptr inbounds ir<%call1>, ir<%indvars.iv>, ir<5>
    CLONE store ir<null>, ir<%Object>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL13create_istackEv' from objects.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%Object> = getelementptr inbounds ir<%call1>, ir<%indvars.iv>, ir<5>
    REPLICATE store ir<null>, ir<%Object>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL13create_istackEv' from objects.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%Object> = getelementptr inbounds ir<%call1>, ir<%indvars.iv>, ir<5>
    REPLICATE store ir<null>, ir<%Object>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL13create_istackEv' from objects.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%Object> = getelementptr inbounds ir<%call1>, ir<%indvars.iv>, ir<5>
    WIDEN store ir<%Object>, ir<null>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL13create_istackEv' from objects.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %Object = getelementptr inbounds %"struct.pov::istk_entry", ptr %call1, i64 %indvars.iv, i32 5 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %Object, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL13create_istackEv' from objects.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %Object = getelementptr inbounds %"struct.pov::istk_entry", ptr %call1, i64 %indvars.iv, i32 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store ptr null, ptr %Object, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 14

-----------------Function that is being costed:'_ZN3povL13create_istackEv' from objects.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %Object = getelementptr inbounds %"struct.pov::istk_entry", ptr %call1, i64 %indvars.iv, i32 5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %Object, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180

-----------------Function that is being costed:'_ZN3povL13create_istackEv' from objects.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %Object = getelementptr inbounds %"struct.pov::istk_entry", ptr %call1, i64 %indvars.iv, i32 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr null, ptr %Object, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 46170898401, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: 46170898401, RTCostB: 17179869180
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL13create_istackEv at line: objects.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%Object> = getelementptr inbounds ir<%call1>, vp<%4>, ir<5>
    CLONE store ir<null>, ir<%Object>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 16
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o octree.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           octree.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o optout.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           optout.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o parse.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           parse.cpp
========== Loop: _ZN3povL11Parse_Mesh2Ev' from parse.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body373.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %conv108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1028 = phi 0, %indvars.iv.next1029, ir<1>
    CLONE ir<%arrayidx375> = getelementptr inbounds ir<%call115>, ir<%indvars.iv1028>
    CLONE ir<%P1376> = getelementptr inbounds ir<%arrayidx375>, ir<16>
    CLONE ir<%28> = load ir<%P1376>
    CLONE ir<%UV1379> = getelementptr inbounds ir<%arrayidx375>, ir<88>
    CLONE store ir<%28>, ir<%UV1379>
    CLONE ir<%P2382> = getelementptr inbounds ir<%arrayidx375>, ir<24>
    CLONE ir<%29> = load ir<%P2382>
    CLONE ir<%UV2385> = getelementptr inbounds ir<%arrayidx375>, ir<96>
    CLONE store ir<%29>, ir<%UV2385>
    CLONE ir<%P3388> = getelementptr inbounds ir<%arrayidx375>, ir<32>
    CLONE ir<%30> = load ir<%P3388>
    CLONE ir<%UV3391> = getelementptr inbounds ir<%arrayidx375>, ir<104>
    CLONE store ir<%30>, ir<%UV3391>
    CLONE ir<%indvars.iv.next1029> = add nuw nsw ir<%indvars.iv1028>, ir<1>
    CLONE ir<%exitcond1032.not> = icmp eq ir<%indvars.iv.next1029>, ir<%wide.trip.count1031>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end416.loopexit>, scalar.ph

ir-bb<if.end416.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11Parse_Mesh2Ev' from parse.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body373.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %conv108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1028 = phi 0, %indvars.iv.next1029, ir<1>
    REPLICATE ir<%arrayidx375> = getelementptr inbounds ir<%call115>, ir<%indvars.iv1028>
    REPLICATE ir<%P1376> = getelementptr inbounds ir<%arrayidx375>, ir<16>
    REPLICATE ir<%28> = load ir<%P1376>
    REPLICATE ir<%UV1379> = getelementptr inbounds ir<%arrayidx375>, ir<88>
    REPLICATE store ir<%28>, ir<%UV1379>
    REPLICATE ir<%P2382> = getelementptr inbounds ir<%arrayidx375>, ir<24>
    REPLICATE ir<%29> = load ir<%P2382>
    REPLICATE ir<%UV2385> = getelementptr inbounds ir<%arrayidx375>, ir<96>
    REPLICATE store ir<%29>, ir<%UV2385>
    REPLICATE ir<%P3388> = getelementptr inbounds ir<%arrayidx375>, ir<32>
    REPLICATE ir<%30> = load ir<%P3388>
    REPLICATE ir<%UV3391> = getelementptr inbounds ir<%arrayidx375>, ir<104>
    REPLICATE store ir<%30>, ir<%UV3391>
    REPLICATE ir<%indvars.iv.next1029> = add nuw nsw ir<%indvars.iv1028>, ir<1>
    CLONE ir<%exitcond1032.not> = icmp eq ir<%indvars.iv.next1029>, ir<%wide.trip.count1031>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end416.loopexit>, scalar.ph

ir-bb<if.end416.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11Parse_Mesh2Ev' from parse.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body373.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %conv108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1028 = phi 0, %indvars.iv.next1029, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx375> = getelementptr inbounds ir<%call115>, ir<%indvars.iv1028>
    WIDEN-GEP Var[Inv] ir<%P1376> = getelementptr inbounds ir<%arrayidx375>, ir<16>
    REPLICATE ir<%28> = load ir<%P1376>
    WIDEN-GEP Var[Inv] ir<%UV1379> = getelementptr inbounds ir<%arrayidx375>, ir<88>
    REPLICATE store ir<%28>, ir<%UV1379>
    WIDEN-GEP Var[Inv] ir<%P2382> = getelementptr inbounds ir<%arrayidx375>, ir<24>
    REPLICATE ir<%29> = load ir<%P2382>
    WIDEN-GEP Var[Inv] ir<%UV2385> = getelementptr inbounds ir<%arrayidx375>, ir<96>
    REPLICATE store ir<%29>, ir<%UV2385>
    WIDEN-GEP Var[Inv] ir<%P3388> = getelementptr inbounds ir<%arrayidx375>, ir<32>
    REPLICATE ir<%30> = load ir<%P3388>
    WIDEN-GEP Var[Inv] ir<%UV3391> = getelementptr inbounds ir<%arrayidx375>, ir<104>
    REPLICATE store ir<%30>, ir<%UV3391>
    WIDEN ir<%indvars.iv.next1029> = add nuw nsw ir<%indvars.iv1028>, ir<1>
    CLONE ir<%exitcond1032.not> = icmp eq ir<%indvars.iv.next1029>, ir<%wide.trip.count1031>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end416.loopexit>, scalar.ph

ir-bb<if.end416.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11Parse_Mesh2Ev' from parse.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body373.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %conv108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1028 = phi 0, %indvars.iv.next1029, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx375> = getelementptr inbounds ir<%call115>, ir<%indvars.iv1028>
    WIDEN-GEP Var[Inv] ir<%P1376> = getelementptr inbounds ir<%arrayidx375>, ir<16>
    WIDEN ir<%28> = load ir<%P1376>
    WIDEN-GEP Var[Inv] ir<%UV1379> = getelementptr inbounds ir<%arrayidx375>, ir<88>
    WIDEN store ir<%UV1379>, ir<%28>
    WIDEN-GEP Var[Inv] ir<%P2382> = getelementptr inbounds ir<%arrayidx375>, ir<24>
    WIDEN ir<%29> = load ir<%P2382>
    WIDEN-GEP Var[Inv] ir<%UV2385> = getelementptr inbounds ir<%arrayidx375>, ir<96>
    WIDEN store ir<%UV2385>, ir<%29>
    WIDEN-GEP Var[Inv] ir<%P3388> = getelementptr inbounds ir<%arrayidx375>, ir<32>
    WIDEN ir<%30> = load ir<%P3388>
    WIDEN-GEP Var[Inv] ir<%UV3391> = getelementptr inbounds ir<%arrayidx375>, ir<104>
    WIDEN store ir<%UV3391>, ir<%30>
    WIDEN ir<%indvars.iv.next1029> = add nuw nsw ir<%indvars.iv1028>, ir<1>
    CLONE ir<%exitcond1032.not> = icmp eq ir<%indvars.iv.next1029>, ir<%wide.trip.count1031>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end416.loopexit>, scalar.ph

ir-bb<if.end416.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL11Parse_Mesh2Ev' from parse.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1028 = phi i64 [ 0, %for.body373.preheader ], [ %indvars.iv.next1029, %for.body373 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx375 = getelementptr inbounds %"struct.pov::Mesh_Triangle_Struct", ptr %call115, i64 %indvars.iv1028 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %P1376 = getelementptr inbounds i8, ptr %arrayidx375, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %28 = load i64, ptr %P1376, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %UV1379 = getelementptr inbounds i8, ptr %arrayidx375, i64 88 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %28, ptr %UV1379, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %P2382 = getelementptr inbounds i8, ptr %arrayidx375, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %29 = load i64, ptr %P2382, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %UV2385 = getelementptr inbounds i8, ptr %arrayidx375, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %29, ptr %UV2385, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %P3388 = getelementptr inbounds i8, ptr %arrayidx375, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %30 = load i64, ptr %P3388, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %UV3391 = getelementptr inbounds i8, ptr %arrayidx375, i64 104 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %30, ptr %UV3391, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1029 = add nuw nsw i64 %indvars.iv1028, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1032.not = icmp eq i64 %indvars.iv.next1029, %wide.trip.count1031 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1032.not, label %if.end416.loopexit, label %for.body373 of type:br
LV: Scalar loop costs: 14.
-----------------Function that is being costed:'_ZN3povL11Parse_Mesh2Ev' from parse.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1028 = phi i64 [ 0, %for.body373.preheader ], [ %indvars.iv.next1029, %for.body373 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx375 = getelementptr inbounds %"struct.pov::Mesh_Triangle_Struct", ptr %call115, i64 %indvars.iv1028 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %P1376 = getelementptr inbounds i8, ptr %arrayidx375, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %28 = load i64, ptr %P1376, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %UV1379 = getelementptr inbounds i8, ptr %arrayidx375, i64 88 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i64 %28, ptr %UV1379, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %P2382 = getelementptr inbounds i8, ptr %arrayidx375, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %29 = load i64, ptr %P2382, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %UV2385 = getelementptr inbounds i8, ptr %arrayidx375, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i64 %29, ptr %UV2385, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %P3388 = getelementptr inbounds i8, ptr %arrayidx375, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %30 = load i64, ptr %P3388, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %UV3391 = getelementptr inbounds i8, ptr %arrayidx375, i64 104 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i64 %30, ptr %UV3391, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1029 = add nuw nsw i64 %indvars.iv1028, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1032.not = icmp eq i64 %indvars.iv.next1029, %wide.trip.count1031 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1032.not, label %if.end416.loopexit, label %for.body373 of type:br
LV: Vector loop of width 2 costs: 91

-----------------Function that is being costed:'_ZN3povL11Parse_Mesh2Ev' from parse.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1028 = phi i64 [ 0, %for.body373.preheader ], [ %indvars.iv.next1029, %for.body373 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx375 = getelementptr inbounds %"struct.pov::Mesh_Triangle_Struct", ptr %call115, i64 %indvars.iv1028 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %P1376 = getelementptr inbounds i8, ptr %arrayidx375, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %28 = load i64, ptr %P1376, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %UV1379 = getelementptr inbounds i8, ptr %arrayidx375, i64 88 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %28, ptr %UV1379, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %P2382 = getelementptr inbounds i8, ptr %arrayidx375, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %29 = load i64, ptr %P2382, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %UV2385 = getelementptr inbounds i8, ptr %arrayidx375, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %29, ptr %UV2385, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %P3388 = getelementptr inbounds i8, ptr %arrayidx375, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %30 = load i64, ptr %P3388, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %UV3391 = getelementptr inbounds i8, ptr %arrayidx375, i64 104 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %30, ptr %UV3391, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1029 = add nuw nsw i64 %indvars.iv1028, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1032.not = icmp eq i64 %indvars.iv.next1029, %wide.trip.count1031 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1032.not, label %if.end416.loopexit, label %for.body373 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771058
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771058

-----------------Function that is being costed:'_ZN3povL11Parse_Mesh2Ev' from parse.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1028 = phi i64 [ 0, %for.body373.preheader ], [ %indvars.iv.next1029, %for.body373 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx375 = getelementptr inbounds %"struct.pov::Mesh_Triangle_Struct", ptr %call115, i64 %indvars.iv1028 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %P1376 = getelementptr inbounds i8, ptr %arrayidx375, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %28 = load i64, ptr %P1376, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %UV1379 = getelementptr inbounds i8, ptr %arrayidx375, i64 88 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %28, ptr %UV1379, align 8, !tbaa !26 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %P2382 = getelementptr inbounds i8, ptr %arrayidx375, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %29 = load i64, ptr %P2382, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %UV2385 = getelementptr inbounds i8, ptr %arrayidx375, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %29, ptr %UV2385, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %P3388 = getelementptr inbounds i8, ptr %arrayidx375, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %30 = load i64, ptr %P3388, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %UV3391 = getelementptr inbounds i8, ptr %arrayidx375, i64 104 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %30, ptr %UV3391, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1029 = add nuw nsw i64 %indvars.iv1028, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1032.not = icmp eq i64 %indvars.iv.next1029, %wide.trip.count1031 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1032.not, label %if.end416.loopexit, label %for.body373 of type:br
LV: Vector loop of width vscale x 2 costs: 62
A is scalable.	B is not scalable.	
RTCostA: 133143985970, RTCostB: 30064771058
A is scalable.	B is not scalable.	
RTCostA: 133143985970, RTCostB: 30064771058
LV: Selecting VF: 1 With Cost: 14.
maxbefore: 2
maxafter: 2
========== Loop: _ZN3povL11Parse_Mesh2Ev' from parse.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body423.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %conv108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1033 = phi 0, %indvars.iv.next1034, ir<1>
    CLONE ir<%arrayidx425> = getelementptr inbounds ir<%call115>, ir<%indvars.iv1033>
    CLONE ir<%P1426> = getelementptr inbounds ir<%arrayidx425>, ir<16>
    CLONE ir<%31> = load ir<%P1426>
    CLONE ir<%N1429> = getelementptr inbounds ir<%arrayidx425>, ir<64>
    CLONE store ir<%31>, ir<%N1429>
    CLONE ir<%P2432> = getelementptr inbounds ir<%arrayidx425>, ir<24>
    CLONE ir<%32> = load ir<%P2432>
    CLONE ir<%N2435> = getelementptr inbounds ir<%arrayidx425>, ir<72>
    CLONE store ir<%32>, ir<%N2435>
    CLONE ir<%P3438> = getelementptr inbounds ir<%arrayidx425>, ir<32>
    CLONE ir<%33> = load ir<%P3438>
    CLONE ir<%N3441> = getelementptr inbounds ir<%arrayidx425>, ir<80>
    CLONE store ir<%33>, ir<%N3441>
    CLONE ir<%indvars.iv.next1034> = add nuw nsw ir<%indvars.iv1033>, ir<1>
    CLONE ir<%exitcond1037.not> = icmp eq ir<%indvars.iv.next1034>, ir<%wide.trip.count1036>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end451.loopexit>, scalar.ph

ir-bb<if.end451.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11Parse_Mesh2Ev' from parse.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body423.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %conv108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1033 = phi 0, %indvars.iv.next1034, ir<1>
    REPLICATE ir<%arrayidx425> = getelementptr inbounds ir<%call115>, ir<%indvars.iv1033>
    REPLICATE ir<%P1426> = getelementptr inbounds ir<%arrayidx425>, ir<16>
    REPLICATE ir<%31> = load ir<%P1426>
    REPLICATE ir<%N1429> = getelementptr inbounds ir<%arrayidx425>, ir<64>
    REPLICATE store ir<%31>, ir<%N1429>
    REPLICATE ir<%P2432> = getelementptr inbounds ir<%arrayidx425>, ir<24>
    REPLICATE ir<%32> = load ir<%P2432>
    REPLICATE ir<%N2435> = getelementptr inbounds ir<%arrayidx425>, ir<72>
    REPLICATE store ir<%32>, ir<%N2435>
    REPLICATE ir<%P3438> = getelementptr inbounds ir<%arrayidx425>, ir<32>
    REPLICATE ir<%33> = load ir<%P3438>
    REPLICATE ir<%N3441> = getelementptr inbounds ir<%arrayidx425>, ir<80>
    REPLICATE store ir<%33>, ir<%N3441>
    REPLICATE ir<%indvars.iv.next1034> = add nuw nsw ir<%indvars.iv1033>, ir<1>
    CLONE ir<%exitcond1037.not> = icmp eq ir<%indvars.iv.next1034>, ir<%wide.trip.count1036>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end451.loopexit>, scalar.ph

ir-bb<if.end451.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11Parse_Mesh2Ev' from parse.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body423.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %conv108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1033 = phi 0, %indvars.iv.next1034, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx425> = getelementptr inbounds ir<%call115>, ir<%indvars.iv1033>
    WIDEN-GEP Var[Inv] ir<%P1426> = getelementptr inbounds ir<%arrayidx425>, ir<16>
    REPLICATE ir<%31> = load ir<%P1426>
    WIDEN-GEP Var[Inv] ir<%N1429> = getelementptr inbounds ir<%arrayidx425>, ir<64>
    REPLICATE store ir<%31>, ir<%N1429>
    WIDEN-GEP Var[Inv] ir<%P2432> = getelementptr inbounds ir<%arrayidx425>, ir<24>
    REPLICATE ir<%32> = load ir<%P2432>
    WIDEN-GEP Var[Inv] ir<%N2435> = getelementptr inbounds ir<%arrayidx425>, ir<72>
    REPLICATE store ir<%32>, ir<%N2435>
    WIDEN-GEP Var[Inv] ir<%P3438> = getelementptr inbounds ir<%arrayidx425>, ir<32>
    REPLICATE ir<%33> = load ir<%P3438>
    WIDEN-GEP Var[Inv] ir<%N3441> = getelementptr inbounds ir<%arrayidx425>, ir<80>
    REPLICATE store ir<%33>, ir<%N3441>
    WIDEN ir<%indvars.iv.next1034> = add nuw nsw ir<%indvars.iv1033>, ir<1>
    CLONE ir<%exitcond1037.not> = icmp eq ir<%indvars.iv.next1034>, ir<%wide.trip.count1036>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end451.loopexit>, scalar.ph

ir-bb<if.end451.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL11Parse_Mesh2Ev' from parse.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body423.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %conv108 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1033 = phi 0, %indvars.iv.next1034, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx425> = getelementptr inbounds ir<%call115>, ir<%indvars.iv1033>
    WIDEN-GEP Var[Inv] ir<%P1426> = getelementptr inbounds ir<%arrayidx425>, ir<16>
    WIDEN ir<%31> = load ir<%P1426>
    WIDEN-GEP Var[Inv] ir<%N1429> = getelementptr inbounds ir<%arrayidx425>, ir<64>
    WIDEN store ir<%N1429>, ir<%31>
    WIDEN-GEP Var[Inv] ir<%P2432> = getelementptr inbounds ir<%arrayidx425>, ir<24>
    WIDEN ir<%32> = load ir<%P2432>
    WIDEN-GEP Var[Inv] ir<%N2435> = getelementptr inbounds ir<%arrayidx425>, ir<72>
    WIDEN store ir<%N2435>, ir<%32>
    WIDEN-GEP Var[Inv] ir<%P3438> = getelementptr inbounds ir<%arrayidx425>, ir<32>
    WIDEN ir<%33> = load ir<%P3438>
    WIDEN-GEP Var[Inv] ir<%N3441> = getelementptr inbounds ir<%arrayidx425>, ir<80>
    WIDEN store ir<%N3441>, ir<%33>
    WIDEN ir<%indvars.iv.next1034> = add nuw nsw ir<%indvars.iv1033>, ir<1>
    CLONE ir<%exitcond1037.not> = icmp eq ir<%indvars.iv.next1034>, ir<%wide.trip.count1036>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end451.loopexit>, scalar.ph

ir-bb<if.end451.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL11Parse_Mesh2Ev' from parse.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1033 = phi i64 [ 0, %for.body423.preheader ], [ %indvars.iv.next1034, %for.body423 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx425 = getelementptr inbounds %"struct.pov::Mesh_Triangle_Struct", ptr %call115, i64 %indvars.iv1033 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %P1426 = getelementptr inbounds i8, ptr %arrayidx425, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %31 = load i64, ptr %P1426, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %N1429 = getelementptr inbounds i8, ptr %arrayidx425, i64 64 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %31, ptr %N1429, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %P2432 = getelementptr inbounds i8, ptr %arrayidx425, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %32 = load i64, ptr %P2432, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %N2435 = getelementptr inbounds i8, ptr %arrayidx425, i64 72 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %32, ptr %N2435, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %P3438 = getelementptr inbounds i8, ptr %arrayidx425, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %33 = load i64, ptr %P3438, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %N3441 = getelementptr inbounds i8, ptr %arrayidx425, i64 80 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %33, ptr %N3441, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1034 = add nuw nsw i64 %indvars.iv1033, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1037.not = icmp eq i64 %indvars.iv.next1034, %wide.trip.count1036 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1037.not, label %if.end451.loopexit, label %for.body423 of type:br
LV: Scalar loop costs: 14.
-----------------Function that is being costed:'_ZN3povL11Parse_Mesh2Ev' from parse.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1033 = phi i64 [ 0, %for.body423.preheader ], [ %indvars.iv.next1034, %for.body423 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx425 = getelementptr inbounds %"struct.pov::Mesh_Triangle_Struct", ptr %call115, i64 %indvars.iv1033 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %P1426 = getelementptr inbounds i8, ptr %arrayidx425, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %31 = load i64, ptr %P1426, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %N1429 = getelementptr inbounds i8, ptr %arrayidx425, i64 64 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i64 %31, ptr %N1429, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %P2432 = getelementptr inbounds i8, ptr %arrayidx425, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %32 = load i64, ptr %P2432, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %N2435 = getelementptr inbounds i8, ptr %arrayidx425, i64 72 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i64 %32, ptr %N2435, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %P3438 = getelementptr inbounds i8, ptr %arrayidx425, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %33 = load i64, ptr %P3438, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %N3441 = getelementptr inbounds i8, ptr %arrayidx425, i64 80 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i64 %33, ptr %N3441, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1034 = add nuw nsw i64 %indvars.iv1033, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1037.not = icmp eq i64 %indvars.iv.next1034, %wide.trip.count1036 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1037.not, label %if.end451.loopexit, label %for.body423 of type:br
LV: Vector loop of width 2 costs: 91

-----------------Function that is being costed:'_ZN3povL11Parse_Mesh2Ev' from parse.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1033 = phi i64 [ 0, %for.body423.preheader ], [ %indvars.iv.next1034, %for.body423 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx425 = getelementptr inbounds %"struct.pov::Mesh_Triangle_Struct", ptr %call115, i64 %indvars.iv1033 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %P1426 = getelementptr inbounds i8, ptr %arrayidx425, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %31 = load i64, ptr %P1426, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %N1429 = getelementptr inbounds i8, ptr %arrayidx425, i64 64 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %31, ptr %N1429, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %P2432 = getelementptr inbounds i8, ptr %arrayidx425, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %32 = load i64, ptr %P2432, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %N2435 = getelementptr inbounds i8, ptr %arrayidx425, i64 72 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %32, ptr %N2435, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %P3438 = getelementptr inbounds i8, ptr %arrayidx425, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %33 = load i64, ptr %P3438, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %N3441 = getelementptr inbounds i8, ptr %arrayidx425, i64 80 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %33, ptr %N3441, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next1034 = add nuw nsw i64 %indvars.iv1033, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1037.not = icmp eq i64 %indvars.iv.next1034, %wide.trip.count1036 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1037.not, label %if.end451.loopexit, label %for.body423 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771058
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771058

-----------------Function that is being costed:'_ZN3povL11Parse_Mesh2Ev' from parse.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1033 = phi i64 [ 0, %for.body423.preheader ], [ %indvars.iv.next1034, %for.body423 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx425 = getelementptr inbounds %"struct.pov::Mesh_Triangle_Struct", ptr %call115, i64 %indvars.iv1033 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %P1426 = getelementptr inbounds i8, ptr %arrayidx425, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %31 = load i64, ptr %P1426, align 8, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %N1429 = getelementptr inbounds i8, ptr %arrayidx425, i64 64 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %31, ptr %N1429, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %P2432 = getelementptr inbounds i8, ptr %arrayidx425, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %32 = load i64, ptr %P2432, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %N2435 = getelementptr inbounds i8, ptr %arrayidx425, i64 72 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %32, ptr %N2435, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %P3438 = getelementptr inbounds i8, ptr %arrayidx425, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %33 = load i64, ptr %P3438, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %N3441 = getelementptr inbounds i8, ptr %arrayidx425, i64 80 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %33, ptr %N3441, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1034 = add nuw nsw i64 %indvars.iv1033, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1037.not = icmp eq i64 %indvars.iv.next1034, %wide.trip.count1036 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1037.not, label %if.end451.loopexit, label %for.body423 of type:br
LV: Vector loop of width vscale x 2 costs: 62
A is scalable.	B is not scalable.	
RTCostA: 133143985970, RTCostB: 30064771058
A is scalable.	B is not scalable.	
RTCostA: 133143985970, RTCostB: 30064771058
LV: Selecting VF: 1 With Cost: 14.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o parsestr.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           parsestr.cpp
@@ Instruction =>  %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 -> Cost: 2 -> VectorType: <16 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 -> Cost: 2 -> VectorType: <16 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov14String_To_UCS2EPcb' from parsestr.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i31 (trunc i64 %call to i31) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv250 = phi %indvars.iv.next251, 0, ir<1>
    CLONE ir<%arrayidx8.us> = getelementptr inbounds ir<%str>, ir<%indvars.iv250>
    CLONE ir<%3> = load ir<%arrayidx8.us>
    CLONE ir<%conv9.us> = zext ir<%3>
    CLONE ir<%arrayidx11.us> = getelementptr inbounds ir<%call4>, ir<%indvars.iv250>
    CLONE store ir<%conv9.us>, ir<%arrayidx11.us>
    CLONE ir<%indvars.iv.next251> = add nuw nsw ir<%indvars.iv250>, ir<1>
    CLONE ir<%exitcond254.not> = icmp eq ir<%indvars.iv.next251>, ir<%wide.trip.count253>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end44.loopexit>, scalar.ph

ir-bb<if.end44.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov14String_To_UCS2EPcb' from parsestr.cpp==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i31 (trunc i64 %call to i31) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv250 = phi %indvars.iv.next251, 0, ir<1>
    CLONE ir<%arrayidx8.us> = getelementptr inbounds ir<%str>, ir<%indvars.iv250>
    vp<%4> = vector-pointer ir<%arrayidx8.us>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%conv9.us> = zext  ir<%3> to i16
    CLONE ir<%arrayidx11.us> = getelementptr inbounds ir<%call4>, ir<%indvars.iv250>
    vp<%5> = vector-pointer ir<%arrayidx11.us>
    WIDEN store vp<%5>, ir<%conv9.us>
    CLONE ir<%indvars.iv.next251> = add nuw nsw ir<%indvars.iv250>, ir<1>
    CLONE ir<%exitcond254.not> = icmp eq ir<%indvars.iv.next251>, ir<%wide.trip.count253>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end44.loopexit>, scalar.ph

ir-bb<if.end44.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov14String_To_UCS2EPcb' from parsestr.cpp==========
========== VPlan for Vector Factor Range: 1 to 16==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i31 (trunc i64 %call to i31) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv250 = phi %indvars.iv.next251, 0, ir<1>
    CLONE ir<%arrayidx8.us> = getelementptr inbounds ir<%str>, ir<%indvars.iv250>
    vp<%4> = vector-pointer ir<%arrayidx8.us>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%conv9.us> = zext  ir<%3> to i16
    CLONE ir<%arrayidx11.us> = getelementptr inbounds ir<%call4>, ir<%indvars.iv250>
    vp<%5> = vector-pointer ir<%arrayidx11.us>
    WIDEN store vp<%5>, ir<%conv9.us>
    CLONE ir<%indvars.iv.next251> = add nuw nsw ir<%indvars.iv250>, ir<1>
    CLONE ir<%exitcond254.not> = icmp eq ir<%indvars.iv.next251>, ir<%wide.trip.count253>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end44.loopexit>, scalar.ph

ir-bb<if.end44.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv250 = phi i64 [ %indvars.iv.next251, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx8.us = getelementptr inbounds i8, ptr %str, i64 %indvars.iv250 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv9.us = zext i8 %3 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx11.us = getelementptr inbounds i16, ptr %call4, i64 %indvars.iv250 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next251 = add nuw nsw i64 %indvars.iv250, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond254.not = icmp eq i64 %indvars.iv.next251, %wide.trip.count253 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond254.not, label %if.end44.loopexit, label %for.body.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv250 = phi i64 [ %indvars.iv.next251, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx8.us = getelementptr inbounds i8, ptr %str, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv9.us = zext i8 %3 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx11.us = getelementptr inbounds i16, ptr %call4, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next251 = add nuw nsw i64 %indvars.iv250, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond254.not = icmp eq i64 %indvars.iv.next251, %wide.trip.count253 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond254.not, label %if.end44.loopexit, label %for.body.us of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv250 = phi i64 [ %indvars.iv.next251, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx8.us = getelementptr inbounds i8, ptr %str, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv9.us = zext i8 %3 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx11.us = getelementptr inbounds i16, ptr %call4, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next251 = add nuw nsw i64 %indvars.iv250, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond254.not = icmp eq i64 %indvars.iv.next251, %wide.trip.count253 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond254.not, label %if.end44.loopexit, label %for.body.us of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 11
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 44
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv250 = phi i64 [ %indvars.iv.next251, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx8.us = getelementptr inbounds i8, ptr %str, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv9.us = zext i8 %3 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx11.us = getelementptr inbounds i16, ptr %call4, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next251 = add nuw nsw i64 %indvars.iv250, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond254.not = icmp eq i64 %indvars.iv.next251, %wide.trip.count253 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond254.not, label %if.end44.loopexit, label %for.body.us of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv250 = phi i64 [ %indvars.iv.next251, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx8.us = getelementptr inbounds i8, ptr %str, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 of type:load
LV: Found an estimated cost of 2 for VF 16 For instruction:   %conv9.us = zext i8 %3 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx11.us = getelementptr inbounds i16, ptr %call4, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 16 For instruction:   store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next251 = add nuw nsw i64 %indvars.iv250, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond254.not = icmp eq i64 %indvars.iv.next251, %wide.trip.count253 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond254.not, label %if.end44.loopexit, label %for.body.us of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv250 = phi i64 [ %indvars.iv.next251, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx8.us = getelementptr inbounds i8, ptr %str, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv9.us = zext i8 %3 to i16 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx11.us = getelementptr inbounds i16, ptr %call4, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next251 = add nuw nsw i64 %indvars.iv250, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond254.not = icmp eq i64 %indvars.iv.next251, %wide.trip.count253 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond254.not, label %if.end44.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv250 = phi i64 [ %indvars.iv.next251, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx8.us = getelementptr inbounds i8, ptr %str, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv9.us = zext i8 %3 to i16 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx11.us = getelementptr inbounds i16, ptr %call4, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next251 = add nuw nsw i64 %indvars.iv250, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond254.not = icmp eq i64 %indvars.iv.next251, %wide.trip.count253 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond254.not, label %if.end44.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv250 = phi i64 [ %indvars.iv.next251, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx8.us = getelementptr inbounds i8, ptr %str, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv9.us = zext i8 %3 to i16 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx11.us = getelementptr inbounds i16, ptr %call4, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next251 = add nuw nsw i64 %indvars.iv250, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond254.not = icmp eq i64 %indvars.iv.next251, %wide.trip.count253 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond254.not, label %if.end44.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 56

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv250 = phi i64 [ %indvars.iv.next251, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx8.us = getelementptr inbounds i8, ptr %str, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %3 = load i8, ptr %arrayidx8.us, align 1, !tbaa !25 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %conv9.us = zext i8 %3 to i16 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx11.us = getelementptr inbounds i16, ptr %call4, i64 %indvars.iv250 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i16 %conv9.us, ptr %arrayidx11.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next251 = add nuw nsw i64 %indvars.iv250, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond254.not = icmp eq i64 %indvars.iv.next251, %wide.trip.count253 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond254.not, label %if.end44.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 11
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 44
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 40
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: _ZN3pov14String_To_UCS2EPcb at line: parsestr.cpp
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=2 at function: _ZN3pov14String_To_UCS2EPcb at line: parsestr.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i31 (trunc i64 %call to i31) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx8.us> = getelementptr inbounds ir<%str>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx8.us>
    WIDEN ir<%4> = load vp<%5>
    WIDEN-CAST ir<%conv9.us> = zext  ir<%4> to i16
    CLONE ir<%arrayidx11.us> = getelementptr inbounds ir<%call4>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx11.us>
    WIDEN store vp<%6>, ir<%conv9.us>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end44.loopexit>, scalar.ph

ir-bb<if.end44.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: _ZN3pov14String_To_UCS2EPcb at line: parsestr.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count253> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx8.us> = getelementptr inbounds ir<%str>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx8.us>
    WIDEN ir<%33> = load vp<%4>
    WIDEN-CAST ir<%conv9.us> = zext  ir<%33> to i16
    CLONE ir<%arrayidx11.us> = getelementptr inbounds ir<%call4>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx11.us>
    WIDEN store vp<%5>, ir<%conv9.us>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%wide.trip.count253>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end44.loopexit>, scalar.ph

ir-bb<if.end44.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov14String_To_UCS2EPcb' from parsestr.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body50.lr.ph.split.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %53 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv258 = phi %indvars.iv.next259, 0, ir<1>
    CLONE ir<%arrayidx52.us> = getelementptr inbounds ir<%char_array.0237>, ir<%indvars.iv258>
    CLONE ir<%54> = load ir<%arrayidx52.us>
    CLONE ir<%arrayidx136.us> = getelementptr inbounds ir<%call47>, ir<%indvars.iv258>
    CLONE store ir<%54>, ir<%arrayidx136.us>
    CLONE ir<%indvars.iv.next259> = add nuw nsw ir<%indvars.iv258>, ir<1>
    CLONE ir<%exitcond264.not> = icmp eq ir<%indvars.iv.next259>, ir<%wide.trip.count263>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end141.loopexit>, scalar.ph

ir-bb<for.end141.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov14String_To_UCS2EPcb' from parsestr.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body50.lr.ph.split.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %53 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv258 = phi %indvars.iv.next259, 0, ir<1>
    CLONE ir<%arrayidx52.us> = getelementptr inbounds ir<%char_array.0237>, ir<%indvars.iv258>
    vp<%4> = vector-pointer ir<%arrayidx52.us>
    WIDEN ir<%54> = load vp<%4>
    CLONE ir<%arrayidx136.us> = getelementptr inbounds ir<%call47>, ir<%indvars.iv258>
    vp<%5> = vector-pointer ir<%arrayidx136.us>
    WIDEN store vp<%5>, ir<%54>
    CLONE ir<%indvars.iv.next259> = add nuw nsw ir<%indvars.iv258>, ir<1>
    CLONE ir<%exitcond264.not> = icmp eq ir<%indvars.iv.next259>, ir<%wide.trip.count263>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end141.loopexit>, scalar.ph

ir-bb<for.end141.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov14String_To_UCS2EPcb' from parsestr.cpp==========
========== VPlan for Vector Factor Range: 1 to 16==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body50.lr.ph.split.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %53 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv258 = phi %indvars.iv.next259, 0, ir<1>
    CLONE ir<%arrayidx52.us> = getelementptr inbounds ir<%char_array.0237>, ir<%indvars.iv258>
    vp<%4> = vector-pointer ir<%arrayidx52.us>
    WIDEN ir<%54> = load vp<%4>
    CLONE ir<%arrayidx136.us> = getelementptr inbounds ir<%call47>, ir<%indvars.iv258>
    vp<%5> = vector-pointer ir<%arrayidx136.us>
    WIDEN store vp<%5>, ir<%54>
    CLONE ir<%indvars.iv.next259> = add nuw nsw ir<%indvars.iv258>, ir<1>
    CLONE ir<%exitcond264.not> = icmp eq ir<%indvars.iv.next259>, ir<%wide.trip.count263>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end141.loopexit>, scalar.ph

ir-bb<for.end141.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv258 = phi i64 [ %indvars.iv.next259, %for.body50.us ], [ 0, %for.body50.lr.ph.split.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx52.us = getelementptr inbounds i16, ptr %char_array.0237, i64 %indvars.iv258 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx136.us = getelementptr inbounds i16, ptr %call47, i64 %indvars.iv258 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next259 = add nuw nsw i64 %indvars.iv258, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next259, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond264.not, label %for.end141.loopexit, label %for.body50.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv258 = phi i64 [ %indvars.iv.next259, %for.body50.us ], [ 0, %for.body50.lr.ph.split.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx52.us = getelementptr inbounds i16, ptr %char_array.0237, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx136.us = getelementptr inbounds i16, ptr %call47, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next259 = add nuw nsw i64 %indvars.iv258, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next259, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond264.not, label %for.end141.loopexit, label %for.body50.us of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418236, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418236, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv258 = phi i64 [ %indvars.iv.next259, %for.body50.us ], [ 0, %for.body50.lr.ph.split.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx52.us = getelementptr inbounds i16, ptr %char_array.0237, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx136.us = getelementptr inbounds i16, ptr %call47, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next259 = add nuw nsw i64 %indvars.iv258, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next259, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond264.not, label %for.end141.loopexit, label %for.body50.us of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 10737418236
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv258 = phi i64 [ %indvars.iv.next259, %for.body50.us ], [ 0, %for.body50.lr.ph.split.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx52.us = getelementptr inbounds i16, ptr %char_array.0237, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx136.us = getelementptr inbounds i16, ptr %call47, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next259 = add nuw nsw i64 %indvars.iv258, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next259, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond264.not, label %for.end141.loopexit, label %for.body50.us of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv258 = phi i64 [ %indvars.iv.next259, %for.body50.us ], [ 0, %for.body50.lr.ph.split.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx52.us = getelementptr inbounds i16, ptr %char_array.0237, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx136.us = getelementptr inbounds i16, ptr %call47, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next259 = add nuw nsw i64 %indvars.iv258, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next259, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond264.not, label %for.end141.loopexit, label %for.body50.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1073741862

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv258 = phi i64 [ %indvars.iv.next259, %for.body50.us ], [ 0, %for.body50.lr.ph.split.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx52.us = getelementptr inbounds i16, ptr %char_array.0237, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx136.us = getelementptr inbounds i16, ptr %call47, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next259 = add nuw nsw i64 %indvars.iv258, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next259, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond264.not, label %for.end141.loopexit, label %for.body50.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 1073741862

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv258 = phi i64 [ %indvars.iv.next259, %for.body50.us ], [ 0, %for.body50.lr.ph.split.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx52.us = getelementptr inbounds i16, ptr %char_array.0237, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx136.us = getelementptr inbounds i16, ptr %call47, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next259 = add nuw nsw i64 %indvars.iv258, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next259, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond264.not, label %for.end141.loopexit, label %for.body50.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 1073741862
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN3pov14String_To_UCS2EPcb' from parsestr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv258 = phi i64 [ %indvars.iv.next259, %for.body50.us ], [ 0, %for.body50.lr.ph.split.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx52.us = getelementptr inbounds i16, ptr %char_array.0237, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %54 = load i16, ptr %arrayidx52.us, align 2, !tbaa !12 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx136.us = getelementptr inbounds i16, ptr %call47, i64 %indvars.iv258 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i16 %54, ptr %arrayidx136.us, align 2, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next259 = add nuw nsw i64 %indvars.iv258, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond264.not = icmp eq i64 %indvars.iv.next259, %wide.trip.count263 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond264.not, label %for.end141.loopexit, label %for.body50.us of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 12884901882
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 536870998, RTCostB: 1073741862
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 10737418236
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 2147483662
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 1073741862
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 1073741862
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: _ZN3pov14String_To_UCS2EPcb at line: parsestr.cpp
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=2 at function: _ZN3pov14String_To_UCS2EPcb at line: parsestr.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body50.lr.ph.split.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %53 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx52.us> = getelementptr inbounds ir<%char_array.0237>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx52.us>
    WIDEN ir<%58> = load vp<%5>
    CLONE ir<%arrayidx136.us> = getelementptr inbounds ir<%call47>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx136.us>
    WIDEN store vp<%6>, ir<%58>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end141.loopexit>, scalar.ph

ir-bb<for.end141.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: _ZN3pov14String_To_UCS2EPcb at line: parsestr.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count263> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx52.us> = getelementptr inbounds ir<%char_array.0237>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx52.us>
    WIDEN ir<%85> = load vp<%4>
    CLONE ir<%arrayidx136.us> = getelementptr inbounds ir<%call47>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx136.us>
    WIDEN store vp<%5>, ir<%85>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%wide.trip.count263>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end141.loopexit>, scalar.ph

ir-bb<for.end141.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 6
Loops Epilogues Vectorized: 2
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o parstxtr.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           parstxtr.cpp
========== Loop: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %13 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv177 = phi 0, %indvars.iv.next178, ir<1>
    CLONE ir<%Filter> = getelementptr inbounds ir<%14>, ir<%indvars.iv177>, ir<3>
    CLONE store ir<%conv48>, ir<%Filter>
    CLONE ir<%indvars.iv.next178> = add nuw nsw ir<%indvars.iv177>, ir<1>
    CLONE ir<%exitcond181.not> = icmp eq ir<%indvars.iv.next178>, ir<%conv45>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %13 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv177 = phi 0, %indvars.iv.next178, ir<1>
    REPLICATE ir<%Filter> = getelementptr inbounds ir<%14>, ir<%indvars.iv177>, ir<3>
    REPLICATE store ir<%conv48>, ir<%Filter>
    REPLICATE ir<%indvars.iv.next178> = add nuw nsw ir<%indvars.iv177>, ir<1>
    CLONE ir<%exitcond181.not> = icmp eq ir<%indvars.iv.next178>, ir<%conv45>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %13 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv177 = phi 0, %indvars.iv.next178, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%Filter> = getelementptr inbounds ir<%14>, ir<%indvars.iv177>, ir<3>
    REPLICATE store ir<%conv48>, ir<%Filter>
    WIDEN ir<%indvars.iv.next178> = add nuw nsw ir<%indvars.iv177>, ir<1>
    CLONE ir<%exitcond181.not> = icmp eq ir<%indvars.iv.next178>, ir<%conv45>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %13 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv177 = phi 0, %indvars.iv.next178, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%Filter> = getelementptr inbounds ir<%14>, ir<%indvars.iv177>, ir<3>
    WIDEN store ir<%Filter>, ir<%conv48>
    WIDEN ir<%indvars.iv.next178> = add nuw nsw ir<%indvars.iv177>, ir<1>
    CLONE ir<%exitcond181.not> = icmp eq ir<%indvars.iv.next178>, ir<%conv45>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv177 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next178, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %Filter = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %14, i64 %indvars.iv177, i32 3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv48, ptr %Filter, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %conv45 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond181.not, label %while.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv177 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next178, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %Filter = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %14, i64 %indvars.iv177, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i16 %conv48, ptr %Filter, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %conv45 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond181.not, label %while.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv177 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next178, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %Filter = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %14, i64 %indvars.iv177, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i16 %conv48, ptr %Filter, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %conv45 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond181.not, label %while.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 4

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv177 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next178, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %Filter = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %14, i64 %indvars.iv177, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 32 for VF 8 For instruction:   store i16 %conv48, ptr %Filter, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %conv45 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond181.not, label %while.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 4

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv177 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next178, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %Filter = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %14, i64 %indvars.iv177, i32 3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %conv48, ptr %Filter, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %conv45 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond181.not, label %while.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 131068

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv177 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next178, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %Filter = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %14, i64 %indvars.iv177, i32 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i16 %conv48, ptr %Filter, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %conv45 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond181.not, label %while.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 352225, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: 352225, RTCostB: 131068

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv177 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next178, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %Filter = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %14, i64 %indvars.iv177, i32 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i16 %conv48, ptr %Filter, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %conv45 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond181.not, label %while.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 344008, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: 344008, RTCostB: 131068

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv177 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next178, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %Filter = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %14, i64 %indvars.iv177, i32 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i16 %conv48, ptr %Filter, align 2, !tbaa !32 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %conv45 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond181.not, label %while.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 339862, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: 339862, RTCostB: 131068
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE at line: parstxtr.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %13 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%Filter> = getelementptr inbounds ir<%14>, vp<%4>, ir<3>
    CLONE store ir<%conv48>, ir<%Filter>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body85.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %26 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%Transmit> = getelementptr inbounds ir<%27>, ir<%indvars.iv>, ir<4>
    CLONE store ir<%conv87>, ir<%Transmit>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end118.loopexit>, scalar.ph

ir-bb<while.end118.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body85.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %26 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    REPLICATE ir<%Transmit> = getelementptr inbounds ir<%27>, ir<%indvars.iv>, ir<4>
    REPLICATE store ir<%conv87>, ir<%Transmit>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end118.loopexit>, scalar.ph

ir-bb<while.end118.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body85.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %26 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%Transmit> = getelementptr inbounds ir<%27>, ir<%indvars.iv>, ir<4>
    REPLICATE store ir<%conv87>, ir<%Transmit>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end118.loopexit>, scalar.ph

ir-bb<while.end118.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body85.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %26 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%Transmit> = getelementptr inbounds ir<%27>, ir<%indvars.iv>, ir<4>
    WIDEN store ir<%Transmit>, ir<%conv87>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%conv83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end118.loopexit>, scalar.ph

ir-bb<while.end118.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body85.lr.ph ], [ %indvars.iv.next, %for.body85 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %Transmit = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %27, i64 %indvars.iv, i32 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv87, ptr %Transmit, align 2, !tbaa !41 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv83 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %while.end118.loopexit, label %for.body85 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body85.lr.ph ], [ %indvars.iv.next, %for.body85 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %Transmit = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %27, i64 %indvars.iv, i32 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i16 %conv87, ptr %Transmit, align 2, !tbaa !41 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv83 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %while.end118.loopexit, label %for.body85 of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body85.lr.ph ], [ %indvars.iv.next, %for.body85 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %Transmit = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %27, i64 %indvars.iv, i32 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i16 %conv87, ptr %Transmit, align 2, !tbaa !41 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv83 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %while.end118.loopexit, label %for.body85 of type:br
LV: Vector loop of width 4 costs: 4

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body85.lr.ph ], [ %indvars.iv.next, %for.body85 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %Transmit = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %27, i64 %indvars.iv, i32 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 32 for VF 8 For instruction:   store i16 %conv87, ptr %Transmit, align 2, !tbaa !41 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv83 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %while.end118.loopexit, label %for.body85 of type:br
LV: Vector loop of width 8 costs: 4

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body85.lr.ph ], [ %indvars.iv.next, %for.body85 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %Transmit = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %27, i64 %indvars.iv, i32 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %conv87, ptr %Transmit, align 2, !tbaa !41 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %while.end118.loopexit, label %for.body85 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 131068

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body85.lr.ph ], [ %indvars.iv.next, %for.body85 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %Transmit = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %27, i64 %indvars.iv, i32 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i16 %conv87, ptr %Transmit, align 2, !tbaa !41 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %while.end118.loopexit, label %for.body85 of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 352225, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: 352225, RTCostB: 131068

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body85.lr.ph ], [ %indvars.iv.next, %for.body85 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %Transmit = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %27, i64 %indvars.iv, i32 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i16 %conv87, ptr %Transmit, align 2, !tbaa !41 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %while.end118.loopexit, label %for.body85 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 344008, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: 344008, RTCostB: 131068

-----------------Function that is being costed:'_ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE' from parstxtr.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body85.lr.ph ], [ %indvars.iv.next, %for.body85 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %Transmit = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %27, i64 %indvars.iv, i32 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i16 %conv87, ptr %Transmit, align 2, !tbaa !41 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %conv83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %while.end118.loopexit, label %for.body85 of type:br
LV: Vector loop of width vscale x 8 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 339862, RTCostB: 131068
A is scalable.	B is not scalable.	
RTCostA: 339862, RTCostB: 131068
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL15Parse_Image_MapEPNS_14Pigment_StructE at line: parstxtr.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body85.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %26 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%Transmit> = getelementptr inbounds ir<%27>, vp<%4>, ir<4>
    CLONE store ir<%conv87>, ir<%Transmit>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end118.loopexit>, scalar.ph

ir-bb<while.end118.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 40
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pattern.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           pattern.cpp
@@ Instruction =>  %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body5.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%ptr.168> = WIDEN-POINTER-INDUCTION ir<%ptr.165>, 4
    WIDEN-INDUCTION %k.067 = phi 1, %inc, ir<1>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%ptr.168>, ir<%idx.neg>
    CLONE ir<%0> = load ir<%add.ptr>
    CLONE ir<%add.ptr8> = getelementptr inbounds ir<%ptr.168>, ir<%idx.neg7>
    CLONE ir<%1> = load ir<%add.ptr8>
    CLONE ir<%add9> = add nsw ir<%1>, ir<%0>
    CLONE store ir<%add9>, ir<%ptr.168>
    CLONE ir<%inc> = add nuw nsw ir<%k.067>, ir<1>
    CLONE ir<%ptr.1> = getelementptr inbounds ir<%ptr.168>, ir<4>
    CLONE ir<%2> = zext nneg ir<%inc>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv>, ir<%2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.cleanup4.loopexit>, scalar.ph

ir-bb<for.cond.cleanup4.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %ptr.1.lcssa90 = ir<%ptr.1>
}

========== Loop: _ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body5.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%ptr.168> = WIDEN-POINTER-INDUCTION ir<%ptr.165>, 4
    WIDEN-INDUCTION %k.067 = phi 1, %inc, ir<1>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%ptr.168>, ir<%idx.neg>
    vp<%4> = vector-pointer ir<%add.ptr>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%add.ptr8> = getelementptr inbounds ir<%ptr.168>, ir<%idx.neg7>
    vp<%5> = vector-pointer ir<%add.ptr8>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%add9> = add nsw ir<%1>, ir<%0>
    vp<%6> = vector-pointer ir<%ptr.168>
    WIDEN store vp<%6>, ir<%add9>
    CLONE ir<%inc> = add nuw nsw ir<%k.067>, ir<1>
    CLONE ir<%ptr.1> = getelementptr inbounds ir<%ptr.168>, ir<4>
    CLONE ir<%2> = zext nneg ir<%inc>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv>, ir<%2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond.cleanup4.loopexit>, scalar.ph

ir-bb<for.cond.cleanup4.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %ptr.1.lcssa90 = ir<%ptr.1>
}

========== Loop: _ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body5.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%ptr.168> = WIDEN-POINTER-INDUCTION ir<%ptr.165>, 4
    WIDEN-INDUCTION %k.067 = phi 1, %inc, ir<1>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%ptr.168>, ir<%idx.neg>
    vp<%4> = vector-pointer ir<%add.ptr>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%add.ptr8> = getelementptr inbounds ir<%ptr.168>, ir<%idx.neg7>
    vp<%5> = vector-pointer ir<%add.ptr8>
    WIDEN ir<%1> = load vp<%5>
    WIDEN ir<%add9> = add nsw ir<%1>, ir<%0>
    vp<%6> = vector-pointer ir<%ptr.168>
    WIDEN store vp<%6>, ir<%add9>
    CLONE ir<%inc> = add nuw nsw ir<%k.067>, ir<1>
    CLONE ir<%ptr.1> = getelementptr inbounds ir<%ptr.168>, ir<4>
    CLONE ir<%2> = zext nneg ir<%inc>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv>, ir<%2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond.cleanup4.loopexit>, scalar.ph

ir-bb<for.cond.cleanup4.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %ptr.1.lcssa90 = ir<%ptr.1>
}


-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ptr.168 = phi ptr [ %ptr.165, %for.body5.lr.ph ], [ %ptr.1, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %k.067 = phi i32 [ 1, %for.body5.lr.ph ], [ %inc, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr8 = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg7 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add9 = add nsw i32 %1, %0 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw nsw i32 %k.067, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ptr.1 = getelementptr inbounds i8, ptr %ptr.168, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %2 = zext nneg i32 %inc to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup4.loopexit, label %for.body5 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ptr.168 = phi ptr [ %ptr.165, %for.body5.lr.ph ], [ %ptr.1, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %k.067 = phi i32 [ 1, %for.body5.lr.ph ], [ %inc, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr8 = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg7 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add9 = add nsw i32 %1, %0 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw nsw i32 %k.067, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ptr.1 = getelementptr inbounds i8, ptr %ptr.168, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %2 = zext nneg i32 %inc to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup4.loopexit, label %for.body5 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 96, RTCostB: 288
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 96, RTCostB: 288
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ptr.168 = phi ptr [ %ptr.165, %for.body5.lr.ph ], [ %ptr.1, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %k.067 = phi i32 [ 1, %for.body5.lr.ph ], [ %inc, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr8 = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg7 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add9 = add nsw i32 %1, %0 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nuw nsw i32 %k.067, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ptr.1 = getelementptr inbounds i8, ptr %ptr.168, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %2 = zext nneg i32 %inc to i64 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup4.loopexit, label %for.body5 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 48, RTCostB: 288
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 48, RTCostB: 96
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ptr.168 = phi ptr [ %ptr.165, %for.body5.lr.ph ], [ %ptr.1, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %k.067 = phi i32 [ 1, %for.body5.lr.ph ], [ %inc, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr8 = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg7 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add9 = add nsw i32 %1, %0 of type:add
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nuw nsw i32 %k.067, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ptr.1 = getelementptr inbounds i8, ptr %ptr.168, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %2 = zext nneg i32 %inc to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup4.loopexit, label %for.body5 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 288
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 48

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ptr.168 = phi ptr [ %ptr.165, %for.body5.lr.ph ], [ %ptr.1, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %k.067 = phi i32 [ 1, %for.body5.lr.ph ], [ %inc, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr8 = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg7 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add9 = add nsw i32 %1, %0 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nuw nsw i32 %k.067, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ptr.1 = getelementptr inbounds i8, ptr %ptr.168, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %2 = zext nneg i32 %inc to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup4.loopexit, label %for.body5 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 48, RTCostB: 288
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 48, RTCostB: 48
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ptr.168 = phi ptr [ %ptr.165, %for.body5.lr.ph ], [ %ptr.1, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %k.067 = phi i32 [ 1, %for.body5.lr.ph ], [ %inc, %for.body5 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %add.ptr = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load i32, ptr %add.ptr, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %add.ptr8 = getelementptr inbounds i32, ptr %ptr.168, i64 %idx.neg7 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load i32, ptr %add.ptr8, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add9 = add nsw i32 %1, %0 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %add9, ptr %ptr.168, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc = add nuw nsw i32 %k.067, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ptr.1 = getelementptr inbounds i8, ptr %ptr.168, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %2 = zext nneg i32 %inc to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv, %2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup4.loopexit, label %for.body5 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 24, RTCostB: 288
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 24, RTCostB: 48
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN3povL30InitializeBinomialCoefficientsEv at line: pattern.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body5.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<4>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<4>
    EMIT vp<%6> = ptradd ir<%ptr.165>, vp<%5>
    CLONE ir<%add.ptr> = getelementptr inbounds vp<%6>, ir<%idx.neg>
    vp<%7> = vector-pointer ir<%add.ptr>
    WIDEN ir<%0> = load vp<%7>
    CLONE ir<%add.ptr8> = getelementptr inbounds vp<%6>, ir<%idx.neg7>
    vp<%8> = vector-pointer ir<%add.ptr8>
    WIDEN ir<%1> = load vp<%8>
    WIDEN ir<%add9> = add nsw ir<%1>, ir<%0>
    vp<%9> = vector-pointer vp<%6>
    WIDEN store vp<%9>, ir<%add9>
    CLONE ir<%ptr.1> = getelementptr inbounds vp<%6>, ir<4>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.cond.cleanup4.loopexit>, scalar.ph

ir-bb<for.cond.cleanup4.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %ptr.1.lcssa90 = ir<%ptr.1>
}
================ Final VPlan ================

@@ Instruction =>  %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: _ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.cond21.preheader>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%ptr.375> = WIDEN-POINTER-INDUCTION ir<%ptr.372>, 4
    WIDEN-INDUCTION %k20.074 = phi %inc28, 1, ir<1>
    CLONE ir<%and> = and ir<%k20.074>, ir<2>
    CLONE ir<%cmp25.not> = icmp eq ir<%and>, ir<0>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp25.not>
    CLONE ir<%38> = load ir<%ptr.375>, vp<%4>
    CLONE ir<%sub> = sub nsw ir<0>, ir<%38>
    CLONE store ir<%sub>, ir<%ptr.375>, vp<%4>
  Successor(s): if.end

  if.end:
    EMIT vp<%5> = or vp<%4>, ir<%cmp25.not>
    CLONE ir<%inc28> = add nuw nsw ir<%k20.074>, ir<1>
    CLONE ir<%ptr.3> = getelementptr inbounds ir<%ptr.375>, ir<4>
    CLONE ir<%exitcond85.not> = icmp eq ir<%inc28>, ir<%m.079>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.cleanup23.loopexit>, scalar.ph

ir-bb<for.cond.cleanup23.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %ptr.3.lcssa89 = ir<%ptr.3>
}

========== Loop: _ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.cond21.preheader>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%ptr.375> = WIDEN-POINTER-INDUCTION ir<%ptr.372>, 4
    WIDEN-INDUCTION %k20.074 = phi %inc28, 1, ir<1>
    WIDEN ir<%and> = and ir<%k20.074>, ir<2>
    WIDEN ir<%cmp25.not> = icmp eq ir<%and>, ir<0>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp25.not>
    vp<%5> = vector-pointer ir<%ptr.375>
    WIDEN ir<%38> = load vp<%5>, vp<%4>
    WIDEN ir<%sub> = sub nsw ir<0>, ir<%38>
    vp<%6> = vector-pointer ir<%ptr.375>
    WIDEN store vp<%6>, ir<%sub>, vp<%4>
  Successor(s): if.end

  if.end:
    EMIT vp<%7> = or vp<%4>, ir<%cmp25.not>
    WIDEN ir<%inc28> = add nuw nsw ir<%k20.074>, ir<1>
    CLONE ir<%ptr.3> = getelementptr inbounds ir<%ptr.375>, ir<4>
    CLONE ir<%exitcond85.not> = icmp eq ir<%inc28>, ir<%m.079>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.cleanup23.loopexit>, scalar.ph

ir-bb<for.cond.cleanup23.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %ptr.3.lcssa89 = ir<%ptr.3>
}

========== Loop: _ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.cond21.preheader>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%ptr.375> = WIDEN-POINTER-INDUCTION ir<%ptr.372>, 4
    WIDEN-INDUCTION %k20.074 = phi %inc28, 1, ir<1>
    WIDEN ir<%and> = and ir<%k20.074>, ir<2>
    WIDEN ir<%cmp25.not> = icmp eq ir<%and>, ir<0>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp25.not>
    vp<%5> = vector-pointer ir<%ptr.375>
    WIDEN ir<%38> = load vp<%5>, vp<%4>
    WIDEN ir<%sub> = sub nsw ir<0>, ir<%38>
    vp<%6> = vector-pointer ir<%ptr.375>
    WIDEN store vp<%6>, ir<%sub>, vp<%4>
  Successor(s): if.end

  if.end:
    EMIT vp<%7> = or vp<%4>, ir<%cmp25.not>
    WIDEN ir<%inc28> = add nuw nsw ir<%k20.074>, ir<1>
    CLONE ir<%ptr.3> = getelementptr inbounds ir<%ptr.375>, ir<4>
    CLONE ir<%exitcond85.not> = icmp eq ir<%inc28>, ir<%m.079>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.cleanup23.loopexit>, scalar.ph

ir-bb<for.cond.cleanup23.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %ptr.3.lcssa89 = ir<%ptr.3>
}


-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ptr.375 = phi ptr [ %ptr.3, %if.end ], [ %ptr.372, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %k20.074 = phi i32 [ %inc28, %if.end ], [ 1, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and = and i32 %k20.074, 2 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp25.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp25.not, label %if.end, label %if.then of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = sub nsw i32 0, %38 of type:sub
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc28 = add nuw nsw i32 %k20.074, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ptr.3 = getelementptr inbounds i8, ptr %ptr.375, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond85.not = icmp eq i32 %inc28, %m.079 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond85.not, label %for.cond.cleanup23.loopexit, label %for.body24 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ptr.375 = phi ptr [ %ptr.3, %if.end ], [ %ptr.372, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %k20.074 = phi i32 [ %inc28, %if.end ], [ 1, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and = and i32 %k20.074, 2 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp25.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp25.not, label %if.end, label %if.then of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = sub nsw i32 0, %38 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc28 = add nuw nsw i32 %k20.074, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ptr.3 = getelementptr inbounds i8, ptr %ptr.375, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond85.not = icmp eq i32 %inc28, %m.079 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond85.not, label %for.cond.cleanup23.loopexit, label %for.body24 of type:br
LV: Vector loop of width 2 costs: 12
A is not scalable.	B is not scalable.	
RTCostA: 400, RTCostB: 160
A is not scalable.	B is not scalable.	
RTCostA: 400, RTCostB: 160

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ptr.375 = phi ptr [ %ptr.3, %if.end ], [ %ptr.372, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %k20.074 = phi i32 [ %inc28, %if.end ], [ 1, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and = and i32 %k20.074, 2 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp25.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp25.not, label %if.end, label %if.then of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub = sub nsw i32 0, %38 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc28 = add nuw nsw i32 %k20.074, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ptr.3 = getelementptr inbounds i8, ptr %ptr.375, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond85.not = icmp eq i32 %inc28, %m.079 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond85.not, label %for.cond.cleanup23.loopexit, label %for.body24 of type:br
LV: Vector loop of width 4 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 360, RTCostB: 160
A is not scalable.	B is not scalable.	
RTCostA: 360, RTCostB: 160

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ptr.375 = phi ptr [ %ptr.3, %if.end ], [ %ptr.372, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %k20.074 = phi i32 [ %inc28, %if.end ], [ 1, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and = and i32 %k20.074, 2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp25.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp25.not, label %if.end, label %if.then of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = sub nsw i32 0, %38 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc28 = add nuw nsw i32 %k20.074, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ptr.3 = getelementptr inbounds i8, ptr %ptr.375, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond85.not = icmp eq i32 %inc28, %m.079 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond85.not, label %for.cond.cleanup23.loopexit, label %for.body24 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 160
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 160

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ptr.375 = phi ptr [ %ptr.3, %if.end ], [ %ptr.372, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %k20.074 = phi i32 [ %inc28, %if.end ], [ 1, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and = and i32 %k20.074, 2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp25.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp25.not, label %if.end, label %if.then of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = sub nsw i32 0, %38 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc28 = add nuw nsw i32 %k20.074, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ptr.3 = getelementptr inbounds i8, ptr %ptr.375, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond85.not = icmp eq i32 %inc28, %m.079 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond85.not, label %for.cond.cleanup23.loopexit, label %for.body24 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 56, RTCostB: 160
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 56, RTCostB: 160
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ptr.375 = phi ptr [ %ptr.3, %if.end ], [ %ptr.372, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %k20.074 = phi i32 [ %inc28, %if.end ], [ 1, %for.body24.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and = and i32 %k20.074, 2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp25.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp25.not, label %if.end, label %if.then of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %38 = load i32, ptr %ptr.375, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub = sub nsw i32 0, %38 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %sub, ptr %ptr.375, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %if.end of type:br

-----------------Function that is being costed:'_ZN3povL30InitializeBinomialCoefficientsEv' from pattern.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc28 = add nuw nsw i32 %k20.074, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ptr.3 = getelementptr inbounds i8, ptr %ptr.375, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond85.not = icmp eq i32 %inc28, %m.079 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond85.not, label %for.cond.cleanup23.loopexit, label %for.body24 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 28, RTCostB: 160
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 28, RTCostB: 56
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN3povL30InitializeBinomialCoefficientsEv at line: pattern.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.cond21.preheader>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %k20.074 = phi %inc28, 1, ir<1>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<4>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<4>
    EMIT vp<%6> = ptradd ir<%ptr.372>, vp<%5>
    WIDEN ir<%and> = and ir<%k20.074>, ir<2>
    WIDEN ir<%cmp25.not> = icmp eq ir<%and>, ir<0>
    EMIT vp<%7> = not ir<%cmp25.not>
    vp<%8> = vector-pointer vp<%6>
    WIDEN ir<%38> = load vp<%8>, vp<%7>
    WIDEN ir<%sub> = sub nsw ir<0>, ir<%38>
    vp<%9> = vector-pointer vp<%6>
    WIDEN store vp<%9>, ir<%sub>, vp<%7>
    CLONE ir<%ptr.3> = getelementptr inbounds vp<%6>, ir<4>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.cond.cleanup23.loopexit>, scalar.ph

ir-bb<for.cond.cleanup23.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %ptr.3.lcssa89 = ir<%ptr.3>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 34
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pgm.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           pgm.cpp
========== Loop: _ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %11 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv313 = phi 0, %indvars.iv.next314, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv313 = phi 0, %indvars.iv.next314\l" +
    "  ir<%12>, ir<1>
    CLONE ir<%13> = mul ir<%12>, ir<255>
    CLONE ir<%div> = udiv ir<%13>, ir<%11>
    CLONE ir<%conv82> = trunc ir<%div>
    CLONE ir<%arrayidx83> = getelementptr inbounds ir<%call79>, ir<%indvars.iv313>
    CLONE store ir<%conv82>, ir<%arrayidx83>
    CLONE ir<%Green> = getelementptr inbounds ir<%arrayidx83>, ir<2>
    CLONE store ir<%conv82>, ir<%Green>
    CLONE ir<%Blue> = getelementptr inbounds ir<%arrayidx83>, ir<4>
    CLONE store ir<%conv82>, ir<%Blue>
    CLONE ir<%Filter> = getelementptr inbounds ir<%arrayidx83>, ir<6>
    CLONE store ir<0>, ir<%Filter>
    CLONE ir<%Transmit> = getelementptr inbounds ir<%arrayidx83>, ir<8>
    CLONE store ir<0>, ir<%Transmit>
    CLONE ir<%indvars.iv.next314> = add nuw nsw ir<%indvars.iv313>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next314>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %11 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv313 = phi 0, %indvars.iv.next314, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv313 = phi 0, %indvars.iv.next314\l" +
    "  ir<%12>, ir<1>
    WIDEN ir<%13> = mul ir<%12>, ir<255>
    WIDEN ir<%div> = udiv ir<%13>, ir<%11>
    WIDEN-CAST ir<%conv82> = trunc  ir<%div> to i16
    CLONE ir<%arrayidx83> = getelementptr inbounds ir<%call79>, ir<%indvars.iv313>
    CLONE ir<%Green> = getelementptr inbounds ir<%arrayidx83>, ir<2>
    CLONE ir<%Blue> = getelementptr inbounds ir<%arrayidx83>, ir<4>
    CLONE ir<%Filter> = getelementptr inbounds ir<%arrayidx83>, ir<6>
    CLONE ir<%Transmit> = getelementptr inbounds ir<%arrayidx83>, ir<8>
    INTERLEAVE-GROUP with factor 5 at <badref>, ir<%Transmit>
      store ir<%conv82> to index 0
      store ir<%conv82> to index 1
      store ir<%conv82> to index 2
      store ir<0> to index 3
      store ir<0> to index 4
    WIDEN ir<%indvars.iv.next314> = add nuw nsw ir<%indvars.iv313>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next314>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %11 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv313 = phi 0, %indvars.iv.next314, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv313 = phi 0, %indvars.iv.next314\l" +
    "  ir<%12>, ir<1>
    WIDEN ir<%13> = mul ir<%12>, ir<255>
    WIDEN ir<%div> = udiv ir<%13>, ir<%11>
    WIDEN-CAST ir<%conv82> = trunc  ir<%div> to i16
    WIDEN-GEP Inv[Var] ir<%arrayidx83> = getelementptr inbounds ir<%call79>, ir<%indvars.iv313>
    REPLICATE store ir<%conv82>, ir<%arrayidx83>
    WIDEN-GEP Var[Inv] ir<%Green> = getelementptr inbounds ir<%arrayidx83>, ir<2>
    REPLICATE store ir<%conv82>, ir<%Green>
    WIDEN-GEP Var[Inv] ir<%Blue> = getelementptr inbounds ir<%arrayidx83>, ir<4>
    REPLICATE store ir<%conv82>, ir<%Blue>
    WIDEN-GEP Var[Inv] ir<%Filter> = getelementptr inbounds ir<%arrayidx83>, ir<6>
    REPLICATE store ir<0>, ir<%Filter>
    WIDEN-GEP Var[Inv] ir<%Transmit> = getelementptr inbounds ir<%arrayidx83>, ir<8>
    REPLICATE store ir<0>, ir<%Transmit>
    WIDEN ir<%indvars.iv.next314> = add nuw nsw ir<%indvars.iv313>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next314>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %11 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv313 = phi 0, %indvars.iv.next314, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv313 = phi 0, %indvars.iv.next314\l" +
    "  ir<%12>, ir<1>
    WIDEN ir<%13> = mul ir<%12>, ir<255>
    WIDEN ir<%div> = udiv ir<%13>, ir<%11>
    WIDEN-CAST ir<%conv82> = trunc  ir<%div> to i16
    WIDEN-GEP Inv[Var] ir<%arrayidx83> = getelementptr inbounds ir<%call79>, ir<%indvars.iv313>
    WIDEN store ir<%arrayidx83>, ir<%conv82>
    WIDEN-GEP Var[Inv] ir<%Green> = getelementptr inbounds ir<%arrayidx83>, ir<2>
    WIDEN store ir<%Green>, ir<%conv82>
    WIDEN-GEP Var[Inv] ir<%Blue> = getelementptr inbounds ir<%arrayidx83>, ir<4>
    WIDEN store ir<%Blue>, ir<%conv82>
    WIDEN-GEP Var[Inv] ir<%Filter> = getelementptr inbounds ir<%arrayidx83>, ir<6>
    WIDEN store ir<%Filter>, ir<0>
    WIDEN-GEP Var[Inv] ir<%Transmit> = getelementptr inbounds ir<%arrayidx83>, ir<8>
    WIDEN store ir<%Transmit>, ir<0>
    WIDEN ir<%indvars.iv.next314> = add nuw nsw ir<%indvars.iv313>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next314>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv313 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next314, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %12 = trunc i64 %indvars.iv313 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %13 = mul i32 %12, 255 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %div = udiv i32 %13, %11 of type:udiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv82 = trunc i32 %div to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx83 = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %call79, i64 %indvars.iv313 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv82, ptr %arrayidx83, align 2, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %Green = getelementptr inbounds i8, ptr %arrayidx83, i64 2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv82, ptr %Green, align 2, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %Blue = getelementptr inbounds i8, ptr %arrayidx83, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv82, ptr %Blue, align 2, !tbaa !23 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %Filter = getelementptr inbounds i8, ptr %arrayidx83, i64 6 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 0, ptr %Filter, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %Transmit = getelementptr inbounds i8, ptr %arrayidx83, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 0, ptr %Transmit, align 2, !tbaa !25 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next314 = add nuw nsw i64 %indvars.iv313, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next314, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 14.
-----------------Function that is being costed:'_ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv313 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next314, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %12 = trunc i64 %indvars.iv313 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %13 = mul i32 %12, 255 of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %div = udiv i32 %13, %11 of type:udiv
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv82 = trunc i32 %div to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx83 = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %call79, i64 %indvars.iv313 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i16 %conv82, ptr %arrayidx83, align 2, !tbaa !20 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i16 %conv82, ptr %Green, align 2, !tbaa !22 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i16 %conv82, ptr %Blue, align 2, !tbaa !23 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i16 0, ptr %Filter, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %Transmit = getelementptr inbounds i8, ptr %arrayidx83, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 42 for VF 2 For instruction:   store i16 0, ptr %Transmit, align 2, !tbaa !25 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next314 = add nuw nsw i64 %indvars.iv313, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next314, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 23
A is not scalable.	B is not scalable.	
RTCostA: 98784247776, RTCostB: 60129542130
A is not scalable.	B is not scalable.	
RTCostA: 98784247776, RTCostB: 60129542130

-----------------Function that is being costed:'_ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv313 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next314, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %12 = trunc i64 %indvars.iv313 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %13 = mul i32 %12, 255 of type:mul
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div = udiv i32 %13, %11 of type:udiv
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv82 = trunc i32 %div to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx83 = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %call79, i64 %indvars.iv313 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i16 %conv82, ptr %arrayidx83, align 2, !tbaa !20 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i16 %conv82, ptr %Green, align 2, !tbaa !22 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i16 %conv82, ptr %Blue, align 2, !tbaa !23 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i16 0, ptr %Filter, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %Transmit = getelementptr inbounds i8, ptr %arrayidx83, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 84 for VF 4 For instruction:   store i16 0, ptr %Transmit, align 2, !tbaa !25 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next314 = add nuw nsw i64 %indvars.iv313, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next314, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 22
A is not scalable.	B is not scalable.	
RTCostA: 97710505935, RTCostB: 60129542130
A is not scalable.	B is not scalable.	
RTCostA: 97710505935, RTCostB: 60129542130

-----------------Function that is being costed:'_ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv313 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next314, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %12 = trunc i64 %indvars.iv313 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 8 For instruction:   %13 = mul i32 %12, 255 of type:mul
LV: Found an estimated cost of 4 for VF 8 For instruction:   %div = udiv i32 %13, %11 of type:udiv
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv82 = trunc i32 %div to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx83 = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %call79, i64 %indvars.iv313 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i16 %conv82, ptr %arrayidx83, align 2, !tbaa !20 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i16 %conv82, ptr %Green, align 2, !tbaa !22 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i16 %conv82, ptr %Blue, align 2, !tbaa !23 of type:store
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i16 0, ptr %Filter, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %Transmit = getelementptr inbounds i8, ptr %arrayidx83, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 168 for VF 8 For instruction:   store i16 0, ptr %Transmit, align 2, !tbaa !25 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next314 = add nuw nsw i64 %indvars.iv313, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next314, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 22
A is not scalable.	B is not scalable.	
RTCostA: 96636764078, RTCostB: 60129542130
A is not scalable.	B is not scalable.	
RTCostA: 96636764078, RTCostB: 60129542130

-----------------Function that is being costed:'_ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv313 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next314, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %12 = trunc i64 %indvars.iv313 to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = mul i32 %12, 255 of type:mul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = udiv i32 %13, %11 of type:udiv
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv82 = trunc i32 %div to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx83 = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %call79, i64 %indvars.iv313 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i16 %conv82, ptr %arrayidx83, align 2, !tbaa !20 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i16 %conv82, ptr %Green, align 2, !tbaa !22 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i16 %conv82, ptr %Blue, align 2, !tbaa !23 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i16 0, ptr %Filter, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %Transmit = getelementptr inbounds i8, ptr %arrayidx83, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 0, ptr %Transmit, align 2, !tbaa !25 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next314 = add nuw nsw i64 %indvars.iv313, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next314, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 60129542130
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 60129542130

-----------------Function that is being costed:'_ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv313 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next314, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %12 = trunc i64 %indvars.iv313 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %13 = mul i32 %12, 255 of type:mul
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = udiv i32 %13, %11 of type:udiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv82 = trunc i32 %div to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx83 = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %call79, i64 %indvars.iv313 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i16 %conv82, ptr %arrayidx83, align 2, !tbaa !20 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i16 %conv82, ptr %Green, align 2, !tbaa !22 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i16 %conv82, ptr %Blue, align 2, !tbaa !23 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i16 0, ptr %Filter, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %Transmit = getelementptr inbounds i8, ptr %arrayidx83, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 205 for VF vscale x 2 For instruction:   store i16 0, ptr %Transmit, align 2, !tbaa !25 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next314 = add nuw nsw i64 %indvars.iv313, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next314, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 52
A is scalable.	B is not scalable.	
RTCostA: 226559524695, RTCostB: 60129542130
A is scalable.	B is not scalable.	
RTCostA: 226559524695, RTCostB: 60129542130

-----------------Function that is being costed:'_ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv313 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next314, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %12 = trunc i64 %indvars.iv313 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %13 = mul i32 %12, 255 of type:mul
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div = udiv i32 %13, %11 of type:udiv
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv82 = trunc i32 %div to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx83 = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %call79, i64 %indvars.iv313 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i16 %conv82, ptr %arrayidx83, align 2, !tbaa !20 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i16 %conv82, ptr %Green, align 2, !tbaa !22 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i16 %conv82, ptr %Blue, align 2, !tbaa !23 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i16 0, ptr %Filter, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %Transmit = getelementptr inbounds i8, ptr %arrayidx83, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 405 for VF vscale x 4 For instruction:   store i16 0, ptr %Transmit, align 2, !tbaa !25 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next314 = add nuw nsw i64 %indvars.iv313, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next314, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 51
A is scalable.	B is not scalable.	
RTCostA: 221190815430, RTCostB: 60129542130
A is scalable.	B is not scalable.	
RTCostA: 221190815430, RTCostB: 60129542130

-----------------Function that is being costed:'_ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc' from pgm.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv313 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next314, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %12 = trunc i64 %indvars.iv313 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %13 = mul i32 %12, 255 of type:mul
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %div = udiv i32 %13, %11 of type:udiv
LV: Found an estimated cost of 3 for VF vscale x 8 For instruction:   %conv82 = trunc i32 %div to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx83 = getelementptr inbounds %"struct.pov::Image_Colour_Struct", ptr %call79, i64 %indvars.iv313 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   store i16 %conv82, ptr %arrayidx83, align 2, !tbaa !20 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   store i16 %conv82, ptr %Green, align 2, !tbaa !22 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   store i16 %conv82, ptr %Blue, align 2, !tbaa !23 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   store i16 0, ptr %Filter, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %Transmit = getelementptr inbounds i8, ptr %arrayidx83, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 805 for VF vscale x 8 For instruction:   store i16 0, ptr %Transmit, align 2, !tbaa !25 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next314 = add nuw nsw i64 %indvars.iv313, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next314, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 51
A is scalable.	B is not scalable.	
RTCostA: 219848637855, RTCostB: 60129542130
A is scalable.	B is not scalable.	
RTCostA: 219848637855, RTCostB: 60129542130
LV: Selecting VF: 1 With Cost: 14.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3pov14Read_PGM_ImageEPNS_12Image_StructEPc at line: pgm.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %11 to i64)
No successors

vector.ph:
  SCALAR-CAST vp<%3> = trunc ir<1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    SCALAR-CAST vp<%6> = trunc vp<%4> to i32
    vp<%7> = SCALAR-STEPS vp<%6>, vp<%3>
    CLONE ir<%13> = mul vp<%7>, ir<255>
    CLONE ir<%div> = udiv ir<%13>, ir<%11>
    CLONE ir<%conv82> = trunc ir<%div>
    CLONE ir<%arrayidx83> = getelementptr inbounds ir<%call79>, vp<%5>
    CLONE store ir<%conv82>, ir<%arrayidx83>
    CLONE ir<%Green> = getelementptr inbounds ir<%arrayidx83>, ir<2>
    CLONE store ir<%conv82>, ir<%Green>
    CLONE ir<%Blue> = getelementptr inbounds ir<%arrayidx83>, ir<4>
    CLONE store ir<%conv82>, ir<%Blue>
    CLONE ir<%Filter> = getelementptr inbounds ir<%arrayidx83>, ir<6>
    CLONE store ir<0>, ir<%Filter>
    CLONE ir<%Transmit> = getelementptr inbounds ir<%arrayidx83>, ir<8>
    CLONE store ir<0>, ir<%Transmit>
    EMIT vp<%8> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o photons.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           photons.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pigment.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           pigment.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o planes.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           planes.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o point.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           point.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o poly.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           poly.cpp
@@ Instruction =>  %10 = load double, ptr %arrayidx, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %10, ptr %arrayidx26, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load double, ptr %arrayidx, align 8, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %10, ptr %arrayidx26, align 8, !tbaa !19 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %10 = load double, ptr %arrayidx, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %10, ptr %arrayidx26, align 8, !tbaa !19 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL9Copy_PolyEPNS_13Object_StructE' from poly.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 ((1 + %7)<nsw> * (2 + %7)<nsw> * (3 + %7)<nsw>) to i64) /u 6)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    CLONE ir<%10> = load ir<%arrayidx>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%9>, ir<%indvars.iv>
    CLONE store ir<%10>, ir<%arrayidx26>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9Copy_PolyEPNS_13Object_StructE' from poly.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 ((1 + %7)<nsw> * (2 + %7)<nsw> * (3 + %7)<nsw>) to i64) /u 6)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%10> = load vp<%4>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%9>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx26>
    WIDEN store vp<%5>, ir<%10>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9Copy_PolyEPNS_13Object_StructE' from poly.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 ((1 + %7)<nsw> * (2 + %7)<nsw> * (3 + %7)<nsw>) to i64) /u 6)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%10> = load vp<%4>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%9>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx26>
    WIDEN store vp<%5>, ir<%10>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL9Copy_PolyEPNS_13Object_StructE' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load double, ptr %arrayidx, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx26 = getelementptr inbounds double, ptr %9, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %10, ptr %arrayidx26, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3povL9Copy_PolyEPNS_13Object_StructE' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load double, ptr %arrayidx, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx26 = getelementptr inbounds double, ptr %9, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %10, ptr %arrayidx26, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL9Copy_PolyEPNS_13Object_StructE' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load double, ptr %arrayidx, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx26 = getelementptr inbounds double, ptr %9, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %10, ptr %arrayidx26, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'_ZN3povL9Copy_PolyEPNS_13Object_StructE' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load double, ptr %arrayidx, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx26 = getelementptr inbounds double, ptr %9, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %10, ptr %arrayidx26, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL9Copy_PolyEPNS_13Object_StructE at line: poly.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 ((1 + %7)<nsw> * (2 + %7)<nsw> * (3 + %7)<nsw>) to i64) /u 6)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%8>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%16> = load vp<%5>
    CLONE ir<%arrayidx26> = getelementptr inbounds ir<%10>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx26>
    WIDEN store vp<%6>, ir<%16>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %54 = load double, ptr %arrayidx169, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %55 = load double, ptr %arrayidx172, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %add173, ptr %arrayidx172, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %54 = load double, ptr %arrayidx169, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %55 = load double, ptr %arrayidx172, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %add173, ptr %arrayidx172, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %54 = load double, ptr %arrayidx169, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %55 = load double, ptr %arrayidx172, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %add173, ptr %arrayidx172, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL9intersectEPNS_10Ray_StructEiPdiS2_' from poly.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond151.preheader>:
  EMIT vp<%2> = EXPAND SCEV {{1,+,1}<nuw><nsw><%for.cond95.preheader>,+,-1}<nsw><%for.body118>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv386 = phi 0, %indvars.iv.next387, ir<1>
    CLONE ir<%53> = add nuw nsw ir<%51>, ir<%indvars.iv386>
    CLONE ir<%arrayidx169> = getelementptr inbounds ir<%arrayidx136>, ir<0>, ir<%indvars.iv386>
    CLONE ir<%54> = load ir<%arrayidx169>
    CLONE ir<%mul170> = fmul ir<%mul166>, ir<%54>
    CLONE ir<%arrayidx172> = getelementptr inbounds ir<%eqn>, ir<0>, ir<%53>
    CLONE ir<%55> = load ir<%arrayidx172>
    CLONE ir<%add173> = fadd ir<%55>, ir<%mul170>
    CLONE store ir<%add173>, ir<%arrayidx172>
    CLONE ir<%indvars.iv.next387> = add nuw nsw ir<%indvars.iv386>, ir<1>
    CLONE ir<%exitcond391.not> = icmp eq ir<%indvars.iv.next387>, ir<%indvars.iv410>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond151.for.inc177_crit_edge>, scalar.ph

ir-bb<for.cond151.for.inc177_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9intersectEPNS_10Ray_StructEiPdiS2_' from poly.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond151.preheader>:
  EMIT vp<%2> = EXPAND SCEV {{1,+,1}<nuw><nsw><%for.cond95.preheader>,+,-1}<nsw><%for.body118>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv386 = phi 0, %indvars.iv.next387, ir<1>
    CLONE ir<%53> = add nuw nsw ir<%51>, ir<%indvars.iv386>
    CLONE ir<%arrayidx169> = getelementptr inbounds ir<%arrayidx136>, ir<0>, ir<%indvars.iv386>
    vp<%4> = vector-pointer ir<%arrayidx169>
    WIDEN ir<%54> = load vp<%4>
    WIDEN ir<%mul170> = fmul ir<%mul166>, ir<%54>
    CLONE ir<%arrayidx172> = getelementptr inbounds ir<%eqn>, ir<0>, ir<%53>
    vp<%5> = vector-pointer ir<%arrayidx172>
    WIDEN ir<%55> = load vp<%5>
    WIDEN ir<%add173> = fadd ir<%55>, ir<%mul170>
    vp<%6> = vector-pointer ir<%arrayidx172>
    WIDEN store vp<%6>, ir<%add173>
    CLONE ir<%indvars.iv.next387> = add nuw nsw ir<%indvars.iv386>, ir<1>
    CLONE ir<%exitcond391.not> = icmp eq ir<%indvars.iv.next387>, ir<%indvars.iv410>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond151.for.inc177_crit_edge>, scalar.ph

ir-bb<for.cond151.for.inc177_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9intersectEPNS_10Ray_StructEiPdiS2_' from poly.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond151.preheader>:
  EMIT vp<%2> = EXPAND SCEV {{1,+,1}<nuw><nsw><%for.cond95.preheader>,+,-1}<nsw><%for.body118>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv386 = phi 0, %indvars.iv.next387, ir<1>
    CLONE ir<%53> = add nuw nsw ir<%51>, ir<%indvars.iv386>
    CLONE ir<%arrayidx169> = getelementptr inbounds ir<%arrayidx136>, ir<0>, ir<%indvars.iv386>
    vp<%4> = vector-pointer ir<%arrayidx169>
    WIDEN ir<%54> = load vp<%4>
    WIDEN ir<%mul170> = fmul ir<%mul166>, ir<%54>
    CLONE ir<%arrayidx172> = getelementptr inbounds ir<%eqn>, ir<0>, ir<%53>
    vp<%5> = vector-pointer ir<%arrayidx172>
    WIDEN ir<%55> = load vp<%5>
    WIDEN ir<%add173> = fadd ir<%55>, ir<%mul170>
    vp<%6> = vector-pointer ir<%arrayidx172>
    WIDEN store vp<%6>, ir<%add173>
    CLONE ir<%indvars.iv.next387> = add nuw nsw ir<%indvars.iv386>, ir<1>
    CLONE ir<%exitcond391.not> = icmp eq ir<%indvars.iv.next387>, ir<%indvars.iv410>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond151.for.inc177_crit_edge>, scalar.ph

ir-bb<for.cond151.for.inc177_crit_edge>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL9intersectEPNS_10Ray_StructEiPdiS2_' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond151.preheader ], [ %indvars.iv.next387, %for.body153 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %53 = add nuw nsw i64 %51, %indvars.iv386 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx169 = getelementptr inbounds [16 x double], ptr %arrayidx136, i64 0, i64 %indvars.iv386 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %54 = load double, ptr %arrayidx169, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul170 = fmul double %mul166, %54 of type:fmul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx172 = getelementptr inbounds [16 x double], ptr %eqn, i64 0, i64 %53 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %55 = load double, ptr %arrayidx172, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add173 = fadd double %55, %mul170 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %add173, ptr %arrayidx172, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond391.not = icmp eq i64 %indvars.iv.next387, %indvars.iv410 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond391.not, label %for.cond151.for.inc177_crit_edge, label %for.body153 of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'_ZN3povL9intersectEPNS_10Ray_StructEiPdiS2_' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond151.preheader ], [ %indvars.iv.next387, %for.body153 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %53 = add nuw nsw i64 %51, %indvars.iv386 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx169 = getelementptr inbounds [16 x double], ptr %arrayidx136, i64 0, i64 %indvars.iv386 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %54 = load double, ptr %arrayidx169, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul170 = fmul double %mul166, %54 of type:fmul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx172 = getelementptr inbounds [16 x double], ptr %eqn, i64 0, i64 %53 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %55 = load double, ptr %arrayidx172, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add173 = fadd double %55, %mul170 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %add173, ptr %arrayidx172, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond391.not = icmp eq i64 %indvars.iv.next387, %indvars.iv410 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond391.not, label %for.cond151.for.inc177_crit_edge, label %for.body153 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 24
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL9intersectEPNS_10Ray_StructEiPdiS2_' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond151.preheader ], [ %indvars.iv.next387, %for.body153 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %53 = add nuw nsw i64 %51, %indvars.iv386 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx169 = getelementptr inbounds [16 x double], ptr %arrayidx136, i64 0, i64 %indvars.iv386 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %54 = load double, ptr %arrayidx169, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul170 = fmul double %mul166, %54 of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx172 = getelementptr inbounds [16 x double], ptr %eqn, i64 0, i64 %53 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %55 = load double, ptr %arrayidx172, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add173 = fadd double %55, %mul170 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %add173, ptr %arrayidx172, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond391.not = icmp eq i64 %indvars.iv.next387, %indvars.iv410 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond391.not, label %for.cond151.for.inc177_crit_edge, label %for.body153 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3povL9intersectEPNS_10Ray_StructEiPdiS2_' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond151.preheader ], [ %indvars.iv.next387, %for.body153 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %53 = add nuw nsw i64 %51, %indvars.iv386 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx169 = getelementptr inbounds [16 x double], ptr %arrayidx136, i64 0, i64 %indvars.iv386 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %54 = load double, ptr %arrayidx169, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul170 = fmul double %mul166, %54 of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx172 = getelementptr inbounds [16 x double], ptr %eqn, i64 0, i64 %53 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %55 = load double, ptr %arrayidx172, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add173 = fadd double %55, %mul170 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %add173, ptr %arrayidx172, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond391.not = icmp eq i64 %indvars.iv.next387, %indvars.iv410 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond391.not, label %for.cond151.for.inc177_crit_edge, label %for.body153 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL9intersectEPNS_10Ray_StructEiPdiS2_ at line: poly.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond151.preheader>:
  EMIT vp<%2> = EXPAND SCEV {{1,+,1}<nuw><nsw><%for.cond95.preheader>,+,-1}<nsw><%for.body118>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%53> = add nuw nsw ir<%51>, vp<%4>
    CLONE ir<%arrayidx169> = getelementptr inbounds ir<%arrayidx136>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx169>
    WIDEN ir<%54> = load vp<%5>
    WIDEN ir<%mul170> = fmul ir<%mul166>, ir<%54>
    CLONE ir<%arrayidx172> = getelementptr inbounds ir<%eqn>, ir<0>, ir<%53>
    vp<%6> = vector-pointer ir<%arrayidx172>
    WIDEN ir<%55> = load vp<%6>
    WIDEN ir<%add173> = fadd ir<%55>, ir<%mul170>
    vp<%7> = vector-pointer ir<%arrayidx172>
    WIDEN store vp<%7>, ir<%add173>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond151.for.inc177_crit_edge>, scalar.ph

ir-bb<for.cond151.for.inc177_crit_edge>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL8binomialEii' from poly.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((-1 * %r) + %n) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION %i.0.in87 = phi %r, %i.0, ir<1>
    CLONE ir<%i.0> = add nuw nsw ir<%i.0.in87>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@_ZZN3povL8binomialEiiE6stack1>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%i.0>, ir<%arrayidx15>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond17.preheader>, scalar.ph

ir-bb<for.cond17.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL8binomialEii' from poly.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((-1 * %r) + %n) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION %i.0.in87 = phi %r, %i.0, ir<1>
    WIDEN ir<%i.0> = add nuw nsw ir<%i.0.in87>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@_ZZN3povL8binomialEiiE6stack1>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx15>
    WIDEN store vp<%4>, ir<%i.0>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond17.preheader>, scalar.ph

ir-bb<for.cond17.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL8binomialEii' from poly.cpp==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((-1 * %r) + %n) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION %i.0.in87 = phi %r, %i.0, ir<1>
    WIDEN ir<%i.0> = add nuw nsw ir<%i.0.in87>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@_ZZN3povL8binomialEiiE6stack1>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx15>
    WIDEN store vp<%4>, ir<%i.0>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond17.preheader>, scalar.ph

ir-bb<for.cond17.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL8binomialEii' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0.in87 = phi i32 [ %r, %for.body.preheader ], [ %i.0, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %i.0 = add nuw nsw i32 %i.0.in87, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx15 = getelementptr inbounds [40 x i32], ptr @_ZZN3povL8binomialEiiE6stack1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond17.preheader, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'_ZN3povL8binomialEii' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0.in87 = phi i32 [ %r, %for.body.preheader ], [ %i.0, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %i.0 = add nuw nsw i32 %i.0.in87, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx15 = getelementptr inbounds [40 x i32], ptr @_ZZN3povL8binomialEiiE6stack1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond17.preheader, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL8binomialEii' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0.in87 = phi i32 [ %r, %for.body.preheader ], [ %i.0, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %i.0 = add nuw nsw i32 %i.0.in87, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx15 = getelementptr inbounds [40 x i32], ptr @_ZZN3povL8binomialEiiE6stack1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond17.preheader, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3povL8binomialEii' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0.in87 = phi i32 [ %r, %for.body.preheader ], [ %i.0, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %i.0 = add nuw nsw i32 %i.0.in87, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx15 = getelementptr inbounds [40 x i32], ptr @_ZZN3povL8binomialEiiE6stack1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond17.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'_ZN3povL8binomialEii' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0.in87 = phi i32 [ %r, %for.body.preheader ], [ %i.0, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %i.0 = add nuw nsw i32 %i.0.in87, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx15 = getelementptr inbounds [40 x i32], ptr @_ZZN3povL8binomialEiiE6stack1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond17.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3povL8binomialEii' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0.in87 = phi i32 [ %r, %for.body.preheader ], [ %i.0, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %i.0 = add nuw nsw i32 %i.0.in87, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx15 = getelementptr inbounds [40 x i32], ptr @_ZZN3povL8binomialEiiE6stack1, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %i.0, ptr %arrayidx15, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond17.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN3povL8binomialEii at line: poly.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((-1 * %r) + %n) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %i.0.in87 = phi %r, %i.0, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    WIDEN ir<%i.0> = add nuw nsw ir<%i.0.in87>, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@_ZZN3povL8binomialEiiE6stack1>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx15>
    WIDEN store vp<%5>, ir<%i.0>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond17.preheader>, scalar.ph

ir-bb<for.cond17.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %36 = load i32, ptr %arrayidx48, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load i32, ptr %arrayidx48, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL8binomialEii' from poly.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body46.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((-1 * %r) + %n) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv119 = phi 0, %indvars.iv.next120, ir<1>
    WIDEN-REDUCTION-PHI ir<%result.099> = phi ir<1>, ir<%mul>
    CLONE ir<%arrayidx48> = getelementptr inbounds ir<@_ZZN3povL8binomialEiiE6stack1>, ir<0>, ir<%indvars.iv119>
    CLONE ir<%36> = load ir<%arrayidx48>
    CLONE ir<%mul> = mul ir<%36>, ir<%result.099>
    CLONE ir<%indvars.iv.next120> = add nuw nsw ir<%indvars.iv119>, ir<1>
    CLONE ir<%exitcond123.not> = icmp eq ir<%indvars.iv.next120>, ir<%wide.trip.count122>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%result.099>, ir<%mul>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %mul.lcssa = vp<%6>
}

========== Loop: _ZN3povL8binomialEii' from poly.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body46.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((-1 * %r) + %n) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv119 = phi 0, %indvars.iv.next120, ir<1>
    WIDEN-REDUCTION-PHI ir<%result.099> = phi ir<1>, ir<%mul>
    CLONE ir<%arrayidx48> = getelementptr inbounds ir<@_ZZN3povL8binomialEiiE6stack1>, ir<0>, ir<%indvars.iv119>
    vp<%4> = vector-pointer ir<%arrayidx48>
    WIDEN ir<%36> = load vp<%4>
    WIDEN ir<%mul> = mul ir<%36>, ir<%result.099>
    CLONE ir<%indvars.iv.next120> = add nuw nsw ir<%indvars.iv119>, ir<1>
    CLONE ir<%exitcond123.not> = icmp eq ir<%indvars.iv.next120>, ir<%wide.trip.count122>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%result.099>, ir<%mul>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %mul.lcssa = vp<%7>
}


-----------------Function that is being costed:'_ZN3povL8binomialEii' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv119 = phi i64 [ 0, %for.body46.preheader ], [ %indvars.iv.next120, %for.body46 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %result.099 = phi i32 [ 1, %for.body46.preheader ], [ %mul, %for.body46 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx48 = getelementptr inbounds [40 x i32], ptr @_ZZN3povL8binomialEiiE6stack1, i64 0, i64 %indvars.iv119 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %36 = load i32, ptr %arrayidx48, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul = mul i32 %36, %result.099 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next120 = add nuw nsw i64 %indvars.iv119, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond123.not = icmp eq i64 %indvars.iv.next120, %wide.trip.count122 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond123.not, label %if.end54.loopexit, label %for.body46 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'_ZN3povL8binomialEii' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv119 = phi i64 [ 0, %for.body46.preheader ], [ %indvars.iv.next120, %for.body46 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %result.099 = phi i32 [ 1, %for.body46.preheader ], [ %mul, %for.body46 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx48 = getelementptr inbounds [40 x i32], ptr @_ZZN3povL8binomialEiiE6stack1, i64 0, i64 %indvars.iv119 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %36 = load i32, ptr %arrayidx48, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul = mul i32 %36, %result.099 of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next120 = add nuw nsw i64 %indvars.iv119, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond123.not = icmp eq i64 %indvars.iv.next120, %wide.trip.count122 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond123.not, label %if.end54.loopexit, label %for.body46 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL8binomialEii' from poly.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv119 = phi i64 [ 0, %for.body46.preheader ], [ %indvars.iv.next120, %for.body46 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %result.099 = phi i32 [ 1, %for.body46.preheader ], [ %mul, %for.body46 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx48 = getelementptr inbounds [40 x i32], ptr @_ZZN3povL8binomialEiiE6stack1, i64 0, i64 %indvars.iv119 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %36 = load i32, ptr %arrayidx48, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul = mul i32 %36, %result.099 of type:mul
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next120 = add nuw nsw i64 %indvars.iv119, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond123.not = icmp eq i64 %indvars.iv.next120, %wide.trip.count122 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond123.not, label %if.end54.loopexit, label %for.body46 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2
LV: Selecting VF: 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=4, UF=2 at function: _ZN3povL8binomialEii at line: poly.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body46.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((-1 * %r) + %n) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%result.099> = phi ir<1>, ir<%mul>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx48> = getelementptr inbounds ir<@_ZZN3povL8binomialEiiE6stack1>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx48>
    WIDEN ir<%36> = load vp<%5>
    WIDEN ir<%mul> = mul ir<%36>, ir<%result.099>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%result.099>, ir<%mul>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %mul.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 12
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o polygon.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           polygon.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o polysolv.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           polysolv.cpp
@@ Instruction =>  %3 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
MVT: v2f64
@@ Instruction =>  store double %div, ptr %arrayidx4, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
@@ Instruction =>  %3 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
MVT: nxv2f64
@@ Instruction =>  store double %div, ptr %arrayidx4, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  %3 = load double, ptr %arrayidx, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
MVT: nxv2f64
@@ Instruction =>  store double %div, ptr %arrayidx4, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN3povL9polysolveEiPdS0_' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %order) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Coeffs>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%div> = fdiv ir<%3>, ir<%0>
    CLONE ir<%4> = sub nsw ir<%1>, ir<%indvars.iv>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%coef>, ir<0>, ir<%4>
    CLONE store ir<%div>, ir<%arrayidx4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9polysolveEiPdS0_' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %order) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Coeffs>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN ir<%div> = fdiv ir<%3>, ir<%0>
    CLONE ir<%4> = sub nsw ir<%1>, ir<%indvars.iv>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%coef>, ir<0>, ir<%4>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx4>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9polysolveEiPdS0_' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %order) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Coeffs>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN ir<%div> = fdiv ir<%3>, ir<%0>
    CLONE ir<%4> = sub nsw ir<%1>, ir<%indvars.iv>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%coef>, ir<0>, ir<%4>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx4>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL9polysolveEiPdS0_' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Coeffs, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv double %3, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = sub nsw i64 %1, %indvars.iv of type:sub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds [16 x double], ptr %coef, i64 0, i64 %4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div, ptr %arrayidx4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3povL9polysolveEiPdS0_' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Coeffs, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv double %3, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = sub nsw i64 %1, %indvars.iv of type:sub
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds [16 x double], ptr %coef, i64 0, i64 %4 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store double %div, ptr %arrayidx4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 19327352832
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 19327352832
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL9polysolveEiPdS0_' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Coeffs, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv double %3, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %4 = sub nsw i64 %1, %indvars.iv of type:sub
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds [16 x double], ptr %coef, i64 0, i64 %4 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %div, ptr %arrayidx4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352832
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934592

-----------------Function that is being costed:'_ZN3povL9polysolveEiPdS0_' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %Coeffs, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv double %3, %0 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = sub nsw i64 %1, %indvars.iv of type:sub
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds [16 x double], ptr %coef, i64 0, i64 %4 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %div, ptr %arrayidx4, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 19327352832
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL9polysolveEiPdS0_ at line: polysolv.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %order) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Coeffs>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%5>
    WIDEN ir<%div> = fdiv ir<%3>, ir<%0>
    CLONE ir<%4> = sub nsw ir<%1>, vp<%4>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%coef>, ir<0>, ir<%4>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx4>
    WIDEN store vp<%6>, ir<%div>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
MVT: nxv2f64
MVT: nxv2f64
@@ Instruction =>  %2 = load double, ptr %fc.075, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %div, ptr %fp.074, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load double, ptr %fc.075, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %div, ptr %fp.074, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
========== Loop: _ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %ord to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%fc.075> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 8
    EMIT ir<%fp.074> = WIDEN-POINTER-INDUCTION ir<%coef7>, 8
    WIDEN-INDUCTION %i.073 = phi %inc, 1, ir<1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%fc.075>, ir<8>
    CLONE ir<%2> = load ir<%fc.075>
    CLONE ir<%conv11> = uitofp nneg ir<%i.073>
    CLONE ir<%mul12> = fmul ir<%2>, ir<%conv11>
    CLONE ir<%div> = fdiv ir<%mul12>, ir<%1>
    CLONE ir<%incdec.ptr13> = getelementptr inbounds ir<%fp.074>, ir<8>
    CLONE store ir<%div>, ir<%fp.074>
    CLONE ir<%inc> = add nuw ir<%i.073>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%i.073>, ir<%ord>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %ord to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%fc.075> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 8
    EMIT ir<%fp.074> = WIDEN-POINTER-INDUCTION ir<%coef7>, 8
    WIDEN-INDUCTION %i.073 = phi %inc, 1, ir<1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%fc.075>, ir<8>
    vp<%4> = vector-pointer ir<%fc.075>
    WIDEN ir<%2> = load vp<%4>
    WIDEN-CAST ir<%conv11> = uitofp  nneg ir<%i.073> to double
    WIDEN ir<%mul12> = fmul ir<%2>, ir<%conv11>
    WIDEN ir<%div> = fdiv ir<%mul12>, ir<%1>
    CLONE ir<%incdec.ptr13> = getelementptr inbounds ir<%fp.074>, ir<8>
    vp<%5> = vector-pointer ir<%fp.074>
    WIDEN store vp<%5>, ir<%div>
    WIDEN ir<%inc> = add nuw ir<%i.073>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%i.073>, ir<%ord>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %ord to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%fc.075> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 8
    EMIT ir<%fp.074> = WIDEN-POINTER-INDUCTION ir<%coef7>, 8
    WIDEN-INDUCTION %i.073 = phi %inc, 1, ir<1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%fc.075>, ir<8>
    vp<%4> = vector-pointer ir<%fc.075>
    WIDEN ir<%2> = load vp<%4>
    WIDEN-CAST ir<%conv11> = uitofp  nneg ir<%i.073> to double
    WIDEN ir<%mul12> = fmul ir<%2>, ir<%conv11>
    WIDEN ir<%div> = fdiv ir<%mul12>, ir<%1>
    CLONE ir<%incdec.ptr13> = getelementptr inbounds ir<%fp.074>, ir<8>
    vp<%5> = vector-pointer ir<%fp.074>
    WIDEN store vp<%5>, ir<%div>
    WIDEN ir<%inc> = add nuw ir<%i.073>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%i.073>, ir<%ord>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fc.075 = phi ptr [ %incdec.ptr, %for.body ], [ %add.ptr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fp.074 = phi ptr [ %incdec.ptr13, %for.body ], [ %coef7, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.073 = phi i32 [ %inc, %for.body ], [ 1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %fc.075, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load double, ptr %fc.075, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv11 = uitofp nneg i32 %i.073 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul12 = fmul double %2, %conv11 of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv double %mul12, %1 of type:fdiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr13 = getelementptr inbounds i8, ptr %fp.074, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div, ptr %fp.074, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw i32 %i.073, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %i.073, %ord of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'_ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fc.075 = phi ptr [ %incdec.ptr, %for.body ], [ %add.ptr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fp.074 = phi ptr [ %incdec.ptr13, %for.body ], [ %coef7, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.073 = phi i32 [ %inc, %for.body ], [ 1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %fc.075, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load double, ptr %fc.075, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv11 = uitofp nneg i32 %i.073 to double of type:uitofp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul12 = fmul double %2, %conv11 of type:fmul
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv double %mul12, %1 of type:fdiv
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr13 = getelementptr inbounds i8, ptr %fp.074, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %div, ptr %fp.074, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw i32 %i.073, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %i.073, %ord of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418241, RTCostB: 23622320117
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418241, RTCostB: 23622320117
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fc.075 = phi ptr [ %incdec.ptr, %for.body ], [ %add.ptr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fp.074 = phi ptr [ %incdec.ptr13, %for.body ], [ %coef7, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.073 = phi i32 [ %inc, %for.body ], [ 1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %fc.075, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load double, ptr %fc.075, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv11 = uitofp nneg i32 %i.073 to double of type:uitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul12 = fmul double %2, %conv11 of type:fmul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv double %mul12, %1 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr13 = getelementptr inbounds i8, ptr %fp.074, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %div, ptr %fp.074, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nuw i32 %i.073, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %i.073, %ord of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320117
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10737418241
LV: Selecting VF: 2 With Cost: 5.
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=2, UF=1 at function: _ZN3povL10buildsturmEiPNS_1pE at line: polysolv.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %ord to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %i.073 = phi %inc, 1, ir<1>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%add.ptr>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%coef7>, vp<%8>
    vp<%10> = vector-pointer vp<%6>
    WIDEN ir<%2> = load vp<%10>
    WIDEN-CAST ir<%conv11> = uitofp  nneg ir<%i.073> to double
    WIDEN ir<%mul12> = fmul ir<%2>, ir<%conv11>
    WIDEN ir<%div> = fdiv ir<%mul12>, ir<%1>
    vp<%11> = vector-pointer vp<%9>
    WIDEN store vp<%11>, ir<%div>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2f64
@@ Instruction =>  %17 = load double, ptr %fp.1.ptr, align 8, !tbaa !11 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  store double %div32, ptr %fp.1.ptr, align 8, !tbaa !11 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  %17 = load double, ptr %fp.1.ptr, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %div32, ptr %fp.1.ptr, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %17 = load double, ptr %fp.1.ptr, align 8, !tbaa !11 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %div32, ptr %fp.1.ptr, align 8, !tbaa !11 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body31.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((15 + (8 * (sext i32 %14 to i64))<nsw> + (-1 * (15 smin (8 + (8 * (sext i32 %14 to i64))<nsw>)<nsw>))<nsw>) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %fp.1.idx77 = phi %fp.1.add, %coef19.add, ir<-8>
    CLONE ir<%fp.1.ptr> = getelementptr inbounds ir<%sp.082>, ir<%fp.1.idx77>
    CLONE ir<%17> = load ir<%fp.1.ptr>
    CLONE ir<%div32> = fdiv ir<%17>, ir<%fneg>
    CLONE store ir<%div32>, ir<%fp.1.ptr>
    CLONE ir<%fp.1.add> = add nsw ir<%fp.1.idx77>, ir<-8>
    CLONE ir<%cmp30.not> = icmp slt ir<%fp.1.idx77>, ir<16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc36.loopexit>, scalar.ph

ir-bb<for.inc36.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body31.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((15 + (8 * (sext i32 %14 to i64))<nsw> + (-1 * (15 smin (8 + (8 * (sext i32 %14 to i64))<nsw>)<nsw>))<nsw>) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %fp.1.idx77 = phi %fp.1.add, %coef19.add, ir<-8>
    CLONE ir<%fp.1.ptr> = getelementptr inbounds ir<%sp.082>, ir<%fp.1.idx77>
    vp<%4> = vector-pointer (reverse) ir<%fp.1.ptr>
    WIDEN ir<%17> = load vp<%4>
    WIDEN ir<%div32> = fdiv ir<%17>, ir<%fneg>
    vp<%5> = vector-pointer (reverse) ir<%fp.1.ptr>
    WIDEN store vp<%5>, ir<%div32>
    CLONE ir<%fp.1.add> = add nsw ir<%fp.1.idx77>, ir<-8>
    CLONE ir<%cmp30.not> = icmp slt ir<%fp.1.idx77>, ir<16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc36.loopexit>, scalar.ph

ir-bb<for.inc36.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body31.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((15 + (8 * (sext i32 %14 to i64))<nsw> + (-1 * (15 smin (8 + (8 * (sext i32 %14 to i64))<nsw>)<nsw>))<nsw>) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %fp.1.idx77 = phi %fp.1.add, %coef19.add, ir<-8>
    CLONE ir<%fp.1.ptr> = getelementptr inbounds ir<%sp.082>, ir<%fp.1.idx77>
    vp<%4> = vector-pointer (reverse) ir<%fp.1.ptr>
    WIDEN ir<%17> = load vp<%4>
    WIDEN ir<%div32> = fdiv ir<%17>, ir<%fneg>
    vp<%5> = vector-pointer (reverse) ir<%fp.1.ptr>
    WIDEN store vp<%5>, ir<%div32>
    CLONE ir<%fp.1.add> = add nsw ir<%fp.1.idx77>, ir<-8>
    CLONE ir<%cmp30.not> = icmp slt ir<%fp.1.idx77>, ir<16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc36.loopexit>, scalar.ph

ir-bb<for.inc36.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fp.1.idx77 = phi i64 [ %fp.1.add, %for.body31 ], [ %coef19.add, %for.body31.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fp.1.ptr = getelementptr inbounds i8, ptr %sp.082, i64 %fp.1.idx77 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %17 = load double, ptr %fp.1.ptr, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div32 = fdiv double %17, %fneg of type:fdiv
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div32, ptr %fp.1.ptr, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %fp.1.add = add nsw i64 %fp.1.idx77, -8 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp30.not = icmp slt i64 %fp.1.idx77, 16 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp30.not, label %for.inc36.loopexit, label %for.body31 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'_ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fp.1.idx77 = phi i64 [ %fp.1.add, %for.body31 ], [ %coef19.add, %for.body31.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fp.1.ptr = getelementptr inbounds i8, ptr %sp.082, i64 %fp.1.idx77 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %17 = load double, ptr %fp.1.ptr, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div32 = fdiv double %17, %fneg of type:fdiv
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store double %div32, ptr %fp.1.ptr, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %fp.1.add = add nsw i64 %fp.1.idx77, -8 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp30.not = icmp slt i64 %fp.1.idx77, 16 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp30.not, label %for.inc36.loopexit, label %for.body31 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869184
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869184
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fp.1.idx77 = phi i64 [ %fp.1.add, %for.body31 ], [ %coef19.add, %for.body31.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fp.1.ptr = getelementptr inbounds i8, ptr %sp.082, i64 %fp.1.idx77 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %17 = load double, ptr %fp.1.ptr, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div32 = fdiv double %17, %fneg of type:fdiv
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %div32, ptr %fp.1.ptr, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %fp.1.add = add nsw i64 %fp.1.idx77, -8 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp30.not = icmp slt i64 %fp.1.idx77, 16 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp30.not, label %for.inc36.loopexit, label %for.body31 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869184
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934592

-----------------Function that is being costed:'_ZN3povL10buildsturmEiPNS_1pE' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fp.1.idx77 = phi i64 [ %fp.1.add, %for.body31 ], [ %coef19.add, %for.body31.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fp.1.ptr = getelementptr inbounds i8, ptr %sp.082, i64 %fp.1.idx77 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %17 = load double, ptr %fp.1.ptr, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div32 = fdiv double %17, %fneg of type:fdiv
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %div32, ptr %fp.1.ptr, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %fp.1.add = add nsw i64 %fp.1.idx77, -8 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp30.not = icmp slt i64 %fp.1.idx77, 16 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp30.not, label %for.inc36.loopexit, label %for.body31 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 17179869184
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL10buildsturmEiPNS_1pE at line: polysolv.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body31.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((15 + (8 * (sext i32 %14 to i64))<nsw> + (-1 * (15 smin (8 + (8 * (sext i32 %14 to i64))<nsw>)<nsw>))<nsw>) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%coef19.add> + vp<%3> * ir<-8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-8>
    CLONE ir<%fp.1.ptr> = getelementptr inbounds ir<%sp.082>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%fp.1.ptr>
    WIDEN ir<%17> = load vp<%6>
    WIDEN ir<%div32> = fdiv ir<%17>, ir<%fneg>
    vp<%7> = vector-pointer (reverse) ir<%fp.1.ptr>
    WIDEN store vp<%7>, ir<%div32>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc36.loopexit>, scalar.ph

ir-bb<for.inc36.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN3povL4modpEPNS_1pES1_S1_' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 ((-1 * (1 smin (-1 + (-1 * %0) + %2))) + (-1 * %0) + %2) to i64) /u 2))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv167 = phi %4, %indvars.iv.next168, ir<-2>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%coef5>, ir<0>, ir<%indvars.iv167>
    CLONE ir<%5> = load ir<%arrayidx7>
    CLONE ir<%fneg> = fneg ir<%5>
    CLONE store ir<%fneg>, ir<%arrayidx7>
    CLONE ir<%indvars.iv.next168> = add nsw ir<%indvars.iv167>, ir<-2>
    CLONE ir<%6> = trunc ir<%indvars.iv167>
    CLONE ir<%cmp4> = icmp sgt ir<%6>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL4modpEPNS_1pES1_S1_' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 ((-1 * (1 smin (-1 + (-1 * %0) + %2))) + (-1 * %0) + %2) to i64) /u 2))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv167 = phi %4, %indvars.iv.next168, ir<-2>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv167 = phi %4, %indvars.iv.next168\l" +
    "  ir<%6>, ir<-2>
    REPLICATE ir<%arrayidx7> = getelementptr inbounds ir<%coef5>, ir<0>, ir<%indvars.iv167>
    REPLICATE ir<%5> = load ir<%arrayidx7>
    WIDEN ir<%fneg> = fneg ir<%5>
    REPLICATE store ir<%fneg>, ir<%arrayidx7>
    REPLICATE ir<%indvars.iv.next168> = add nsw ir<%indvars.iv167>, ir<-2>
    CLONE ir<%cmp4> = icmp sgt ir<%6>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL4modpEPNS_1pES1_S1_' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 ((-1 * (1 smin (-1 + (-1 * %0) + %2))) + (-1 * %0) + %2) to i64) /u 2))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv167 = phi %4, %indvars.iv.next168, ir<-2>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv167 = phi %4, %indvars.iv.next168\l" +
    "  ir<%6>, ir<-2>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx7> = getelementptr inbounds ir<%coef5>, ir<0>, ir<%indvars.iv167>
    REPLICATE ir<%5> = load ir<%arrayidx7>
    WIDEN ir<%fneg> = fneg ir<%5>
    REPLICATE store ir<%fneg>, ir<%arrayidx7>
    WIDEN ir<%indvars.iv.next168> = add nsw ir<%indvars.iv167>, ir<-2>
    CLONE ir<%cmp4> = icmp sgt ir<%6>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL4modpEPNS_1pES1_S1_' from polysolv.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 ((-1 * (1 smin (-1 + (-1 * %0) + %2))) + (-1 * %0) + %2) to i64) /u 2))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv167 = phi %4, %indvars.iv.next168, ir<-2>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv167 = phi %4, %indvars.iv.next168\l" +
    "  ir<%6>, ir<-2>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx7> = getelementptr inbounds ir<%coef5>, ir<0>, ir<%indvars.iv167>
    WIDEN ir<%5> = load ir<%arrayidx7>
    WIDEN ir<%fneg> = fneg ir<%5>
    WIDEN store ir<%arrayidx7>, ir<%fneg>
    WIDEN ir<%indvars.iv.next168> = add nsw ir<%indvars.iv167>, ir<-2>
    CLONE ir<%cmp4> = icmp sgt ir<%6>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL4modpEPNS_1pES1_S1_' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv167 = phi i64 [ %4, %for.body.lr.ph ], [ %indvars.iv.next168, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx7 = getelementptr inbounds [16 x double], ptr %coef5, i64 0, i64 %indvars.iv167 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %5 = load double, ptr %arrayidx7, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %fneg = fneg double %5 of type:fneg
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %fneg, ptr %arrayidx7, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next168 = add nsw i64 %indvars.iv167, -2 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %6 = trunc nuw i64 %indvars.iv167 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp4 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp4, label %for.body, label %for.end.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3povL4modpEPNS_1pES1_S1_' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv167 = phi i64 [ %4, %for.body.lr.ph ], [ %indvars.iv.next168, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx7 = getelementptr inbounds [16 x double], ptr %coef5, i64 0, i64 %indvars.iv167 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 10 for VF 2 For instruction:   %5 = load double, ptr %arrayidx7, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %fneg = fneg double %5 of type:fneg
LV: Decision: Scalarize
LV: Found an estimated cost of 10 for VF 2 For instruction:   store double %fneg, ptr %arrayidx7, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next168 = add nsw i64 %indvars.iv167, -2 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %6 = trunc nuw i64 %indvars.iv167 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp4 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp4, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 12348030976, RTCostB: 7516192768
A is not scalable.	B is not scalable.	
RTCostA: 12348030976, RTCostB: 7516192768

-----------------Function that is being costed:'_ZN3povL4modpEPNS_1pES1_S1_' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv167 = phi i64 [ %4, %for.body.lr.ph ], [ %indvars.iv.next168, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx7 = getelementptr inbounds [16 x double], ptr %coef5, i64 0, i64 %indvars.iv167 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = load double, ptr %arrayidx7, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %fneg = fneg double %5 of type:fneg
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %fneg, ptr %arrayidx7, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next168 = add nsw i64 %indvars.iv167, -2 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %6 = trunc nuw i64 %indvars.iv167 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp4 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp4, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192768
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192768

-----------------Function that is being costed:'_ZN3povL4modpEPNS_1pES1_S1_' from polysolv.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv167 = phi i64 [ %4, %for.body.lr.ph ], [ %indvars.iv.next168, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx7 = getelementptr inbounds [16 x double], ptr %coef5, i64 0, i64 %indvars.iv167 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %5 = load double, ptr %arrayidx7, align 8, !tbaa !14 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %fneg = fneg double %5 of type:fneg
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double %fneg, ptr %arrayidx7, align 8, !tbaa !14 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next168 = add nsw i64 %indvars.iv167, -2 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %6 = trunc nuw i64 %indvars.iv167 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp4 = icmp sgt i32 %6, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp4, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 22817013760, RTCostB: 7516192768
A is scalable.	B is not scalable.	
RTCostA: 22817013760, RTCostB: 7516192768
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3povL4modpEPNS_1pES1_S1_ at line: polysolv.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 ((-1 * (1 smin (-1 + (-1 * %0) + %2))) + (-1 * %0) + %2) to i64) /u 2))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%4> + vp<%3> * ir<-2>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-2>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%coef5>, ir<0>, vp<%5>
    CLONE ir<%5> = load ir<%arrayidx7>
    CLONE ir<%fneg> = fneg ir<%5>
    CLONE store ir<%fneg>, ir<%arrayidx7>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pov_mem.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           pov_mem.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pov_util.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           pov_util.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o povms.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           povms.cpp
@@ Instruction =>  %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
LV: Decision: Scalarize
@@ Instruction =>  %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
LV: Decision: Scalarize
@@ Instruction =>  %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
LV: Decision: Scalarize
@@ Instruction =>  %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
LV: Decision: Scalarize
@@ Instruction =>  %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: _Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%2>, ir<1>
    CLONE ir<%0> = load ir<%arrayidx.us>
    CLONE ir<%arrayidx5.us> = getelementptr inbounds ir<%dstdata>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx5.us>
    CLONE ir<%cmp7.us> = icmp eq ir<%0>, ir<%1>
  Successor(s): if.then.us

  if.then.us:
    CLONE store ir<%2>, ir<%arrayidx9.us>, ir<%cmp7.us>
  Successor(s): for.inc.us

  for.inc.us:
    EMIT vp<%4> = not ir<%cmp7.us>
    EMIT vp<%5> = or ir<%cmp7.us>, vp<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count28>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond1.for.inc10_crit_edge.us>, scalar.ph

ir-bb<for.cond1.for.inc10_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: _Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%2>, ir<1>
    CLONE ir<%0> = load ir<%arrayidx.us>
    CLONE ir<%arrayidx5.us> = getelementptr inbounds ir<%dstdata>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx5.us>
    WIDEN ir<%1> = load vp<%4>
    WIDEN ir<%cmp7.us> = icmp eq ir<%0>, ir<%1>
  Successor(s): if.then.us

  if.then.us:
    REPLICATE store ir<%2>, ir<%arrayidx9.us>, ir<%cmp7.us>
  Successor(s): for.inc.us

  for.inc.us:
    EMIT vp<%5> = not ir<%cmp7.us>
    EMIT vp<%6> = or ir<%cmp7.us>, vp<%5>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count28>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1.for.inc10_crit_edge.us>, scalar.ph

ir-bb<for.cond1.for.inc10_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: _Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%2>, ir<1>
    CLONE ir<%0> = load ir<%arrayidx.us>
    CLONE ir<%arrayidx5.us> = getelementptr inbounds ir<%dstdata>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx5.us>
    WIDEN ir<%1> = load vp<%4>
    WIDEN ir<%cmp7.us> = icmp eq ir<%0>, ir<%1>
  Successor(s): if.then.us

  if.then.us:
    REPLICATE store ir<%2>, ir<%arrayidx9.us>, ir<%cmp7.us>
  Successor(s): for.inc.us

  for.inc.us:
    EMIT vp<%5> = not ir<%cmp7.us>
    EMIT vp<%6> = or ir<%cmp7.us>, vp<%5>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count28>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1.for.inc10_crit_edge.us>, scalar.ph

ir-bb<for.cond1.for.inc10_crit_edge.us>:
No successors

scalar.ph:
No successors
}

========== Loop: _Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%2>, ir<1>
    CLONE ir<%0> = load ir<%arrayidx.us>
    CLONE ir<%arrayidx5.us> = getelementptr inbounds ir<%dstdata>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx5.us>
    WIDEN ir<%1> = load vp<%4>
    WIDEN ir<%cmp7.us> = icmp eq ir<%0>, ir<%1>
  Successor(s): if.then.us

  if.then.us:
    WIDEN store ir<%arrayidx9.us>, ir<%2>, ir<%cmp7.us>
  Successor(s): for.inc.us

  for.inc.us:
    EMIT vp<%5> = not ir<%cmp7.us>
    EMIT vp<%6> = or ir<%cmp7.us>, vp<%5>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count28>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1.for.inc10_crit_edge.us>, scalar.ph

ir-bb<for.cond1.for.inc10_crit_edge.us>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next, %for.inc.us ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load i8, ptr %arrayidx.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx5.us = getelementptr inbounds i8, ptr %dstdata, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp7.us = icmp eq i8 %0, %1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp7.us, label %if.then.us, label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %2 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %2, ptr %arrayidx9.us, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count28 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond1.for.inc10_crit_edge.us, label %for.body3.us of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next, %for.inc.us ] of type:phi
LV: Found an estimated cost of 2 for VF 2 For instruction:   %0 = load i8, ptr %arrayidx.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx5.us = getelementptr inbounds i8, ptr %dstdata, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp7.us = icmp eq i8 %0, %1 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp7.us, label %if.then.us, label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   %2 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %2, ptr %arrayidx9.us, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count28 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond1.for.inc10_crit_edge.us, label %for.body3.us of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 18253610999, RTCostB: 17179869176
A is not scalable.	B is not scalable.	
RTCostA: 18253610999, RTCostB: 17179869176

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next, %for.inc.us ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %0 = load i8, ptr %arrayidx.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx5.us = getelementptr inbounds i8, ptr %dstdata, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp7.us = icmp eq i8 %0, %1 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp7.us, label %if.then.us, label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 4 for VF 4 For instruction:   %2 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %2, ptr %arrayidx9.us, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count28 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond1.for.inc10_crit_edge.us, label %for.body3.us of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next, %for.inc.us ] of type:phi
LV: Found an estimated cost of 2 for VF 8 For instruction:   %0 = load i8, ptr %arrayidx.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx5.us = getelementptr inbounds i8, ptr %dstdata, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp7.us = icmp eq i8 %0, %1 of type:icmp
LV: Found an estimated cost of 16 for VF 8 For instruction:   br i1 %cmp7.us, label %if.then.us, label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 8 for VF 8 For instruction:   %2 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %2, ptr %arrayidx9.us, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count28 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.cond1.for.inc10_crit_edge.us, label %for.body3.us of type:br
LV: Vector loop of width 8 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 11005853711, RTCostB: 17179869176
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 11005853711, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next, %for.inc.us ] of type:phi
LV: Found an estimated cost of 2 for VF 16 For instruction:   %0 = load i8, ptr %arrayidx.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx5.us = getelementptr inbounds i8, ptr %dstdata, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp7.us = icmp eq i8 %0, %1 of type:icmp
LV: Found an estimated cost of 32 for VF 16 For instruction:   br i1 %cmp7.us, label %if.then.us, label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 16 for VF 16 For instruction:   %2 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 16 for VF 16 For instruction:   store i32 %2, ptr %arrayidx9.us, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count28 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.cond1.for.inc10_crit_edge.us, label %for.body3.us of type:br
LV: Vector loop of width 16 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 10334765099, RTCostB: 17179869176
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10334765099, RTCostB: 11005853711
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next, %for.inc.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %0 = load i8, ptr %arrayidx.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx5.us = getelementptr inbounds i8, ptr %dstdata, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp7.us = icmp eq i8 %0, %1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp7.us, label %if.then.us, label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %2 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %2, ptr %arrayidx9.us, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count28 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond1.for.inc10_crit_edge.us, label %for.body3.us of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10334765099

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next, %for.inc.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %0 = load i8, ptr %arrayidx.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx5.us = getelementptr inbounds i8, ptr %dstdata, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp7.us = icmp eq i8 %0, %1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp7.us, label %if.then.us, label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %2 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %2, ptr %arrayidx9.us, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count28 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond1.for.inc10_crit_edge.us, label %for.body3.us of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 25232932841, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 25232932841, RTCostB: 10334765099

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond1.preheader.us ], [ %indvars.iv.next, %for.inc.us ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %0 = load i8, ptr %arrayidx.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx5.us = getelementptr inbounds i8, ptr %dstdata, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load i8, ptr %arrayidx5.us, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp7.us = icmp eq i8 %0, %1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp7.us, label %if.then.us, label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %2 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %2, ptr %arrayidx9.us, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc.us of type:br

-----------------Function that is being costed:'_Z27POVMSStream_BuildOrderTablePhS_Pii' from povms.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count28 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond1.for.inc10_crit_edge.us, label %for.body3.us of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 23622320096, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 23622320096, RTCostB: 10334765099
LV: Selecting VF: 16 With Cost: 4.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 11005853711, RTCostB: 12884901888
LEV: Vectorizing epilogue loop with VF = 8 at function: _Z27POVMSStream_BuildOrderTablePhS_Pii at line: povms.cpp
LEV: EpilogueVF.Width: 8
Executing best plan with VF=16, UF=1 at function: _Z27POVMSStream_BuildOrderTablePhS_Pii at line: povms.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond1.preheader.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
  SCALAR-CAST vp<%3> = trunc ir<1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    SCALAR-CAST vp<%6> = trunc vp<%4> to i32
    CLONE ir<%1> = load ir<%arrayidx.us>
    CLONE ir<%arrayidx5.us> = getelementptr inbounds ir<%dstdata>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx5.us>
    WIDEN ir<%2> = load vp<%7>
    WIDEN ir<%cmp7.us> = icmp eq ir<%1>, ir<%2>
  Successor(s): pred.store

  <xVFxUF> pred.store: {
    pred.store.entry:
      BRANCH-ON-MASK ir<%cmp7.us>
    Successor(s): pred.store.if, pred.store.continue

    pred.store.if:
      vp<%8> = SCALAR-STEPS vp<%6>, vp<%3>
      REPLICATE store vp<%8>, ir<%arrayidx9.us>
    Successor(s): pred.store.continue

    pred.store.continue:
    No successors
  }
  Successor(s): if.then.us.0

  if.then.us.0:
    EMIT vp<%9> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.cond1.for.inc10_crit_edge.us>, scalar.ph

ir-bb<for.cond1.for.inc10_crit_edge.us>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=8, UF=1 at function: _Z27POVMSStream_BuildOrderTablePhS_Pii at line: povms.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count28> = original trip-count

vector.ph:
  SCALAR-CAST vp<%2> = trunc ir<1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    SCALAR-CAST vp<%5> = trunc vp<%3> to i32
    CLONE ir<%40> = load ir<%arrayidx.us>
    CLONE ir<%arrayidx5.us> = getelementptr inbounds ir<%dstdata>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx5.us>
    WIDEN ir<%41> = load vp<%6>
    WIDEN ir<%cmp7.us> = icmp eq ir<%40>, ir<%41>
  Successor(s): pred.store

  <xVFxUF> pred.store: {
    pred.store.entry:
      BRANCH-ON-MASK ir<%cmp7.us>
    Successor(s): pred.store.if, pred.store.continue

    pred.store.if:
      vp<%7> = SCALAR-STEPS vp<%5>, vp<%2>
      REPLICATE store vp<%7>, ir<%arrayidx9.us>
    Successor(s): pred.store.continue

    pred.store.continue:
    No successors
  }
  Successor(s): if.then.us.0

  if.then.us.0:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<%wide.trip.count28>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond1.for.inc10_crit_edge.us>, scalar.ph

ir-bb<for.cond1.for.inc10_crit_edge.us>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 13
Loops Epilogues Vectorized: 1
================================================
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: _Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%stream>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%data>, ir<%indvars.iv>
    CLONE store ir<%0>, ir<%arrayidx2>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%stream>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%data>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%stream>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%data>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418236, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418236, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225484, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225484, RTCostB: 10737418236
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 3221225484
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 12884901882
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 1073741862
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 536870998

-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 536870998

-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 536870998

-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 12884901882
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 536870998
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'_Z29POVMSStream_ReadDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 268435638, RTCostB: 12884901882
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 268435638, RTCostB: 536870998
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 3221225484, RTCostB: 10737418236
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 3221225484
A is not scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 1073741862
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 536870998
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 536870998
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 536870998
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: _Z29POVMSStream_ReadDataUnorderedPhS_i at line: povms.cpp
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: _Z29POVMSStream_ReadDataUnorderedPhS_i at line: povms.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%stream>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%data>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%6>, ir<%4>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: _Z29POVMSStream_ReadDataUnorderedPhS_i at line: povms.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%stream>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%31> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%data>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%31>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%wide.trip.count>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 15
Loops Epilogues Vectorized: 2
================================================
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: _Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<%indvars.iv>
    CLONE ir<%0> = load ir<%arrayidx>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%stream>, ir<%indvars.iv>
    CLONE store ir<%0>, ir<%arrayidx2>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%stream>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%stream>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418236, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418236, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225484, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225484, RTCostB: 10737418236
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 3221225484
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 12884901882
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 1073741862
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 536870998

-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 536870998

-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 536870998

-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 12884901882
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 536870998
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'_Z30POVMSStream_WriteDataUnorderedPhS_i' from povms.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %data, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %0 = load i8, ptr %arrayidx, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2 = getelementptr inbounds i8, ptr %stream, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %0, ptr %arrayidx2, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 268435638, RTCostB: 12884901882
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 268435638, RTCostB: 536870998
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 3221225484, RTCostB: 10737418236
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 3221225484
A is not scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 1073741862
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 536870998
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 536870998
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 536870998
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: _Z30POVMSStream_WriteDataUnorderedPhS_i at line: povms.cpp
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: _Z30POVMSStream_WriteDataUnorderedPhS_i at line: povms.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %datasize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%5>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%stream>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%6>, ir<%4>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: _Z30POVMSStream_WriteDataUnorderedPhS_i at line: povms.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%31> = load vp<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%stream>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx2>
    WIDEN store vp<%5>, ir<%31>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%wide.trip.count>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 17
Loops Epilogues Vectorized: 3
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o povmscpp.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           povmscpp.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o povmsend.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           povmsend.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o povmsrec.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           povmsrec.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o povray.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           povray.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ppm.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           ppm.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o prism.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           prism.cpp
MVT: v2f64
@@ Instruction =>  %96 = load double, ptr %arrayidx490, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  store double %99, ptr %arrayidx511, align 8, !tbaa !20 -> Cost: 9 -> VectorType: <2 x double> -> ttilog -> MaskedMemoryOpCost(8)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  %96 = load double, ptr %arrayidx490, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %99, ptr %arrayidx511, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %96 = load double, ptr %arrayidx490, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %99, ptr %arrayidx511, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body488.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call484 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1208 = phi %95, %indvars.iv.next1209, ir<-1>
    CLONE ir<%indvars.iv.next1209> = add nsw ir<%indvars.iv1208>, ir<-1>
    CLONE ir<%arrayidx490> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next1209>
    CLONE ir<%96> = load ir<%arrayidx490>
    CLONE ir<%cmp491> = fcmp ult ir<%96>, ir<0.000000e+00>
    CLONE ir<%cmp495> = fcmp ugt ir<%96>, ir<1.000000e+00>
    CLONE ir<%or.cond1194> = or ir<%cmp491>, ir<%cmp495>
  Successor(s): if.then496

  if.then496:
    EMIT vp<%4> = not ir<%or.cond1194>
    CLONE ir<%97> = call @llvm.fmuladd.f64(ir<%96>, ir<%91>, ir<%92>)
    CLONE ir<%98> = call @llvm.fmuladd.f64(ir<%96>, ir<%97>, ir<%93>)
    CLONE ir<%99> = call @llvm.fmuladd.f64(ir<%96>, ir<%98>, ir<%94>)
    CLONE ir<%arrayidx511> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next1209>
    CLONE store ir<%99>, ir<%arrayidx511>, vp<%4>
  Successor(s): if.end512

  if.end512:
    EMIT vp<%5> = or vp<%4>, ir<%or.cond1194>
    CLONE ir<%tobool487.not> = icmp eq ir<%indvars.iv.next1209>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end514.loopexit>, scalar.ph

ir-bb<if.end514.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body488.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call484 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv1208 = phi %95, %indvars.iv.next1209, ir<-1>
    CLONE ir<%indvars.iv.next1209> = add ir<%indvars.iv1208>, ir<-1>
    CLONE ir<%arrayidx490> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next1209>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx490>
    WIDEN ir<%96> = load vp<%4>
    WIDEN ir<%cmp491> = fcmp ult ir<%96>, ir<0.000000e+00>
    WIDEN ir<%cmp495> = fcmp ugt ir<%96>, ir<1.000000e+00>
    WIDEN ir<%or.cond1194> = or ir<%cmp491>, ir<%cmp495>
  Successor(s): if.then496

  if.then496:
    EMIT vp<%5> = not ir<%or.cond1194>
    WIDEN-CALL ir<%97> = call @llvm.fmuladd.f64(ir<%96>, ir<%91>, ir<%92>) (using vector intrinsic)
    WIDEN-CALL ir<%98> = call @llvm.fmuladd.f64(ir<%96>, ir<%97>, ir<%93>) (using vector intrinsic)
    WIDEN-CALL ir<%99> = call @llvm.fmuladd.f64(ir<%96>, ir<%98>, ir<%94>) (using vector intrinsic)
    CLONE ir<%arrayidx511> = getelementptr ir<%y>, ir<0>, ir<%indvars.iv.next1209>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx511>
    WIDEN store vp<%6>, ir<%99>, vp<%5>
  Successor(s): if.end512

  if.end512:
    EMIT vp<%7> = or vp<%5>, ir<%or.cond1194>
    CLONE ir<%tobool487.not> = icmp eq ir<%indvars.iv.next1209>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end514.loopexit>, scalar.ph

ir-bb<if.end514.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body488.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call484 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv1208 = phi %95, %indvars.iv.next1209, ir<-1>
    CLONE ir<%indvars.iv.next1209> = add ir<%indvars.iv1208>, ir<-1>
    CLONE ir<%arrayidx490> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next1209>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx490>
    WIDEN ir<%96> = load vp<%4>
    WIDEN ir<%cmp491> = fcmp ult ir<%96>, ir<0.000000e+00>
    WIDEN ir<%cmp495> = fcmp ugt ir<%96>, ir<1.000000e+00>
    WIDEN ir<%or.cond1194> = or ir<%cmp491>, ir<%cmp495>
  Successor(s): if.then496

  if.then496:
    EMIT vp<%5> = not ir<%or.cond1194>
    WIDEN-CALL ir<%97> = call @llvm.fmuladd.f64(ir<%96>, ir<%91>, ir<%92>) (using vector intrinsic)
    WIDEN-CALL ir<%98> = call @llvm.fmuladd.f64(ir<%96>, ir<%97>, ir<%93>) (using vector intrinsic)
    WIDEN-CALL ir<%99> = call @llvm.fmuladd.f64(ir<%96>, ir<%98>, ir<%94>) (using vector intrinsic)
    CLONE ir<%arrayidx511> = getelementptr ir<%y>, ir<0>, ir<%indvars.iv.next1209>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx511>
    WIDEN store vp<%6>, ir<%99>, vp<%5>
  Successor(s): if.end512

  if.end512:
    EMIT vp<%7> = or vp<%5>, ir<%or.cond1194>
    CLONE ir<%tobool487.not> = icmp eq ir<%indvars.iv.next1209>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end514.loopexit>, scalar.ph

ir-bb<if.end514.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1208 = phi i64 [ %95, %while.body488.lr.ph ], [ %indvars.iv.next1209, %if.end512 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1209 = add nsw i64 %indvars.iv1208, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx490 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next1209 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %96 = load double, ptr %arrayidx490, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp491 = fcmp ult double %96, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp495 = fcmp ugt double %96, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond1194 = or i1 %cmp491, %cmp495 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond1194, label %if.end512, label %if.then496 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %97 = call double @llvm.fmuladd.f64(double %96, double %91, double %92) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %98 = call double @llvm.fmuladd.f64(double %96, double %97, double %93) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %99 = call double @llvm.fmuladd.f64(double %96, double %98, double %94) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx511 = getelementptr inbounds [4 x double], ptr %y, i64 0, i64 %indvars.iv.next1209 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %99, ptr %arrayidx511, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end512 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool487.not = icmp eq i64 %indvars.iv.next1209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool487.not, label %if.end514.loopexit, label %while.body488 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1208 = phi i64 [ %95, %while.body488.lr.ph ], [ %indvars.iv.next1209, %if.end512 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1209 = add nsw i64 %indvars.iv1208, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx490 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next1209 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %96 = load double, ptr %arrayidx490, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp491 = fcmp ult double %96, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp495 = fcmp ugt double %96, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond1194 = or i1 %cmp491, %cmp495 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %or.cond1194, label %if.end512, label %if.then496 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %97 = call double @llvm.fmuladd.f64(double %96, double %91, double %92) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %98 = call double @llvm.fmuladd.f64(double %96, double %97, double %93) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %99 = call double @llvm.fmuladd.f64(double %96, double %98, double %94) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx511 = getelementptr inbounds [4 x double], ptr %y, i64 0, i64 %indvars.iv.next1209 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 9 for VF 2 For instruction:   store double %99, ptr %arrayidx511, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end512 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool487.not = icmp eq i64 %indvars.iv.next1209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool487.not, label %if.end514.loopexit, label %while.body488 of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1208 = phi i64 [ %95, %while.body488.lr.ph ], [ %indvars.iv.next1209, %if.end512 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1209 = add nsw i64 %indvars.iv1208, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx490 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next1209 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %96 = load double, ptr %arrayidx490, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp491 = fcmp ult double %96, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp495 = fcmp ugt double %96, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.cond1194 = or i1 %cmp491, %cmp495 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond1194, label %if.end512, label %if.then496 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %97 = call double @llvm.fmuladd.f64(double %96, double %91, double %92) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %98 = call double @llvm.fmuladd.f64(double %96, double %97, double %93) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %99 = call double @llvm.fmuladd.f64(double %96, double %98, double %94) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx511 = getelementptr inbounds [4 x double], ptr %y, i64 0, i64 %indvars.iv.next1209 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %99, ptr %arrayidx511, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end512 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool487.not = icmp eq i64 %indvars.iv.next1209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool487.not, label %if.end514.loopexit, label %while.body488 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1208 = phi i64 [ %95, %while.body488.lr.ph ], [ %indvars.iv.next1209, %if.end512 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1209 = add nsw i64 %indvars.iv1208, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx490 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next1209 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %96 = load double, ptr %arrayidx490, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp491 = fcmp ult double %96, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp495 = fcmp ugt double %96, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond1194 = or i1 %cmp491, %cmp495 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond1194, label %if.end512, label %if.then496 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %97 = call double @llvm.fmuladd.f64(double %96, double %91, double %92) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %98 = call double @llvm.fmuladd.f64(double %96, double %97, double %93) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %99 = call double @llvm.fmuladd.f64(double %96, double %98, double %94) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx511 = getelementptr inbounds [4 x double], ptr %y, i64 0, i64 %indvars.iv.next1209 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %99, ptr %arrayidx511, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end512 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool487.not = icmp eq i64 %indvars.iv.next1209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool487.not, label %if.end514.loopexit, label %while.body488 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d at line: prism.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body488.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call484 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%95> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next1209> = add vp<%5>, ir<-1>
    CLONE ir<%arrayidx490> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next1209>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx490>
    WIDEN ir<%96> = load vp<%6>
    WIDEN ir<%cmp491> = fcmp ult ir<%96>, ir<0.000000e+00>
    WIDEN ir<%cmp495> = fcmp ugt ir<%96>, ir<1.000000e+00>
    WIDEN ir<%or.cond1194> = or ir<%cmp491>, ir<%cmp495>
    EMIT vp<%7> = not ir<%or.cond1194>
    WIDEN-CALL ir<%97> = call @llvm.fmuladd.f64(ir<%96>, ir<%91>, ir<%92>) (using vector intrinsic)
    WIDEN-CALL ir<%98> = call @llvm.fmuladd.f64(ir<%96>, ir<%97>, ir<%93>) (using vector intrinsic)
    WIDEN-CALL ir<%99> = call @llvm.fmuladd.f64(ir<%96>, ir<%98>, ir<%94>) (using vector intrinsic)
    CLONE ir<%arrayidx511> = getelementptr ir<%y>, ir<0>, ir<%indvars.iv.next1209>
    vp<%8> = vector-pointer (reverse) ir<%arrayidx511>
    WIDEN store vp<%8>, ir<%99>, vp<%7>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end514.loopexit>, scalar.ph

ir-bb<if.end514.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2f64
@@ Instruction =>  %84 = load double, ptr %arrayidx452, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  store double %87, ptr %arrayidx472, align 8, !tbaa !20 -> Cost: 9 -> VectorType: <2 x double> -> ttilog -> MaskedMemoryOpCost(8)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  %84 = load double, ptr %arrayidx452, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %87, ptr %arrayidx472, align 8, !tbaa !20 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %84 = load double, ptr %arrayidx452, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %87, ptr %arrayidx472, align 8, !tbaa !20 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call450 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %83, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx452> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next>
    CLONE ir<%84> = load ir<%arrayidx452>
    CLONE ir<%cmp453> = fcmp ult ir<%84>, ir<0.000000e+00>
    CLONE ir<%cmp456> = fcmp ugt ir<%84>, ir<1.000000e+00>
    CLONE ir<%or.cond> = or ir<%cmp453>, ir<%cmp456>
  Successor(s): if.then457

  if.then457:
    EMIT vp<%4> = not ir<%or.cond>
    CLONE ir<%85> = call @llvm.fmuladd.f64(ir<%84>, ir<%79>, ir<%80>)
    CLONE ir<%86> = call @llvm.fmuladd.f64(ir<%84>, ir<%85>, ir<%81>)
    CLONE ir<%87> = call @llvm.fmuladd.f64(ir<%84>, ir<%86>, ir<%82>)
    CLONE ir<%arrayidx472> = getelementptr inbounds ir<%x>, ir<0>, ir<%indvars.iv.next>
    CLONE store ir<%87>, ir<%arrayidx472>, vp<%4>
  Successor(s): if.end473

  if.end473:
    EMIT vp<%5> = or vp<%4>, ir<%or.cond>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call450 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %83, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx452> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx452>
    WIDEN ir<%84> = load vp<%4>
    WIDEN ir<%cmp453> = fcmp ult ir<%84>, ir<0.000000e+00>
    WIDEN ir<%cmp456> = fcmp ugt ir<%84>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = or ir<%cmp453>, ir<%cmp456>
  Successor(s): if.then457

  if.then457:
    EMIT vp<%5> = not ir<%or.cond>
    WIDEN-CALL ir<%85> = call @llvm.fmuladd.f64(ir<%84>, ir<%79>, ir<%80>) (using vector intrinsic)
    WIDEN-CALL ir<%86> = call @llvm.fmuladd.f64(ir<%84>, ir<%85>, ir<%81>) (using vector intrinsic)
    WIDEN-CALL ir<%87> = call @llvm.fmuladd.f64(ir<%84>, ir<%86>, ir<%82>) (using vector intrinsic)
    CLONE ir<%arrayidx472> = getelementptr ir<%x>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx472>
    WIDEN store vp<%6>, ir<%87>, vp<%5>
  Successor(s): if.end473

  if.end473:
    EMIT vp<%7> = or vp<%5>, ir<%or.cond>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call450 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %83, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx452> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx452>
    WIDEN ir<%84> = load vp<%4>
    WIDEN ir<%cmp453> = fcmp ult ir<%84>, ir<0.000000e+00>
    WIDEN ir<%cmp456> = fcmp ugt ir<%84>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = or ir<%cmp453>, ir<%cmp456>
  Successor(s): if.then457

  if.then457:
    EMIT vp<%5> = not ir<%or.cond>
    WIDEN-CALL ir<%85> = call @llvm.fmuladd.f64(ir<%84>, ir<%79>, ir<%80>) (using vector intrinsic)
    WIDEN-CALL ir<%86> = call @llvm.fmuladd.f64(ir<%84>, ir<%85>, ir<%81>) (using vector intrinsic)
    WIDEN-CALL ir<%87> = call @llvm.fmuladd.f64(ir<%84>, ir<%86>, ir<%82>) (using vector intrinsic)
    CLONE ir<%arrayidx472> = getelementptr ir<%x>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx472>
    WIDEN store vp<%6>, ir<%87>, vp<%5>
  Successor(s): if.end473

  if.end473:
    EMIT vp<%7> = or vp<%5>, ir<%or.cond>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %83, %while.body.lr.ph ], [ %indvars.iv.next, %if.end473 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx452 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %84 = load double, ptr %arrayidx452, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp453 = fcmp ult double %84, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp456 = fcmp ugt double %84, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond = or i1 %cmp453, %cmp456 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond, label %if.end473, label %if.then457 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %85 = call double @llvm.fmuladd.f64(double %84, double %79, double %80) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %86 = call double @llvm.fmuladd.f64(double %84, double %85, double %81) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %87 = call double @llvm.fmuladd.f64(double %84, double %86, double %82) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx472 = getelementptr inbounds [4 x double], ptr %x, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %87, ptr %arrayidx472, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end473 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %83, %while.body.lr.ph ], [ %indvars.iv.next, %if.end473 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx452 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %84 = load double, ptr %arrayidx452, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp453 = fcmp ult double %84, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp456 = fcmp ugt double %84, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond = or i1 %cmp453, %cmp456 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %or.cond, label %if.end473, label %if.then457 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %85 = call double @llvm.fmuladd.f64(double %84, double %79, double %80) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %86 = call double @llvm.fmuladd.f64(double %84, double %85, double %81) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %87 = call double @llvm.fmuladd.f64(double %84, double %86, double %82) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx472 = getelementptr inbounds [4 x double], ptr %x, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 9 for VF 2 For instruction:   store double %87, ptr %arrayidx472, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end473 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 19
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 19, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %83, %while.body.lr.ph ], [ %indvars.iv.next, %if.end473 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx452 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %84 = load double, ptr %arrayidx452, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp453 = fcmp ult double %84, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp456 = fcmp ugt double %84, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.cond = or i1 %cmp453, %cmp456 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond, label %if.end473, label %if.then457 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %85 = call double @llvm.fmuladd.f64(double %84, double %79, double %80) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %86 = call double @llvm.fmuladd.f64(double %84, double %85, double %81) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %87 = call double @llvm.fmuladd.f64(double %84, double %86, double %82) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx472 = getelementptr inbounds [4 x double], ptr %x, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %87, ptr %arrayidx472, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end473 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %83, %while.body.lr.ph ], [ %indvars.iv.next, %if.end473 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx452 = getelementptr inbounds [2 x double], ptr %r, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %84 = load double, ptr %arrayidx452, align 8, !tbaa !20 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp453 = fcmp ult double %84, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp456 = fcmp ugt double %84, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond = or i1 %cmp453, %cmp456 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond, label %if.end473, label %if.then457 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %85 = call double @llvm.fmuladd.f64(double %84, double %79, double %80) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %86 = call double @llvm.fmuladd.f64(double %84, double %85, double %81) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %87 = call double @llvm.fmuladd.f64(double %84, double %86, double %82) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx472 = getelementptr inbounds [4 x double], ptr %x, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %87, ptr %arrayidx472, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end473 of type:br

-----------------Function that is being costed:'_ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov13Compute_PrismEPNS_12Prism_StructEPA2_d at line: prism.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call450 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%83> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add vp<%5>, ir<-1>
    CLONE ir<%arrayidx452> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx452>
    WIDEN ir<%84> = load vp<%6>
    WIDEN ir<%cmp453> = fcmp ult ir<%84>, ir<0.000000e+00>
    WIDEN ir<%cmp456> = fcmp ugt ir<%84>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = or ir<%cmp453>, ir<%cmp456>
    EMIT vp<%7> = not ir<%or.cond>
    WIDEN-CALL ir<%85> = call @llvm.fmuladd.f64(ir<%84>, ir<%79>, ir<%80>) (using vector intrinsic)
    WIDEN-CALL ir<%86> = call @llvm.fmuladd.f64(ir<%84>, ir<%85>, ir<%81>) (using vector intrinsic)
    WIDEN-CALL ir<%87> = call @llvm.fmuladd.f64(ir<%84>, ir<%86>, ir<%82>) (using vector intrinsic)
    CLONE ir<%arrayidx472> = getelementptr ir<%x>, ir<0>, ir<%indvars.iv.next>
    vp<%8> = vector-pointer (reverse) ir<%arrayidx472>
    WIDEN store vp<%8>, ir<%87>, vp<%7>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: v2f64
@@ Instruction =>  %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 -> Cost: 4 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 -> Cost: 4 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(2) = LT.first(2) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%NC.173> = phi ir<%NC.076>, ir<%NC.2>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next>
    CLONE ir<%10> = load ir<%arrayidx28>
    CLONE ir<%cmp29> = fcmp oge ir<%10>, ir<0.000000e+00>
    CLONE ir<%cmp31> = fcmp ole ir<%10>, ir<1.000000e+00>
    CLONE ir<%or.cond> = and ir<%cmp29>, ir<%cmp31>
  Successor(s): if.then32

  if.then32:
    CLONE ir<%11> = call @llvm.fmuladd.f64(ir<%10>, ir<%Entry.sroa.6.0.copyload>, ir<%Entry.sroa.8.0.copyload>)
    CLONE ir<%12> = call @llvm.fmuladd.f64(ir<%10>, ir<%11>, ir<%Entry.sroa.10.0.copyload>)
    CLONE ir<%13> = call @llvm.fmuladd.f64(ir<%10>, ir<%12>, ir<%Entry.sroa.12.0.copyload>)
    CLONE ir<%sub41> = fsub ir<%13>, ir<%u>
    CLONE ir<%cmp42> = fcmp ult ir<%sub41>, ir<0.000000e+00>
  Successor(s): if.then43

  if.then43:
    EMIT vp<%4> = not ir<%cmp42>
    EMIT vp<%5> = logical-and ir<%or.cond>, vp<%4>
    CLONE ir<%inc> = add ir<%NC.173>, ir<1>
  Successor(s): if.end44

  if.end44:
    EMIT vp<%6> = logical-and ir<%or.cond>, ir<%cmp42>
    EMIT vp<%7> = or vp<%6>, vp<%5>
    EMIT vp<%8> = not ir<%or.cond>
    EMIT vp<%9> = or vp<%7>, vp<%8>
    BLEND ir<%NC.2> = ir<%inc> ir<%NC.173>/vp<%6> ir<%NC.173>/vp<%8>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = compute-reduction-result ir<%NC.173>, ir<%NC.2>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<for.inc.loopexit>, scalar.ph

ir-bb<for.inc.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %NC.2.lcssa = vp<%12>
}

========== Loop: _ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%11>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%NC.173> = phi ir<%NC.076>, ir<%NC.2>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx28>
    WIDEN ir<%10> = load vp<%4>
    WIDEN ir<%cmp29> = fcmp oge ir<%10>, ir<0.000000e+00>
    WIDEN ir<%cmp31> = fcmp ole ir<%10>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = and ir<%cmp29>, ir<%cmp31>
  Successor(s): if.then32

  if.then32:
    WIDEN-CALL ir<%11> = call @llvm.fmuladd.f64(ir<%10>, ir<%Entry.sroa.6.0.copyload>, ir<%Entry.sroa.8.0.copyload>) (using vector intrinsic)
    WIDEN-CALL ir<%12> = call @llvm.fmuladd.f64(ir<%10>, ir<%11>, ir<%Entry.sroa.10.0.copyload>) (using vector intrinsic)
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%10>, ir<%12>, ir<%Entry.sroa.12.0.copyload>) (using vector intrinsic)
    WIDEN ir<%sub41> = fsub ir<%13>, ir<%u>
    WIDEN ir<%cmp42> = fcmp ult ir<%sub41>, ir<0.000000e+00>
  Successor(s): if.then43

  if.then43:
    EMIT vp<%5> = not ir<%cmp42>
    EMIT vp<%6> = logical-and ir<%or.cond>, vp<%5>
    WIDEN ir<%inc> = add ir<%NC.173>, ir<1>
  Successor(s): if.end44

  if.end44:
    EMIT vp<%7> = logical-and ir<%or.cond>, ir<%cmp42>
    EMIT vp<%8> = or vp<%7>, vp<%6>
    EMIT vp<%9> = not ir<%or.cond>
    EMIT vp<%10> = or vp<%8>, vp<%9>
    BLEND ir<%NC.2> = ir<%inc> ir<%NC.173>/vp<%7> ir<%NC.173>/vp<%9>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%11> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = compute-reduction-result ir<%NC.173>, ir<%NC.2>
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.inc.loopexit>, scalar.ph

ir-bb<for.inc.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %NC.2.lcssa = vp<%13>
}

========== Loop: _ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%11>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%NC.173> = phi ir<%NC.076>, ir<%NC.2>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx28>
    WIDEN ir<%10> = load vp<%4>
    WIDEN ir<%cmp29> = fcmp oge ir<%10>, ir<0.000000e+00>
    WIDEN ir<%cmp31> = fcmp ole ir<%10>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = and ir<%cmp29>, ir<%cmp31>
  Successor(s): if.then32

  if.then32:
    WIDEN-CALL ir<%11> = call @llvm.fmuladd.f64(ir<%10>, ir<%Entry.sroa.6.0.copyload>, ir<%Entry.sroa.8.0.copyload>) (using vector intrinsic)
    WIDEN-CALL ir<%12> = call @llvm.fmuladd.f64(ir<%10>, ir<%11>, ir<%Entry.sroa.10.0.copyload>) (using vector intrinsic)
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%10>, ir<%12>, ir<%Entry.sroa.12.0.copyload>) (using vector intrinsic)
    WIDEN ir<%sub41> = fsub ir<%13>, ir<%u>
    WIDEN ir<%cmp42> = fcmp ult ir<%sub41>, ir<0.000000e+00>
  Successor(s): if.then43

  if.then43:
    EMIT vp<%5> = not ir<%cmp42>
    EMIT vp<%6> = logical-and ir<%or.cond>, vp<%5>
    WIDEN ir<%inc> = add ir<%NC.173>, ir<1>
  Successor(s): if.end44

  if.end44:
    EMIT vp<%7> = logical-and ir<%or.cond>, ir<%cmp42>
    EMIT vp<%8> = or vp<%7>, vp<%6>
    EMIT vp<%9> = not ir<%or.cond>
    EMIT vp<%10> = or vp<%8>, vp<%9>
    BLEND ir<%NC.2> = ir<%inc> ir<%NC.173>/vp<%7> ir<%NC.173>/vp<%9>
    CLONE ir<%tobool.not> = icmp eq ir<%indvars.iv.next>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%11> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = compute-reduction-result ir<%NC.173>, ir<%NC.2>
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.inc.loopexit>, scalar.ph

ir-bb<for.inc.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %NC.2.lcssa = vp<%13>
}


-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %if.end44 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %NC.173 = phi i32 [ %NC.076, %while.body.preheader ], [ %NC.2, %if.end44 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx28 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp29 = fcmp oge double %10, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp31 = fcmp ole double %10, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond = and i1 %cmp29, %cmp31 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond, label %if.then32, label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %11 = call double @llvm.fmuladd.f64(double %10, double %Entry.sroa.6.0.copyload, double %Entry.sroa.8.0.copyload) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %12 = call double @llvm.fmuladd.f64(double %10, double %11, double %Entry.sroa.10.0.copyload) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %13 = call double @llvm.fmuladd.f64(double %10, double %12, double %Entry.sroa.12.0.copyload) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub41 = fsub double %13, %u of type:fsub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp42 = fcmp ult double %sub41, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp42, label %if.end44, label %if.then43 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %NC.173, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %NC.2 = phi i32 [ %inc, %if.then43 ], [ %NC.173, %if.then32 ], [ %NC.173, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %if.end44 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %NC.173 = phi i32 [ %NC.076, %while.body.preheader ], [ %NC.2, %if.end44 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx28 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp29 = fcmp oge double %10, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp31 = fcmp ole double %10, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond = and i1 %cmp29, %cmp31 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %or.cond, label %if.then32, label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %11 = call double @llvm.fmuladd.f64(double %10, double %Entry.sroa.6.0.copyload, double %Entry.sroa.8.0.copyload) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %12 = call double @llvm.fmuladd.f64(double %10, double %11, double %Entry.sroa.10.0.copyload) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %13 = call double @llvm.fmuladd.f64(double %10, double %12, double %Entry.sroa.12.0.copyload) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub41 = fsub double %13, %u of type:fsub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp42 = fcmp ult double %sub41, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp42, label %if.end44, label %if.then43 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %NC.173, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 12 for VF 2 For instruction:   %NC.2 = phi i32 [ %inc, %if.then43 ], [ %NC.173, %if.then32 ], [ %NC.173, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %if.end44 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %NC.173 = phi i32 [ %NC.076, %while.body.preheader ], [ %NC.2, %if.end44 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx28 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp29 = fcmp oge double %10, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp31 = fcmp ole double %10, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond = and i1 %cmp29, %cmp31 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %or.cond, label %if.then32, label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 4 for VF 4 For instruction:   %11 = call double @llvm.fmuladd.f64(double %10, double %Entry.sroa.6.0.copyload, double %Entry.sroa.8.0.copyload) of type:call
LV: Found an estimated cost of 4 for VF 4 For instruction:   %12 = call double @llvm.fmuladd.f64(double %10, double %11, double %Entry.sroa.10.0.copyload) of type:call
LV: Found an estimated cost of 4 for VF 4 For instruction:   %13 = call double @llvm.fmuladd.f64(double %10, double %12, double %Entry.sroa.12.0.copyload) of type:call
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub41 = fsub double %13, %u of type:fsub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp42 = fcmp ult double %sub41, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp42, label %if.end44, label %if.then43 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nsw i32 %NC.173, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 24 for VF 4 For instruction:   %NC.2 = phi i32 [ %inc, %if.then43 ], [ %NC.173, %if.then32 ], [ %NC.173, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 13
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 52
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 52, CostB * EstimatedWidthA: 36
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 52
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 52, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %if.end44 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %NC.173 = phi i32 [ %NC.076, %while.body.preheader ], [ %NC.2, %if.end44 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx28 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp29 = fcmp oge double %10, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp31 = fcmp ole double %10, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.cond = and i1 %cmp29, %cmp31 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond, label %if.then32, label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = call double @llvm.fmuladd.f64(double %10, double %Entry.sroa.6.0.copyload, double %Entry.sroa.8.0.copyload) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = call double @llvm.fmuladd.f64(double %10, double %11, double %Entry.sroa.10.0.copyload) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = call double @llvm.fmuladd.f64(double %10, double %12, double %Entry.sroa.12.0.copyload) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub41 = fsub double %13, %u of type:fsub
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp42 = fcmp ult double %sub41, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp42, label %if.end44, label %if.then43 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nsw i32 %NC.173, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %NC.2 = phi i32 [ %inc, %if.then43 ], [ %NC.173, %if.then32 ], [ %NC.173, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %if.end44 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %NC.173 = phi i32 [ %NC.076, %while.body.preheader ], [ %NC.2, %if.end44 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx28 = getelementptr inbounds [3 x double], ptr %y, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %10 = load double, ptr %arrayidx28, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp29 = fcmp oge double %10, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp31 = fcmp ole double %10, 1.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond = and i1 %cmp29, %cmp31 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond, label %if.then32, label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %11 = call double @llvm.fmuladd.f64(double %10, double %Entry.sroa.6.0.copyload, double %Entry.sroa.8.0.copyload) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %12 = call double @llvm.fmuladd.f64(double %10, double %11, double %Entry.sroa.10.0.copyload) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %13 = call double @llvm.fmuladd.f64(double %10, double %12, double %Entry.sroa.12.0.copyload) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub41 = fsub double %13, %u of type:fsub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp42 = fcmp ult double %sub41, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp42, label %if.end44, label %if.then43 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %NC.173, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end44 of type:br

-----------------Function that is being costed:'_ZN3povL8in_curveEPNS_12Prism_StructEdd' from prism.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %NC.2 = phi i32 [ %inc, %if.then43 ], [ %NC.173, %if.then32 ], [ %NC.173, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i64 %indvars.iv.next, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %for.inc.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 36
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 4.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL8in_curveEPNS_12Prism_StructEdd at line: prism.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-REDUCTION-PHI ir<%NC.173> = phi ir<%NC.076>, ir<%NC.2>
    vp<%4>    = DERIVED-IV ir<%9> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%y>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx28>
    WIDEN ir<%10> = load vp<%6>
    WIDEN ir<%cmp29> = fcmp oge ir<%10>, ir<0.000000e+00>
    WIDEN ir<%cmp31> = fcmp ole ir<%10>, ir<1.000000e+00>
    WIDEN ir<%or.cond> = and ir<%cmp29>, ir<%cmp31>
    WIDEN-CALL ir<%11> = call @llvm.fmuladd.f64(ir<%10>, ir<%Entry.sroa.6.0.copyload>, ir<%Entry.sroa.8.0.copyload>) (using vector intrinsic)
    WIDEN-CALL ir<%12> = call @llvm.fmuladd.f64(ir<%10>, ir<%11>, ir<%Entry.sroa.10.0.copyload>) (using vector intrinsic)
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%10>, ir<%12>, ir<%Entry.sroa.12.0.copyload>) (using vector intrinsic)
    WIDEN ir<%sub41> = fsub ir<%13>, ir<%u>
    WIDEN ir<%cmp42> = fcmp ult ir<%sub41>, ir<0.000000e+00>
    WIDEN ir<%inc> = add ir<%NC.173>, ir<1>
    EMIT vp<%7> = logical-and ir<%or.cond>, ir<%cmp42>
    EMIT vp<%8> = not ir<%or.cond>
    BLEND ir<%NC.2> = ir<%inc> ir<%NC.173>/vp<%7> ir<%NC.173>/vp<%8>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%NC.173>, ir<%NC.2>
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.inc.loopexit>, scalar.ph

ir-bb<for.inc.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %NC.2.lcssa = vp<%11>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o processoptions.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           processoptions.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o processrenderoptions.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           processrenderoptions.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o quadrics.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           quadrics.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o quatern.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           quatern.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o rad_data.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           rad_data.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o radiosit.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           radiosit.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ray.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           ray.cpp
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %3, ptr %arrayidx6, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %3, ptr %arrayidx6, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %3, ptr %arrayidx6, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov19Copy_Ray_ContainersEPNS_10Ray_StructES1_' from ray.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %1) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%Interiors4>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%3>, ir<%arrayidx6>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov19Copy_Ray_ContainersEPNS_10Ray_StructES1_' from ray.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %1) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%Interiors4>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%5>, ir<%3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov19Copy_Ray_ContainersEPNS_10Ray_StructES1_' from ray.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %1) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%Interiors4>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%5>, ir<%3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov19Copy_Ray_ContainersEPNS_10Ray_StructES1_' from ray.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load ptr, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx6 = getelementptr inbounds [100 x ptr], ptr %Interiors4, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %3, ptr %arrayidx6, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3pov19Copy_Ray_ContainersEPNS_10Ray_StructES1_' from ray.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load ptr, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx6 = getelementptr inbounds [100 x ptr], ptr %Interiors4, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %3, ptr %arrayidx6, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 12884901888
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov19Copy_Ray_ContainersEPNS_10Ray_StructES1_' from ray.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load ptr, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx6 = getelementptr inbounds [100 x ptr], ptr %Interiors4, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %3, ptr %arrayidx6, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901888
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967296

-----------------Function that is being costed:'_ZN3pov19Copy_Ray_ContainersEPNS_10Ray_StructES1_' from ray.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load ptr, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx6 = getelementptr inbounds [100 x ptr], ptr %Interiors4, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %3, ptr %arrayidx6, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483648, RTCostB: 12884901888
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483648, RTCostB: 4294967296
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov19Copy_Ray_ContainersEPNS_10Ray_StructES1_ at line: ray.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %1) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%7> = load vp<%5>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%Interiors4>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%6>, ir<%7>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 1
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %2 = load ptr, ptr %arrayidx, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %2, ptr %arrayidx3, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load ptr, ptr %arrayidx, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %2, ptr %arrayidx3, align 8, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %2 = load ptr, ptr %arrayidx, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %2, ptr %arrayidx3, align 8, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov8Ray_ExitEPNS_10Ray_StructEi' from ray.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %0 to i64) + (-1 * (sext i32 %nr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %1, %indvars.iv.next, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv.next>
    CLONE ir<%2> = load ir<%arrayidx>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%2>, ir<%arrayidx3>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov8Ray_ExitEPNS_10Ray_StructEi' from ray.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %0 to i64) + (-1 * (sext i32 %nr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %1, %indvars.iv.next, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%2>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov8Ray_ExitEPNS_10Ray_StructEi' from ray.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %0 to i64) + (-1 * (sext i32 %nr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %1, %indvars.iv.next, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%4>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%5>, ir<%2>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov8Ray_ExitEPNS_10Ray_StructEi' from ray.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load ptr, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %2, ptr %arrayidx3, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3pov8Ray_ExitEPNS_10Ray_StructEi' from ray.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load ptr, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %2, ptr %arrayidx3, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov8Ray_ExitEPNS_10Ray_StructEi' from ray.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load ptr, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %2, ptr %arrayidx3, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'_ZN3pov8Ray_ExitEPNS_10Ray_StructEi' from ray.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load ptr, ptr %arrayidx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3 = getelementptr inbounds [100 x ptr], ptr %Interiors, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %2, ptr %arrayidx3, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov8Ray_ExitEPNS_10Ray_StructEi at line: ray.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %0 to i64) + (-1 * (sext i32 %nr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%Interiors>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN ir<%2> = load vp<%6>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%Interiors>, ir<0>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx3>
    WIDEN store vp<%7>, ir<%2>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o rendctrl.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           rendctrl.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o render.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           render.cpp
========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond108.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %shl) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv402 = phi 1, %indvars.iv.next403, ir<1>
    CLONE ir<%arrayidx115> = getelementptr inbounds ir<%32>, ir<%indvars.iv402>
    CLONE store ir<0>, ir<%arrayidx115>
    CLONE ir<%indvars.iv.next403> = add nuw nsw ir<%indvars.iv402>, ir<1>
    CLONE ir<%exitcond407.not> = icmp eq ir<%indvars.iv.next403>, ir<%wide.trip.count411>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond108.for.inc120_crit_edge>, scalar.ph

ir-bb<for.cond108.for.inc120_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond108.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %shl) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv402 = phi 1, %indvars.iv.next403, ir<1>
    REPLICATE ir<%arrayidx115> = getelementptr inbounds ir<%32>, ir<%indvars.iv402>
    REPLICATE store ir<0>, ir<%arrayidx115>
    REPLICATE ir<%indvars.iv.next403> = add nuw nsw ir<%indvars.iv402>, ir<1>
    CLONE ir<%exitcond407.not> = icmp eq ir<%indvars.iv.next403>, ir<%wide.trip.count411>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond108.for.inc120_crit_edge>, scalar.ph

ir-bb<for.cond108.for.inc120_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond108.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %shl) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv402 = phi 1, %indvars.iv.next403, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx115> = getelementptr inbounds ir<%32>, ir<%indvars.iv402>
    REPLICATE store ir<0>, ir<%arrayidx115>
    WIDEN ir<%indvars.iv.next403> = add nuw nsw ir<%indvars.iv402>, ir<1>
    CLONE ir<%exitcond407.not> = icmp eq ir<%indvars.iv.next403>, ir<%wide.trip.count411>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond108.for.inc120_crit_edge>, scalar.ph

ir-bb<for.cond108.for.inc120_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond108.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %shl) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv402 = phi 1, %indvars.iv.next403, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx115> = getelementptr inbounds ir<%32>, ir<%indvars.iv402>
    WIDEN store ir<%arrayidx115>, ir<0>
    WIDEN ir<%indvars.iv.next403> = add nuw nsw ir<%indvars.iv402>, ir<1>
    CLONE ir<%exitcond407.not> = icmp eq ir<%indvars.iv.next403>, ir<%wide.trip.count411>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond108.for.inc120_crit_edge>, scalar.ph

ir-bb<for.cond108.for.inc120_crit_edge>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv402 = phi i64 [ 1, %for.cond108.preheader ], [ %indvars.iv.next403, %for.body111 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx115 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %32, i64 %indvars.iv402 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx115, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next403 = add nuw nsw i64 %indvars.iv402, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next403, %wide.trip.count411 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond407.not, label %for.cond108.for.inc120_crit_edge, label %for.body111 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv402 = phi i64 [ 1, %for.cond108.preheader ], [ %indvars.iv.next403, %for.body111 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx115 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %32, i64 %indvars.iv402 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 0, ptr %arrayidx115, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next403 = add nuw nsw i64 %indvars.iv402, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next403, %wide.trip.count411 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond407.not, label %for.cond108.for.inc120_crit_edge, label %for.body111 of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv402 = phi i64 [ 1, %for.cond108.preheader ], [ %indvars.iv.next403, %for.body111 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx115 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %32, i64 %indvars.iv402 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 0, ptr %arrayidx115, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next403 = add nuw nsw i64 %indvars.iv402, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next403, %wide.trip.count411 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond407.not, label %for.cond108.for.inc120_crit_edge, label %for.body111 of type:br
LV: Vector loop of width 4 costs: 4

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv402 = phi i64 [ 1, %for.cond108.preheader ], [ %indvars.iv.next403, %for.body111 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx115 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %32, i64 %indvars.iv402 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx115, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next403 = add nuw nsw i64 %indvars.iv402, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next403, %wide.trip.count411 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond407.not, label %for.cond108.for.inc120_crit_edge, label %for.body111 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv402 = phi i64 [ 1, %for.cond108.preheader ], [ %indvars.iv.next403, %for.body111 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx115 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %32, i64 %indvars.iv402 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx115, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next403 = add nuw nsw i64 %indvars.iv402, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next403, %wide.trip.count411 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond407.not, label %for.cond108.for.inc120_crit_edge, label %for.body111 of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 23085449185, RTCostB: 8589934588

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv402 = phi i64 [ 1, %for.cond108.preheader ], [ %indvars.iv.next403, %for.body111 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx115 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %32, i64 %indvars.iv402 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx115, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next403 = add nuw nsw i64 %indvars.iv402, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond407.not = icmp eq i64 %indvars.iv.next403, %wide.trip.count411 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond407.not, label %for.cond108.for.inc120_crit_edge, label %for.body111 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 22548578248, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 22548578248, RTCostB: 8589934588
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3pov22Start_Adaptive_TracingEv at line: render.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond108.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax %shl) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx115> = getelementptr inbounds ir<%32>, vp<%5>
    CLONE store ir<0>, ir<%arrayidx115>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond108.for.inc120_crit_edge>, scalar.ph

ir-bb<for.cond108.for.inc120_crit_edge>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (0 smax %shl) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv396 = phi %indvars.iv.next397, 0, ir<1>
    CLONE ir<%arrayidx90> = getelementptr inbounds ir<%call13>, ir<%indvars.iv396>
    CLONE ir<%25> = load ir<%arrayidx90>
    CLONE store ir<0>, ir<%25>
    CLONE ir<%indvars.iv.next397> = add nuw nsw ir<%indvars.iv396>, ir<1>
    CLONE ir<%exitcond401.not> = icmp eq ir<%indvars.iv.next397>, ir<%wide.trip.count400>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (0 smax %shl) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv396 = phi %indvars.iv.next397, 0, ir<1>
    CLONE ir<%arrayidx90> = getelementptr inbounds ir<%call13>, ir<%indvars.iv396>
    vp<%4> = vector-pointer ir<%arrayidx90>
    WIDEN ir<%25> = load vp<%4>
    REPLICATE store ir<0>, ir<%25>
    CLONE ir<%indvars.iv.next397> = add nuw nsw ir<%indvars.iv396>, ir<1>
    CLONE ir<%exitcond401.not> = icmp eq ir<%indvars.iv.next397>, ir<%wide.trip.count400>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (0 smax %shl) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv396 = phi %indvars.iv.next397, 0, ir<1>
    CLONE ir<%arrayidx90> = getelementptr inbounds ir<%call13>, ir<%indvars.iv396>
    vp<%4> = vector-pointer ir<%arrayidx90>
    WIDEN ir<%25> = load vp<%4>
    REPLICATE store ir<0>, ir<%25>
    CLONE ir<%indvars.iv.next397> = add nuw nsw ir<%indvars.iv396>, ir<1>
    CLONE ir<%exitcond401.not> = icmp eq ir<%indvars.iv.next397>, ir<%wide.trip.count400>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (0 smax %shl) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv396 = phi %indvars.iv.next397, 0, ir<1>
    CLONE ir<%arrayidx90> = getelementptr inbounds ir<%call13>, ir<%indvars.iv396>
    vp<%4> = vector-pointer ir<%arrayidx90>
    WIDEN ir<%25> = load vp<%4>
    WIDEN store ir<%25>, ir<0>
    CLONE ir<%indvars.iv.next397> = add nuw nsw ir<%indvars.iv396>, ir<1>
    CLONE ir<%exitcond401.not> = icmp eq ir<%indvars.iv.next397>, ir<%wide.trip.count400>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv396 = phi i64 [ %indvars.iv.next397, %for.body88 ], [ 0, %for.body88.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx90 = getelementptr inbounds ptr, ptr %call13, i64 %indvars.iv396 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %25, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond401.not = icmp eq i64 %indvars.iv.next397, %wide.trip.count400 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond401.not, label %for.end95.loopexit, label %for.body88 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv396 = phi i64 [ %indvars.iv.next397, %for.body88 ], [ 0, %for.body88.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx90 = getelementptr inbounds ptr, ptr %call13, i64 %indvars.iv396 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 0, ptr %25, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond401.not = icmp eq i64 %indvars.iv.next397, %wide.trip.count400 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond401.not, label %for.end95.loopexit, label %for.body88 of type:br
LV: Vector loop of width 2 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 31138512896, RTCostB: 12884901888
A is not scalable.	B is not scalable.	
RTCostA: 31138512896, RTCostB: 12884901888

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv396 = phi i64 [ %indvars.iv.next397, %for.body88 ], [ 0, %for.body88.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx90 = getelementptr inbounds ptr, ptr %call13, i64 %indvars.iv396 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 0, ptr %25, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond401.not = icmp eq i64 %indvars.iv.next397, %wide.trip.count400 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond401.not, label %for.end95.loopexit, label %for.body88 of type:br
LV: Vector loop of width 4 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 30064771072, RTCostB: 12884901888
A is not scalable.	B is not scalable.	
RTCostA: 30064771072, RTCostB: 12884901888

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv396 = phi i64 [ %indvars.iv.next397, %for.body88 ], [ 0, %for.body88.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx90 = getelementptr inbounds ptr, ptr %call13, i64 %indvars.iv396 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %25, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond401.not = icmp eq i64 %indvars.iv.next397, %wide.trip.count400 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond401.not, label %for.end95.loopexit, label %for.body88 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901888
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901888

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv396 = phi i64 [ %indvars.iv.next397, %for.body88 ], [ 0, %for.body88.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx90 = getelementptr inbounds ptr, ptr %call13, i64 %indvars.iv396 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %25 = load ptr, ptr %arrayidx90, align 8, !tbaa !29 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %25, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next397 = add nuw nsw i64 %indvars.iv396, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond401.not = icmp eq i64 %indvars.iv.next397, %wide.trip.count400 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond401.not, label %for.end95.loopexit, label %for.body88 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 23622320128, RTCostB: 12884901888
A is scalable.	B is not scalable.	
RTCostA: 23622320128, RTCostB: 12884901888
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3pov22Start_Adaptive_TracingEv at line: render.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body88.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (0 smax %shl) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx90> = getelementptr inbounds ir<%call13>, vp<%4>
    CLONE ir<%25> = load ir<%arrayidx90>
    CLONE store ir<0>, ir<%25>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %mul75336) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv391 = phi 0, %indvars.iv.next392, ir<1>
    CLONE ir<%arrayidx80> = getelementptr inbounds ir<%Last_Row.0370>, ir<%indvars.iv391>
    CLONE store ir<0>, ir<%arrayidx80>
    CLONE ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond395.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count394>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond85.preheader.loopexit>, scalar.ph

ir-bb<for.cond85.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %mul75336) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv391 = phi 0, %indvars.iv.next392, ir<1>
    REPLICATE ir<%arrayidx80> = getelementptr inbounds ir<%Last_Row.0370>, ir<%indvars.iv391>
    REPLICATE store ir<0>, ir<%arrayidx80>
    REPLICATE ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond395.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count394>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond85.preheader.loopexit>, scalar.ph

ir-bb<for.cond85.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %mul75336) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv391 = phi 0, %indvars.iv.next392, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx80> = getelementptr inbounds ir<%Last_Row.0370>, ir<%indvars.iv391>
    REPLICATE store ir<0>, ir<%arrayidx80>
    WIDEN ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond395.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count394>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond85.preheader.loopexit>, scalar.ph

ir-bb<for.cond85.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov22Start_Adaptive_TracingEv' from render.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %mul75336) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv391 = phi 0, %indvars.iv.next392, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx80> = getelementptr inbounds ir<%Last_Row.0370>, ir<%indvars.iv391>
    WIDEN store ir<%arrayidx80>, ir<0>
    WIDEN ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond395.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count394>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond85.preheader.loopexit>, scalar.ph

ir-bb<for.cond85.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv391 = phi i64 [ 0, %for.body78.preheader ], [ %indvars.iv.next392, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx80 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %Last_Row.0370, i64 %indvars.iv391 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %arrayidx80, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond395.not, label %for.cond85.preheader.loopexit, label %for.body78 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv391 = phi i64 [ 0, %for.body78.preheader ], [ %indvars.iv.next392, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx80 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %Last_Row.0370, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 0, ptr %arrayidx80, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond395.not, label %for.cond85.preheader.loopexit, label %for.body78 of type:br
LV: Vector loop of width 2 costs: 5

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv391 = phi i64 [ 0, %for.body78.preheader ], [ %indvars.iv.next392, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx80 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %Last_Row.0370, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 0, ptr %arrayidx80, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond395.not, label %for.cond85.preheader.loopexit, label %for.body78 of type:br
LV: Vector loop of width 4 costs: 4

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv391 = phi i64 [ 0, %for.body78.preheader ], [ %indvars.iv.next392, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx80 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %Last_Row.0370, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx80, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond395.not, label %for.cond85.preheader.loopexit, label %for.body78 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934592
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934592

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv391 = phi i64 [ 0, %for.body78.preheader ], [ %indvars.iv.next392, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx80 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %Last_Row.0370, i64 %indvars.iv391 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx80, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond395.not, label %for.cond85.preheader.loopexit, label %for.body78 of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 23085449216, RTCostB: 8589934592
A is scalable.	B is not scalable.	
RTCostA: 23085449216, RTCostB: 8589934592

-----------------Function that is being costed:'_ZN3pov22Start_Adaptive_TracingEv' from render.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv391 = phi i64 [ 0, %for.body78.preheader ], [ %indvars.iv.next392, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx80 = getelementptr inbounds %"struct.pov::Pixel_Struct", ptr %Last_Row.0370, i64 %indvars.iv391 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx80, align 4, !tbaa !30 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond395.not, label %for.cond85.preheader.loopexit, label %for.body78 of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 22548578304, RTCostB: 8589934592
A is scalable.	B is not scalable.	
RTCostA: 22548578304, RTCostB: 8589934592
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3pov22Start_Adaptive_TracingEv at line: render.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %mul75336) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx80> = getelementptr inbounds ir<%Last_Row.0370>, vp<%4>
    CLONE store ir<0>, ir<%arrayidx80>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond85.preheader.loopexit>, scalar.ph

ir-bb<for.cond85.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 24
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o renderfrontend.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           renderfrontend.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o renderio.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           renderio.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sor.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           sor.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o specrand.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           specrand.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spec_qsort.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spec_qsort.cpp
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load i8, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %1, ptr %a.05, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %0, ptr %b.06, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %l.addr.07 = phi %dec, %l, ir<-1>
    EMIT ir<%b.06> = WIDEN-POINTER-INDUCTION ir<%y>, 1
    EMIT ir<%a.05> = WIDEN-POINTER-INDUCTION ir<%x>, 1
    CLONE ir<%dec> = add ir<%l.addr.07>, ir<-1>
    CLONE ir<%0> = load ir<%a.05>
    CLONE ir<%1> = load ir<%b.06>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%a.05>, ir<1>
    CLONE store ir<%1>, ir<%a.05>
    CLONE ir<%incdec.ptr1> = getelementptr inbounds ir<%b.06>, ir<1>
    CLONE store ir<%0>, ir<%b.06>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %l.addr.07 = phi %dec, %l, ir<-1>
    EMIT ir<%b.06> = WIDEN-POINTER-INDUCTION ir<%y>, 1
    EMIT ir<%a.05> = WIDEN-POINTER-INDUCTION ir<%x>, 1
    CLONE ir<%dec> = add ir<%l.addr.07>, ir<-1>
    vp<%3> = vector-pointer ir<%a.05>
    WIDEN ir<%0> = load vp<%3>
    vp<%4> = vector-pointer ir<%b.06>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%a.05>, ir<1>
    vp<%5> = vector-pointer ir<%a.05>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%incdec.ptr1> = getelementptr inbounds ir<%b.06>, ir<1>
    vp<%6> = vector-pointer ir<%b.06>
    WIDEN store vp<%6>, ir<%0>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %l.addr.07 = phi %dec, %l, ir<-1>
    EMIT ir<%b.06> = WIDEN-POINTER-INDUCTION ir<%y>, 1
    EMIT ir<%a.05> = WIDEN-POINTER-INDUCTION ir<%x>, 1
    CLONE ir<%dec> = add ir<%l.addr.07>, ir<-1>
    vp<%3> = vector-pointer ir<%a.05>
    WIDEN ir<%0> = load vp<%3>
    vp<%4> = vector-pointer ir<%b.06>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%a.05>, ir<1>
    vp<%5> = vector-pointer ir<%a.05>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%incdec.ptr1> = getelementptr inbounds ir<%b.06>, ir<1>
    vp<%6> = vector-pointer ir<%b.06>
    WIDEN store vp<%6>, ir<%0>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 40
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'_ZN3povL9spec_swapEPvS0_m' from spec_qsort.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %l.addr.07 = phi i64 [ %dec, %while.body ], [ %l, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %b.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %y, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %a.05 = phi ptr [ %incdec.ptr, %while.body ], [ %x, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add i64 %l.addr.07, -1 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %0 = load i8, ptr %a.05, align 1, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %1 = load i8, ptr %b.06, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %a.05, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %1, ptr %a.05, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr1 = getelementptr inbounds i8, ptr %b.06, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %0, ptr %b.06, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool.not = icmp eq i64 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 320
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 72
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 80
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 96
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: _ZN3povL9spec_swapEPvS0_m at line: spec_qsort.cpp
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: _ZN3povL9spec_swapEPvS0_m at line: spec_qsort.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%y>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%x>, vp<%5>
    vp<%7> = vector-pointer vp<%6>
    WIDEN ir<%0> = load vp<%7>
    vp<%8> = vector-pointer vp<%4>
    WIDEN ir<%1> = load vp<%8>
    vp<%9> = vector-pointer vp<%6>
    WIDEN store vp<%9>, ir<%1>
    vp<%10> = vector-pointer vp<%4>
    WIDEN store vp<%10>, ir<%0>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: _ZN3povL9spec_swapEPvS0_m at line: spec_qsort.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%l> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%11>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%4> = ptradd ir<%y>, vp<%3>
    vp<%5> = SCALAR-STEPS vp<%2>, ir<1>
    EMIT vp<%6> = ptradd ir<%x>, vp<%5>
    vp<%7> = vector-pointer vp<%6>
    WIDEN ir<%35> = load vp<%7>
    vp<%8> = vector-pointer vp<%4>
    WIDEN ir<%36> = load vp<%8>
    vp<%9> = vector-pointer vp<%6>
    WIDEN store vp<%9>, ir<%36>
    vp<%10> = vector-pointer vp<%4>
    WIDEN store vp<%10>, ir<%35>
    EMIT vp<%11> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq ir<%l>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spheres.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spheres.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o sphsweep.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           sphsweep.cpp
@@ Instruction =>  %322 = load double, ptr %arrayidx601, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %322, ptr %arrayidx603, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %322 = load double, ptr %arrayidx601, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %322, ptr %arrayidx603, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %322 = load double, ptr %arrayidx601, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %322, ptr %arrayidx603, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov30Intersect_Sphere_Sweep_SegmentEPNS_10Ray_StructEPNS_27Sphere_Sweep_Segment_StructEPNS_35Sphere_Sweep_Intersection_StructureE' from sphsweep.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 (-1 + %Num_Poly_Roots.11138) to i64) + (-1 * (sext i32 %m.01139 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %idxprom590, %indvars.iv.next, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx601> = getelementptr inbounds ir<%Root>, ir<0>, ir<%indvars.iv.next>
    CLONE ir<%322> = load ir<%arrayidx601>
    CLONE ir<%arrayidx603> = getelementptr inbounds ir<%Root>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%322>, ir<%arrayidx603>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end606.loopexit>, scalar.ph

ir-bb<if.end606.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov30Intersect_Sphere_Sweep_SegmentEPNS_10Ray_StructEPNS_27Sphere_Sweep_Segment_StructEPNS_35Sphere_Sweep_Intersection_StructureE' from sphsweep.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 (-1 + %Num_Poly_Roots.11138) to i64) + (-1 * (sext i32 %m.01139 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %idxprom590, %indvars.iv.next, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx601> = getelementptr inbounds ir<%Root>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx601>
    WIDEN ir<%322> = load vp<%4>
    CLONE ir<%arrayidx603> = getelementptr inbounds ir<%Root>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx603>
    WIDEN store vp<%5>, ir<%322>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end606.loopexit>, scalar.ph

ir-bb<if.end606.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov30Intersect_Sphere_Sweep_SegmentEPNS_10Ray_StructEPNS_27Sphere_Sweep_Segment_StructEPNS_35Sphere_Sweep_Intersection_StructureE' from sphsweep.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 (-1 + %Num_Poly_Roots.11138) to i64) + (-1 * (sext i32 %m.01139 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %idxprom590, %indvars.iv.next, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx601> = getelementptr inbounds ir<%Root>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx601>
    WIDEN ir<%322> = load vp<%4>
    CLONE ir<%arrayidx603> = getelementptr inbounds ir<%Root>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx603>
    WIDEN store vp<%5>, ir<%322>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end606.loopexit>, scalar.ph

ir-bb<if.end606.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov30Intersect_Sphere_Sweep_SegmentEPNS_10Ray_StructEPNS_27Sphere_Sweep_Segment_StructEPNS_35Sphere_Sweep_Intersection_StructureE' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %idxprom590, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx601 = getelementptr inbounds [10 x double], ptr %Root, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %322 = load double, ptr %arrayidx601, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx603 = getelementptr inbounds [10 x double], ptr %Root, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %322, ptr %arrayidx603, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end606.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3pov30Intersect_Sphere_Sweep_SegmentEPNS_10Ray_StructEPNS_27Sphere_Sweep_Segment_StructEPNS_35Sphere_Sweep_Intersection_StructureE' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %idxprom590, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx601 = getelementptr inbounds [10 x double], ptr %Root, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %322 = load double, ptr %arrayidx601, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx603 = getelementptr inbounds [10 x double], ptr %Root, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %322, ptr %arrayidx603, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end606.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov30Intersect_Sphere_Sweep_SegmentEPNS_10Ray_StructEPNS_27Sphere_Sweep_Segment_StructEPNS_35Sphere_Sweep_Intersection_StructureE' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %idxprom590, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx601 = getelementptr inbounds [10 x double], ptr %Root, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %322 = load double, ptr %arrayidx601, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx603 = getelementptr inbounds [10 x double], ptr %Root, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %322, ptr %arrayidx603, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end606.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'_ZN3pov30Intersect_Sphere_Sweep_SegmentEPNS_10Ray_StructEPNS_27Sphere_Sweep_Segment_StructEPNS_35Sphere_Sweep_Intersection_StructureE' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %idxprom590, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx601 = getelementptr inbounds [10 x double], ptr %Root, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %322 = load double, ptr %arrayidx601, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx603 = getelementptr inbounds [10 x double], ptr %Root, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %322, ptr %arrayidx603, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end606.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3pov30Intersect_Sphere_Sweep_SegmentEPNS_10Ray_StructEPNS_27Sphere_Sweep_Segment_StructEPNS_35Sphere_Sweep_Intersection_StructureE at line: sphsweep.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 (-1 + %Num_Poly_Roots.11138) to i64) + (-1 * (sext i32 %m.01139 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%idxprom590> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx601> = getelementptr inbounds ir<%Root>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer ir<%arrayidx601>
    WIDEN ir<%322> = load vp<%6>
    CLONE ir<%arrayidx603> = getelementptr inbounds ir<%Root>, ir<0>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx603>
    WIDEN store vp<%7>, ir<%322>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end606.loopexit>, scalar.ph

ir-bb<if.end606.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx7, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx7, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx7, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store double %mul, ptr %arrayidx7, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %arrayidx7, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %degree) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%Coef>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx3>
    CLONE ir<%arrayidx5> = getelementptr inbounds ir<%arrayidx>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx5>
    CLONE ir<%conv> = sitofp ir<%4>
    CLONE ir<%mul> = fmul ir<%3>, ir<%conv>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%mul>, ir<%arrayidx7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond8.preheader>, scalar.ph

ir-bb<for.cond8.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %degree) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%Coef>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx3>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx5> = getelementptr inbounds ir<%arrayidx>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx5>
    WIDEN ir<%4> = load vp<%5>
    WIDEN-CAST ir<%conv> = sitofp  ir<%4> to double
    WIDEN ir<%mul> = fmul ir<%3>, ir<%conv>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx7>
    WIDEN store vp<%6>, ir<%mul>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond8.preheader>, scalar.ph

ir-bb<for.cond8.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %degree) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%Coef>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx3>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx5> = getelementptr inbounds ir<%arrayidx>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx5>
    WIDEN ir<%4> = load vp<%5>
    WIDEN-CAST ir<%conv> = sitofp  ir<%4> to double
    WIDEN ir<%mul> = fmul ir<%3>, ir<%conv>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx7>
    WIDEN store vp<%6>, ir<%mul>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond8.preheader>, scalar.ph

ir-bb<for.cond8.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3 = getelementptr inbounds double, ptr %Coef, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx5 = getelementptr inbounds i32, ptr %arrayidx, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv = sitofp i32 %4 to double of type:sitofp
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul double %3, %conv of type:fmul
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx7 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul, ptr %arrayidx7, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond8.preheader, label %for.body of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'_ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3 = getelementptr inbounds double, ptr %Coef, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx5 = getelementptr inbounds i32, ptr %arrayidx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv = sitofp i32 %4 to double of type:sitofp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul double %3, %conv of type:fmul
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx7 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %mul, ptr %arrayidx7, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond8.preheader, label %for.body of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676416, RTCostB: 23622320128
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676416, RTCostB: 23622320128
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3 = getelementptr inbounds double, ptr %Coef, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx5 = getelementptr inbounds i32, ptr %arrayidx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 4 for VF 4 For instruction:   %conv = sitofp i32 %4 to double of type:sitofp
LV: Found an estimated cost of 4 for VF 4 For instruction:   %mul = fmul double %3, %conv of type:fmul
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx7 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store double %mul, ptr %arrayidx7, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond8.preheader, label %for.body of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 8053063680, RTCostB: 23622320128
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8053063680, RTCostB: 9663676416
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3 = getelementptr inbounds double, ptr %Coef, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx5 = getelementptr inbounds i32, ptr %arrayidx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv = sitofp i32 %4 to double of type:sitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul double %3, %conv of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx7 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul, ptr %arrayidx7, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond8.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 23622320128
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8053063680

-----------------Function that is being costed:'_ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3 = getelementptr inbounds double, ptr %Coef, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load double, ptr %arrayidx3, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx5 = getelementptr inbounds i32, ptr %arrayidx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load i32, ptr %arrayidx5, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv = sitofp i32 %4 to double of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul double %3, %conv of type:fmul
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx7 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %mul, ptr %arrayidx7, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond8.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 23622320128
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8053063680
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL9bezier_01EiPdS0_bd at line: sphsweep.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + %degree) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%Coef>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx3>
    WIDEN ir<%3> = load vp<%5>
    CLONE ir<%arrayidx5> = getelementptr inbounds ir<%arrayidx>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx5>
    WIDEN ir<%4> = load vp<%6>
    WIDEN-CAST ir<%conv> = sitofp  ir<%4> to double
    WIDEN ir<%mul> = fmul ir<%3>, ir<%conv>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%d>, ir<0>, vp<%4>
    vp<%7> = vector-pointer ir<%arrayidx7>
    WIDEN store vp<%7>, ir<%mul>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond8.preheader>, scalar.ph

ir-bb<for.cond8.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %47 = load double, ptr %arrayidx32, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %add35, ptr %arrayidx34, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load double, ptr %arrayidx32, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %add35, ptr %arrayidx34, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %47 = load double, ptr %arrayidx32, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %add35, ptr %arrayidx34, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body30.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {%degree,+,-1}<nw><%for.body10> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    FIRST-ORDER-RECURRENCE-PHI ir<%46> = phi ir<%.pre>, ir<%47>
    WIDEN-INDUCTION %indvars.iv77 = phi 0, %indvars.iv.next78, ir<1>
    CLONE ir<%indvars.iv.next78> = add nuw nsw ir<%indvars.iv77>, ir<1>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv.next78>
    CLONE ir<%47> = load ir<%arrayidx32>
    EMIT vp<%4> = first-order splice ir<%46>, ir<%47>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv77>
    CLONE ir<%add35> = fadd ir<%47>, vp<%4>
    CLONE store ir<%add35>, ir<%arrayidx34>
    CLONE ir<%exitcond83.not> = icmp eq ir<%indvars.iv.next78>, ir<%wide.trip.count82>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = extract-from-end ir<%47>, ir<1>
  EMIT vp<%8> = extract-from-end ir<%47>, ir<2>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.inc39.loopexit>, scalar.ph

ir-bb<for.inc39.loopexit>:
No successors

scalar.ph:
  EMIT vp<%11> = resume-phi vp<%7>, ir<%.pre>
No successors

Live-out double %46 = vp<%11>
}

========== Loop: _ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body30.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {%degree,+,-1}<nw><%for.body10> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    FIRST-ORDER-RECURRENCE-PHI ir<%46> = phi ir<%.pre>, ir<%47>
    WIDEN-INDUCTION %indvars.iv77 = phi 0, %indvars.iv.next78, ir<1>
    CLONE ir<%indvars.iv.next78> = add nuw nsw ir<%indvars.iv77>, ir<1>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv.next78>
    vp<%4> = vector-pointer ir<%arrayidx32>
    WIDEN ir<%47> = load vp<%4>
    EMIT vp<%5> = first-order splice ir<%46>, ir<%47>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv77>
    WIDEN ir<%add35> = fadd ir<%47>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx34>
    WIDEN store vp<%6>, ir<%add35>
    CLONE ir<%exitcond83.not> = icmp eq ir<%indvars.iv.next78>, ir<%wide.trip.count82>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = extract-from-end ir<%47>, ir<1>
  EMIT vp<%10> = extract-from-end ir<%47>, ir<2>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.inc39.loopexit>, scalar.ph

ir-bb<for.inc39.loopexit>:
No successors

scalar.ph:
  EMIT vp<%13> = resume-phi vp<%9>, ir<%.pre>
No successors

Live-out double %46 = vp<%13>
}

========== Loop: _ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body30.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {%degree,+,-1}<nw><%for.body10> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    FIRST-ORDER-RECURRENCE-PHI ir<%46> = phi ir<%.pre>, ir<%47>
    WIDEN-INDUCTION %indvars.iv77 = phi 0, %indvars.iv.next78, ir<1>
    CLONE ir<%indvars.iv.next78> = add nuw nsw ir<%indvars.iv77>, ir<1>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv.next78>
    vp<%4> = vector-pointer ir<%arrayidx32>
    WIDEN ir<%47> = load vp<%4>
    EMIT vp<%5> = first-order splice ir<%46>, ir<%47>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv77>
    WIDEN ir<%add35> = fadd ir<%47>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx34>
    WIDEN store vp<%6>, ir<%add35>
    CLONE ir<%exitcond83.not> = icmp eq ir<%indvars.iv.next78>, ir<%wide.trip.count82>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = extract-from-end ir<%47>, ir<1>
  EMIT vp<%10> = extract-from-end ir<%47>, ir<2>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.inc39.loopexit>, scalar.ph

ir-bb<for.inc39.loopexit>:
No successors

scalar.ph:
  EMIT vp<%13> = resume-phi vp<%9>, ir<%.pre>
No successors

Live-out double %46 = vp<%13>
}


-----------------Function that is being costed:'_ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %46 = phi double [ %.pre, %for.body30.preheader ], [ %47, %for.body30 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv77 = phi i64 [ 0, %for.body30.preheader ], [ %indvars.iv.next78, %for.body30 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next78 = add nuw nsw i64 %indvars.iv77, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx32 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv.next78 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %47 = load double, ptr %arrayidx32, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx34 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add35 = fadd double %47, %46 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %add35, ptr %arrayidx34, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond83.not = icmp eq i64 %indvars.iv.next78, %wide.trip.count82 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond83.not, label %for.inc39.loopexit, label %for.body30 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %46 = phi double [ %.pre, %for.body30.preheader ], [ %47, %for.body30 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv77 = phi i64 [ 0, %for.body30.preheader ], [ %indvars.iv.next78, %for.body30 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next78 = add nuw nsw i64 %indvars.iv77, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx32 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv.next78 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %47 = load double, ptr %arrayidx32, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx34 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add35 = fadd double %47, %46 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %add35, ptr %arrayidx34, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond83.not = icmp eq i64 %indvars.iv.next78, %wide.trip.count82 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond83.not, label %for.inc39.loopexit, label %for.body30 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %46 = phi double [ %.pre, %for.body30.preheader ], [ %47, %for.body30 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv77 = phi i64 [ 0, %for.body30.preheader ], [ %indvars.iv.next78, %for.body30 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next78 = add nuw nsw i64 %indvars.iv77, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx32 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv.next78 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %47 = load double, ptr %arrayidx32, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx34 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add35 = fadd double %47, %46 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %add35, ptr %arrayidx34, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond83.not = icmp eq i64 %indvars.iv.next78, %wide.trip.count82 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond83.not, label %for.inc39.loopexit, label %for.body30 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'_ZN3povL9bezier_01EiPdS0_bd' from sphsweep.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %46 = phi double [ %.pre, %for.body30.preheader ], [ %47, %for.body30 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv77 = phi i64 [ 0, %for.body30.preheader ], [ %indvars.iv.next78, %for.body30 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next78 = add nuw nsw i64 %indvars.iv77, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx32 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv.next78 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %47 = load double, ptr %arrayidx32, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx34 = getelementptr inbounds [11 x double], ptr %d, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add35 = fadd double %47, %46 of type:fadd
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %add35, ptr %arrayidx34, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond83.not = icmp eq i64 %indvars.iv.next78, %wide.trip.count82 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond83.not, label %for.inc39.loopexit, label %for.body30 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL9bezier_01EiPdS0_bd at line: sphsweep.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body30.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 {%degree,+,-1}<nw><%for.body10> to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    FIRST-ORDER-RECURRENCE-PHI ir<%46> = phi ir<%.pre>, ir<%47>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%indvars.iv.next78> = add nuw nsw vp<%4>, ir<1>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%d>, ir<0>, ir<%indvars.iv.next78>
    vp<%5> = vector-pointer ir<%arrayidx32>
    WIDEN ir<%47> = load vp<%5>
    EMIT vp<%6> = first-order splice ir<%46>, ir<%47>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%d>, ir<0>, vp<%4>
    WIDEN ir<%add35> = fadd ir<%47>, vp<%6>
    vp<%7> = vector-pointer ir<%arrayidx34>
    WIDEN store vp<%7>, ir<%add35>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = extract-from-end ir<%47>, ir<1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.inc39.loopexit>, scalar.ph

ir-bb<for.inc39.loopexit>:
No successors

scalar.ph:
  EMIT vp<%13> = resume-phi vp<%10>, ir<%.pre>
No successors

Live-out double %46 = vp<%13>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o splines.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           splines.cpp
@@ Instruction =>  store double %sub21, ptr %arrayidx23, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %div, ptr %arrayidx40, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %sub21, ptr %arrayidx23, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %div, ptr %arrayidx40, align 8, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %sub21, ptr %arrayidx23, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %div, ptr %arrayidx40, align 8, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov23Precompute_Cubic_CoeffsEPNS_13Spline_StructE' from splines.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (-1 + %4) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv.next>
    CLONE ir<%10> = load ir<%arrayidx>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    CLONE ir<%11> = load ir<%arrayidx19>
    CLONE ir<%sub21> = fsub ir<%10>, ir<%11>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<%sub21>, ir<%arrayidx23>
    CLONE ir<%arrayidx29> = getelementptr inbounds ir<%5>, ir<%indvars.iv.next>, ir<1>, ir<%indvars.iv240>
    CLONE ir<%12> = load ir<%arrayidx29>
    CLONE ir<%arrayidx35> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<1>, ir<%indvars.iv240>
    CLONE ir<%13> = load ir<%arrayidx35>
    CLONE ir<%sub36> = fsub ir<%12>, ir<%13>
    CLONE ir<%div> = fdiv ir<%sub36>, ir<%sub21>
    CLONE ir<%arrayidx40> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    CLONE store ir<%div>, ir<%arrayidx40>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov23Precompute_Cubic_CoeffsEPNS_13Spline_StructE' from splines.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (-1 + %4) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv.next>
    REPLICATE ir<%10> = load ir<%arrayidx>
    REPLICATE ir<%arrayidx19> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    REPLICATE ir<%11> = load ir<%arrayidx19>
    WIDEN ir<%sub21> = fsub ir<%10>, ir<%11>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%4>, ir<%sub21>
    REPLICATE ir<%arrayidx29> = getelementptr inbounds ir<%5>, ir<%indvars.iv.next>, ir<1>, ir<%indvars.iv240>
    REPLICATE ir<%12> = load ir<%arrayidx29>
    REPLICATE ir<%arrayidx35> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<1>, ir<%indvars.iv240>
    REPLICATE ir<%13> = load ir<%arrayidx35>
    WIDEN ir<%sub36> = fsub ir<%12>, ir<%13>
    WIDEN ir<%div> = fdiv ir<%sub36>, ir<%sub21>
    CLONE ir<%arrayidx40> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx40>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov23Precompute_Cubic_CoeffsEPNS_13Spline_StructE' from splines.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (-1 + %4) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv.next>
    REPLICATE ir<%10> = load ir<%arrayidx>
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    REPLICATE ir<%11> = load ir<%arrayidx19>
    WIDEN ir<%sub21> = fsub ir<%10>, ir<%11>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%4>, ir<%sub21>
    WIDEN-GEP Inv[Var][Inv][Inv] ir<%arrayidx29> = getelementptr inbounds ir<%5>, ir<%indvars.iv.next>, ir<1>, ir<%indvars.iv240>
    REPLICATE ir<%12> = load ir<%arrayidx29>
    WIDEN-GEP Inv[Var][Inv][Inv] ir<%arrayidx35> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<1>, ir<%indvars.iv240>
    REPLICATE ir<%13> = load ir<%arrayidx35>
    WIDEN ir<%sub36> = fsub ir<%12>, ir<%13>
    WIDEN ir<%div> = fdiv ir<%sub36>, ir<%sub21>
    CLONE ir<%arrayidx40> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx40>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov23Precompute_Cubic_CoeffsEPNS_13Spline_StructE' from splines.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (-1 + %4) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv.next>
    WIDEN ir<%10> = load ir<%arrayidx>
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    WIDEN ir<%11> = load ir<%arrayidx19>
    WIDEN ir<%sub21> = fsub ir<%10>, ir<%11>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%4>, ir<%sub21>
    WIDEN-GEP Inv[Var][Inv][Inv] ir<%arrayidx29> = getelementptr inbounds ir<%5>, ir<%indvars.iv.next>, ir<1>, ir<%indvars.iv240>
    WIDEN ir<%12> = load ir<%arrayidx29>
    WIDEN-GEP Inv[Var][Inv][Inv] ir<%arrayidx35> = getelementptr inbounds ir<%5>, ir<%indvars.iv>, ir<1>, ir<%indvars.iv240>
    WIDEN ir<%13> = load ir<%arrayidx35>
    WIDEN ir<%sub36> = fsub ir<%12>, ir<%13>
    WIDEN ir<%div> = fdiv ir<%sub36>, ir<%sub21>
    CLONE ir<%arrayidx40> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx40>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov23Precompute_Cubic_CoeffsEPNS_13Spline_StructE' from splines.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body16 ], [ 0, %for.body16.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load double, ptr %arrayidx, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub21 = fsub double %10, %11 of type:fsub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23 = getelementptr inbounds double, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %sub21, ptr %arrayidx23, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx29 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv.next, i32 1, i64 %indvars.iv240 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load double, ptr %arrayidx29, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx35 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv, i32 1, i64 %indvars.iv240 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %13 = load double, ptr %arrayidx35, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub36 = fsub double %12, %13 of type:fsub
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv double %sub36, %sub21 of type:fdiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx40 = getelementptr inbounds double, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div, ptr %arrayidx40, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body16 of type:br
LV: Scalar loop costs: 18.
-----------------Function that is being costed:'_ZN3pov23Precompute_Cubic_CoeffsEPNS_13Spline_StructE' from splines.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body16 ], [ 0, %for.body16.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %10 = load double, ptr %arrayidx, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub21 = fsub double %10, %11 of type:fsub
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23 = getelementptr inbounds double, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %sub21, ptr %arrayidx23, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx29 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv.next, i32 1, i64 %indvars.iv240 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %12 = load double, ptr %arrayidx29, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx35 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv, i32 1, i64 %indvars.iv240 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %13 = load double, ptr %arrayidx35, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub36 = fsub double %12, %13 of type:fsub
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv double %sub36, %sub21 of type:fdiv
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx40 = getelementptr inbounds double, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %div, ptr %arrayidx40, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body16 of type:br
LV: Vector loop of width 2 costs: 60
A is not scalable.	B is not scalable.	
RTCostA: 128849018760, RTCostB: 38654705628
A is not scalable.	B is not scalable.	
RTCostA: 128849018760, RTCostB: 38654705628

-----------------Function that is being costed:'_ZN3pov23Precompute_Cubic_CoeffsEPNS_13Spline_StructE' from splines.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body16 ], [ 0, %for.body16.preheader ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load double, ptr %arrayidx, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub21 = fsub double %10, %11 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23 = getelementptr inbounds double, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %sub21, ptr %arrayidx23, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx29 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv.next, i32 1, i64 %indvars.iv240 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load double, ptr %arrayidx29, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx35 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv, i32 1, i64 %indvars.iv240 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = load double, ptr %arrayidx35, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub36 = fsub double %12, %13 of type:fsub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv double %sub36, %sub21 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx40 = getelementptr inbounds double, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %div, ptr %arrayidx40, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body16 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705628
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 38654705628

-----------------Function that is being costed:'_ZN3pov23Precompute_Cubic_CoeffsEPNS_13Spline_StructE' from splines.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body16 ], [ 0, %for.body16.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv.next of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %10 = load double, ptr %arrayidx, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub21 = fsub double %10, %11 of type:fsub
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23 = getelementptr inbounds double, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %sub21, ptr %arrayidx23, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx29 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv.next, i32 1, i64 %indvars.iv240 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %12 = load double, ptr %arrayidx29, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx35 = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %5, i64 %indvars.iv, i32 1, i64 %indvars.iv240 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %13 = load double, ptr %arrayidx35, align 8, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub36 = fsub double %12, %13 of type:fsub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv double %sub36, %sub21 of type:fdiv
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx40 = getelementptr inbounds double, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %div, ptr %arrayidx40, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body16 of type:br
LV: Vector loop of width vscale x 2 costs: 43
A is scalable.	B is not scalable.	
RTCostA: 92341796728, RTCostB: 38654705628
A is scalable.	B is not scalable.	
RTCostA: 92341796728, RTCostB: 38654705628
LV: Selecting VF: 1 With Cost: 18.
maxbefore: 2
maxafter: 2
========== Loop: _ZN3pov19Insert_Spline_EntryEPNS_13Spline_StructEdPd' from splines.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %4 to i64) + (-1 * (sext i32 %3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %5, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<-1.000000e+06>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov19Insert_Spline_EntryEPNS_13Spline_StructEdPd' from splines.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %4 to i64) + (-1 * (sext i32 %3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %5, %indvars.iv.next, ir<1>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    REPLICATE store ir<-1.000000e+06>, ir<%arrayidx>
    REPLICATE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov19Insert_Spline_EntryEPNS_13Spline_StructEdPd' from splines.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %4 to i64) + (-1 * (sext i32 %3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %5, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    REPLICATE store ir<-1.000000e+06>, ir<%arrayidx>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov19Insert_Spline_EntryEPNS_13Spline_StructEdPd' from splines.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %4 to i64) + (-1 * (sext i32 %3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %5, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx>, ir<-1.000000e+06>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov19Insert_Spline_EntryEPNS_13Spline_StructEdPd' from splines.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double -1.000000e+06, ptr %arrayidx, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3pov19Insert_Spline_EntryEPNS_13Spline_StructEdPd' from splines.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store double -1.000000e+06, ptr %arrayidx, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 14

-----------------Function that is being costed:'_ZN3pov19Insert_Spline_EntryEPNS_13Spline_StructEdPd' from splines.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double -1.000000e+06, ptr %arrayidx, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'_ZN3pov19Insert_Spline_EntryEPNS_13Spline_StructEdPd' from splines.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %5, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %"struct.pov::Spline_Entry", ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double -1.000000e+06, ptr %arrayidx, align 8, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 10
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 43
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 43, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 43
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 43, CostB * EstimatedWidthA: 16
LV: Selecting VF: 1 With Cost: 4.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3pov19Insert_Spline_EntryEPNS_13Spline_StructEdPd at line: splines.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %4 to i64) + (-1 * (sext i32 %3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%5> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, vp<%5>
    CLONE store ir<-1.000000e+06>, ir<%arrayidx>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o statspov.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           statspov.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o stringutilities.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           stringutilities.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o super.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           super.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o targa.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           targa.cpp
========== Loop: _ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end100>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i7 (trunc i32 %call55 to i7) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %18, ir<1>
    WIDEN-INDUCTION %x.1 = phi %dec, %and121, ir<-1>
    CLONE ir<%arrayidx104> = getelementptr inbounds ir<%line_data>, ir<%indvars.iv>
    CLONE ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx104>, ir<8>
    CLONE store ir<%conv102>, ir<%arrayidx105>
    CLONE ir<%arrayidx109> = getelementptr inbounds ir<%arrayidx104>, ir<4>
    CLONE store ir<%conv106>, ir<%arrayidx109>
    CLONE store ir<%conv110>, ir<%arrayidx104>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<%arrayidx104>, ir<16>
    CLONE store ir<%conv114>, ir<%arrayidx117>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%dec> = add nsw ir<%x.1>, ir<-1>
    CLONE ir<%cmp119.not> = icmp eq ir<%x.1>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.cond180.loopexit281>, scalar.ph

ir-bb<do.cond180.loopexit281>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end100>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i7 (trunc i32 %call55 to i7) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %18, ir<1>
    WIDEN-INDUCTION %x.1 = phi %dec, %and121, ir<-1>
    REPLICATE ir<%arrayidx104> = getelementptr inbounds ir<%line_data>, ir<%indvars.iv>
    REPLICATE ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx104>, ir<8>
    REPLICATE store ir<%conv102>, ir<%arrayidx105>
    REPLICATE ir<%arrayidx109> = getelementptr inbounds ir<%arrayidx104>, ir<4>
    REPLICATE store ir<%conv106>, ir<%arrayidx109>
    REPLICATE store ir<%conv110>, ir<%arrayidx104>
    REPLICATE ir<%arrayidx117> = getelementptr inbounds ir<%arrayidx104>, ir<16>
    REPLICATE store ir<%conv114>, ir<%arrayidx117>
    REPLICATE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%dec> = add nsw ir<%x.1>, ir<-1>
    CLONE ir<%cmp119.not> = icmp eq ir<%x.1>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.cond180.loopexit281>, scalar.ph

ir-bb<do.cond180.loopexit281>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end100>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i7 (trunc i32 %call55 to i7) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %18, ir<1>
    WIDEN-INDUCTION %x.1 = phi %dec, %and121, ir<-1>
    WIDEN-GEP Inv[Var] ir<%arrayidx104> = getelementptr inbounds ir<%line_data>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx104>, ir<8>
    REPLICATE store ir<%conv102>, ir<%arrayidx105>
    WIDEN-GEP Var[Inv] ir<%arrayidx109> = getelementptr inbounds ir<%arrayidx104>, ir<4>
    REPLICATE store ir<%conv106>, ir<%arrayidx109>
    REPLICATE store ir<%conv110>, ir<%arrayidx104>
    WIDEN-GEP Var[Inv] ir<%arrayidx117> = getelementptr inbounds ir<%arrayidx104>, ir<16>
    REPLICATE store ir<%conv114>, ir<%arrayidx117>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%dec> = add nsw ir<%x.1>, ir<-1>
    CLONE ir<%cmp119.not> = icmp eq ir<%x.1>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.cond180.loopexit281>, scalar.ph

ir-bb<do.cond180.loopexit281>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end100>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i7 (trunc i32 %call55 to i7) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %18, ir<1>
    WIDEN-INDUCTION %x.1 = phi %dec, %and121, ir<-1>
    WIDEN-GEP Inv[Var] ir<%arrayidx104> = getelementptr inbounds ir<%line_data>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx104>, ir<8>
    WIDEN store ir<%arrayidx105>, ir<%conv102>
    WIDEN-GEP Var[Inv] ir<%arrayidx109> = getelementptr inbounds ir<%arrayidx104>, ir<4>
    WIDEN store ir<%arrayidx109>, ir<%conv106>
    WIDEN store ir<%arrayidx104>, ir<%conv110>
    WIDEN-GEP Var[Inv] ir<%arrayidx117> = getelementptr inbounds ir<%arrayidx104>, ir<16>
    WIDEN store ir<%arrayidx117>, ir<%conv114>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%dec> = add nsw ir<%x.1>, ir<-1>
    CLONE ir<%cmp119.not> = icmp eq ir<%x.1>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<do.cond180.loopexit281>, scalar.ph

ir-bb<do.cond180.loopexit281>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}


-----------------Function that is being costed:'_ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body101 ], [ %18, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.1 = phi i32 [ %dec, %do.body101 ], [ %and121, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx104 = getelementptr inbounds [5 x float], ptr %line_data, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx105 = getelementptr inbounds i8, ptr %arrayidx104, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv102, ptr %arrayidx105, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx109 = getelementptr inbounds i8, ptr %arrayidx104, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv106, ptr %arrayidx109, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv110, ptr %arrayidx104, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx117 = getelementptr inbounds i8, ptr %arrayidx104, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store float %conv114, ptr %arrayidx117, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %x.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp119.not = icmp eq i32 %x.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp119.not, label %do.cond180.loopexit281, label %do.body101 of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'_ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body101 ], [ %18, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.1 = phi i32 [ %dec, %do.body101 ], [ %and121, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx104 = getelementptr inbounds [5 x float], ptr %line_data, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 2 For instruction:   store float %conv102, ptr %arrayidx105, align 4, !tbaa !27 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 2 For instruction:   store float %conv106, ptr %arrayidx109, align 4, !tbaa !27 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 2 For instruction:   store float %conv110, ptr %arrayidx104, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx117 = getelementptr inbounds i8, ptr %arrayidx104, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 32 for VF 2 For instruction:   store float %conv114, ptr %arrayidx117, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %x.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp119.not = icmp eq i32 %x.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp119.not, label %do.cond180.loopexit281, label %do.body101 of type:br
LV: Vector loop of width 2 costs: 17

-----------------Function that is being costed:'_ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body101 ], [ %18, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x.1 = phi i32 [ %dec, %do.body101 ], [ %and121, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx104 = getelementptr inbounds [5 x float], ptr %line_data, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 4 For instruction:   store float %conv102, ptr %arrayidx105, align 4, !tbaa !27 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 4 For instruction:   store float %conv106, ptr %arrayidx109, align 4, !tbaa !27 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 4 For instruction:   store float %conv110, ptr %arrayidx104, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx117 = getelementptr inbounds i8, ptr %arrayidx104, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 64 for VF 4 For instruction:   store float %conv114, ptr %arrayidx117, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %x.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp119.not = icmp eq i32 %x.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp119.not, label %do.cond180.loopexit281, label %do.body101 of type:br
LV: Vector loop of width 4 costs: 16

-----------------Function that is being costed:'_ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body101 ], [ %18, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.1 = phi i32 [ %dec, %do.body101 ], [ %and121, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx104 = getelementptr inbounds [5 x float], ptr %line_data, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store float %conv102, ptr %arrayidx105, align 4, !tbaa !27 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store float %conv106, ptr %arrayidx109, align 4, !tbaa !27 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store float %conv110, ptr %arrayidx104, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx117 = getelementptr inbounds i8, ptr %arrayidx104, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store float %conv114, ptr %arrayidx117, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %x.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp119.not = icmp eq i32 %x.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp119.not, label %do.cond180.loopexit281, label %do.body101 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1408
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1408

-----------------Function that is being costed:'_ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body101 ], [ %18, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.1 = phi i32 [ %dec, %do.body101 ], [ %and121, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx104 = getelementptr inbounds [5 x float], ptr %line_data, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store float %conv102, ptr %arrayidx105, align 4, !tbaa !27 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store float %conv106, ptr %arrayidx109, align 4, !tbaa !27 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store float %conv110, ptr %arrayidx104, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx117 = getelementptr inbounds i8, ptr %arrayidx104, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 164 for VF vscale x 2 For instruction:   store float %conv114, ptr %arrayidx117, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %x.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp119.not = icmp eq i32 %x.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp119.not, label %do.cond180.loopexit281, label %do.body101 of type:br
LV: Vector loop of width vscale x 2 costs: 41
A is scalable.	B is not scalable.	
RTCostA: 5344, RTCostB: 1408
A is scalable.	B is not scalable.	
RTCostA: 5344, RTCostB: 1408

-----------------Function that is being costed:'_ZN3pov11Targa_Image9Read_LineEPA5_f' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %do.body101 ], [ %18, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %x.1 = phi i32 [ %dec, %do.body101 ], [ %and121, %if.end100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx104 = getelementptr inbounds [5 x float], ptr %line_data, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store float %conv102, ptr %arrayidx105, align 4, !tbaa !27 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store float %conv106, ptr %arrayidx109, align 4, !tbaa !27 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store float %conv110, ptr %arrayidx104, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx117 = getelementptr inbounds i8, ptr %arrayidx104, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 324 for VF vscale x 4 For instruction:   store float %conv114, ptr %arrayidx117, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i32 %x.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp119.not = icmp eq i32 %x.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp119.not, label %do.cond180.loopexit281, label %do.body101 of type:br
LV: Vector loop of width vscale x 4 costs: 41
A is scalable.	B is not scalable.	
RTCostA: 5248, RTCostB: 1408
A is scalable.	B is not scalable.	
RTCostA: 5248, RTCostB: 1408
LV: Selecting VF: 1 With Cost: 11.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3pov11Targa_Image9Read_LineEPA5_f at line: targa.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end100>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i7 (trunc i32 %call55 to i7) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%18> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx104> = getelementptr inbounds ir<%line_data>, vp<%5>
    CLONE ir<%arrayidx105> = getelementptr inbounds ir<%arrayidx104>, ir<8>
    CLONE store ir<%conv102>, ir<%arrayidx105>
    CLONE ir<%arrayidx109> = getelementptr inbounds ir<%arrayidx104>, ir<4>
    CLONE store ir<%conv106>, ir<%arrayidx109>
    CLONE store ir<%conv110>, ir<%arrayidx104>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<%arrayidx104>, ir<16>
    CLONE store ir<%conv114>, ir<%arrayidx117>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<1>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.cond180.loopexit281>, scalar.ph

ir-bb<do.cond180.loopexit281>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond360.preheader.us645.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((zext i8 %6 to i32) + (256 * (zext i8 %7 to i32))<nuw><nsw>) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv763 = phi 0, %indvars.iv.next764, ir<1>
    CLONE ir<%arrayidx379.us648> = getelementptr inbounds ir<%57>, ir<%indvars.iv763>
    CLONE store ir<%.pre>, ir<%arrayidx379.us648>
    CLONE ir<%indvars.iv.next764> = add nuw nsw ir<%indvars.iv763>, ir<1>
    CLONE ir<%exitcond767.not> = icmp eq ir<%indvars.iv.next764>, ir<%wide.trip.count766>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>, scalar.ph

ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond360.preheader.us645.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((zext i8 %6 to i32) + (256 * (zext i8 %7 to i32))<nuw><nsw>) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv763 = phi 0, %indvars.iv.next764, ir<1>
    CLONE ir<%arrayidx379.us648> = getelementptr inbounds ir<%57>, ir<%indvars.iv763>
    vp<%4> = vector-pointer ir<%arrayidx379.us648>
    WIDEN store vp<%4>, ir<%.pre>
    CLONE ir<%indvars.iv.next764> = add nuw nsw ir<%indvars.iv763>, ir<1>
    CLONE ir<%exitcond767.not> = icmp eq ir<%indvars.iv.next764>, ir<%wide.trip.count766>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>, scalar.ph

ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond360.preheader.us645.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((zext i8 %6 to i32) + (256 * (zext i8 %7 to i32))<nuw><nsw>) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv763 = phi 0, %indvars.iv.next764, ir<1>
    CLONE ir<%arrayidx379.us648> = getelementptr inbounds ir<%57>, ir<%indvars.iv763>
    vp<%4> = vector-pointer ir<%arrayidx379.us648>
    WIDEN store vp<%4>, ir<%.pre>
    CLONE ir<%indvars.iv.next764> = add nuw nsw ir<%indvars.iv763>, ir<1>
    CLONE ir<%exitcond767.not> = icmp eq ir<%indvars.iv.next764>, ir<%wide.trip.count766>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>, scalar.ph

ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 64
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 6

-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'_ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc' from targa.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv763 = phi i64 [ 0, %for.cond360.preheader.us645.preheader ], [ %indvars.iv.next764, %for.cond360.preheader.us645 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx379.us648 = getelementptr inbounds i8, ptr %57, i64 %indvars.iv763 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %.pre, ptr %arrayidx379.us648, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next764 = add nuw nsw i64 %indvars.iv763, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond767.not = icmp eq i64 %indvars.iv.next764, %wide.trip.count766 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond767.not, label %for.cond357.for.end408_crit_edge.us.loopexit874, label %for.cond360.preheader.us645 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 3
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 32
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 3
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 3
B VF: 16, EstimatedWidthB: 16, CostB: 3
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: _ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc at line: targa.cpp
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: _ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc at line: targa.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond360.preheader.us645.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 ((zext i8 %6 to i32) + (256 * (zext i8 %7 to i32))<nuw><nsw>) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx379.us648> = getelementptr inbounds ir<%57>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx379.us648>
    WIDEN store vp<%5>, ir<%.pre>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>, scalar.ph

ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: _ZN3pov16Read_Targa_ImageEPNS_12Image_StructEPc at line: targa.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%55> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx379.us648> = getelementptr inbounds ir<%59>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx379.us648>
    WIDEN store vp<%4>, ir<%.pre>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%55>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>, scalar.ph

ir-bb<for.cond357.for.end408_crit_edge.us.loopexit874>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 17
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o textstream.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           textstream.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o textstreambuffer.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           textstreambuffer.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o texture.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           texture.cpp
========== Loop: _ZN3pov16Initialize_NoiseEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<267> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%2> = shl nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%2>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%mul6> = fmul ir<%3>, ir<5.000000e-01>
    CLONE ir<%4> = or disjoint ir<%2>, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%4>
    CLONE store ir<%mul6>, ir<%arrayidx9>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<267>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<267>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body12.preheader>, scalar.ph

ir-bb<for.body12.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov16Initialize_NoiseEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<267> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%2> = shl nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%2>
    INTERLEAVE-GROUP with factor 2 at %3, ir<%arrayidx>
      ir<%3> = load from index 0
    WIDEN ir<%mul6> = fmul ir<%3>, ir<5.000000e-01>
    WIDEN ir<%4> = or disjoint ir<%2>, ir<1>
    REPLICATE ir<%arrayidx9> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%4>
    REPLICATE store ir<%mul6>, ir<%arrayidx9>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<267>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3pov16Initialize_NoiseEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<267> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%2> = shl nuw nsw ir<%indvars.iv>, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%2>
    REPLICATE ir<%3> = load ir<%arrayidx>
    WIDEN ir<%mul6> = fmul ir<%3>, ir<5.000000e-01>
    WIDEN ir<%4> = or disjoint ir<%2>, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx9> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%4>
    REPLICATE store ir<%mul6>, ir<%arrayidx9>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<267>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN3pov16Initialize_NoiseEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<267> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%2> = shl nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%2>
    INTERLEAVE-GROUP with factor 2 at %3, ir<%arrayidx>
      ir<%3> = load from index 0
    WIDEN ir<%mul6> = fmul ir<%3>, ir<5.000000e-01>
    WIDEN ir<%4> = or disjoint ir<%2>, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx9> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%4>
    WIDEN store ir<%arrayidx9>, ir<%mul6>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<267>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov16Initialize_NoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = shl nuw nsw i64 %indvars.iv, 1 of type:shl
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [534 x double], ptr @_ZN3pov6RTableE, i64 0, i64 %2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul6 = fmul double %3, 5.000000e-01 of type:fmul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = or disjoint i64 %2, 1 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds [534 x double], ptr @_ZN3pov6RTableE, i64 0, i64 %4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul6, ptr %arrayidx9, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 267 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.body12.preheader, label %for.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN3pov16Initialize_NoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = shl nuw nsw i64 %indvars.iv, 1 of type:shl
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [534 x double], ptr @_ZN3pov6RTableE, i64 0, i64 %2 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul6 = fmul double %3, 5.000000e-01 of type:fmul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = or disjoint i64 %2, 1 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds [534 x double], ptr @_ZN3pov6RTableE, i64 0, i64 %4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   store double %mul6, ptr %arrayidx9, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 267 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.body12.preheader, label %for.body of type:br
LV: Vector loop of width 2 costs: 18
A is not scalable.	B is not scalable.	
RTCostA: 4798, RTCostB: 2670
A is not scalable.	B is not scalable.	
RTCostA: 4798, RTCostB: 2670

-----------------Function that is being costed:'_ZN3pov16Initialize_NoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = shl nuw nsw i64 %indvars.iv, 1 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [534 x double], ptr @_ZN3pov6RTableE, i64 0, i64 %2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul6 = fmul double %3, 5.000000e-01 of type:fmul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = or disjoint i64 %2, 1 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds [534 x double], ptr @_ZN3pov6RTableE, i64 0, i64 %4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul6, ptr %arrayidx9, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 267 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.body12.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2670
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2670

-----------------Function that is being costed:'_ZN3pov16Initialize_NoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = shl nuw nsw i64 %indvars.iv, 1 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [534 x double], ptr @_ZN3pov6RTableE, i64 0, i64 %2 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul6 = fmul double %3, 5.000000e-01 of type:fmul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = or disjoint i64 %2, 1 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds [534 x double], ptr @_ZN3pov6RTableE, i64 0, i64 %4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double %mul6, ptr %arrayidx9, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 267 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.body12.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
RTCostA: 3264, RTCostB: 2670
A is scalable.	B is not scalable.	
RTCostA: 3264, RTCostB: 2670
LV: Selecting VF: 1 With Cost: 10.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN3pov16Initialize_NoiseEv at line: texture.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<267> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%2> = shl nuw nsw vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%2>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%mul6> = fmul ir<%3>, ir<5.000000e-01>
    CLONE ir<%4> = or disjoint ir<%2>, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@_ZN3pov6RTableE>, ir<0>, ir<%4>
    CLONE store ir<%mul6>, ir<%arrayidx9>
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<267>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body12.preheader>, scalar.ph

ir-bb<for.body12.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16InitTextureTableEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%conv>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<4096>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body3.preheader>, scalar.ph

ir-bb<for.body3.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16InitTextureTableEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%3>, ir<%conv>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<4096>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body3.preheader>, scalar.ph

ir-bb<for.body3.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16InitTextureTableEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 1 to 16==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%3>, ir<%conv>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<4096>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body3.preheader>, scalar.ph

ir-bb<for.body3.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv = trunc i64 %indvars.iv to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.body3.preheader, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv = trunc i64 %indvars.iv to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.body3.preheader, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12288, RTCostB: 16384
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12288, RTCostB: 16384
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %conv = trunc i64 %indvars.iv to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.body3.preheader, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 4096, RTCostB: 16384
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4096, RTCostB: 12288
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %conv = trunc i64 %indvars.iv to i16 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.body3.preheader, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 3072, RTCostB: 16384
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3072, RTCostB: 4096
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv = trunc i64 %indvars.iv to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.body3.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 16384
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3072

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv = trunc i64 %indvars.iv to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.body3.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3072, RTCostB: 16384
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3072, RTCostB: 3072
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv = trunc i64 %indvars.iv to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.body3.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2048, RTCostB: 16384
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2048, RTCostB: 3072
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %conv = trunc i64 %indvars.iv to i16 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i16 %conv, ptr %arrayidx, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.body3.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1536, RTCostB: 16384
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1536, RTCostB: 2048
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 4096, RTCostB: 12288
A is not scalable.	B is not scalable.	
RTCostA: 3072, RTCostB: 4096
A is scalable.	B is not scalable.	
RTCostA: 3072, RTCostB: 3072
A is scalable.	B is scalable.	
RTCostA: 2048, RTCostB: 3072
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: _ZN3povL16InitTextureTableEv at line: texture.cpp
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=2 at function: _ZN3povL16InitTextureTableEv at line: texture.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body3.preheader>, scalar.ph

ir-bb<for.body3.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: _ZN3povL16InitTextureTableEv at line: texture.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body3.preheader>, scalar.ph

ir-bb<for.body3.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL16InitTextureTableEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv44 = phi %indvars.iv.next45, 0, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%indvars.iv44>
    CLONE ir<%47> = load ir<%arrayidx19>
    CLONE ir<%48> = or disjoint ir<%indvars.iv44>, ir<4096>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%48>
    CLONE store ir<%47>, ir<%arrayidx21>
    CLONE ir<%indvars.iv.next45> = add nuw nsw ir<%indvars.iv44>, ir<1>
    CLONE ir<%exitcond48.not> = icmp eq ir<%indvars.iv.next45>, ir<4096>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end24>, scalar.ph

ir-bb<for.end24>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16InitTextureTableEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv44 = phi %indvars.iv.next45, 0, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%indvars.iv44>
    vp<%3> = vector-pointer ir<%arrayidx19>
    WIDEN ir<%47> = load vp<%3>
    CLONE ir<%48> = or disjoint ir<%indvars.iv44>, ir<4096>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%48>
    vp<%4> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%4>, ir<%47>
    CLONE ir<%indvars.iv.next45> = add nuw nsw ir<%indvars.iv44>, ir<1>
    CLONE ir<%exitcond48.not> = icmp eq ir<%indvars.iv.next45>, ir<4096>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end24>, scalar.ph

ir-bb<for.end24>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL16InitTextureTableEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 1 to 16==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv44 = phi %indvars.iv.next45, 0, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%indvars.iv44>
    vp<%3> = vector-pointer ir<%arrayidx19>
    WIDEN ir<%47> = load vp<%3>
    CLONE ir<%48> = or disjoint ir<%indvars.iv44>, ir<4096>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%48>
    vp<%4> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%4>, ir<%47>
    CLONE ir<%indvars.iv.next45> = add nuw nsw ir<%indvars.iv44>, ir<1>
    CLONE ir<%exitcond48.not> = icmp eq ir<%indvars.iv.next45>, ir<4096>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end24>, scalar.ph

ir-bb<for.end24>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv44 = phi i64 [ %indvars.iv.next45, %for.body17 ], [ 0, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv44 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %48 = or disjoint i64 %indvars.iv44, 4096 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx21 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %48 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond48.not = icmp eq i64 %indvars.iv.next45, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond48.not, label %for.end24, label %for.body17 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv44 = phi i64 [ %indvars.iv.next45, %for.body17 ], [ 0, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %48 = or disjoint i64 %indvars.iv44, 4096 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx21 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %48 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond48.not = icmp eq i64 %indvars.iv.next45, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond48.not, label %for.end24, label %for.body17 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 22528, RTCostB: 28672
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 22528, RTCostB: 28672
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv44 = phi i64 [ %indvars.iv.next45, %for.body17 ], [ 0, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %48 = or disjoint i64 %indvars.iv44, 4096 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx21 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %48 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond48.not = icmp eq i64 %indvars.iv.next45, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond48.not, label %for.end24, label %for.body17 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 5120, RTCostB: 28672
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5120, RTCostB: 22528
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv44 = phi i64 [ %indvars.iv.next45, %for.body17 ], [ 0, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx19 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %48 = or disjoint i64 %indvars.iv44, 4096 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx21 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %48 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond48.not = icmp eq i64 %indvars.iv.next45, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond48.not, label %for.end24, label %for.body17 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 2560, RTCostB: 28672
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2560, RTCostB: 5120
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv44 = phi i64 [ %indvars.iv.next45, %for.body17 ], [ 0, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %48 = or disjoint i64 %indvars.iv44, 4096 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx21 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %48 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond48.not = icmp eq i64 %indvars.iv.next45, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond48.not, label %for.end24, label %for.body17 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 28672
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2560

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv44 = phi i64 [ %indvars.iv.next45, %for.body17 ], [ 0, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %48 = or disjoint i64 %indvars.iv44, 4096 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx21 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %48 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond48.not = icmp eq i64 %indvars.iv.next45, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond48.not, label %for.end24, label %for.body17 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5120, RTCostB: 28672
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5120, RTCostB: 2560

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv44 = phi i64 [ %indvars.iv.next45, %for.body17 ], [ 0, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx19 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %48 = or disjoint i64 %indvars.iv44, 4096 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx21 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %48 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond48.not = icmp eq i64 %indvars.iv.next45, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond48.not, label %for.end24, label %for.body17 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2560, RTCostB: 28672
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2560, RTCostB: 2560
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN3povL16InitTextureTableEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv44 = phi i64 [ %indvars.iv.next45, %for.body17 ], [ 0, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx19 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %47 = load i16, ptr %arrayidx19, align 2, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %48 = or disjoint i64 %indvars.iv44, 4096 of type:or
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx21 = getelementptr inbounds [8192 x i16], ptr @_ZN3pov9hashTableE, i64 0, i64 %48 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i16 %47, ptr %arrayidx21, align 2, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond48.not = icmp eq i64 %indvars.iv.next45, 4096 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond48.not, label %for.end24, label %for.body17 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1280, RTCostB: 28672
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1280, RTCostB: 2560
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 5120, RTCostB: 22528
A is not scalable.	B is not scalable.	
RTCostA: 2560, RTCostB: 5120
A is scalable.	B is not scalable.	
RTCostA: 5120, RTCostB: 2560
A is scalable.	B is not scalable.	
RTCostA: 2560, RTCostB: 2560
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: _ZN3povL16InitTextureTableEv at line: texture.cpp
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=2 at function: _ZN3povL16InitTextureTableEv at line: texture.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx19>
    WIDEN ir<%47> = load vp<%4>
    CLONE ir<%48> = or disjoint vp<%3>, ir<4096>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%48>
    vp<%5> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%5>, ir<%47>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end24>, scalar.ph

ir-bb<for.end24>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: _ZN3povL16InitTextureTableEv at line: texture.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<4096> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx19>
    WIDEN ir<%76> = load vp<%4>
    CLONE ir<%77> = or disjoint vp<%3>, ir<4096>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<@_ZN3pov9hashTableE>, ir<0>, ir<%77>
    vp<%5> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%5>, ir<%76>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<4096>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end24>, scalar.ph

ir-bb<for.end24>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 6
Loops Epilogues Vectorized: 2
================================================
@@ Instruction =>  store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL14InitSolidNoiseEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<2048> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv88 = phi %indvars.iv.next89, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv88 = phi %indvars.iv.next89, 0\l" +
    "  ir<%1>, ir<1>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<@_ZN3povL16NoisePermutationE>, ir<0>, ir<%indvars.iv88>
    CLONE store ir<%1>, ir<%arrayidx21>
    CLONE ir<%indvars.iv.next89> = add nuw nsw ir<%indvars.iv88>, ir<1>
    CLONE ir<%exitcond91.not> = icmp eq ir<%indvars.iv.next89>, ir<2048>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<2048>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body27.preheader>, scalar.ph

ir-bb<for.body27.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14InitSolidNoiseEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<2048> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv88 = phi %indvars.iv.next89, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv88 = phi %indvars.iv.next89, 0\l" +
    "  ir<%1>, ir<1>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<@_ZN3povL16NoisePermutationE>, ir<0>, ir<%indvars.iv88>
    vp<%3> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%3>, ir<%1>
    WIDEN ir<%indvars.iv.next89> = add nuw nsw ir<%indvars.iv88>, ir<1>
    CLONE ir<%exitcond91.not> = icmp eq ir<%indvars.iv.next89>, ir<2048>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<2048>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body27.preheader>, scalar.ph

ir-bb<for.body27.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL14InitSolidNoiseEv' from texture.cpp==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<2048> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv88 = phi %indvars.iv.next89, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv88 = phi %indvars.iv.next89, 0\l" +
    "  ir<%1>, ir<1>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<@_ZN3povL16NoisePermutationE>, ir<0>, ir<%indvars.iv88>
    vp<%3> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%3>, ir<%1>
    WIDEN ir<%indvars.iv.next89> = add nuw nsw ir<%indvars.iv88>, ir<1>
    CLONE ir<%exitcond91.not> = icmp eq ir<%indvars.iv.next89>, ir<2048>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<2048>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body27.preheader>, scalar.ph

ir-bb<for.body27.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL14InitSolidNoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv88 = phi i64 [ %indvars.iv.next89, %for.body19 ], [ 0, %for.body19.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx21 = getelementptr inbounds [4098 x i32], ptr @_ZN3povL16NoisePermutationE, i64 0, i64 %indvars.iv88 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv88 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next89 = add nuw nsw i64 %indvars.iv88, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond91.not = icmp eq i64 %indvars.iv.next89, 2048 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond91.not, label %for.body27.preheader, label %for.body19 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN3povL14InitSolidNoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv88 = phi i64 [ %indvars.iv.next89, %for.body19 ], [ 0, %for.body19.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx21 = getelementptr inbounds [4098 x i32], ptr @_ZN3povL16NoisePermutationE, i64 0, i64 %indvars.iv88 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv88 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next89 = add nuw nsw i64 %indvars.iv88, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond91.not = icmp eq i64 %indvars.iv.next89, 2048 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond91.not, label %for.body27.preheader, label %for.body19 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3072, RTCostB: 8192
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3072, RTCostB: 8192
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL14InitSolidNoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv88 = phi i64 [ %indvars.iv.next89, %for.body19 ], [ 0, %for.body19.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx21 = getelementptr inbounds [4098 x i32], ptr @_ZN3povL16NoisePermutationE, i64 0, i64 %indvars.iv88 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv88 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next89 = add nuw nsw i64 %indvars.iv88, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond91.not = icmp eq i64 %indvars.iv.next89, 2048 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond91.not, label %for.body27.preheader, label %for.body19 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2048, RTCostB: 8192
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2048, RTCostB: 3072
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3povL14InitSolidNoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv88 = phi i64 [ %indvars.iv.next89, %for.body19 ], [ 0, %for.body19.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx21 = getelementptr inbounds [4098 x i32], ptr @_ZN3povL16NoisePermutationE, i64 0, i64 %indvars.iv88 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv88 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next89 = add nuw nsw i64 %indvars.iv88, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond91.not = icmp eq i64 %indvars.iv.next89, 2048 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond91.not, label %for.body27.preheader, label %for.body19 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8192
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2048

-----------------Function that is being costed:'_ZN3povL14InitSolidNoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv88 = phi i64 [ %indvars.iv.next89, %for.body19 ], [ 0, %for.body19.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx21 = getelementptr inbounds [4098 x i32], ptr @_ZN3povL16NoisePermutationE, i64 0, i64 %indvars.iv88 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv88 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next89 = add nuw nsw i64 %indvars.iv88, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond91.not = icmp eq i64 %indvars.iv.next89, 2048 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond91.not, label %for.body27.preheader, label %for.body19 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1536, RTCostB: 8192
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1536, RTCostB: 2048
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3povL14InitSolidNoiseEv' from texture.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv88 = phi i64 [ %indvars.iv.next89, %for.body19 ], [ 0, %for.body19.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx21 = getelementptr inbounds [4098 x i32], ptr @_ZN3povL16NoisePermutationE, i64 0, i64 %indvars.iv88 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv88 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %1, ptr %arrayidx21, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next89 = add nuw nsw i64 %indvars.iv88, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond91.not = icmp eq i64 %indvars.iv.next89, 2048 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond91.not, label %for.body27.preheader, label %for.body19 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1024, RTCostB: 8192
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1024, RTCostB: 1536
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN3povL14InitSolidNoiseEv at line: texture.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<2048> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv88 = phi %indvars.iv.next89, 0\l" +
    "  ir<%1>, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<@_ZN3povL16NoisePermutationE>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx21>
    WIDEN store vp<%4>, ir<%1>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<2048>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body27.preheader>, scalar.ph

ir-bb<for.body27.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 10
Loops Epilogues Vectorized: 2
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o tokenize.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           tokenize.cpp
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 10 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 20 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 %0, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: _ZN3pov18pre_init_tokenizerEv' from tokenize.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<535> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%13>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@_ZN3pov21Conversion_Util_TableE>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%0>, ir<%arrayidx>
    CLONE ir<%cmp1> = icmp ult ir<%indvars.iv>, ir<64>
  Successor(s): if.else

  if.else:
    EMIT vp<%3> = not ir<%cmp1>
    CLONE ir<%cmp4> = icmp ult ir<%indvars.iv>, ir<77>
  Successor(s): if.else8

  if.else8:
    EMIT vp<%4> = not ir<%cmp4>
    EMIT vp<%5> = logical-and vp<%3>, vp<%4>
    CLONE ir<%cmp9> = icmp ult ir<%indvars.iv>, ir<89>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp9>
    EMIT vp<%7> = logical-and vp<%3>, ir<%cmp4>
    EMIT vp<%8> = or vp<%6>, vp<%7>
    EMIT vp<%9> = or vp<%8>, ir<%cmp1>
    BLEND ir<%.sink> = ir<64> ir<77>/vp<%7> ir<89>/vp<%6>
    CLONE store ir<%.sink>, ir<%arrayidx>, vp<%9>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%10> = not ir<%cmp9>
    EMIT vp<%11> = logical-and vp<%5>, vp<%10>
    EMIT vp<%12> = or vp<%9>, vp<%11>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<535>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%13> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq ir<535>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov18pre_init_tokenizerEv' from tokenize.cpp==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<535> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    CLONE ir<%arrayidx> = getelementptr ir<@_ZN3pov21Conversion_Util_TableE>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%3>, ir<%0>
    WIDEN ir<%cmp1> = icmp ult ir<%indvars.iv>, ir<64>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%cmp1>
    WIDEN ir<%cmp4> = icmp ult ir<%indvars.iv>, ir<77>
  Successor(s): if.else8

  if.else8:
    EMIT vp<%5> = not ir<%cmp4>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%cmp9> = icmp ult ir<%indvars.iv>, ir<89>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%7> = logical-and vp<%6>, ir<%cmp9>
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp4>
    EMIT vp<%9> = or vp<%7>, vp<%8>
    EMIT vp<%10> = or vp<%9>, ir<%cmp1>
    BLEND ir<%.sink> = ir<64> ir<77>/vp<%8> ir<89>/vp<%7>
    vp<%11> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%11>, ir<%.sink>, vp<%10>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%12> = not ir<%cmp9>
    EMIT vp<%13> = logical-and vp<%6>, vp<%12>
    EMIT vp<%14> = or vp<%10>, vp<%13>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<535>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = icmp eq ir<535>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3pov18pre_init_tokenizerEv' from tokenize.cpp==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<535> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    CLONE ir<%arrayidx> = getelementptr ir<@_ZN3pov21Conversion_Util_TableE>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%3>, ir<%0>
    WIDEN ir<%cmp1> = icmp ult ir<%indvars.iv>, ir<64>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%cmp1>
    WIDEN ir<%cmp4> = icmp ult ir<%indvars.iv>, ir<77>
  Successor(s): if.else8

  if.else8:
    EMIT vp<%5> = not ir<%cmp4>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%cmp9> = icmp ult ir<%indvars.iv>, ir<89>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%7> = logical-and vp<%6>, ir<%cmp9>
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp4>
    EMIT vp<%9> = or vp<%7>, vp<%8>
    EMIT vp<%10> = or vp<%9>, ir<%cmp1>
    BLEND ir<%.sink> = ir<64> ir<77>/vp<%8> ir<89>/vp<%7>
    vp<%11> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%11>, ir<%.sink>, vp<%10>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%12> = not ir<%cmp9>
    EMIT vp<%13> = logical-and vp<%6>, vp<%12>
    EMIT vp<%14> = or vp<%10>, vp<%13>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<535>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = icmp eq ir<535>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [535 x i32], ptr @_ZN3pov21Conversion_Util_TableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1 = icmp ult i64 %indvars.iv, 64 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp4 = icmp ult i64 %indvars.iv, 77 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp4, label %for.inc.sink.split, label %if.else8 of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, 89 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp9, label %for.inc.sink.split, label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %.sink = phi i32 [ 64, %for.body ], [ 77, %if.else ], [ 89, %if.else8 ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 535 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [535 x i32], ptr @_ZN3pov21Conversion_Util_TableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1 = icmp ult i64 %indvars.iv, 64 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp4 = icmp ult i64 %indvars.iv, 77 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp4, label %for.inc.sink.split, label %if.else8 of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, 89 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp9, label %for.inc.sink.split, label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 12 for VF 2 For instruction:   %.sink = phi i32 [ 64, %for.body ], [ 77, %if.else ], [ 89, %if.else8 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 535 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 7482, RTCostB: 3210
A is not scalable.	B is not scalable.	
RTCostA: 7482, RTCostB: 3210

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [535 x i32], ptr @_ZN3pov21Conversion_Util_TableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp1 = icmp ult i64 %indvars.iv, 64 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp4 = icmp ult i64 %indvars.iv, 77 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp4, label %for.inc.sink.split, label %if.else8 of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, 89 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp9, label %for.inc.sink.split, label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 24 for VF 4 For instruction:   %.sink = phi i32 [ 64, %for.body ], [ 77, %if.else ], [ 89, %if.else8 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 535 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 13
A is not scalable.	B is not scalable.	
RTCostA: 7200, RTCostB: 3210
A is not scalable.	B is not scalable.	
RTCostA: 7200, RTCostB: 3210

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [535 x i32], ptr @_ZN3pov21Conversion_Util_TableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1 = icmp ult i64 %indvars.iv, 64 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp4 = icmp ult i64 %indvars.iv, 77 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp4, label %for.inc.sink.split, label %if.else8 of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, 89 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp9, label %for.inc.sink.split, label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %.sink = phi i32 [ 64, %for.body ], [ 77, %if.else ], [ 89, %if.else8 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 535 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3210
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3210

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [535 x i32], ptr @_ZN3pov21Conversion_Util_TableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1 = icmp ult i64 %indvars.iv, 64 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp4 = icmp ult i64 %indvars.iv, 77 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp4, label %for.inc.sink.split, label %if.else8 of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, 89 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp9, label %for.inc.sink.split, label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %.sink = phi i32 [ 64, %for.body ], [ 77, %if.else ], [ 89, %if.else8 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 535 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 1215, RTCostB: 3210
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1215, RTCostB: 3210
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [535 x i32], ptr @_ZN3pov21Conversion_Util_TableE, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %0 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %0, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp1 = icmp ult i64 %indvars.iv, 64 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp4 = icmp ult i64 %indvars.iv, 77 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp4, label %for.inc.sink.split, label %if.else8 of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp9 = icmp ult i64 %indvars.iv, 89 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp9, label %for.inc.sink.split, label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %.sink = phi i32 [ 64, %for.body ], [ 77, %if.else ], [ 89, %if.else8 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %.sink, ptr %arrayidx, align 4, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN3pov18pre_init_tokenizerEv' from tokenize.cpp-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 535 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 900, RTCostB: 3210
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 900, RTCostB: 1215
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN3pov18pre_init_tokenizerEv at line: tokenize.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<535> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%13>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%0>, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr ir<@_ZN3pov21Conversion_Util_TableE>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%0>
    WIDEN ir<%cmp1> = icmp ult ir<%indvars.iv>, ir<64>
    EMIT vp<%5> = not ir<%cmp1>
    WIDEN ir<%cmp4> = icmp ult ir<%indvars.iv>, ir<77>
    EMIT vp<%6> = not ir<%cmp4>
    EMIT vp<%7> = logical-and vp<%5>, vp<%6>
    WIDEN ir<%cmp9> = icmp ult ir<%indvars.iv>, ir<89>
    EMIT vp<%8> = logical-and vp<%7>, ir<%cmp9>
    EMIT vp<%9> = logical-and vp<%5>, ir<%cmp4>
    EMIT vp<%10> = or vp<%8>, vp<%9>
    EMIT vp<%11> = or vp<%10>, ir<%cmp1>
    BLEND ir<%.sink> = ir<64> ir<77>/vp<%9> ir<89>/vp<%8>
    vp<%12> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%12>, ir<%.sink>, vp<%11>
    EMIT vp<%13> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq ir<535>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o torus.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           torus.cpp
MVT: v2f64
@@ Instruction =>  %27 = load double, ptr %arrayidx84, align 8, !tbaa !15 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
@@ Instruction =>  store double %div, ptr %arrayidx87, align 8, !tbaa !15 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
MVT: nxv2f64
@@ Instruction =>  %27 = load double, ptr %arrayidx84, align 8, !tbaa !15 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  store double %div, ptr %arrayidx87, align 8, !tbaa !15 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
MVT: nxv2f64
@@ Instruction =>  %27 = load double, ptr %arrayidx84, align 8, !tbaa !15 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  store double %div, ptr %arrayidx87, align 8, !tbaa !15 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL15intersect_torusEPNS_10Ray_StructEPNS_12Torus_StructEPd' from torus.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call82 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv134 = phi %26, %indvars.iv.next135, ir<-1>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%indvars.iv.next135> = add nsw ir<%indvars.iv134>, ir<-1>
    CLONE ir<%arrayidx84> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next135>
    CLONE ir<%27> = load ir<%arrayidx84>
    CLONE ir<%add85> = fadd ir<%Closer.0>, ir<%27>
    CLONE ir<%div> = fdiv ir<%add85>, ir<%25>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx87> = getelementptr inbounds ir<%Depth>, ir<%indvars.iv>
    CLONE store ir<%div>, ir<%arrayidx87>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end88>, scalar.ph

ir-bb<if.end88>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15intersect_torusEPNS_10Ray_StructEPNS_12Torus_StructEPd' from torus.cpp==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call82 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv134 = phi %26, %indvars.iv.next135, ir<-1>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%indvars.iv.next135> = add nsw ir<%indvars.iv134>, ir<-1>
    CLONE ir<%arrayidx84> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next135>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx84>
    WIDEN ir<%27> = load vp<%4>
    WIDEN ir<%add85> = fadd ir<%Closer.0>, ir<%27>
    WIDEN ir<%div> = fdiv ir<%add85>, ir<%25>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx87> = getelementptr inbounds ir<%Depth>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx87>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end88>, scalar.ph

ir-bb<if.end88>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL15intersect_torusEPNS_10Ray_StructEPNS_12Torus_StructEPd' from torus.cpp==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call82 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv134 = phi %26, %indvars.iv.next135, ir<-1>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%indvars.iv.next135> = add nsw ir<%indvars.iv134>, ir<-1>
    CLONE ir<%arrayidx84> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next135>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx84>
    WIDEN ir<%27> = load vp<%4>
    WIDEN ir<%add85> = fadd ir<%Closer.0>, ir<%27>
    WIDEN ir<%div> = fdiv ir<%add85>, ir<%25>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx87> = getelementptr inbounds ir<%Depth>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx87>
    WIDEN store vp<%5>, ir<%div>
    CLONE ir<%exitcond> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end88>, scalar.ph

ir-bb<if.end88>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL15intersect_torusEPNS_10Ray_StructEPNS_12Torus_StructEPd' from torus.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv134 = phi i64 [ %26, %while.body.lr.ph ], [ %indvars.iv.next135, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next135 = add nsw i64 %indvars.iv134, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx84 = getelementptr inbounds [4 x double], ptr %r, i64 0, i64 %indvars.iv.next135 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %27 = load double, ptr %arrayidx84, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add85 = fadd double %Closer.0, %27 of type:fadd
LV: Found an estimated cost of 2 for VF 1 For instruction:   %div = fdiv double %add85, %25 of type:fdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx87 = getelementptr inbounds double, ptr %Depth, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %div, ptr %arrayidx87, align 8, !tbaa !15 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond, label %if.end88, label %while.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN3povL15intersect_torusEPNS_10Ray_StructEPNS_12Torus_StructEPd' from torus.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv134 = phi i64 [ %26, %while.body.lr.ph ], [ %indvars.iv.next135, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next135 = add nsw i64 %indvars.iv134, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx84 = getelementptr inbounds [4 x double], ptr %r, i64 0, i64 %indvars.iv.next135 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %27 = load double, ptr %arrayidx84, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add85 = fadd double %Closer.0, %27 of type:fadd
LV: Found an estimated cost of 2 for VF 2 For instruction:   %div = fdiv double %add85, %25 of type:fdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx87 = getelementptr inbounds double, ptr %Depth, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %div, ptr %arrayidx87, align 8, !tbaa !15 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond, label %if.end88, label %while.body of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 19327352833, RTCostB: 42949672950
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 19327352833, RTCostB: 42949672950
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL15intersect_torusEPNS_10Ray_StructEPNS_12Torus_StructEPd' from torus.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv134 = phi i64 [ %26, %while.body.lr.ph ], [ %indvars.iv.next135, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next135 = add nsw i64 %indvars.iv134, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx84 = getelementptr inbounds [4 x double], ptr %r, i64 0, i64 %indvars.iv.next135 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %27 = load double, ptr %arrayidx84, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add85 = fadd double %Closer.0, %27 of type:fadd
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = fdiv double %add85, %25 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx87 = getelementptr inbounds double, ptr %Depth, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %div, ptr %arrayidx87, align 8, !tbaa !15 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond, label %if.end88, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 42949672950
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352833

-----------------Function that is being costed:'_ZN3povL15intersect_torusEPNS_10Ray_StructEPNS_12Torus_StructEPd' from torus.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv134 = phi i64 [ %26, %while.body.lr.ph ], [ %indvars.iv.next135, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next135 = add nsw i64 %indvars.iv134, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx84 = getelementptr inbounds [4 x double], ptr %r, i64 0, i64 %indvars.iv.next135 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %27 = load double, ptr %arrayidx84, align 8, !tbaa !15 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add85 = fadd double %Closer.0, %27 of type:fadd
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div = fdiv double %add85, %25 of type:fdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx87 = getelementptr inbounds double, ptr %Depth, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %div, ptr %arrayidx87, align 8, !tbaa !15 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond, label %if.end88, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 9663676437, RTCostB: 42949672950
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 9663676437, RTCostB: 19327352833
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN3povL15intersect_torusEPNS_10Ray_StructEPNS_12Torus_StructEPd at line: torus.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call82 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%26> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%indvars.iv.next135> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx84> = getelementptr inbounds ir<%r>, ir<0>, ir<%indvars.iv.next135>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx84>
    WIDEN ir<%27> = load vp<%7>
    WIDEN ir<%add85> = fadd ir<%Closer.0>, ir<%27>
    WIDEN ir<%div> = fdiv ir<%add85>, ir<%25>
    CLONE ir<%arrayidx87> = getelementptr inbounds ir<%Depth>, vp<%6>
    vp<%8> = vector-pointer ir<%arrayidx87>
    WIDEN store vp<%8>, ir<%div>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end88>, scalar.ph

ir-bb<if.end88>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2f64
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o triangle.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           triangle.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o truetype.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           truetype.cpp
@@ Instruction =>  %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i16 %add412, ptr %gep, align 2, !tbaa !26 -> Cost: 4 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %add412, ptr %gep, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %add412, ptr %gep, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  store i16 %add412, ptr %gep, align 2, !tbaa !26 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %add412, ptr %gep, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %add412, ptr %gep, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 %add412, ptr %gep, align 2, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body406.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (sext i16 %75 to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx409> = getelementptr inbounds ir<%85>, ir<%indvars.iv>
    CLONE ir<%89> = load ir<%arrayidx409>
    CLONE ir<%add412> = add ir<%89>, ir<%77>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv>
    CLONE store ir<%add412>, ir<%gep>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond422.preheader.loopexit>, scalar.ph

ir-bb<for.cond422.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body406.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (sext i16 %75 to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx409> = getelementptr inbounds ir<%85>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx409>
    WIDEN ir<%89> = load vp<%4>
    WIDEN ir<%add412> = add ir<%89>, ir<%77>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%gep>
    WIDEN store vp<%5>, ir<%add412>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond422.preheader.loopexit>, scalar.ph

ir-bb<for.cond422.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp==========
========== VPlan for Vector Factor Range: 1 to 16==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body406.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (sext i16 %75 to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx409> = getelementptr inbounds ir<%85>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx409>
    WIDEN ir<%89> = load vp<%4>
    WIDEN ir<%add412> = add ir<%89>, ir<%77>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%gep>
    WIDEN store vp<%5>, ir<%add412>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond422.preheader.loopexit>, scalar.ph

ir-bb<for.cond422.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body406.lr.ph ], [ %indvars.iv.next, %for.body406 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx409 = getelementptr inbounds i16, ptr %85, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add412 = add i16 %89, %77 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep = getelementptr i16, ptr %invariant.gep, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %add412, ptr %gep, align 2, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond422.preheader.loopexit, label %for.body406 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body406.lr.ph ], [ %indvars.iv.next, %for.body406 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx409 = getelementptr inbounds i16, ptr %85, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add412 = add i16 %89, %77 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep = getelementptr i16, ptr %invariant.gep, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i16 %add412, ptr %gep, align 2, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond422.preheader.loopexit, label %for.body406 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 180220, RTCostB: 229369
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 180220, RTCostB: 229369
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body406.lr.ph ], [ %indvars.iv.next, %for.body406 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx409 = getelementptr inbounds i16, ptr %85, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add412 = add i16 %89, %77 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %gep = getelementptr i16, ptr %invariant.gep, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i16 %add412, ptr %gep, align 2, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond422.preheader.loopexit, label %for.body406 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 40976, RTCostB: 229369
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 40976, RTCostB: 180220
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body406.lr.ph ], [ %indvars.iv.next, %for.body406 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx409 = getelementptr inbounds i16, ptr %85, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %add412 = add i16 %89, %77 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %gep = getelementptr i16, ptr %invariant.gep, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i16 %add412, ptr %gep, align 2, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.cond422.preheader.loopexit, label %for.body406 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 20524, RTCostB: 229369
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 20524, RTCostB: 40976
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body406.lr.ph ], [ %indvars.iv.next, %for.body406 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx409 = getelementptr inbounds i16, ptr %85, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add412 = add i16 %89, %77 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %gep = getelementptr i16, ptr %invariant.gep, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %add412, ptr %gep, align 2, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond422.preheader.loopexit, label %for.body406 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 229369
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 20524

-----------------Function that is being costed:'_ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body406.lr.ph ], [ %indvars.iv.next, %for.body406 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx409 = getelementptr inbounds i16, ptr %85, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add412 = add i16 %89, %77 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %gep = getelementptr i16, ptr %invariant.gep, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i16 %add412, ptr %gep, align 2, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond422.preheader.loopexit, label %for.body406 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 40976, RTCostB: 229369
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 40976, RTCostB: 20524

-----------------Function that is being costed:'_ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body406.lr.ph ], [ %indvars.iv.next, %for.body406 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx409 = getelementptr inbounds i16, ptr %85, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add412 = add i16 %89, %77 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %gep = getelementptr i16, ptr %invariant.gep, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i16 %add412, ptr %gep, align 2, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond422.preheader.loopexit, label %for.body406 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 20524, RTCostB: 229369
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 20524, RTCostB: 20524
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj' from truetype.cpp-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body406.lr.ph ], [ %indvars.iv.next, %for.body406 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx409 = getelementptr inbounds i16, ptr %85, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %89 = load i16, ptr %arrayidx409, align 2, !tbaa !26 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %add412 = add i16 %89, %77 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %gep = getelementptr i16, ptr %invariant.gep, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i16 %add412, ptr %gep, align 2, !tbaa !26 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.cond422.preheader.loopexit, label %for.body406 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 10340, RTCostB: 229369
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 10340, RTCostB: 20524
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 40976, RTCostB: 180220
A is not scalable.	B is not scalable.	
RTCostA: 20524, RTCostB: 40976
A is scalable.	B is not scalable.	
RTCostA: 40976, RTCostB: 20524
A is scalable.	B is not scalable.	
RTCostA: 20524, RTCostB: 20524
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: _ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj at line: truetype.cpp
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=2 at function: _ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj at line: truetype.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body406.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (sext i16 %75 to i32) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx409> = getelementptr inbounds ir<%85>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx409>
    WIDEN ir<%97> = load vp<%5>
    WIDEN ir<%add412> = add ir<%97>, ir<%77>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, vp<%4>
    vp<%6> = vector-pointer ir<%gep>
    WIDEN store vp<%6>, ir<%add412>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond422.preheader.loopexit>, scalar.ph

ir-bb<for.cond422.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: _ZN3povL19ExtractGlyphOutlineEPNS_18FontFileInfoStructEPjj at line: truetype.cpp
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx409> = getelementptr inbounds ir<%85>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx409>
    WIDEN ir<%126> = load vp<%4>
    WIDEN ir<%add412> = add ir<%126>, ir<%77>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, vp<%3>
    vp<%5> = vector-pointer ir<%gep>
    WIDEN store vp<%5>, ir<%add412>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%wide.trip.count>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond422.preheader.loopexit>, scalar.ph

ir-bb<for.cond422.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 27
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o txttest.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           txttest.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o userdisp.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           userdisp.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o userio.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           userio.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o vbuffer.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           vbuffer.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o vlbuffer.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           vlbuffer.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o warps.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           warps.cpp
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration     -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           atmosph.o bbox.o bcyl.o bezier.o blob.o boxes.o bsphere.o camera.o chi2.o colour.o colutils.o cones.o csg.o defaultplatformbase.o defaultrenderfrontend.o discs.o express.o fileinputoutput.o fncode.o fnintern.o fnpovfpu.o fnsyntax.o fpmetric.o fractal.o function.o hcmplx.o hfield.o histogra.o iff.o image.o interior.o isosurf.o lathe.o lbuffer.o lightgrp.o lighting.o mathutil.o matrices.o media.o mesh.o messageoutput.o normal.o objects.o octree.o optout.o parse.o parsestr.o parstxtr.o pattern.o pgm.o photons.o pigment.o planes.o point.o poly.o polygon.o polysolv.o pov_mem.o pov_util.o povms.o povmscpp.o povmsend.o povmsrec.o povray.o ppm.o prism.o processoptions.o processrenderoptions.o quadrics.o quatern.o rad_data.o radiosit.o ray.o rendctrl.o render.o renderfrontend.o renderio.o sor.o specrand.o spec_qsort.o spheres.o sphsweep.o splines.o statspov.o stringutilities.o super.o targa.o textstream.o textstreambuffer.o texture.o tokenize.o torus.o triangle.o truetype.o txttest.o userdisp.o userio.o vbuffer.o vlbuffer.o warps.o                     -o povray
