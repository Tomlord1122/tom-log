/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o mcf.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                mcf.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o mcfutil.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                mcfutil.c
========== Loop: flow_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%node.070>, 104
    EMIT ir<%.pn72> = WIDEN-POINTER-INDUCTION ir<%5>, 104
    CLONE ir<%flow7> = getelementptr inbounds ir<%.pn72>, ir<184>
    CLONE ir<%6> = load ir<%flow7>
    CLONE ir<%basic_arc> = getelementptr inbounds ir<%.pn72>, ir<152>
    CLONE ir<%7> = load ir<%basic_arc>
    CLONE ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    CLONE store ir<%6>, ir<%flow8>
    CLONE ir<%node.0> = getelementptr inbounds ir<%node.073>, ir<104>
    CLONE ir<%cmp5.not> = icmp eq ir<%node.0>, ir<%4>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: flow_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%node.070>, 104
    EMIT ir<%.pn72> = WIDEN-POINTER-INDUCTION ir<%5>, 104
    REPLICATE ir<%flow7> = getelementptr inbounds ir<%.pn72>, ir<184>
    REPLICATE ir<%6> = load ir<%flow7>
    REPLICATE ir<%basic_arc> = getelementptr inbounds ir<%.pn72>, ir<152>
    REPLICATE ir<%7> = load ir<%basic_arc>
    REPLICATE ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    REPLICATE store ir<%6>, ir<%flow8>
    WIDEN-GEP Var[Inv] ir<%node.0> = getelementptr inbounds ir<%node.073>, ir<104>
    CLONE ir<%cmp5.not> = icmp eq ir<%node.0>, ir<%4>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: flow_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%node.070>, 104
    EMIT ir<%.pn72> = WIDEN-POINTER-INDUCTION ir<%5>, 104
    WIDEN-GEP Var[Inv] ir<%flow7> = getelementptr inbounds ir<%.pn72>, ir<184>
    REPLICATE ir<%6> = load ir<%flow7>
    WIDEN-GEP Var[Inv] ir<%basic_arc> = getelementptr inbounds ir<%.pn72>, ir<152>
    REPLICATE ir<%7> = load ir<%basic_arc>
    WIDEN-GEP Var[Inv] ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    REPLICATE store ir<%6>, ir<%flow8>
    WIDEN-GEP Var[Inv] ir<%node.0> = getelementptr inbounds ir<%node.073>, ir<104>
    CLONE ir<%cmp5.not> = icmp eq ir<%node.0>, ir<%4>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: flow_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%node.070>, 104
    EMIT ir<%.pn72> = WIDEN-POINTER-INDUCTION ir<%5>, 104
    WIDEN-GEP Var[Inv] ir<%flow7> = getelementptr inbounds ir<%.pn72>, ir<184>
    WIDEN ir<%6> = load ir<%flow7>
    WIDEN-GEP Var[Inv] ir<%basic_arc> = getelementptr inbounds ir<%.pn72>, ir<152>
    WIDEN ir<%7> = load ir<%basic_arc>
    WIDEN-GEP Var[Inv] ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    WIDEN store ir<%flow8>, ir<%6>
    WIDEN-GEP Var[Inv] ir<%node.0> = getelementptr inbounds ir<%node.073>, ir<104>
    CLONE ir<%cmp5.not> = icmp eq ir<%node.0>, ir<%4>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %node.073 = phi ptr [ %node.0, %for.body6 ], [ %node.070, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %.pn72 = phi ptr [ %node.073, %for.body6 ], [ %5, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %flow7 = getelementptr inbounds i8, ptr %.pn72, i64 184 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load i64, ptr %flow7, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn72, i64 152 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load ptr, ptr %basic_arc, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %flow8 = getelementptr inbounds i8, ptr %7, i64 48 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %6, ptr %flow8, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5.not = icmp eq ptr %node.0, %4 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5.not, label %for.cond14.preheader.loopexit, label %for.body6 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %node.073 = phi ptr [ %node.0, %for.body6 ], [ %node.070, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %.pn72 = phi ptr [ %node.073, %for.body6 ], [ %5, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %flow7 = getelementptr inbounds i8, ptr %.pn72, i64 184 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %6 = load i64, ptr %flow7, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn72, i64 152 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %7 = load ptr, ptr %basic_arc, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %flow8 = getelementptr inbounds i8, ptr %7, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i64 %6, ptr %flow8, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5.not = icmp eq ptr %node.0, %4 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5.not, label %for.cond14.preheader.loopexit, label %for.body6 of type:br
LV: Vector loop of width 2 costs: 45
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 91
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 91, CostB * EstimatedWidthA: 14
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 91
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 91, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %node.073 = phi ptr [ %node.0, %for.body6 ], [ %node.070, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %.pn72 = phi ptr [ %node.073, %for.body6 ], [ %5, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %flow7 = getelementptr inbounds i8, ptr %.pn72, i64 184 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load i64, ptr %flow7, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn72, i64 152 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load ptr, ptr %basic_arc, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %flow8 = getelementptr inbounds i8, ptr %7, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %6, ptr %flow8, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5.not = icmp eq ptr %node.0, %4 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5.not, label %for.cond14.preheader.loopexit, label %for.body6 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %node.073 = phi ptr [ %node.0, %for.body6 ], [ %node.070, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %.pn72 = phi ptr [ %node.073, %for.body6 ], [ %5, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %flow7 = getelementptr inbounds i8, ptr %.pn72, i64 184 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %6 = load i64, ptr %flow7, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn72, i64 152 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %7 = load ptr, ptr %basic_arc, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %flow8 = getelementptr inbounds i8, ptr %7, i64 48 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %6, ptr %flow8, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp5.not = icmp eq ptr %node.0, %4 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5.not, label %for.cond14.preheader.loopexit, label %for.body6 of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 124
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 124, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 124
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 124, CostB * EstimatedWidthA: 28
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: flow_cost at line: mcfutil.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<104>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<104>
    EMIT vp<%6> = ptradd ir<%5>, vp<%5>
    CLONE ir<%flow7> = getelementptr inbounds vp<%6>, ir<184>
    CLONE ir<%6> = load ir<%flow7>
    CLONE ir<%basic_arc> = getelementptr inbounds vp<%6>, ir<152>
    CLONE ir<%7> = load ir<%basic_arc>
    CLONE ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    CLONE store ir<%6>, ir<%flow8>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: flow_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-REDUCTION-PHI ir<%operational_cost.077> = phi ir<0>, ir<%operational_cost.1>
    WIDEN-REDUCTION-PHI ir<%fleet.076> = phi ir<0>, ir<%fleet.1>
    EMIT ir<%arc.175> = WIDEN-POINTER-INDUCTION ir<%1>, 64
    CLONE ir<%flow17> = getelementptr inbounds ir<%arc.175>, ir<48>
    CLONE ir<%29> = load ir<%flow17>
    CLONE ir<%tobool.not> = icmp eq ir<%29>, ir<0>
  Successor(s): if.then18

  if.then18:
    EMIT vp<%4> = not ir<%tobool.not>
    CLONE ir<%tail> = getelementptr inbounds ir<%arc.175>, ir<8>
    CLONE ir<%30> = load ir<%tail>, vp<%4>
    CLONE ir<%number> = getelementptr inbounds ir<%30>, ir<96>
    CLONE ir<%31> = load ir<%number>, vp<%4>
    CLONE ir<%cmp19> = icmp slt ir<%31>, ir<0>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%5> = not ir<%cmp19>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%tobool25.not> = icmp eq ir<%31>, ir<0>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%7> = logical-and vp<%6>, ir<%tobool25.not>
    CLONE ir<%34> = load ir<%arc.175>, vp<%7>
    CLONE ir<%35> = load ir<%bigM>, vp<%7>
    CLONE ir<%sub> = add ir<%34>, ir<%operational_cost.077>
    CLONE ir<%add> = sub ir<%sub>, ir<%35>
    CLONE ir<%inc> = add ir<%fleet.076>, ir<1>
  Successor(s): land.lhs.true

  land.lhs.true:
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp19>
    CLONE ir<%head> = getelementptr inbounds ir<%arc.175>, ir<16>
    CLONE ir<%32> = load ir<%head>, vp<%8>
    CLONE ir<%number20> = getelementptr inbounds ir<%32>, ir<96>
    CLONE ir<%33> = load ir<%number20>, vp<%8>
    CLONE ir<%cmp21> = icmp sgt ir<%33>, ir<0>
  Successor(s): if.else27

  if.else27:
    EMIT vp<%9> = not ir<%cmp21>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    EMIT vp<%11> = not ir<%tobool25.not>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    CLONE ir<%36> = load ir<%arc.175>, vp<%13>
    CLONE ir<%add29> = add ir<%36>, ir<%operational_cost.077>
  Successor(s): for.inc33

  for.inc33:
    EMIT vp<%14> = or ir<%tobool.not>, vp<%7>
    EMIT vp<%15> = or vp<%14>, vp<%13>
    EMIT vp<%16> = logical-and vp<%8>, ir<%cmp21>
    EMIT vp<%17> = or vp<%15>, vp<%16>
    BLEND ir<%fleet.1> = ir<%fleet.076> ir<%fleet.076>/vp<%13> ir<%inc>/vp<%7> ir<%fleet.076>/ir<%tobool.not>
    BLEND ir<%operational_cost.1> = ir<%operational_cost.077> ir<%add29>/vp<%13> ir<%add>/vp<%7> ir<%operational_cost.077>/ir<%tobool.not>
    CLONE ir<%incdec.ptr34> = getelementptr inbounds ir<%arc.175>, ir<64>
    CLONE ir<%cmp15.not> = icmp eq ir<%incdec.ptr34>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = compute-reduction-result ir<%operational_cost.077>, ir<%operational_cost.1>
  EMIT vp<%21> = compute-reduction-result ir<%fleet.076>, ir<%fleet.1>
  EMIT vp<%22> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%22>
Successor(s): ir-bb<for.end35.loopexit>, scalar.ph

ir-bb<for.end35.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %fleet.1.lcssa = vp<%21>
Live-out i64 %operational_cost.1.lcssa = vp<%20>
}

========== Loop: flow_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-REDUCTION-PHI ir<%operational_cost.077> = phi ir<0>, ir<%operational_cost.1>
    WIDEN-REDUCTION-PHI ir<%fleet.076> = phi ir<0>, ir<%fleet.1>
    EMIT ir<%arc.175> = WIDEN-POINTER-INDUCTION ir<%1>, 64
    CLONE ir<%flow17> = getelementptr inbounds ir<%arc.175>, ir<48>
    INTERLEAVE-GROUP with factor 8 at %29, ir<%flow17>
      ir<%29> = load from index 0
    WIDEN ir<%tobool.not> = icmp eq ir<%29>, ir<0>
  Successor(s): if.then18

  if.then18:
    EMIT vp<%4> = not ir<%tobool.not>
    REPLICATE ir<%tail> = getelementptr inbounds ir<%arc.175>, ir<8>
    REPLICATE ir<%30> = load ir<%tail>, vp<%4>
    REPLICATE ir<%number> = getelementptr inbounds ir<%30>, ir<96>
    REPLICATE ir<%31> = load ir<%number>, vp<%4>
    WIDEN ir<%cmp19> = icmp slt ir<%31>, ir<0>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%5> = not ir<%cmp19>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%tobool25.not> = icmp eq ir<%31>, ir<0>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%7> = logical-and vp<%6>, ir<%tobool25.not>
    REPLICATE ir<%34> = load ir<%arc.175>, vp<%7>
    REPLICATE ir<%35> = load ir<%bigM>, vp<%7>
    WIDEN ir<%sub> = add ir<%34>, ir<%operational_cost.077>
    WIDEN ir<%add> = sub ir<%sub>, ir<%35>
    WIDEN ir<%inc> = add ir<%fleet.076>, ir<1>
  Successor(s): land.lhs.true

  land.lhs.true:
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp19>
    REPLICATE ir<%head> = getelementptr inbounds ir<%arc.175>, ir<16>
    REPLICATE ir<%32> = load ir<%head>, vp<%8>
    REPLICATE ir<%number20> = getelementptr inbounds ir<%32>, ir<96>
    REPLICATE ir<%33> = load ir<%number20>, vp<%8>
    WIDEN ir<%cmp21> = icmp sgt ir<%33>, ir<0>
  Successor(s): if.else27

  if.else27:
    EMIT vp<%9> = not ir<%cmp21>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    EMIT vp<%11> = not ir<%tobool25.not>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    REPLICATE ir<%36> = load ir<%arc.175>, vp<%13>
    WIDEN ir<%add29> = add ir<%36>, ir<%operational_cost.077>
  Successor(s): for.inc33

  for.inc33:
    EMIT vp<%14> = or ir<%tobool.not>, vp<%7>
    EMIT vp<%15> = or vp<%14>, vp<%13>
    EMIT vp<%16> = logical-and vp<%8>, ir<%cmp21>
    EMIT vp<%17> = or vp<%15>, vp<%16>
    BLEND ir<%fleet.1> = ir<%fleet.076> ir<%fleet.076>/vp<%13> ir<%inc>/vp<%7> ir<%fleet.076>/ir<%tobool.not>
    BLEND ir<%operational_cost.1> = ir<%operational_cost.077> ir<%add29>/vp<%13> ir<%add>/vp<%7> ir<%operational_cost.077>/ir<%tobool.not>
    REPLICATE ir<%incdec.ptr34> = getelementptr inbounds ir<%arc.175>, ir<64>
    CLONE ir<%cmp15.not> = icmp eq ir<%incdec.ptr34>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = compute-reduction-result ir<%operational_cost.077>, ir<%operational_cost.1>
  EMIT vp<%21> = compute-reduction-result ir<%fleet.076>, ir<%fleet.1>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: flow_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-REDUCTION-PHI ir<%operational_cost.077> = phi ir<0>, ir<%operational_cost.1>
    WIDEN-REDUCTION-PHI ir<%fleet.076> = phi ir<0>, ir<%fleet.1>
    EMIT ir<%arc.175> = WIDEN-POINTER-INDUCTION ir<%1>, 64
    WIDEN-GEP Var[Inv] ir<%flow17> = getelementptr inbounds ir<%arc.175>, ir<48>
    REPLICATE ir<%29> = load ir<%flow17>
    WIDEN ir<%tobool.not> = icmp eq ir<%29>, ir<0>
  Successor(s): if.then18

  if.then18:
    EMIT vp<%4> = not ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%tail> = getelementptr inbounds ir<%arc.175>, ir<8>
    REPLICATE ir<%30> = load ir<%tail>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%number> = getelementptr inbounds ir<%30>, ir<96>
    REPLICATE ir<%31> = load ir<%number>, vp<%4>
    WIDEN ir<%cmp19> = icmp slt ir<%31>, ir<0>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%5> = not ir<%cmp19>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%tobool25.not> = icmp eq ir<%31>, ir<0>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%7> = logical-and vp<%6>, ir<%tobool25.not>
    REPLICATE ir<%34> = load ir<%arc.175>, vp<%7>
    REPLICATE ir<%35> = load ir<%bigM>, vp<%7>
    WIDEN ir<%sub> = add ir<%34>, ir<%operational_cost.077>
    WIDEN ir<%add> = sub ir<%sub>, ir<%35>
    WIDEN ir<%inc> = add ir<%fleet.076>, ir<1>
  Successor(s): land.lhs.true

  land.lhs.true:
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp19>
    WIDEN-GEP Var[Inv] ir<%head> = getelementptr inbounds ir<%arc.175>, ir<16>
    REPLICATE ir<%32> = load ir<%head>, vp<%8>
    WIDEN-GEP Var[Inv] ir<%number20> = getelementptr inbounds ir<%32>, ir<96>
    REPLICATE ir<%33> = load ir<%number20>, vp<%8>
    WIDEN ir<%cmp21> = icmp sgt ir<%33>, ir<0>
  Successor(s): if.else27

  if.else27:
    EMIT vp<%9> = not ir<%cmp21>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    EMIT vp<%11> = not ir<%tobool25.not>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    REPLICATE ir<%36> = load ir<%arc.175>, vp<%13>
    WIDEN ir<%add29> = add ir<%36>, ir<%operational_cost.077>
  Successor(s): for.inc33

  for.inc33:
    EMIT vp<%14> = or ir<%tobool.not>, vp<%7>
    EMIT vp<%15> = or vp<%14>, vp<%13>
    EMIT vp<%16> = logical-and vp<%8>, ir<%cmp21>
    EMIT vp<%17> = or vp<%15>, vp<%16>
    BLEND ir<%fleet.1> = ir<%fleet.076> ir<%fleet.076>/vp<%13> ir<%inc>/vp<%7> ir<%fleet.076>/ir<%tobool.not>
    BLEND ir<%operational_cost.1> = ir<%operational_cost.077> ir<%add29>/vp<%13> ir<%add>/vp<%7> ir<%operational_cost.077>/ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr34> = getelementptr inbounds ir<%arc.175>, ir<64>
    CLONE ir<%cmp15.not> = icmp eq ir<%incdec.ptr34>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = compute-reduction-result ir<%operational_cost.077>, ir<%operational_cost.1>
  EMIT vp<%21> = compute-reduction-result ir<%fleet.076>, ir<%fleet.1>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: flow_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-REDUCTION-PHI ir<%operational_cost.077> = phi ir<0>, ir<%operational_cost.1>
    WIDEN-REDUCTION-PHI ir<%fleet.076> = phi ir<0>, ir<%fleet.1>
    EMIT ir<%arc.175> = WIDEN-POINTER-INDUCTION ir<%1>, 64
    WIDEN-GEP Var[Inv] ir<%flow17> = getelementptr inbounds ir<%arc.175>, ir<48>
    WIDEN ir<%29> = load ir<%flow17>
    WIDEN ir<%tobool.not> = icmp eq ir<%29>, ir<0>
  Successor(s): if.then18

  if.then18:
    EMIT vp<%4> = not ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%tail> = getelementptr inbounds ir<%arc.175>, ir<8>
    WIDEN ir<%30> = load ir<%tail>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%number> = getelementptr inbounds ir<%30>, ir<96>
    WIDEN ir<%31> = load ir<%number>, vp<%4>
    WIDEN ir<%cmp19> = icmp slt ir<%31>, ir<0>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%5> = not ir<%cmp19>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%tobool25.not> = icmp eq ir<%31>, ir<0>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%7> = logical-and vp<%6>, ir<%tobool25.not>
    WIDEN ir<%34> = load ir<%arc.175>, vp<%7>
    WIDEN ir<%35> = load ir<%bigM>, vp<%7>
    WIDEN ir<%sub> = add ir<%34>, ir<%operational_cost.077>
    WIDEN ir<%add> = sub ir<%sub>, ir<%35>
    WIDEN ir<%inc> = add ir<%fleet.076>, ir<1>
  Successor(s): land.lhs.true

  land.lhs.true:
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp19>
    WIDEN-GEP Var[Inv] ir<%head> = getelementptr inbounds ir<%arc.175>, ir<16>
    WIDEN ir<%32> = load ir<%head>, vp<%8>
    WIDEN-GEP Var[Inv] ir<%number20> = getelementptr inbounds ir<%32>, ir<96>
    WIDEN ir<%33> = load ir<%number20>, vp<%8>
    WIDEN ir<%cmp21> = icmp sgt ir<%33>, ir<0>
  Successor(s): if.else27

  if.else27:
    EMIT vp<%9> = not ir<%cmp21>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    EMIT vp<%11> = not ir<%tobool25.not>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    WIDEN ir<%36> = load ir<%arc.175>, vp<%13>
    WIDEN ir<%add29> = add ir<%36>, ir<%operational_cost.077>
  Successor(s): for.inc33

  for.inc33:
    EMIT vp<%14> = or ir<%tobool.not>, vp<%7>
    EMIT vp<%15> = or vp<%14>, vp<%13>
    EMIT vp<%16> = logical-and vp<%8>, ir<%cmp21>
    EMIT vp<%17> = or vp<%15>, vp<%16>
    BLEND ir<%fleet.1> = ir<%fleet.076> ir<%fleet.076>/vp<%13> ir<%inc>/vp<%7> ir<%fleet.076>/ir<%tobool.not>
    BLEND ir<%operational_cost.1> = ir<%operational_cost.077> ir<%add29>/vp<%13> ir<%add>/vp<%7> ir<%operational_cost.077>/ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr34> = getelementptr inbounds ir<%arc.175>, ir<64>
    CLONE ir<%cmp15.not> = icmp eq ir<%incdec.ptr34>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = compute-reduction-result ir<%operational_cost.077>, ir<%operational_cost.1>
  EMIT vp<%21> = compute-reduction-result ir<%fleet.076>, ir<%fleet.1>
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %34 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %36 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 10 for VF 2 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %34 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %36 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 18 for VF 2 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 18 for VF 2 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Vector loop of width 2 costs: 10500035
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 21000071
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 21000071, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 21000071
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 21000071, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 20 for VF 4 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %34 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %36 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 240 for VF 4 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 240 for VF 4 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Vector loop of width 4 costs: 5250136
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 21000546
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 21000546, CostB * EstimatedWidthA: 48
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 21000546
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 21000546, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %34 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %36 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %34 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %36 = load i64, ptr %arc.175, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Vector loop of width vscale x 2 costs: 85
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 343
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 343, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 343
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 343, CostB * EstimatedWidthA: 48
LV: Selecting VF: 1 With Cost: 12.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 0
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
========== Loop: flow_org_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%node.070>, 104
    EMIT ir<%.pn72> = WIDEN-POINTER-INDUCTION ir<%5>, 104
    CLONE ir<%flow7> = getelementptr inbounds ir<%.pn72>, ir<184>
    CLONE ir<%6> = load ir<%flow7>
    CLONE ir<%basic_arc> = getelementptr inbounds ir<%.pn72>, ir<152>
    CLONE ir<%7> = load ir<%basic_arc>
    CLONE ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    CLONE store ir<%6>, ir<%flow8>
    CLONE ir<%node.0> = getelementptr inbounds ir<%node.073>, ir<104>
    CLONE ir<%cmp5.not> = icmp eq ir<%node.0>, ir<%4>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: flow_org_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%node.070>, 104
    EMIT ir<%.pn72> = WIDEN-POINTER-INDUCTION ir<%5>, 104
    REPLICATE ir<%flow7> = getelementptr inbounds ir<%.pn72>, ir<184>
    REPLICATE ir<%6> = load ir<%flow7>
    REPLICATE ir<%basic_arc> = getelementptr inbounds ir<%.pn72>, ir<152>
    REPLICATE ir<%7> = load ir<%basic_arc>
    REPLICATE ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    REPLICATE store ir<%6>, ir<%flow8>
    WIDEN-GEP Var[Inv] ir<%node.0> = getelementptr inbounds ir<%node.073>, ir<104>
    CLONE ir<%cmp5.not> = icmp eq ir<%node.0>, ir<%4>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: flow_org_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%node.070>, 104
    EMIT ir<%.pn72> = WIDEN-POINTER-INDUCTION ir<%5>, 104
    WIDEN-GEP Var[Inv] ir<%flow7> = getelementptr inbounds ir<%.pn72>, ir<184>
    REPLICATE ir<%6> = load ir<%flow7>
    WIDEN-GEP Var[Inv] ir<%basic_arc> = getelementptr inbounds ir<%.pn72>, ir<152>
    REPLICATE ir<%7> = load ir<%basic_arc>
    WIDEN-GEP Var[Inv] ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    REPLICATE store ir<%6>, ir<%flow8>
    WIDEN-GEP Var[Inv] ir<%node.0> = getelementptr inbounds ir<%node.073>, ir<104>
    CLONE ir<%cmp5.not> = icmp eq ir<%node.0>, ir<%4>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: flow_org_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%node.070>, 104
    EMIT ir<%.pn72> = WIDEN-POINTER-INDUCTION ir<%5>, 104
    WIDEN-GEP Var[Inv] ir<%flow7> = getelementptr inbounds ir<%.pn72>, ir<184>
    WIDEN ir<%6> = load ir<%flow7>
    WIDEN-GEP Var[Inv] ir<%basic_arc> = getelementptr inbounds ir<%.pn72>, ir<152>
    WIDEN ir<%7> = load ir<%basic_arc>
    WIDEN-GEP Var[Inv] ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    WIDEN store ir<%flow8>, ir<%6>
    WIDEN-GEP Var[Inv] ir<%node.0> = getelementptr inbounds ir<%node.073>, ir<104>
    CLONE ir<%cmp5.not> = icmp eq ir<%node.0>, ir<%4>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %node.073 = phi ptr [ %node.0, %for.body6 ], [ %node.070, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %.pn72 = phi ptr [ %node.073, %for.body6 ], [ %5, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %flow7 = getelementptr inbounds i8, ptr %.pn72, i64 184 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load i64, ptr %flow7, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn72, i64 152 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load ptr, ptr %basic_arc, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %flow8 = getelementptr inbounds i8, ptr %7, i64 48 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %6, ptr %flow8, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5.not = icmp eq ptr %node.0, %4 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5.not, label %for.cond14.preheader.loopexit, label %for.body6 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %node.073 = phi ptr [ %node.0, %for.body6 ], [ %node.070, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %.pn72 = phi ptr [ %node.073, %for.body6 ], [ %5, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %flow7 = getelementptr inbounds i8, ptr %.pn72, i64 184 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %6 = load i64, ptr %flow7, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn72, i64 152 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %7 = load ptr, ptr %basic_arc, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %flow8 = getelementptr inbounds i8, ptr %7, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i64 %6, ptr %flow8, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5.not = icmp eq ptr %node.0, %4 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5.not, label %for.cond14.preheader.loopexit, label %for.body6 of type:br
LV: Vector loop of width 2 costs: 45
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 91
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 91, CostB * EstimatedWidthA: 14
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 91
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 91, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %node.073 = phi ptr [ %node.0, %for.body6 ], [ %node.070, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %.pn72 = phi ptr [ %node.073, %for.body6 ], [ %5, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %flow7 = getelementptr inbounds i8, ptr %.pn72, i64 184 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load i64, ptr %flow7, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn72, i64 152 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load ptr, ptr %basic_arc, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %flow8 = getelementptr inbounds i8, ptr %7, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %6, ptr %flow8, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5.not = icmp eq ptr %node.0, %4 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5.not, label %for.cond14.preheader.loopexit, label %for.body6 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %node.073 = phi ptr [ %node.0, %for.body6 ], [ %node.070, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %.pn72 = phi ptr [ %node.073, %for.body6 ], [ %5, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %flow7 = getelementptr inbounds i8, ptr %.pn72, i64 184 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %6 = load i64, ptr %flow7, align 8, !tbaa !19 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn72, i64 152 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %7 = load ptr, ptr %basic_arc, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %flow8 = getelementptr inbounds i8, ptr %7, i64 48 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %6, ptr %flow8, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp5.not = icmp eq ptr %node.0, %4 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5.not, label %for.cond14.preheader.loopexit, label %for.body6 of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 124
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 124, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 124
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 124, CostB * EstimatedWidthA: 28
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: flow_org_cost at line: mcfutil.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %5 to i64)) + (ptrtoint ptr %4 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<104>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<104>
    EMIT vp<%6> = ptradd ir<%5>, vp<%5>
    CLONE ir<%flow7> = getelementptr inbounds vp<%6>, ir<184>
    CLONE ir<%6> = load ir<%flow7>
    CLONE ir<%basic_arc> = getelementptr inbounds vp<%6>, ir<152>
    CLONE ir<%7> = load ir<%basic_arc>
    CLONE ir<%flow8> = getelementptr inbounds ir<%7>, ir<48>
    CLONE store ir<%6>, ir<%flow8>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond14.preheader.loopexit>, scalar.ph

ir-bb<for.cond14.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: flow_org_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-REDUCTION-PHI ir<%operational_cost.077> = phi ir<0>, ir<%operational_cost.1>
    WIDEN-REDUCTION-PHI ir<%fleet.076> = phi ir<0>, ir<%fleet.1>
    EMIT ir<%arc.175> = WIDEN-POINTER-INDUCTION ir<%1>, 64
    CLONE ir<%flow17> = getelementptr inbounds ir<%arc.175>, ir<48>
    CLONE ir<%29> = load ir<%flow17>
    CLONE ir<%tobool.not> = icmp eq ir<%29>, ir<0>
  Successor(s): if.then18

  if.then18:
    EMIT vp<%4> = not ir<%tobool.not>
    CLONE ir<%tail> = getelementptr inbounds ir<%arc.175>, ir<8>
    CLONE ir<%30> = load ir<%tail>, vp<%4>
    CLONE ir<%number> = getelementptr inbounds ir<%30>, ir<96>
    CLONE ir<%31> = load ir<%number>, vp<%4>
    CLONE ir<%cmp19> = icmp slt ir<%31>, ir<0>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%5> = not ir<%cmp19>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%tobool25.not> = icmp eq ir<%31>, ir<0>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%7> = logical-and vp<%6>, ir<%tobool25.not>
    CLONE ir<%org_cost> = getelementptr inbounds ir<%arc.175>, ir<56>
    CLONE ir<%34> = load ir<%org_cost>, vp<%7>
    CLONE ir<%35> = load ir<%bigM>, vp<%7>
    CLONE ir<%sub> = add ir<%34>, ir<%operational_cost.077>
    CLONE ir<%add> = sub ir<%sub>, ir<%35>
    CLONE ir<%inc> = add ir<%fleet.076>, ir<1>
  Successor(s): land.lhs.true

  land.lhs.true:
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp19>
    CLONE ir<%head> = getelementptr inbounds ir<%arc.175>, ir<16>
    CLONE ir<%32> = load ir<%head>, vp<%8>
    CLONE ir<%number20> = getelementptr inbounds ir<%32>, ir<96>
    CLONE ir<%33> = load ir<%number20>, vp<%8>
    CLONE ir<%cmp21> = icmp sgt ir<%33>, ir<0>
  Successor(s): if.else27

  if.else27:
    EMIT vp<%9> = not ir<%cmp21>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    EMIT vp<%11> = not ir<%tobool25.not>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    CLONE ir<%org_cost28> = getelementptr inbounds ir<%arc.175>, ir<56>
    CLONE ir<%36> = load ir<%org_cost28>, vp<%13>
    CLONE ir<%add29> = add ir<%36>, ir<%operational_cost.077>
  Successor(s): for.inc33

  for.inc33:
    EMIT vp<%14> = or ir<%tobool.not>, vp<%7>
    EMIT vp<%15> = or vp<%14>, vp<%13>
    EMIT vp<%16> = logical-and vp<%8>, ir<%cmp21>
    EMIT vp<%17> = or vp<%15>, vp<%16>
    BLEND ir<%fleet.1> = ir<%fleet.076> ir<%fleet.076>/vp<%13> ir<%inc>/vp<%7> ir<%fleet.076>/ir<%tobool.not>
    BLEND ir<%operational_cost.1> = ir<%operational_cost.077> ir<%add29>/vp<%13> ir<%add>/vp<%7> ir<%operational_cost.077>/ir<%tobool.not>
    CLONE ir<%incdec.ptr34> = getelementptr inbounds ir<%arc.175>, ir<64>
    CLONE ir<%cmp15.not> = icmp eq ir<%incdec.ptr34>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = compute-reduction-result ir<%operational_cost.077>, ir<%operational_cost.1>
  EMIT vp<%21> = compute-reduction-result ir<%fleet.076>, ir<%fleet.1>
  EMIT vp<%22> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%22>
Successor(s): ir-bb<for.end35.loopexit>, scalar.ph

ir-bb<for.end35.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %fleet.1.lcssa = vp<%21>
Live-out i64 %operational_cost.1.lcssa = vp<%20>
}

========== Loop: flow_org_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-REDUCTION-PHI ir<%operational_cost.077> = phi ir<0>, ir<%operational_cost.1>
    WIDEN-REDUCTION-PHI ir<%fleet.076> = phi ir<0>, ir<%fleet.1>
    EMIT ir<%arc.175> = WIDEN-POINTER-INDUCTION ir<%1>, 64
    CLONE ir<%flow17> = getelementptr inbounds ir<%arc.175>, ir<48>
    INTERLEAVE-GROUP with factor 8 at %29, ir<%flow17>
      ir<%29> = load from index 0
    WIDEN ir<%tobool.not> = icmp eq ir<%29>, ir<0>
  Successor(s): if.then18

  if.then18:
    EMIT vp<%4> = not ir<%tobool.not>
    REPLICATE ir<%tail> = getelementptr inbounds ir<%arc.175>, ir<8>
    REPLICATE ir<%30> = load ir<%tail>, vp<%4>
    REPLICATE ir<%number> = getelementptr inbounds ir<%30>, ir<96>
    REPLICATE ir<%31> = load ir<%number>, vp<%4>
    WIDEN ir<%cmp19> = icmp slt ir<%31>, ir<0>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%5> = not ir<%cmp19>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%tobool25.not> = icmp eq ir<%31>, ir<0>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%7> = logical-and vp<%6>, ir<%tobool25.not>
    REPLICATE ir<%org_cost> = getelementptr inbounds ir<%arc.175>, ir<56>
    REPLICATE ir<%34> = load ir<%org_cost>, vp<%7>
    REPLICATE ir<%35> = load ir<%bigM>, vp<%7>
    WIDEN ir<%sub> = add ir<%34>, ir<%operational_cost.077>
    WIDEN ir<%add> = sub ir<%sub>, ir<%35>
    WIDEN ir<%inc> = add ir<%fleet.076>, ir<1>
  Successor(s): land.lhs.true

  land.lhs.true:
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp19>
    REPLICATE ir<%head> = getelementptr inbounds ir<%arc.175>, ir<16>
    REPLICATE ir<%32> = load ir<%head>, vp<%8>
    REPLICATE ir<%number20> = getelementptr inbounds ir<%32>, ir<96>
    REPLICATE ir<%33> = load ir<%number20>, vp<%8>
    WIDEN ir<%cmp21> = icmp sgt ir<%33>, ir<0>
  Successor(s): if.else27

  if.else27:
    EMIT vp<%9> = not ir<%cmp21>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    EMIT vp<%11> = not ir<%tobool25.not>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    REPLICATE ir<%org_cost28> = getelementptr inbounds ir<%arc.175>, ir<56>
    REPLICATE ir<%36> = load ir<%org_cost28>, vp<%13>
    WIDEN ir<%add29> = add ir<%36>, ir<%operational_cost.077>
  Successor(s): for.inc33

  for.inc33:
    EMIT vp<%14> = or ir<%tobool.not>, vp<%7>
    EMIT vp<%15> = or vp<%14>, vp<%13>
    EMIT vp<%16> = logical-and vp<%8>, ir<%cmp21>
    EMIT vp<%17> = or vp<%15>, vp<%16>
    BLEND ir<%fleet.1> = ir<%fleet.076> ir<%fleet.076>/vp<%13> ir<%inc>/vp<%7> ir<%fleet.076>/ir<%tobool.not>
    BLEND ir<%operational_cost.1> = ir<%operational_cost.077> ir<%add29>/vp<%13> ir<%add>/vp<%7> ir<%operational_cost.077>/ir<%tobool.not>
    REPLICATE ir<%incdec.ptr34> = getelementptr inbounds ir<%arc.175>, ir<64>
    CLONE ir<%cmp15.not> = icmp eq ir<%incdec.ptr34>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = compute-reduction-result ir<%operational_cost.077>, ir<%operational_cost.1>
  EMIT vp<%21> = compute-reduction-result ir<%fleet.076>, ir<%fleet.1>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: flow_org_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-REDUCTION-PHI ir<%operational_cost.077> = phi ir<0>, ir<%operational_cost.1>
    WIDEN-REDUCTION-PHI ir<%fleet.076> = phi ir<0>, ir<%fleet.1>
    EMIT ir<%arc.175> = WIDEN-POINTER-INDUCTION ir<%1>, 64
    WIDEN-GEP Var[Inv] ir<%flow17> = getelementptr inbounds ir<%arc.175>, ir<48>
    REPLICATE ir<%29> = load ir<%flow17>
    WIDEN ir<%tobool.not> = icmp eq ir<%29>, ir<0>
  Successor(s): if.then18

  if.then18:
    EMIT vp<%4> = not ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%tail> = getelementptr inbounds ir<%arc.175>, ir<8>
    REPLICATE ir<%30> = load ir<%tail>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%number> = getelementptr inbounds ir<%30>, ir<96>
    REPLICATE ir<%31> = load ir<%number>, vp<%4>
    WIDEN ir<%cmp19> = icmp slt ir<%31>, ir<0>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%5> = not ir<%cmp19>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%tobool25.not> = icmp eq ir<%31>, ir<0>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%7> = logical-and vp<%6>, ir<%tobool25.not>
    WIDEN-GEP Var[Inv] ir<%org_cost> = getelementptr inbounds ir<%arc.175>, ir<56>
    REPLICATE ir<%34> = load ir<%org_cost>, vp<%7>
    REPLICATE ir<%35> = load ir<%bigM>, vp<%7>
    WIDEN ir<%sub> = add ir<%34>, ir<%operational_cost.077>
    WIDEN ir<%add> = sub ir<%sub>, ir<%35>
    WIDEN ir<%inc> = add ir<%fleet.076>, ir<1>
  Successor(s): land.lhs.true

  land.lhs.true:
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp19>
    WIDEN-GEP Var[Inv] ir<%head> = getelementptr inbounds ir<%arc.175>, ir<16>
    REPLICATE ir<%32> = load ir<%head>, vp<%8>
    WIDEN-GEP Var[Inv] ir<%number20> = getelementptr inbounds ir<%32>, ir<96>
    REPLICATE ir<%33> = load ir<%number20>, vp<%8>
    WIDEN ir<%cmp21> = icmp sgt ir<%33>, ir<0>
  Successor(s): if.else27

  if.else27:
    EMIT vp<%9> = not ir<%cmp21>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    EMIT vp<%11> = not ir<%tobool25.not>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    WIDEN-GEP Var[Inv] ir<%org_cost28> = getelementptr inbounds ir<%arc.175>, ir<56>
    REPLICATE ir<%36> = load ir<%org_cost28>, vp<%13>
    WIDEN ir<%add29> = add ir<%36>, ir<%operational_cost.077>
  Successor(s): for.inc33

  for.inc33:
    EMIT vp<%14> = or ir<%tobool.not>, vp<%7>
    EMIT vp<%15> = or vp<%14>, vp<%13>
    EMIT vp<%16> = logical-and vp<%8>, ir<%cmp21>
    EMIT vp<%17> = or vp<%15>, vp<%16>
    BLEND ir<%fleet.1> = ir<%fleet.076> ir<%fleet.076>/vp<%13> ir<%inc>/vp<%7> ir<%fleet.076>/ir<%tobool.not>
    BLEND ir<%operational_cost.1> = ir<%operational_cost.077> ir<%add29>/vp<%13> ir<%add>/vp<%7> ir<%operational_cost.077>/ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr34> = getelementptr inbounds ir<%arc.175>, ir<64>
    CLONE ir<%cmp15.not> = icmp eq ir<%incdec.ptr34>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = compute-reduction-result ir<%operational_cost.077>, ir<%operational_cost.1>
  EMIT vp<%21> = compute-reduction-result ir<%fleet.076>, ir<%fleet.1>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: flow_org_cost' from mcfutil.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body16.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %1 to i64)) + (ptrtoint ptr %0 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-REDUCTION-PHI ir<%operational_cost.077> = phi ir<0>, ir<%operational_cost.1>
    WIDEN-REDUCTION-PHI ir<%fleet.076> = phi ir<0>, ir<%fleet.1>
    EMIT ir<%arc.175> = WIDEN-POINTER-INDUCTION ir<%1>, 64
    WIDEN-GEP Var[Inv] ir<%flow17> = getelementptr inbounds ir<%arc.175>, ir<48>
    WIDEN ir<%29> = load ir<%flow17>
    WIDEN ir<%tobool.not> = icmp eq ir<%29>, ir<0>
  Successor(s): if.then18

  if.then18:
    EMIT vp<%4> = not ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%tail> = getelementptr inbounds ir<%arc.175>, ir<8>
    WIDEN ir<%30> = load ir<%tail>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%number> = getelementptr inbounds ir<%30>, ir<96>
    WIDEN ir<%31> = load ir<%number>, vp<%4>
    WIDEN ir<%cmp19> = icmp slt ir<%31>, ir<0>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%5> = not ir<%cmp19>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%tobool25.not> = icmp eq ir<%31>, ir<0>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%7> = logical-and vp<%6>, ir<%tobool25.not>
    WIDEN-GEP Var[Inv] ir<%org_cost> = getelementptr inbounds ir<%arc.175>, ir<56>
    WIDEN ir<%34> = load ir<%org_cost>, vp<%7>
    WIDEN ir<%35> = load ir<%bigM>, vp<%7>
    WIDEN ir<%sub> = add ir<%34>, ir<%operational_cost.077>
    WIDEN ir<%add> = sub ir<%sub>, ir<%35>
    WIDEN ir<%inc> = add ir<%fleet.076>, ir<1>
  Successor(s): land.lhs.true

  land.lhs.true:
    EMIT vp<%8> = logical-and vp<%4>, ir<%cmp19>
    WIDEN-GEP Var[Inv] ir<%head> = getelementptr inbounds ir<%arc.175>, ir<16>
    WIDEN ir<%32> = load ir<%head>, vp<%8>
    WIDEN-GEP Var[Inv] ir<%number20> = getelementptr inbounds ir<%32>, ir<96>
    WIDEN ir<%33> = load ir<%number20>, vp<%8>
    WIDEN ir<%cmp21> = icmp sgt ir<%33>, ir<0>
  Successor(s): if.else27

  if.else27:
    EMIT vp<%9> = not ir<%cmp21>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    EMIT vp<%11> = not ir<%tobool25.not>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    WIDEN-GEP Var[Inv] ir<%org_cost28> = getelementptr inbounds ir<%arc.175>, ir<56>
    WIDEN ir<%36> = load ir<%org_cost28>, vp<%13>
    WIDEN ir<%add29> = add ir<%36>, ir<%operational_cost.077>
  Successor(s): for.inc33

  for.inc33:
    EMIT vp<%14> = or ir<%tobool.not>, vp<%7>
    EMIT vp<%15> = or vp<%14>, vp<%13>
    EMIT vp<%16> = logical-and vp<%8>, ir<%cmp21>
    EMIT vp<%17> = or vp<%15>, vp<%16>
    BLEND ir<%fleet.1> = ir<%fleet.076> ir<%fleet.076>/vp<%13> ir<%inc>/vp<%7> ir<%fleet.076>/ir<%tobool.not>
    BLEND ir<%operational_cost.1> = ir<%operational_cost.077> ir<%add29>/vp<%13> ir<%add>/vp<%7> ir<%operational_cost.077>/ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr34> = getelementptr inbounds ir<%arc.175>, ir<64>
    CLONE ir<%cmp15.not> = icmp eq ir<%incdec.ptr34>, ir<%0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = compute-reduction-result ir<%operational_cost.077>, ir<%operational_cost.1>
  EMIT vp<%21> = compute-reduction-result ir<%fleet.076>, ir<%fleet.1>
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %org_cost = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %34 = load i64, ptr %org_cost, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %org_cost28 = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %36 = load i64, ptr %org_cost28, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 10 for VF 2 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %org_cost = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %34 = load i64, ptr %org_cost, align 8, !tbaa !30 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %org_cost28 = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %36 = load i64, ptr %org_cost28, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 18 for VF 2 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 18 for VF 2 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Vector loop of width 2 costs: 10500035
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 21000071
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 21000071, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 21000071
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 21000071, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 20 for VF 4 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %org_cost = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %34 = load i64, ptr %org_cost, align 8, !tbaa !30 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %org_cost28 = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %36 = load i64, ptr %org_cost28, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 240 for VF 4 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 240 for VF 4 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Vector loop of width 4 costs: 5250136
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 21000546
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 21000546, CostB * EstimatedWidthA: 48
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 21000546
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 21000546, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %org_cost = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %34 = load i64, ptr %org_cost, align 8, !tbaa !30 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %org_cost28 = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %36 = load i64, ptr %org_cost28, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %operational_cost.077 = phi i64 [ 0, %for.body16.lr.ph ], [ %operational_cost.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fleet.076 = phi i64 [ 0, %for.body16.lr.ph ], [ %fleet.1, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arc.175 = phi ptr [ %1, %for.body16.lr.ph ], [ %incdec.ptr34, %for.inc33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %flow17 = getelementptr inbounds i8, ptr %arc.175, i64 48 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %29 = load i64, ptr %flow17, align 8, !tbaa !22 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i64 %29, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %for.inc33, label %if.then18 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.175, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %30 = load ptr, ptr %tail, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %number = getelementptr inbounds i8, ptr %30, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %31 = load i32, ptr %number, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp19 = icmp slt i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp19, label %land.lhs.true, label %if.then22 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool25.not = icmp eq i32 %31, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool25.not, label %if.then26, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %org_cost = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %34 = load i64, ptr %org_cost, align 8, !tbaa !30 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %35 = load i64, ptr %bigM, align 8, !tbaa !31 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = add i64 %34, %operational_cost.077 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add = sub i64 %sub, %35 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i64 %fleet.076, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %head = getelementptr inbounds i8, ptr %arc.175, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %32 = load ptr, ptr %head, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %number20 = getelementptr inbounds i8, ptr %32, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %33 = load i32, ptr %number20, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp21 = icmp sgt i32 %33, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp21, label %for.inc33, label %if.else27 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %org_cost28 = getelementptr inbounds i8, ptr %arc.175, i64 56 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %36 = load i64, ptr %org_cost28, align 8, !tbaa !30 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add29 = add nsw i64 %36, %operational_cost.077 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc33 of type:br

-----------------Function that is being costed:'flow_org_cost' from mcfutil.c-----------------
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %fleet.1 = phi i64 [ %fleet.076, %land.lhs.true ], [ %fleet.076, %if.else27 ], [ %inc, %if.then26 ], [ %fleet.076, %for.body16 ] of type:phi
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %operational_cost.1 = phi i64 [ %operational_cost.077, %land.lhs.true ], [ %add29, %if.else27 ], [ %add, %if.then26 ], [ %operational_cost.077, %for.body16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr34 = getelementptr inbounds i8, ptr %arc.175, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp15.not = icmp eq ptr %incdec.ptr34, %0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp15.not, label %for.end35.loopexit, label %for.body16 of type:br
LV: Vector loop of width vscale x 2 costs: 85
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 343
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 343, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 343
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 343, CostB * EstimatedWidthA: 48
LV: Selecting VF: 1 With Cost: 12.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 0
Loops Analyzed: 10
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o readmin.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                readmin.c
========== Loop: read_min' from readmin.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%34> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %i.2416 = phi 1, %inc227, ir<1>
    CLONE ir<%mul208> = mul nuw nsw ir<%i.2416>, ir<3>
    CLONE ir<%sub209> = add nsw ir<%mul208>, ir<-1>
    CLONE ir<%arrayidx210> = getelementptr inbounds ir<%36>, ir<%sub209>
    CLONE store ir<%mul206>, ir<%arrayidx210>
    CLONE ir<%org_cost225> = getelementptr inbounds ir<%36>, ir<%sub209>, ir<7>
    CLONE store ir<%mul206>, ir<%org_cost225>
    CLONE ir<%inc227> = add nuw ir<%i.2416>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%i.2416>, ir<%34>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%34>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: read_min' from readmin.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%34> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %i.2416 = phi 1, %inc227, ir<1>
    WIDEN ir<%mul208> = mul nuw nsw ir<%i.2416>, ir<3>
    WIDEN ir<%sub209> = add nsw ir<%mul208>, ir<-1>
    REPLICATE ir<%arrayidx210> = getelementptr inbounds ir<%36>, ir<%sub209>
    REPLICATE store ir<%mul206>, ir<%arrayidx210>
    REPLICATE ir<%org_cost225> = getelementptr inbounds ir<%36>, ir<%sub209>, ir<7>
    REPLICATE store ir<%mul206>, ir<%org_cost225>
    WIDEN ir<%inc227> = add nuw ir<%i.2416>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%i.2416>, ir<%34>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%34>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: read_min' from readmin.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%34> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %i.2416 = phi 1, %inc227, ir<1>
    WIDEN ir<%mul208> = mul nuw nsw ir<%i.2416>, ir<3>
    WIDEN ir<%sub209> = add nsw ir<%mul208>, ir<-1>
    WIDEN-GEP Inv[Var] ir<%arrayidx210> = getelementptr inbounds ir<%36>, ir<%sub209>
    REPLICATE store ir<%mul206>, ir<%arrayidx210>
    WIDEN-GEP Inv[Var][Inv] ir<%org_cost225> = getelementptr inbounds ir<%36>, ir<%sub209>, ir<7>
    REPLICATE store ir<%mul206>, ir<%org_cost225>
    WIDEN ir<%inc227> = add nuw ir<%i.2416>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%i.2416>, ir<%34>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%34>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: read_min' from readmin.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%34> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %i.2416 = phi 1, %inc227, ir<1>
    WIDEN ir<%mul208> = mul nuw nsw ir<%i.2416>, ir<3>
    WIDEN ir<%sub209> = add nsw ir<%mul208>, ir<-1>
    WIDEN-GEP Inv[Var] ir<%arrayidx210> = getelementptr inbounds ir<%36>, ir<%sub209>
    WIDEN store ir<%arrayidx210>, ir<%mul206>
    WIDEN-GEP Inv[Var][Inv] ir<%org_cost225> = getelementptr inbounds ir<%36>, ir<%sub209>, ir<7>
    WIDEN store ir<%org_cost225>, ir<%mul206>
    WIDEN ir<%inc227> = add nuw ir<%i.2416>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%i.2416>, ir<%34>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%34>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'read_min' from readmin.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.2416 = phi i64 [ 1, %for.body197.lr.ph ], [ %inc227, %for.body197 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul208 = mul nuw nsw i64 %i.2416, 3 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub209 = add nsw i64 %mul208, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx210 = getelementptr inbounds %struct.arc, ptr %36, i64 %sub209 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %mul206, ptr %arrayidx210, align 8, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %org_cost225 = getelementptr inbounds %struct.arc, ptr %36, i64 %sub209, i32 7 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 %mul206, ptr %org_cost225, align 8, !tbaa !34 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc227 = add nuw i64 %i.2416, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %i.2416, %34 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body197 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'read_min' from readmin.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.2416 = phi i64 [ 1, %for.body197.lr.ph ], [ %inc227, %for.body197 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul208 = mul nuw nsw i64 %i.2416, 3 of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub209 = add nsw i64 %mul208, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx210 = getelementptr inbounds %struct.arc, ptr %36, i64 %sub209 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i64 %mul206, ptr %arrayidx210, align 8, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %org_cost225 = getelementptr inbounds %struct.arc, ptr %36, i64 %sub209, i32 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i64 %mul206, ptr %org_cost225, align 8, !tbaa !34 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc227 = add nuw i64 %i.2416, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %i.2416, %34 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body197 of type:br
LV: Vector loop of width 2 costs: 28
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 56
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 16
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 56
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'read_min' from readmin.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.2416 = phi i64 [ 1, %for.body197.lr.ph ], [ %inc227, %for.body197 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul208 = mul nuw nsw i64 %i.2416, 3 of type:mul
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub209 = add nsw i64 %mul208, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx210 = getelementptr inbounds %struct.arc, ptr %36, i64 %sub209 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %mul206, ptr %arrayidx210, align 8, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %org_cost225 = getelementptr inbounds %struct.arc, ptr %36, i64 %sub209, i32 7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 %mul206, ptr %org_cost225, align 8, !tbaa !34 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc227 = add nuw i64 %i.2416, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %i.2416, %34 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body197 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'read_min' from readmin.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.2416 = phi i64 [ 1, %for.body197.lr.ph ], [ %inc227, %for.body197 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul208 = mul nuw nsw i64 %i.2416, 3 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub209 = add nsw i64 %mul208, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx210 = getelementptr inbounds %struct.arc, ptr %36, i64 %sub209 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %mul206, ptr %arrayidx210, align 8, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %org_cost225 = getelementptr inbounds %struct.arc, ptr %36, i64 %sub209, i32 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 %mul206, ptr %org_cost225, align 8, !tbaa !34 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc227 = add nuw i64 %i.2416, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %i.2416, %34 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body197 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 86
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 86, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 86
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 86, CostB * EstimatedWidthA: 32
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: read_min at line: readmin.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%34> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%3>    = DERIVED-IV ir<1> + vp<%2> * ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%mul208> = mul nuw nsw vp<%4>, ir<3>
    CLONE ir<%sub209> = add nsw ir<%mul208>, ir<-1>
    CLONE ir<%arrayidx210> = getelementptr inbounds ir<%36>, ir<%sub209>
    CLONE store ir<%mul206>, ir<%arrayidx210>
    CLONE ir<%org_cost225> = getelementptr inbounds ir<%36>, ir<%sub209>, ir<7>
    CLONE store ir<%mul206>, ir<%org_cost225>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%34>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o implicit.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                implicit.c
LV: Decision: Scalarize
========== Loop: resize_prob' from implicit.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (1 umin (-208 + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64)))))<nuw><nsw> + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64))) /u 104) + (1 umin (-208 + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64)))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%node.041> = WIDEN-POINTER-INDUCTION ir<%node.038>, 104
    EMIT ir<%.pn40> = WIDEN-POINTER-INDUCTION ir<%9>, 104
    CLONE ir<%pred> = getelementptr inbounds ir<%.pn40>, ir<128>
    CLONE ir<%11> = load ir<%pred>
    CLONE ir<%cmp8.not> = icmp eq ir<%11>, ir<%9>
  Successor(s): if.then9

  if.then9:
    EMIT vp<%4> = not ir<%cmp8.not>
    CLONE ir<%basic_arc> = getelementptr inbounds ir<%.pn40>, ir<152>
    CLONE ir<%12> = load ir<%basic_arc>, vp<%4>
    CLONE ir<%13> = ptrtoint ir<%12>
    CLONE ir<%add10> = add ir<%sub>, ir<%13>
    CLONE ir<%14> = inttoptr ir<%add10>
    CLONE store ir<%14>, ir<%basic_arc>, vp<%4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = or ir<%cmp8.not>, vp<%4>
    CLONE ir<%node.0> = getelementptr inbounds ir<%node.041>, ir<104>
    CLONE ir<%cmp> = icmp ult ir<%node.0>, ir<%10>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: resize_prob' from implicit.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (1 umin (-208 + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64)))))<nuw><nsw> + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64))) /u 104) + (1 umin (-208 + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64)))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%node.041> = WIDEN-POINTER-INDUCTION ir<%node.038>, 104
    EMIT ir<%.pn40> = WIDEN-POINTER-INDUCTION ir<%9>, 104
    REPLICATE ir<%pred> = getelementptr inbounds ir<%.pn40>, ir<128>
    REPLICATE ir<%11> = load ir<%pred>
    WIDEN ir<%cmp8.not> = icmp eq ir<%11>, ir<%9>
  Successor(s): if.then9

  if.then9:
    EMIT vp<%4> = not ir<%cmp8.not>
    REPLICATE ir<%basic_arc> = getelementptr inbounds ir<%.pn40>, ir<152>
    REPLICATE ir<%12> = load ir<%basic_arc>, vp<%4>
    REPLICATE ir<%13> = ptrtoint ir<%12>
    REPLICATE ir<%add10> = add ir<%sub>, ir<%13>
    REPLICATE ir<%14> = inttoptr ir<%add10>
    REPLICATE store ir<%14>, ir<%basic_arc>, vp<%4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = or ir<%cmp8.not>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%node.0> = getelementptr inbounds ir<%node.041>, ir<104>
    CLONE ir<%cmp> = icmp ult ir<%node.0>, ir<%10>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: resize_prob' from implicit.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (1 umin (-208 + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64)))))<nuw><nsw> + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64))) /u 104) + (1 umin (-208 + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64)))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%node.041> = WIDEN-POINTER-INDUCTION ir<%node.038>, 104
    EMIT ir<%.pn40> = WIDEN-POINTER-INDUCTION ir<%9>, 104
    WIDEN-GEP Var[Inv] ir<%pred> = getelementptr inbounds ir<%.pn40>, ir<128>
    REPLICATE ir<%11> = load ir<%pred>
    WIDEN ir<%cmp8.not> = icmp eq ir<%11>, ir<%9>
  Successor(s): if.then9

  if.then9:
    EMIT vp<%4> = not ir<%cmp8.not>
    WIDEN-GEP Var[Inv] ir<%basic_arc> = getelementptr inbounds ir<%.pn40>, ir<152>
    REPLICATE ir<%12> = load ir<%basic_arc>, vp<%4>
    WIDEN-CAST ir<%13> = ptrtoint  ir<%12> to i64
    WIDEN ir<%add10> = add ir<%sub>, ir<%13>
    WIDEN-CAST ir<%14> = inttoptr  ir<%add10> to ptr
    REPLICATE store ir<%14>, ir<%basic_arc>, vp<%4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = or ir<%cmp8.not>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%node.0> = getelementptr inbounds ir<%node.041>, ir<104>
    CLONE ir<%cmp> = icmp ult ir<%node.0>, ir<%10>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: resize_prob' from implicit.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (1 umin (-208 + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64)))))<nuw><nsw> + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64))) /u 104) + (1 umin (-208 + (-1 * (ptrtoint ptr %9 to i64)) + ((208 + (ptrtoint ptr %9 to i64)) umax (ptrtoint ptr %10 to i64)))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%node.041> = WIDEN-POINTER-INDUCTION ir<%node.038>, 104
    EMIT ir<%.pn40> = WIDEN-POINTER-INDUCTION ir<%9>, 104
    WIDEN-GEP Var[Inv] ir<%pred> = getelementptr inbounds ir<%.pn40>, ir<128>
    WIDEN ir<%11> = load ir<%pred>
    WIDEN ir<%cmp8.not> = icmp eq ir<%11>, ir<%9>
  Successor(s): if.then9

  if.then9:
    EMIT vp<%4> = not ir<%cmp8.not>
    WIDEN-GEP Var[Inv] ir<%basic_arc> = getelementptr inbounds ir<%.pn40>, ir<152>
    WIDEN ir<%12> = load ir<%basic_arc>, vp<%4>
    WIDEN-CAST ir<%13> = ptrtoint  ir<%12> to i64
    WIDEN ir<%add10> = add ir<%sub>, ir<%13>
    WIDEN-CAST ir<%14> = inttoptr  ir<%add10> to ptr
    WIDEN store ir<%basic_arc>, ir<%14>, vp<%4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = or ir<%cmp8.not>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%node.0> = getelementptr inbounds ir<%node.041>, ir<104>
    CLONE ir<%cmp> = icmp ult ir<%node.0>, ir<%10>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %node.041 = phi ptr [ %node.0, %for.inc ], [ %node.038, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %.pn40 = phi ptr [ %node.041, %for.inc ], [ %9, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %pred = getelementptr inbounds i8, ptr %.pn40, i64 128 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %11 = load ptr, ptr %pred, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp8.not = icmp eq ptr %11, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp8.not, label %for.inc, label %if.then9 of type:br

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn40, i64 152 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load ptr, ptr %basic_arc, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %13 = ptrtoint ptr %12 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add10 = add i64 %sub, %13 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %14 = inttoptr i64 %add10 to ptr of type:inttoptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %14, ptr %basic_arc, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.041, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ult ptr %node.0, %10 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %for.body, label %cleanup.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %node.041 = phi ptr [ %node.0, %for.inc ], [ %node.038, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %.pn40 = phi ptr [ %node.041, %for.inc ], [ %9, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %pred = getelementptr inbounds i8, ptr %.pn40, i64 128 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %11 = load ptr, ptr %pred, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp8.not = icmp eq ptr %11, %9 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp8.not, label %for.inc, label %if.then9 of type:br

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn40, i64 152 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %12 = load ptr, ptr %basic_arc, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %13 = ptrtoint ptr %12 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add10 = add i64 %sub, %13 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %14 = inttoptr i64 %add10 to ptr of type:inttoptr
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %14, ptr %basic_arc, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.041, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ult ptr %node.0, %10 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %for.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 2 costs: 1500020
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3000041
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 3000041, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3000041
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 3000041, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %node.041 = phi ptr [ %node.0, %for.inc ], [ %node.038, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %.pn40 = phi ptr [ %node.041, %for.inc ], [ %9, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %pred = getelementptr inbounds i8, ptr %.pn40, i64 128 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = load ptr, ptr %pred, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp8.not = icmp eq ptr %11, %9 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp8.not, label %for.inc, label %if.then9 of type:br

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn40, i64 152 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load ptr, ptr %basic_arc, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %13 = ptrtoint ptr %12 to i64 of type:ptrtoint
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add10 = add i64 %sub, %13 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %14 = inttoptr i64 %add10 to ptr of type:inttoptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %14, ptr %basic_arc, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.041, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ult ptr %node.0, %10 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %for.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %node.041 = phi ptr [ %node.0, %for.inc ], [ %node.038, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %.pn40 = phi ptr [ %node.041, %for.inc ], [ %9, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %pred = getelementptr inbounds i8, ptr %.pn40, i64 128 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %11 = load ptr, ptr %pred, align 8, !tbaa !21 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp8.not = icmp eq ptr %11, %9 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp8.not, label %for.inc, label %if.then9 of type:br

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %basic_arc = getelementptr inbounds i8, ptr %.pn40, i64 152 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %12 = load ptr, ptr %basic_arc, align 8, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %13 = ptrtoint ptr %12 to i64 of type:ptrtoint
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add10 = add i64 %sub, %13 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %14 = inttoptr i64 %add10 to ptr of type:inttoptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %14, ptr %basic_arc, align 8, !tbaa !24 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'resize_prob' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %node.0 = getelementptr inbounds i8, ptr %node.041, i64 104 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ult ptr %node.0, %10 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %for.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 31
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 126
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 126, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 126
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 126, CostB * EstimatedWidthA: 24
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
========== Loop: price_out_impl' from implicit.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (64 * %new_arcs.3)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%arcnew.0230> = WIDEN-POINTER-INDUCTION ir<%32>, 64
    CLONE ir<%flow82> = getelementptr inbounds ir<%arcnew.0230>, ir<48>
    CLONE store ir<0>, ir<%flow82>
    CLONE ir<%ident83> = getelementptr inbounds ir<%arcnew.0230>, ir<24>
    CLONE store ir<1>, ir<%ident83>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%arcnew.0230>, ir<64>
    CLONE ir<%cmp79.not> = icmp eq ir<%incdec.ptr>, ir<%add.ptr74>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end103.loopexit263>, scalar.ph

ir-bb<if.end103.loopexit263>:
No successors

scalar.ph:
No successors
}

========== Loop: price_out_impl' from implicit.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (64 * %new_arcs.3)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%arcnew.0230> = WIDEN-POINTER-INDUCTION ir<%32>, 64
    REPLICATE ir<%flow82> = getelementptr inbounds ir<%arcnew.0230>, ir<48>
    REPLICATE store ir<0>, ir<%flow82>
    REPLICATE ir<%ident83> = getelementptr inbounds ir<%arcnew.0230>, ir<24>
    REPLICATE store ir<1>, ir<%ident83>
    REPLICATE ir<%incdec.ptr> = getelementptr inbounds ir<%arcnew.0230>, ir<64>
    CLONE ir<%cmp79.not> = icmp eq ir<%incdec.ptr>, ir<%add.ptr74>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end103.loopexit263>, scalar.ph

ir-bb<if.end103.loopexit263>:
No successors

scalar.ph:
No successors
}

========== Loop: price_out_impl' from implicit.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (64 * %new_arcs.3)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%arcnew.0230> = WIDEN-POINTER-INDUCTION ir<%32>, 64
    WIDEN-GEP Var[Inv] ir<%flow82> = getelementptr inbounds ir<%arcnew.0230>, ir<48>
    REPLICATE store ir<0>, ir<%flow82>
    WIDEN-GEP Var[Inv] ir<%ident83> = getelementptr inbounds ir<%arcnew.0230>, ir<24>
    REPLICATE store ir<1>, ir<%ident83>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%arcnew.0230>, ir<64>
    CLONE ir<%cmp79.not> = icmp eq ir<%incdec.ptr>, ir<%add.ptr74>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end103.loopexit263>, scalar.ph

ir-bb<if.end103.loopexit263>:
No successors

scalar.ph:
No successors
}

========== Loop: price_out_impl' from implicit.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (64 * %new_arcs.3)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%arcnew.0230> = WIDEN-POINTER-INDUCTION ir<%32>, 64
    WIDEN-GEP Var[Inv] ir<%flow82> = getelementptr inbounds ir<%arcnew.0230>, ir<48>
    WIDEN store ir<%flow82>, ir<0>
    WIDEN-GEP Var[Inv] ir<%ident83> = getelementptr inbounds ir<%arcnew.0230>, ir<24>
    WIDEN store ir<%ident83>, ir<1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%arcnew.0230>, ir<64>
    CLONE ir<%cmp79.not> = icmp eq ir<%incdec.ptr>, ir<%add.ptr74>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end103.loopexit263>, scalar.ph

ir-bb<if.end103.loopexit263>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'price_out_impl' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arcnew.0230 = phi ptr [ %incdec.ptr, %for.body81 ], [ %32, %for.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %flow82 = getelementptr inbounds i8, ptr %arcnew.0230, i64 48 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 0, ptr %flow82, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ident83 = getelementptr inbounds i8, ptr %arcnew.0230, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %ident83, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %arcnew.0230, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp79.not = icmp eq ptr %incdec.ptr, %add.ptr74 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp79.not, label %if.end103.loopexit263, label %for.body81 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'price_out_impl' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arcnew.0230 = phi ptr [ %incdec.ptr, %for.body81 ], [ %32, %for.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %flow82 = getelementptr inbounds i8, ptr %arcnew.0230, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i64 0, ptr %flow82, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ident83 = getelementptr inbounds i8, ptr %arcnew.0230, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 1, ptr %ident83, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %arcnew.0230, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp79.not = icmp eq ptr %incdec.ptr, %add.ptr74 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp79.not, label %if.end103.loopexit263, label %for.body81 of type:br
LV: Vector loop of width 2 costs: 8

-----------------Function that is being costed:'price_out_impl' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arcnew.0230 = phi ptr [ %incdec.ptr, %for.body81 ], [ %32, %for.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %flow82 = getelementptr inbounds i8, ptr %arcnew.0230, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i64 0, ptr %flow82, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ident83 = getelementptr inbounds i8, ptr %arcnew.0230, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 1, ptr %ident83, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %arcnew.0230, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp79.not = icmp eq ptr %incdec.ptr, %add.ptr74 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp79.not, label %if.end103.loopexit263, label %for.body81 of type:br
LV: Vector loop of width 4 costs: 8

-----------------Function that is being costed:'price_out_impl' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arcnew.0230 = phi ptr [ %incdec.ptr, %for.body81 ], [ %32, %for.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %flow82 = getelementptr inbounds i8, ptr %arcnew.0230, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 0, ptr %flow82, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ident83 = getelementptr inbounds i8, ptr %arcnew.0230, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %ident83, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %arcnew.0230, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp79.not = icmp eq ptr %incdec.ptr, %add.ptr74 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp79.not, label %if.end103.loopexit263, label %for.body81 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'price_out_impl' from implicit.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arcnew.0230 = phi ptr [ %incdec.ptr, %for.body81 ], [ %32, %for.body81.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %flow82 = getelementptr inbounds i8, ptr %arcnew.0230, i64 48 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 0, ptr %flow82, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ident83 = getelementptr inbounds i8, ptr %arcnew.0230, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 1, ptr %ident83, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %arcnew.0230, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp79.not = icmp eq ptr %incdec.ptr, %add.ptr74 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp79.not, label %if.end103.loopexit263, label %for.body81 of type:br
LV: Vector loop of width vscale x 2 costs: 20
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 83
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 83, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 83
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 83, CostB * EstimatedWidthA: 20
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: price_out_impl at line: implicit.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body81.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (64 * %new_arcs.3)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<64>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<64>
    EMIT vp<%6> = ptradd ir<%32>, vp<%5>
    CLONE ir<%flow82> = getelementptr inbounds vp<%6>, ir<48>
    CLONE store ir<0>, ir<%flow82>
    CLONE ir<%ident83> = getelementptr inbounds vp<%6>, ir<24>
    CLONE store ir<1>, ir<%ident83>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end103.loopexit263>, scalar.ph

ir-bb<if.end103.loopexit263>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pstart.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                pstart.c
LV: Decision: Scalarize
LV: Decision: Scalarize
========== Loop: primal_start_artificial' from pstart.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %3 to i64)) + (ptrtoint ptr %2 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%arc.071> = WIDEN-POINTER-INDUCTION ir<%3>, 64
    CLONE ir<%ident> = getelementptr inbounds ir<%arc.071>, ir<24>
    CLONE ir<%4> = load ir<%ident>
    CLONE ir<%cmp1.not> = icmp eq ir<%4>, ir<-1>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp1.not>
    CLONE store ir<1>, ir<%ident>, vp<%4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = or ir<%cmp1.not>, vp<%4>
    CLONE ir<%incdec.ptr3> = getelementptr inbounds ir<%arc.071>, ir<64>
    CLONE ir<%cmp.not> = icmp eq ir<%incdec.ptr3>, ir<%2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: primal_start_artificial' from pstart.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %3 to i64)) + (ptrtoint ptr %2 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%arc.071> = WIDEN-POINTER-INDUCTION ir<%3>, 64
    REPLICATE ir<%ident> = getelementptr inbounds ir<%arc.071>, ir<24>
    REPLICATE ir<%4> = load ir<%ident>
    WIDEN ir<%cmp1.not> = icmp eq ir<%4>, ir<-1>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp1.not>
    REPLICATE store ir<1>, ir<%ident>, vp<%4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = or ir<%cmp1.not>, vp<%4>
    REPLICATE ir<%incdec.ptr3> = getelementptr inbounds ir<%arc.071>, ir<64>
    CLONE ir<%cmp.not> = icmp eq ir<%incdec.ptr3>, ir<%2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: primal_start_artificial' from pstart.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %3 to i64)) + (ptrtoint ptr %2 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%arc.071> = WIDEN-POINTER-INDUCTION ir<%3>, 64
    WIDEN-GEP Var[Inv] ir<%ident> = getelementptr inbounds ir<%arc.071>, ir<24>
    REPLICATE ir<%4> = load ir<%ident>
    WIDEN ir<%cmp1.not> = icmp eq ir<%4>, ir<-1>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp1.not>
    REPLICATE store ir<1>, ir<%ident>, vp<%4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = or ir<%cmp1.not>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr3> = getelementptr inbounds ir<%arc.071>, ir<64>
    CLONE ir<%cmp.not> = icmp eq ir<%incdec.ptr3>, ir<%2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: primal_start_artificial' from pstart.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-64 + (-1 * (ptrtoint ptr %3 to i64)) + (ptrtoint ptr %2 to i64)) /u 64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%arc.071> = WIDEN-POINTER-INDUCTION ir<%3>, 64
    WIDEN-GEP Var[Inv] ir<%ident> = getelementptr inbounds ir<%arc.071>, ir<24>
    WIDEN ir<%4> = load ir<%ident>
    WIDEN ir<%cmp1.not> = icmp eq ir<%4>, ir<-1>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp1.not>
    WIDEN store ir<%ident>, ir<1>, vp<%4>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = or ir<%cmp1.not>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr3> = getelementptr inbounds ir<%arc.071>, ir<64>
    CLONE ir<%cmp.not> = icmp eq ir<%incdec.ptr3>, ir<%2>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arc.071 = phi ptr [ %incdec.ptr3, %for.inc ], [ %3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ident = getelementptr inbounds i8, ptr %arc.071, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load i32, ptr %ident, align 8, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1.not = icmp eq i32 %4, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1.not, label %for.inc, label %if.then of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %ident, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %arc.071, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp.not = icmp eq ptr %incdec.ptr3, %2 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arc.071 = phi ptr [ %incdec.ptr3, %for.inc ], [ %3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ident = getelementptr inbounds i8, ptr %arc.071, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   %4 = load i32, ptr %ident, align 8, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1.not = icmp eq i32 %4, -1 of type:icmp
LV: Found an estimated cost of 4 for VF 2 For instruction:   br i1 %cmp1.not, label %for.inc, label %if.then of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1, ptr %ident, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %arc.071, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp.not = icmp eq ptr %incdec.ptr3, %2 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 10
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 10
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arc.071 = phi ptr [ %incdec.ptr3, %for.inc ], [ %3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ident = getelementptr inbounds i8, ptr %arc.071, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 24 for VF 4 For instruction:   %4 = load i32, ptr %ident, align 8, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1.not = icmp eq i32 %4, -1 of type:icmp
LV: Found an estimated cost of 8 for VF 4 For instruction:   br i1 %cmp1.not, label %for.inc, label %if.then of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 1, ptr %ident, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %arc.071, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp.not = icmp eq ptr %incdec.ptr3, %2 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 9
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 38
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 38, CostB * EstimatedWidthA: 20
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 38
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 38, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arc.071 = phi ptr [ %incdec.ptr3, %for.inc ], [ %3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ident = getelementptr inbounds i8, ptr %arc.071, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load i32, ptr %ident, align 8, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1.not = icmp eq i32 %4, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1.not, label %for.inc, label %if.then of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %ident, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %arc.071, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp.not = icmp eq ptr %incdec.ptr3, %2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arc.071 = phi ptr [ %incdec.ptr3, %for.inc ], [ %3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ident = getelementptr inbounds i8, ptr %arc.071, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %4 = load i32, ptr %ident, align 8, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1.not = icmp eq i32 %4, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1.not, label %for.inc, label %if.then of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 1, ptr %ident, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %arc.071, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp.not = icmp eq ptr %incdec.ptr3, %2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arc.071 = phi ptr [ %incdec.ptr3, %for.inc ], [ %3, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ident = getelementptr inbounds i8, ptr %arc.071, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %4 = load i32, ptr %ident, align 8, !tbaa !25 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp1.not = icmp eq i32 %4, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp1.not, label %for.inc, label %if.then of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 1, ptr %ident, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %arc.071, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp.not = icmp eq ptr %incdec.ptr3, %2 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 20
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 164
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 164, CostB * EstimatedWidthA: 40
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 164
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 164, CostB * EstimatedWidthA: 40
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 2
maxafter: 2
========== Loop: primal_start_artificial' from pstart.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %0 to i64)) + (ptrtoint ptr %5 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%arc.174> = WIDEN-POINTER-INDUCTION ir<%6>, 64
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr>, 104
    CLONE ir<%basic_arc7> = getelementptr inbounds ir<%node.073>, ir<48>
    CLONE store ir<%arc.174>, ir<%basic_arc7>
    CLONE ir<%pred8> = getelementptr inbounds ir<%node.073>, ir<24>
    CLONE store ir<%0>, ir<%pred8>
    CLONE ir<%child9> = getelementptr inbounds ir<%node.073>, ir<16>
    CLONE store ir<null>, ir<%child9>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%node.073>, ir<104>
    CLONE ir<%sibling10> = getelementptr inbounds ir<%node.073>, ir<32>
    CLONE store ir<%add.ptr>, ir<%sibling10>
    CLONE ir<%add.ptr11> = getelementptr inbounds ir<%node.073>, ir<-104>
    CLONE ir<%sibling_prev12> = getelementptr inbounds ir<%node.073>, ir<40>
    CLONE store ir<%add.ptr11>, ir<%sibling_prev12>
    CLONE ir<%depth13> = getelementptr inbounds ir<%node.073>, ir<88>
    CLONE store ir<1>, ir<%depth13>
    CLONE store ir<100000000>, ir<%arc.174>
    CLONE ir<%ident14> = getelementptr inbounds ir<%arc.174>, ir<24>
    CLONE store ir<0>, ir<%ident14>
    CLONE ir<%orientation15> = getelementptr inbounds ir<%node.073>, ir<8>
    CLONE store ir<1>, ir<%orientation15>
    CLONE store ir<0>, ir<%node.073>
    CLONE ir<%tail> = getelementptr inbounds ir<%arc.174>, ir<8>
    CLONE store ir<%node.073>, ir<%tail>
    CLONE ir<%head> = getelementptr inbounds ir<%arc.174>, ir<16>
    CLONE store ir<%0>, ir<%head>
    CLONE ir<%flow17> = getelementptr inbounds ir<%node.073>, ir<80>
    CLONE store ir<0>, ir<%flow17>
    CLONE ir<%incdec.ptr19> = getelementptr inbounds ir<%arc.174>, ir<64>
    CLONE ir<%cmp5.not> = icmp eq ir<%add.ptr>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end21.loopexit>, scalar.ph

ir-bb<for.end21.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: primal_start_artificial' from pstart.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %0 to i64)) + (ptrtoint ptr %5 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%arc.174> = WIDEN-POINTER-INDUCTION ir<%6>, 64
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr>, 104
    REPLICATE ir<%basic_arc7> = getelementptr inbounds ir<%node.073>, ir<48>
    REPLICATE store ir<%arc.174>, ir<%basic_arc7>
    REPLICATE ir<%pred8> = getelementptr inbounds ir<%node.073>, ir<24>
    REPLICATE store ir<%0>, ir<%pred8>
    REPLICATE ir<%child9> = getelementptr inbounds ir<%node.073>, ir<16>
    REPLICATE store ir<null>, ir<%child9>
    WIDEN-GEP Var[Inv] ir<%add.ptr> = getelementptr inbounds ir<%node.073>, ir<104>
    REPLICATE ir<%sibling10> = getelementptr inbounds ir<%node.073>, ir<32>
    REPLICATE store ir<%add.ptr>, ir<%sibling10>
    REPLICATE ir<%add.ptr11> = getelementptr inbounds ir<%node.073>, ir<-104>
    REPLICATE ir<%sibling_prev12> = getelementptr inbounds ir<%node.073>, ir<40>
    REPLICATE store ir<%add.ptr11>, ir<%sibling_prev12>
    REPLICATE ir<%depth13> = getelementptr inbounds ir<%node.073>, ir<88>
    REPLICATE store ir<1>, ir<%depth13>
    REPLICATE store ir<100000000>, ir<%arc.174>
    REPLICATE ir<%ident14> = getelementptr inbounds ir<%arc.174>, ir<24>
    REPLICATE store ir<0>, ir<%ident14>
    REPLICATE ir<%orientation15> = getelementptr inbounds ir<%node.073>, ir<8>
    REPLICATE store ir<1>, ir<%orientation15>
    REPLICATE store ir<0>, ir<%node.073>
    REPLICATE ir<%tail> = getelementptr inbounds ir<%arc.174>, ir<8>
    REPLICATE store ir<%node.073>, ir<%tail>
    REPLICATE ir<%head> = getelementptr inbounds ir<%arc.174>, ir<16>
    REPLICATE store ir<%0>, ir<%head>
    REPLICATE ir<%flow17> = getelementptr inbounds ir<%node.073>, ir<80>
    REPLICATE store ir<0>, ir<%flow17>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr19> = getelementptr inbounds ir<%arc.174>, ir<64>
    CLONE ir<%cmp5.not> = icmp eq ir<%add.ptr>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end21.loopexit>, scalar.ph

ir-bb<for.end21.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: primal_start_artificial' from pstart.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %0 to i64)) + (ptrtoint ptr %5 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%arc.174> = WIDEN-POINTER-INDUCTION ir<%6>, 64
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr>, 104
    WIDEN-GEP Var[Inv] ir<%basic_arc7> = getelementptr inbounds ir<%node.073>, ir<48>
    REPLICATE store ir<%arc.174>, ir<%basic_arc7>
    WIDEN-GEP Var[Inv] ir<%pred8> = getelementptr inbounds ir<%node.073>, ir<24>
    REPLICATE store ir<%0>, ir<%pred8>
    WIDEN-GEP Var[Inv] ir<%child9> = getelementptr inbounds ir<%node.073>, ir<16>
    REPLICATE store ir<null>, ir<%child9>
    WIDEN-GEP Var[Inv] ir<%add.ptr> = getelementptr inbounds ir<%node.073>, ir<104>
    WIDEN-GEP Var[Inv] ir<%sibling10> = getelementptr inbounds ir<%node.073>, ir<32>
    REPLICATE store ir<%add.ptr>, ir<%sibling10>
    WIDEN-GEP Var[Inv] ir<%add.ptr11> = getelementptr inbounds ir<%node.073>, ir<-104>
    WIDEN-GEP Var[Inv] ir<%sibling_prev12> = getelementptr inbounds ir<%node.073>, ir<40>
    REPLICATE store ir<%add.ptr11>, ir<%sibling_prev12>
    WIDEN-GEP Var[Inv] ir<%depth13> = getelementptr inbounds ir<%node.073>, ir<88>
    REPLICATE store ir<1>, ir<%depth13>
    REPLICATE store ir<100000000>, ir<%arc.174>
    WIDEN-GEP Var[Inv] ir<%ident14> = getelementptr inbounds ir<%arc.174>, ir<24>
    REPLICATE store ir<0>, ir<%ident14>
    WIDEN-GEP Var[Inv] ir<%orientation15> = getelementptr inbounds ir<%node.073>, ir<8>
    REPLICATE store ir<1>, ir<%orientation15>
    REPLICATE store ir<0>, ir<%node.073>
    WIDEN-GEP Var[Inv] ir<%tail> = getelementptr inbounds ir<%arc.174>, ir<8>
    REPLICATE store ir<%node.073>, ir<%tail>
    WIDEN-GEP Var[Inv] ir<%head> = getelementptr inbounds ir<%arc.174>, ir<16>
    REPLICATE store ir<%0>, ir<%head>
    WIDEN-GEP Var[Inv] ir<%flow17> = getelementptr inbounds ir<%node.073>, ir<80>
    REPLICATE store ir<0>, ir<%flow17>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr19> = getelementptr inbounds ir<%arc.174>, ir<64>
    CLONE ir<%cmp5.not> = icmp eq ir<%add.ptr>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end21.loopexit>, scalar.ph

ir-bb<for.end21.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: primal_start_artificial' from pstart.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body6.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-208 + (-1 * (ptrtoint ptr %0 to i64)) + (ptrtoint ptr %5 to i64)) /u 104))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%arc.174> = WIDEN-POINTER-INDUCTION ir<%6>, 64
    EMIT ir<%node.073> = WIDEN-POINTER-INDUCTION ir<%incdec.ptr>, 104
    WIDEN-GEP Var[Inv] ir<%basic_arc7> = getelementptr inbounds ir<%node.073>, ir<48>
    WIDEN store ir<%basic_arc7>, ir<%arc.174>
    WIDEN-GEP Var[Inv] ir<%pred8> = getelementptr inbounds ir<%node.073>, ir<24>
    WIDEN store ir<%pred8>, ir<%0>
    WIDEN-GEP Var[Inv] ir<%child9> = getelementptr inbounds ir<%node.073>, ir<16>
    WIDEN store ir<%child9>, ir<null>
    WIDEN-GEP Var[Inv] ir<%add.ptr> = getelementptr inbounds ir<%node.073>, ir<104>
    WIDEN-GEP Var[Inv] ir<%sibling10> = getelementptr inbounds ir<%node.073>, ir<32>
    WIDEN store ir<%sibling10>, ir<%add.ptr>
    WIDEN-GEP Var[Inv] ir<%add.ptr11> = getelementptr inbounds ir<%node.073>, ir<-104>
    WIDEN-GEP Var[Inv] ir<%sibling_prev12> = getelementptr inbounds ir<%node.073>, ir<40>
    WIDEN store ir<%sibling_prev12>, ir<%add.ptr11>
    WIDEN-GEP Var[Inv] ir<%depth13> = getelementptr inbounds ir<%node.073>, ir<88>
    WIDEN store ir<%depth13>, ir<1>
    WIDEN store ir<%arc.174>, ir<100000000>
    WIDEN-GEP Var[Inv] ir<%ident14> = getelementptr inbounds ir<%arc.174>, ir<24>
    WIDEN store ir<%ident14>, ir<0>
    WIDEN-GEP Var[Inv] ir<%orientation15> = getelementptr inbounds ir<%node.073>, ir<8>
    WIDEN store ir<%orientation15>, ir<1>
    WIDEN store ir<%node.073>, ir<0>
    WIDEN-GEP Var[Inv] ir<%tail> = getelementptr inbounds ir<%arc.174>, ir<8>
    WIDEN store ir<%tail>, ir<%node.073>
    WIDEN-GEP Var[Inv] ir<%head> = getelementptr inbounds ir<%arc.174>, ir<16>
    WIDEN store ir<%head>, ir<%0>
    WIDEN-GEP Var[Inv] ir<%flow17> = getelementptr inbounds ir<%node.073>, ir<80>
    WIDEN store ir<%flow17>, ir<0>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr19> = getelementptr inbounds ir<%arc.174>, ir<64>
    CLONE ir<%cmp5.not> = icmp eq ir<%add.ptr>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end21.loopexit>, scalar.ph

ir-bb<for.end21.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arc.174 = phi ptr [ %incdec.ptr19, %for.body6 ], [ %6, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %node.073 = phi ptr [ %add.ptr, %for.body6 ], [ %incdec.ptr, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %basic_arc7 = getelementptr inbounds i8, ptr %node.073, i64 48 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %arc.174, ptr %basic_arc7, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %pred8 = getelementptr inbounds i8, ptr %node.073, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %0, ptr %pred8, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %child9 = getelementptr inbounds i8, ptr %node.073, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr null, ptr %child9, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sibling10 = getelementptr inbounds i8, ptr %node.073, i64 32 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr, ptr %sibling10, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr11 = getelementptr inbounds i8, ptr %node.073, i64 -104 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sibling_prev12 = getelementptr inbounds i8, ptr %node.073, i64 40 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %add.ptr11, ptr %sibling_prev12, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %depth13 = getelementptr inbounds i8, ptr %node.073, i64 88 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 1, ptr %depth13, align 8, !tbaa !19 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 100000000, ptr %arc.174, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ident14 = getelementptr inbounds i8, ptr %arc.174, i64 24 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %ident14, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %orientation15 = getelementptr inbounds i8, ptr %node.073, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 1, ptr %orientation15, align 8, !tbaa !20 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 0, ptr %node.073, align 8, !tbaa !21 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %tail = getelementptr inbounds i8, ptr %arc.174, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %node.073, ptr %tail, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %head = getelementptr inbounds i8, ptr %arc.174, i64 16 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %0, ptr %head, align 8, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %flow17 = getelementptr inbounds i8, ptr %node.073, i64 80 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i64 0, ptr %flow17, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr19 = getelementptr inbounds i8, ptr %arc.174, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5.not = icmp eq ptr %add.ptr, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5.not, label %for.end21.loopexit, label %for.body6 of type:br
LV: Scalar loop costs: 27.
-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arc.174 = phi ptr [ %incdec.ptr19, %for.body6 ], [ %6, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %node.073 = phi ptr [ %add.ptr, %for.body6 ], [ %incdec.ptr, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %basic_arc7 = getelementptr inbounds i8, ptr %node.073, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store ptr %arc.174, ptr %basic_arc7, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %pred8 = getelementptr inbounds i8, ptr %node.073, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store ptr %0, ptr %pred8, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %child9 = getelementptr inbounds i8, ptr %node.073, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store ptr null, ptr %child9, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sibling10 = getelementptr inbounds i8, ptr %node.073, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store ptr %add.ptr, ptr %sibling10, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr11 = getelementptr inbounds i8, ptr %node.073, i64 -104 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sibling_prev12 = getelementptr inbounds i8, ptr %node.073, i64 40 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store ptr %add.ptr11, ptr %sibling_prev12, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %depth13 = getelementptr inbounds i8, ptr %node.073, i64 88 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i64 1, ptr %depth13, align 8, !tbaa !19 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i64 100000000, ptr %arc.174, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ident14 = getelementptr inbounds i8, ptr %arc.174, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 8 for VF 2 For instruction:   store i32 0, ptr %ident14, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %orientation15 = getelementptr inbounds i8, ptr %node.073, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 1, ptr %orientation15, align 8, !tbaa !20 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i64 0, ptr %node.073, align 8, !tbaa !21 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 2 For instruction:   store ptr %node.073, ptr %tail, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %head = getelementptr inbounds i8, ptr %arc.174, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 78 for VF 2 For instruction:   store ptr %0, ptr %head, align 8, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %flow17 = getelementptr inbounds i8, ptr %node.073, i64 80 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i64 0, ptr %flow17, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr19 = getelementptr inbounds i8, ptr %arc.174, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5.not = icmp eq ptr %add.ptr, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5.not, label %for.end21.loopexit, label %for.body6 of type:br
LV: Vector loop of width 2 costs: 166
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 333
B VF: 1, EstimatedWidthB: 1, CostB: 27
CostA * EstimatedWidthB: 333, CostB * EstimatedWidthA: 54
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 333
B VF: 1, EstimatedWidthB: 1, CostB: 27
CostA * EstimatedWidthB: 333, CostB * EstimatedWidthA: 54

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arc.174 = phi ptr [ %incdec.ptr19, %for.body6 ], [ %6, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %node.073 = phi ptr [ %add.ptr, %for.body6 ], [ %incdec.ptr, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %basic_arc7 = getelementptr inbounds i8, ptr %node.073, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store ptr %arc.174, ptr %basic_arc7, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %pred8 = getelementptr inbounds i8, ptr %node.073, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store ptr %0, ptr %pred8, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %child9 = getelementptr inbounds i8, ptr %node.073, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store ptr null, ptr %child9, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sibling10 = getelementptr inbounds i8, ptr %node.073, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store ptr %add.ptr, ptr %sibling10, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr11 = getelementptr inbounds i8, ptr %node.073, i64 -104 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sibling_prev12 = getelementptr inbounds i8, ptr %node.073, i64 40 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store ptr %add.ptr11, ptr %sibling_prev12, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %depth13 = getelementptr inbounds i8, ptr %node.073, i64 88 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i64 1, ptr %depth13, align 8, !tbaa !19 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i64 100000000, ptr %arc.174, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ident14 = getelementptr inbounds i8, ptr %arc.174, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 4 For instruction:   store i32 0, ptr %ident14, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %orientation15 = getelementptr inbounds i8, ptr %node.073, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 1, ptr %orientation15, align 8, !tbaa !20 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i64 0, ptr %node.073, align 8, !tbaa !21 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 4 For instruction:   store ptr %node.073, ptr %tail, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %head = getelementptr inbounds i8, ptr %arc.174, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 156 for VF 4 For instruction:   store ptr %0, ptr %head, align 8, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %flow17 = getelementptr inbounds i8, ptr %node.073, i64 80 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i64 0, ptr %flow17, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr19 = getelementptr inbounds i8, ptr %arc.174, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp5.not = icmp eq ptr %add.ptr, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp5.not, label %for.end21.loopexit, label %for.body6 of type:br
LV: Vector loop of width 4 costs: 166
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 665
B VF: 1, EstimatedWidthB: 1, CostB: 27
CostA * EstimatedWidthB: 665, CostB * EstimatedWidthA: 108
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 665
B VF: 1, EstimatedWidthB: 1, CostB: 27
CostA * EstimatedWidthB: 665, CostB * EstimatedWidthA: 108

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arc.174 = phi ptr [ %incdec.ptr19, %for.body6 ], [ %6, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %node.073 = phi ptr [ %add.ptr, %for.body6 ], [ %incdec.ptr, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %basic_arc7 = getelementptr inbounds i8, ptr %node.073, i64 48 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %arc.174, ptr %basic_arc7, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %pred8 = getelementptr inbounds i8, ptr %node.073, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %0, ptr %pred8, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %child9 = getelementptr inbounds i8, ptr %node.073, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr null, ptr %child9, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sibling10 = getelementptr inbounds i8, ptr %node.073, i64 32 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr, ptr %sibling10, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr11 = getelementptr inbounds i8, ptr %node.073, i64 -104 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sibling_prev12 = getelementptr inbounds i8, ptr %node.073, i64 40 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %add.ptr11, ptr %sibling_prev12, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %depth13 = getelementptr inbounds i8, ptr %node.073, i64 88 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 1, ptr %depth13, align 8, !tbaa !19 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i64 100000000, ptr %arc.174, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ident14 = getelementptr inbounds i8, ptr %arc.174, i64 24 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %ident14, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %orientation15 = getelementptr inbounds i8, ptr %node.073, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 1, ptr %orientation15, align 8, !tbaa !20 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 0, ptr %node.073, align 8, !tbaa !21 of type:store
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store ptr %node.073, ptr %tail, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %head = getelementptr inbounds i8, ptr %arc.174, i64 16 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %0, ptr %head, align 8, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %flow17 = getelementptr inbounds i8, ptr %node.073, i64 80 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i64 0, ptr %flow17, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr19 = getelementptr inbounds i8, ptr %arc.174, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5.not = icmp eq ptr %add.ptr, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5.not, label %for.end21.loopexit, label %for.body6 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 27
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 54
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 27
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 54

-----------------Function that is being costed:'primal_start_artificial' from pstart.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arc.174 = phi ptr [ %incdec.ptr19, %for.body6 ], [ %6, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %node.073 = phi ptr [ %add.ptr, %for.body6 ], [ %incdec.ptr, %for.body6.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %basic_arc7 = getelementptr inbounds i8, ptr %node.073, i64 48 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %arc.174, ptr %basic_arc7, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %pred8 = getelementptr inbounds i8, ptr %node.073, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %0, ptr %pred8, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %child9 = getelementptr inbounds i8, ptr %node.073, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr null, ptr %child9, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr = getelementptr inbounds i8, ptr %node.073, i64 104 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sibling10 = getelementptr inbounds i8, ptr %node.073, i64 32 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %add.ptr, ptr %sibling10, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr11 = getelementptr inbounds i8, ptr %node.073, i64 -104 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sibling_prev12 = getelementptr inbounds i8, ptr %node.073, i64 40 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store ptr %add.ptr11, ptr %sibling_prev12, align 8, !tbaa !30 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %depth13 = getelementptr inbounds i8, ptr %node.073, i64 88 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 1, ptr %depth13, align 8, !tbaa !19 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i64 100000000, ptr %arc.174, align 8, !tbaa !31 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ident14 = getelementptr inbounds i8, ptr %arc.174, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 0, ptr %ident14, align 8, !tbaa !25 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %orientation15 = getelementptr inbounds i8, ptr %node.073, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 1, ptr %orientation15, align 8, !tbaa !20 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 0, ptr %node.073, align 8, !tbaa !21 of type:store
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store ptr %node.073, ptr %tail, align 8, !tbaa !32 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %head = getelementptr inbounds i8, ptr %arc.174, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 123 for VF vscale x 2 For instruction:   store ptr %0, ptr %head, align 8, !tbaa !33 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %flow17 = getelementptr inbounds i8, ptr %node.073, i64 80 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i64 0, ptr %flow17, align 8, !tbaa !22 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr19 = getelementptr inbounds i8, ptr %arc.174, i64 64 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp5.not = icmp eq ptr %add.ptr, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5.not, label %for.end21.loopexit, label %for.body6 of type:br
LV: Vector loop of width vscale x 2 costs: 133
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 534
B VF: 1, EstimatedWidthB: 1, CostB: 27
CostA * EstimatedWidthB: 534, CostB * EstimatedWidthA: 108
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 534
B VF: 1, EstimatedWidthB: 1, CostB: 27
CostA * EstimatedWidthB: 534, CostB * EstimatedWidthA: 108
LV: Selecting VF: 1 With Cost: 27.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o output.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                output.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o treeup.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                treeup.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pbla.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                pbla.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pflowup.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                pflowup.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o psimplex.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                psimplex.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o pbeampp.o -DSPEC_CPU -DNDEBUG  -DWANT_STDC_PROTO  -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                pbeampp.c
@@ Instruction =>  store ptr %arrayidx, ptr %arrayidx1, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %arrayidx, ptr %arrayidx1, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x ptr> -> ttilog -> 
@@ Instruction =>  store ptr %arrayidx, ptr %arrayidx1, align 8, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(1)
========== Loop: primal_bea_mpp' from pbeampp.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<350> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %i.0116 = phi %inc, 1, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@basket>, ir<0>, ir<%i.0116>
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<@perm>, ir<0>, ir<%i.0116>
    CLONE store ir<%arrayidx>, ir<%arrayidx1>
    CLONE ir<%inc> = add nuw nsw ir<%i.0116>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<351>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<350>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: primal_bea_mpp' from pbeampp.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<350> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0116 = phi %inc, 1, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@basket>, ir<0>, ir<%i.0116>
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<@perm>, ir<0>, ir<%i.0116>
    vp<%3> = vector-pointer ir<%arrayidx1>
    WIDEN store vp<%3>, ir<%arrayidx>
    WIDEN ir<%inc> = add nuw nsw ir<%i.0116>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<351>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<350>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: primal_bea_mpp' from pbeampp.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<350> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0116 = phi %inc, 1, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@basket>, ir<0>, ir<%i.0116>
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<@perm>, ir<0>, ir<%i.0116>
    vp<%3> = vector-pointer ir<%arrayidx1>
    WIDEN store vp<%3>, ir<%arrayidx>
    WIDEN ir<%inc> = add nuw nsw ir<%i.0116>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc>, ir<351>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<350>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'primal_bea_mpp' from pbeampp.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0116 = phi i64 [ %inc, %for.body ], [ 1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [351 x %struct.basket], ptr @basket, i64 0, i64 %i.0116 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1 = getelementptr inbounds [351 x ptr], ptr @perm, i64 0, i64 %i.0116 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %arrayidx, ptr %arrayidx1, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw nsw i64 %i.0116, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %inc, 351 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'primal_bea_mpp' from pbeampp.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0116 = phi i64 [ %inc, %for.body ], [ 1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [351 x %struct.basket], ptr @basket, i64 0, i64 %i.0116 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1 = getelementptr inbounds [351 x ptr], ptr @perm, i64 0, i64 %i.0116 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %arrayidx, ptr %arrayidx1, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw nsw i64 %i.0116, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %inc, 351 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 525, RTCostB: 1400
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 525, RTCostB: 1400
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'primal_bea_mpp' from pbeampp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0116 = phi i64 [ %inc, %for.body ], [ 1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [351 x %struct.basket], ptr @basket, i64 0, i64 %i.0116 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1 = getelementptr inbounds [351 x ptr], ptr @perm, i64 0, i64 %i.0116 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %arrayidx, ptr %arrayidx1, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nuw nsw i64 %i.0116, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %inc, 351 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1400
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 525

-----------------Function that is being costed:'primal_bea_mpp' from pbeampp.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0116 = phi i64 [ %inc, %for.body ], [ 1, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [351 x %struct.basket], ptr @basket, i64 0, i64 %i.0116 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1 = getelementptr inbounds [351 x ptr], ptr @perm, i64 0, i64 %i.0116 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store ptr %arrayidx, ptr %arrayidx1, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nuw nsw i64 %i.0116, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %inc, 351 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 269, RTCostB: 1400
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 269, RTCostB: 525
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: primal_bea_mpp at line: pbeampp.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<350> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %i.0116 = phi %inc, 1, ir<1>
    vp<%3>    = DERIVED-IV ir<1> + vp<%2> * ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@basket>, ir<0>, ir<%i.0116>
    CLONE ir<%arrayidx1> = getelementptr inbounds ir<@perm>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx1>
    WIDEN store vp<%5>, ir<%arrayidx>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<350>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration     -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions          mcf.o mcfutil.o readmin.o implicit.o pstart.o output.o treeup.o pbla.o pflowup.o psimplex.o pbeampp.o             -lm        -o mcf
