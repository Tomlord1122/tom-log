/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o changesoplex.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           changesoplex.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o didxset.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           didxset.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dsvector.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           dsvector.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o dvector.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           dvector.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o enter.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           enter.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o example.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           example.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o factor.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           factor.cc
@@ Instruction =>  %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %14, ptr %arrayidx36, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %14, ptr %arrayidx36, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %14, ptr %arrayidx36, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %14, ptr %arrayidx36, align 8, !tbaa !29 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %14, ptr %arrayidx36, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor8packRowsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body28.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %8 to i64))<nsw> + ((sext i32 (%8 + %9) to i64) smax (1 + (sext i32 %8 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv104 = phi %11, %indvars.iv.next105, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, ir<%indvars.iv104>
    CLONE ir<%13> = load ir<%arrayidx30>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    CLONE store ir<%13>, ir<%arrayidx32>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%1>, ir<%indvars.iv104>
    CLONE ir<%14> = load ir<%arrayidx34>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    CLONE store ir<%14>, ir<%arrayidx36>
    CLONE ir<%indvars.iv.next105> = add nsw ir<%indvars.iv104>, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp27> = icmp slt ir<%indvars.iv.next105>, ir<%12>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN6soplex9CLUFactor8packRowsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body28.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %8 to i64))<nsw> + ((sext i32 (%8 + %9) to i64) smax (1 + (sext i32 %8 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv104 = phi %11, %indvars.iv.next105, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, ir<%indvars.iv104>
    vp<%4> = vector-pointer ir<%arrayidx30>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx32>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%1>, ir<%indvars.iv104>
    vp<%6> = vector-pointer ir<%arrayidx34>
    WIDEN ir<%14> = load vp<%6>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%7> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%7>, ir<%14>
    CLONE ir<%indvars.iv.next105> = add nsw ir<%indvars.iv104>, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp27> = icmp slt ir<%indvars.iv.next105>, ir<%12>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN6soplex9CLUFactor8packRowsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body28.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %8 to i64))<nsw> + ((sext i32 (%8 + %9) to i64) smax (1 + (sext i32 %8 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv104 = phi %11, %indvars.iv.next105, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, ir<%indvars.iv104>
    vp<%4> = vector-pointer ir<%arrayidx30>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx32>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%1>, ir<%indvars.iv104>
    vp<%6> = vector-pointer ir<%arrayidx34>
    WIDEN ir<%14> = load vp<%6>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%7> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%7>, ir<%14>
    CLONE ir<%indvars.iv.next105> = add nsw ir<%indvars.iv104>, ir<1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp27> = icmp slt ir<%indvars.iv.next105>, ir<%12>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor8packRowsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv104 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next105, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv104 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx32 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx34 = getelementptr inbounds double, ptr %1, i64 %indvars.iv104 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx36 = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %14, ptr %arrayidx36, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next105 = add nsw i64 %indvars.iv104, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next105, %12 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor8packRowsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv104 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next105, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv104 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx32 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx34 = getelementptr inbounds double, ptr %1, i64 %indvars.iv104 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx36 = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %14, ptr %arrayidx36, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next105 = add nsw i64 %indvars.iv104, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next105, %12 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 15032385540, RTCostB: 47244640245
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 15032385540, RTCostB: 47244640245
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8packRowsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv104 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next105, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv104 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx32 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx34 = getelementptr inbounds double, ptr %1, i64 %indvars.iv104 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx36 = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store double %14, ptr %arrayidx36, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next105 = add nsw i64 %indvars.iv104, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next105, %12 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 9663676440, RTCostB: 47244640245
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676440, RTCostB: 15032385540
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8packRowsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv104 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next105, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv104 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx32 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx34 = getelementptr inbounds double, ptr %1, i64 %indvars.iv104 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx36 = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %14, ptr %arrayidx36, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next105 = add nsw i64 %indvars.iv104, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next105, %12 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 47244640245
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 9663676440

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8packRowsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv104 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next105, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv104 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %13 = load i32, ptr %arrayidx30, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx32 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %13, ptr %arrayidx32, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx34 = getelementptr inbounds double, ptr %1, i64 %indvars.iv104 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %14 = load double, ptr %arrayidx34, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx36 = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %14, ptr %arrayidx36, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next105 = add nsw i64 %indvars.iv104, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next105, %12 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192794, RTCostB: 47244640245
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192794, RTCostB: 9663676440
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN6soplex9CLUFactor8packRowsEv at line: factor.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body28.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %8 to i64))<nsw> + ((sext i32 (%8 + %9) to i64) smax (1 + (sext i32 %8 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%11> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%10> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx30>
    WIDEN ir<%23> = load vp<%8>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%0>, vp<%7>
    vp<%9> = vector-pointer ir<%arrayidx32>
    WIDEN store vp<%9>, ir<%23>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%1>, vp<%5>
    vp<%10> = vector-pointer ir<%arrayidx34>
    WIDEN ir<%24> = load vp<%10>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%1>, vp<%7>
    vp<%11> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%11>, ir<%24>
    CLONE ir<%indvars.iv.next> = add nsw vp<%7>, ir<1>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %40, ptr %arrayidx188, align 8, !tbaa !35 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %40, ptr %arrayidx188, align 8, !tbaa !35 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %40, ptr %arrayidx188, align 8, !tbaa !35 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %40, ptr %arrayidx188, align 8, !tbaa !35 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %40, ptr %arrayidx188, align 8, !tbaa !35 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor8remaxRowEii' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv237 = phi %39, %indvars.iv.next238, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %37, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx186> = getelementptr inbounds ir<%36>, ir<%indvars.iv>
    CLONE ir<%40> = load ir<%arrayidx186>
    CLONE ir<%arrayidx188> = getelementptr inbounds ir<%36>, ir<%indvars.iv237>
    CLONE store ir<%40>, ir<%arrayidx188>
    CLONE ir<%arrayidx190> = getelementptr inbounds ir<%35>, ir<%indvars.iv>
    CLONE ir<%41> = load ir<%arrayidx190>
    CLONE ir<%arrayidx192> = getelementptr inbounds ir<%35>, ir<%indvars.iv237>
    CLONE store ir<%41>, ir<%arrayidx192>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%indvars.iv.next238> = add nsw ir<%indvars.iv237>, ir<1>
    CLONE ir<%cmp184> = icmp slt ir<%indvars.iv.next>, ir<%38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end194.loopexit>, scalar.ph

ir-bb<if.end194.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor8remaxRowEii' from factor.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv237 = phi %39, %indvars.iv.next238, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %37, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx186> = getelementptr inbounds ir<%36>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx186>
    WIDEN ir<%40> = load vp<%4>
    CLONE ir<%arrayidx188> = getelementptr inbounds ir<%36>, ir<%indvars.iv237>
    vp<%5> = vector-pointer ir<%arrayidx188>
    WIDEN store vp<%5>, ir<%40>
    CLONE ir<%arrayidx190> = getelementptr inbounds ir<%35>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx190>
    WIDEN ir<%41> = load vp<%6>
    CLONE ir<%arrayidx192> = getelementptr inbounds ir<%35>, ir<%indvars.iv237>
    vp<%7> = vector-pointer ir<%arrayidx192>
    WIDEN store vp<%7>, ir<%41>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%indvars.iv.next238> = add nsw ir<%indvars.iv237>, ir<1>
    CLONE ir<%cmp184> = icmp slt ir<%indvars.iv.next>, ir<%38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end194.loopexit>, scalar.ph

ir-bb<if.end194.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor8remaxRowEii' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv237 = phi %39, %indvars.iv.next238, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %37, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx186> = getelementptr inbounds ir<%36>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx186>
    WIDEN ir<%40> = load vp<%4>
    CLONE ir<%arrayidx188> = getelementptr inbounds ir<%36>, ir<%indvars.iv237>
    vp<%5> = vector-pointer ir<%arrayidx188>
    WIDEN store vp<%5>, ir<%40>
    CLONE ir<%arrayidx190> = getelementptr inbounds ir<%35>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx190>
    WIDEN ir<%41> = load vp<%6>
    CLONE ir<%arrayidx192> = getelementptr inbounds ir<%35>, ir<%indvars.iv237>
    vp<%7> = vector-pointer ir<%arrayidx192>
    WIDEN store vp<%7>, ir<%41>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%indvars.iv.next238> = add nsw ir<%indvars.iv237>, ir<1>
    CLONE ir<%cmp184> = icmp slt ir<%indvars.iv.next>, ir<%38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end194.loopexit>, scalar.ph

ir-bb<if.end194.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxRowEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv237 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next238, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx186 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx188 = getelementptr inbounds double, ptr %36, i64 %indvars.iv237 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %40, ptr %arrayidx188, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx190 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx192 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv237 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next238 = add nsw i64 %indvars.iv237, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp184 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp184, label %for.body, label %if.end194.loopexit of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxRowEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv237 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next238, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx186 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx188 = getelementptr inbounds double, ptr %36, i64 %indvars.iv237 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %40, ptr %arrayidx188, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx190 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx192 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv237 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next238 = add nsw i64 %indvars.iv237, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp184 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp184, label %for.body, label %if.end194.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 15032385540, RTCostB: 47244640245
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 15032385540, RTCostB: 47244640245
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxRowEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv237 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next238, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx186 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx188 = getelementptr inbounds double, ptr %36, i64 %indvars.iv237 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store double %40, ptr %arrayidx188, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx190 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx192 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv237 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next238 = add nsw i64 %indvars.iv237, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp184 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp184, label %for.body, label %if.end194.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 9663676440, RTCostB: 47244640245
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676440, RTCostB: 15032385540
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxRowEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv237 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next238, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx186 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx188 = getelementptr inbounds double, ptr %36, i64 %indvars.iv237 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %40, ptr %arrayidx188, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx190 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx192 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv237 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next238 = add nsw i64 %indvars.iv237, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp184 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp184, label %for.body, label %if.end194.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 47244640245
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 9663676440

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxRowEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv237 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next238, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx186 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %40 = load double, ptr %arrayidx186, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx188 = getelementptr inbounds double, ptr %36, i64 %indvars.iv237 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %40, ptr %arrayidx188, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx190 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %41 = load i32, ptr %arrayidx190, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx192 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv237 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %41, ptr %arrayidx192, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next238 = add nsw i64 %indvars.iv237, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp184 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp184, label %for.body, label %if.end194.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192794, RTCostB: 47244640245
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192794, RTCostB: 9663676440
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN6soplex9CLUFactor8remaxRowEii at line: factor.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%39> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%37> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%arrayidx186> = getelementptr inbounds ir<%36>, vp<%7>
    vp<%8> = vector-pointer ir<%arrayidx186>
    WIDEN ir<%50> = load vp<%8>
    CLONE ir<%arrayidx188> = getelementptr inbounds ir<%36>, vp<%5>
    vp<%9> = vector-pointer ir<%arrayidx188>
    WIDEN store vp<%9>, ir<%50>
    CLONE ir<%arrayidx190> = getelementptr inbounds ir<%35>, vp<%7>
    vp<%10> = vector-pointer ir<%arrayidx190>
    WIDEN ir<%51> = load vp<%10>
    CLONE ir<%arrayidx192> = getelementptr inbounds ir<%35>, vp<%5>
    vp<%11> = vector-pointer ir<%arrayidx192>
    WIDEN store vp<%11>, ir<%51>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end194.loopexit>, scalar.ph

ir-bb<if.end194.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor11packColumnsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %7 to i64))<nsw> + ((sext i32 (%7 + %8) to i64) smax (1 + (sext i32 %7 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv95 = phi %10, %indvars.iv.next96, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%0>, ir<%indvars.iv95>
    CLONE ir<%12> = load ir<%arrayidx28>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    CLONE store ir<%12>, ir<%arrayidx30>
    CLONE ir<%indvars.iv.next96> = add nsw ir<%indvars.iv95>, ir<1>
    CLONE ir<%cmp25> = icmp slt ir<%indvars.iv.next96>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN6soplex9CLUFactor11packColumnsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %7 to i64))<nsw> + ((sext i32 (%7 + %8) to i64) smax (1 + (sext i32 %7 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv95 = phi %10, %indvars.iv.next96, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%0>, ir<%indvars.iv95>
    vp<%4> = vector-pointer ir<%arrayidx28>
    WIDEN ir<%12> = load vp<%4>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx30>
    WIDEN store vp<%5>, ir<%12>
    CLONE ir<%indvars.iv.next96> = add nsw ir<%indvars.iv95>, ir<1>
    CLONE ir<%cmp25> = icmp slt ir<%indvars.iv.next96>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN6soplex9CLUFactor11packColumnsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %7 to i64))<nsw> + ((sext i32 (%7 + %8) to i64) smax (1 + (sext i32 %7 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv95 = phi %10, %indvars.iv.next96, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%0>, ir<%indvars.iv95>
    vp<%4> = vector-pointer ir<%arrayidx28>
    WIDEN ir<%12> = load vp<%4>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx30>
    WIDEN store vp<%5>, ir<%12>
    CLONE ir<%indvars.iv.next96> = add nsw ir<%indvars.iv95>, ir<1>
    CLONE ir<%cmp25> = icmp slt ir<%indvars.iv.next96>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor11packColumnsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv95 = phi i64 [ %10, %for.body26.preheader ], [ %indvars.iv.next96, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %9, %for.body26.preheader ], [ %indvars.iv.next, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx28 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv95 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp25 = icmp slt i64 %indvars.iv.next96, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp25, label %for.body26, label %for.end.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor11packColumnsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv95 = phi i64 [ %10, %for.body26.preheader ], [ %indvars.iv.next96, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %9, %for.body26.preheader ], [ %indvars.iv.next, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx28 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv95 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp25 = icmp slt i64 %indvars.iv.next96, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp25, label %for.body26, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 30064771065
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 30064771065
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor11packColumnsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv95 = phi i64 [ %10, %for.body26.preheader ], [ %indvars.iv.next96, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %9, %for.body26.preheader ], [ %indvars.iv.next, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx28 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv95 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp25 = icmp slt i64 %indvars.iv.next96, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp25, label %for.body26, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 30064771065
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 10737418242
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor11packColumnsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv95 = phi i64 [ %10, %for.body26.preheader ], [ %indvars.iv.next96, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %9, %for.body26.preheader ], [ %indvars.iv.next, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx28 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv95 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp25 = icmp slt i64 %indvars.iv.next96, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp25, label %for.body26, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771065
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709136

-----------------Function that is being costed:'_ZN6soplex9CLUFactor11packColumnsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv95 = phi i64 [ %10, %for.body26.preheader ], [ %indvars.iv.next96, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %9, %for.body26.preheader ], [ %indvars.iv.next, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx28 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv95 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp25 = icmp slt i64 %indvars.iv.next96, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp25, label %for.body26, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 30064771065
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 5368709136
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex9CLUFactor11packColumnsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv95 = phi i64 [ %10, %for.body26.preheader ], [ %indvars.iv.next96, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %9, %for.body26.preheader ], [ %indvars.iv.next, %for.body26 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx28 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv95 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %12 = load i32, ptr %arrayidx28, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx30 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %12, ptr %arrayidx30, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp25 = icmp slt i64 %indvars.iv.next96, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp25, label %for.body26, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2684354604, RTCostB: 30064771065
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2684354604, RTCostB: 5368709136
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex9CLUFactor11packColumnsEv at line: factor.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %7 to i64))<nsw> + ((sext i32 (%7 + %8) to i64) smax (1 + (sext i32 %7 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4>    = DERIVED-IV ir<%10> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%9> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%0>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx28>
    WIDEN ir<%18> = load vp<%8>
    CLONE ir<%indvars.iv.next> = add nsw vp<%7>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, vp<%7>
    vp<%9> = vector-pointer ir<%arrayidx30>
    WIDEN store vp<%9>, ir<%18>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 6
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor8remaxColEii' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv227 = phi %38, %indvars.iv.next228, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %36, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<%35>, ir<%indvars.iv>
    CLONE ir<%39> = load ir<%arrayidx183>
    CLONE ir<%indvars.iv.next228> = add nsw ir<%indvars.iv227>, ir<1>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<%35>, ir<%indvars.iv227>
    CLONE store ir<%39>, ir<%arrayidx185>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp181> = icmp slt ir<%indvars.iv.next>, ir<%37>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end187.loopexit>, scalar.ph

ir-bb<if.end187.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor8remaxColEii' from factor.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv227 = phi %38, %indvars.iv.next228, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %36, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<%35>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx183>
    WIDEN ir<%39> = load vp<%4>
    CLONE ir<%indvars.iv.next228> = add nsw ir<%indvars.iv227>, ir<1>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<%35>, ir<%indvars.iv227>
    vp<%5> = vector-pointer ir<%arrayidx185>
    WIDEN store vp<%5>, ir<%39>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp181> = icmp slt ir<%indvars.iv.next>, ir<%37>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end187.loopexit>, scalar.ph

ir-bb<if.end187.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor8remaxColEii' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv227 = phi %38, %indvars.iv.next228, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %36, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<%35>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx183>
    WIDEN ir<%39> = load vp<%4>
    CLONE ir<%indvars.iv.next228> = add nsw ir<%indvars.iv227>, ir<1>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<%35>, ir<%indvars.iv227>
    vp<%5> = vector-pointer ir<%arrayidx185>
    WIDEN store vp<%5>, ir<%39>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp181> = icmp slt ir<%indvars.iv.next>, ir<%37>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end187.loopexit>, scalar.ph

ir-bb<if.end187.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxColEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv227 = phi i64 [ %38, %for.body.preheader ], [ %indvars.iv.next228, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %36, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx183 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next228 = add nsw i64 %indvars.iv227, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv227 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp181 = icmp slt i64 %indvars.iv.next, %37 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp181, label %for.body, label %if.end187.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxColEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv227 = phi i64 [ %38, %for.body.preheader ], [ %indvars.iv.next228, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %36, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx183 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next228 = add nsw i64 %indvars.iv227, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv227 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp181 = icmp slt i64 %indvars.iv.next, %37 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp181, label %for.body, label %if.end187.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 30064771065
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418242, RTCostB: 30064771065
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxColEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv227 = phi i64 [ %38, %for.body.preheader ], [ %indvars.iv.next228, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %36, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx183 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next228 = add nsw i64 %indvars.iv227, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv227 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp181 = icmp slt i64 %indvars.iv.next, %37 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp181, label %for.body, label %if.end187.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 30064771065
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 10737418242
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxColEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv227 = phi i64 [ %38, %for.body.preheader ], [ %indvars.iv.next228, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %36, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx183 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next228 = add nsw i64 %indvars.iv227, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv227 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp181 = icmp slt i64 %indvars.iv.next, %37 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp181, label %for.body, label %if.end187.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771065
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 5368709136

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxColEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv227 = phi i64 [ %38, %for.body.preheader ], [ %indvars.iv.next228, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %36, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx183 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next228 = add nsw i64 %indvars.iv227, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv227 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp181 = icmp slt i64 %indvars.iv.next, %37 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp181, label %for.body, label %if.end187.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 30064771065
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709136, RTCostB: 5368709136
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex9CLUFactor8remaxColEii' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv227 = phi i64 [ %38, %for.body.preheader ], [ %indvars.iv.next228, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %36, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx183 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %39 = load i32, ptr %arrayidx183, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next228 = add nsw i64 %indvars.iv227, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx185 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv227 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %39, ptr %arrayidx185, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp181 = icmp slt i64 %indvars.iv.next, %37 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp181, label %for.body, label %if.end187.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2684354604, RTCostB: 30064771065
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2684354604, RTCostB: 5368709136
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex9CLUFactor8remaxColEii at line: factor.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4>    = DERIVED-IV ir<%38> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%36> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<%35>, vp<%7>
    vp<%8> = vector-pointer ir<%arrayidx183>
    WIDEN ir<%45> = load vp<%8>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<%35>, vp<%5>
    vp<%9> = vector-pointer ir<%arrayidx185>
    WIDEN store vp<%9>, ir<%45>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<if.end187.loopexit>, scalar.ph

ir-bb<if.end187.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN6soplex9CLUFactor15initFactorRingsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + (-1 * %7) + %6) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    CLONE store ir<%arrayidx>, ir<%arrayidx>
    CLONE ir<%prev> = getelementptr inbounds ir<%8>, ir<%indvars.iv>, ir<1>
    CLONE store ir<%arrayidx>, ir<%prev>
    CLONE ir<%arrayidx27> = getelementptr inbounds ir<%9>, ir<%indvars.iv>
    CLONE store ir<%arrayidx27>, ir<%arrayidx27>
    CLONE ir<%prev37> = getelementptr inbounds ir<%9>, ir<%indvars.iv>, ir<1>
    CLONE store ir<%arrayidx27>, ir<%prev37>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%19> = trunc ir<%indvars.iv>
    CLONE ir<%cmp> = icmp sgt ir<%19>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond38.preheader.loopexit>, scalar.ph

ir-bb<for.cond38.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor15initFactorRingsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + (-1 * %7) + %6) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %10, %indvars.iv.next\l" +
    "  ir<%19>, ir<-1>
    REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    REPLICATE store ir<%arrayidx>, ir<%arrayidx>
    REPLICATE ir<%prev> = getelementptr inbounds ir<%8>, ir<%indvars.iv>, ir<1>
    REPLICATE store ir<%arrayidx>, ir<%prev>
    REPLICATE ir<%arrayidx27> = getelementptr inbounds ir<%9>, ir<%indvars.iv>
    REPLICATE store ir<%arrayidx27>, ir<%arrayidx27>
    REPLICATE ir<%prev37> = getelementptr inbounds ir<%9>, ir<%indvars.iv>, ir<1>
    REPLICATE store ir<%arrayidx27>, ir<%prev37>
    REPLICATE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp> = icmp sgt ir<%19>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond38.preheader.loopexit>, scalar.ph

ir-bb<for.cond38.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor15initFactorRingsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + (-1 * %7) + %6) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %10, %indvars.iv.next\l" +
    "  ir<%19>, ir<-1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    REPLICATE store ir<%arrayidx>, ir<%arrayidx>
    WIDEN-GEP Inv[Var][Inv] ir<%prev> = getelementptr inbounds ir<%8>, ir<%indvars.iv>, ir<1>
    REPLICATE store ir<%arrayidx>, ir<%prev>
    WIDEN-GEP Inv[Var] ir<%arrayidx27> = getelementptr inbounds ir<%9>, ir<%indvars.iv>
    REPLICATE store ir<%arrayidx27>, ir<%arrayidx27>
    WIDEN-GEP Inv[Var][Inv] ir<%prev37> = getelementptr inbounds ir<%9>, ir<%indvars.iv>, ir<1>
    REPLICATE store ir<%arrayidx27>, ir<%prev37>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp> = icmp sgt ir<%19>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond38.preheader.loopexit>, scalar.ph

ir-bb<for.cond38.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor15initFactorRingsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 + (-1 * %7) + %6) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %10, %indvars.iv.next\l" +
    "  ir<%19>, ir<-1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx>, ir<%arrayidx>
    WIDEN-GEP Inv[Var][Inv] ir<%prev> = getelementptr inbounds ir<%8>, ir<%indvars.iv>, ir<1>
    WIDEN store ir<%prev>, ir<%arrayidx>
    WIDEN-GEP Inv[Var] ir<%arrayidx27> = getelementptr inbounds ir<%9>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx27>, ir<%arrayidx27>
    WIDEN-GEP Inv[Var][Inv] ir<%prev37> = getelementptr inbounds ir<%9>, ir<%indvars.iv>, ir<1>
    WIDEN store ir<%prev37>, ir<%arrayidx27>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp> = icmp sgt ir<%19>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond38.preheader.loopexit>, scalar.ph

ir-bb<for.cond38.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor15initFactorRingsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %10, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %8, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %arrayidx, ptr %arrayidx, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %prev = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %8, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %arrayidx, ptr %prev, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx27 = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %9, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %arrayidx27, ptr %arrayidx27, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %prev37 = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %9, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %arrayidx27, ptr %prev37, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %19 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp sgt i32 %19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %for.body, label %for.cond38.preheader.loopexit of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor15initFactorRingsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %10, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 2 For instruction:   store ptr %arrayidx, ptr %arrayidx, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %prev = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %8, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 2 For instruction:   store ptr %arrayidx, ptr %prev, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx27 = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %9, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF 2 For instruction:   store ptr %arrayidx27, ptr %arrayidx27, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %prev37 = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %9, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 16 for VF 2 For instruction:   store ptr %arrayidx27, ptr %prev37, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %19 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp sgt i32 %19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %for.body, label %for.cond38.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 17

-----------------Function that is being costed:'_ZN6soplex9CLUFactor15initFactorRingsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %10, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store ptr %arrayidx, ptr %arrayidx, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %prev = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %8, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %arrayidx, ptr %prev, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx27 = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %9, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store ptr %arrayidx27, ptr %arrayidx27, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %prev37 = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %9, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store ptr %arrayidx27, ptr %prev37, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %19 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp sgt i32 %19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %for.body, label %for.cond38.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836480
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836480

-----------------Function that is being costed:'_ZN6soplex9CLUFactor15initFactorRingsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %10, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store ptr %arrayidx, ptr %arrayidx, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %prev = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %8, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   store ptr %arrayidx, ptr %prev, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx27 = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %9, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store ptr %arrayidx27, ptr %arrayidx27, align 8, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %prev37 = getelementptr inbounds %"class.soplex::CLUFactor::Pring", ptr %9, i64 %indvars.iv, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 82 for VF vscale x 2 For instruction:   store ptr %arrayidx27, ptr %prev37, align 8, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %19 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp sgt i32 %19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %for.body, label %for.cond38.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 41
A is scalable.	B is not scalable.	
RTCostA: 89120571392, RTCostB: 21474836480
A is scalable.	B is not scalable.	
RTCostA: 89120571392, RTCostB: 21474836480
LV: Selecting VF: 1 With Cost: 10.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor12setupRowValsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%rrperm.0124> = WIDEN-POINTER-INDUCTION ir<%11>, 4
    EMIT ir<%rperm.0123> = WIDEN-POINTER-INDUCTION ir<%12>, 4
    EMIT ir<%rrorig.0122> = WIDEN-POINTER-INDUCTION ir<%13>, 4
    EMIT ir<%rorig.0121> = WIDEN-POINTER-INDUCTION ir<%14>, 4
    EMIT ir<%l_rbeg.0120> = WIDEN-POINTER-INDUCTION ir<%10>, 4
    WIDEN-INDUCTION %i.0119 = phi %dec, %0, ir<-1>
    CLONE ir<%dec> = add nsw ir<%i.0119>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%rrorig.0122>, ir<4>
    CLONE ir<%15> = load ir<%rrorig.0122>
    CLONE ir<%incdec.ptr40> = getelementptr inbounds ir<%rorig.0121>, ir<4>
    CLONE store ir<%15>, ir<%rorig.0121>
    CLONE ir<%incdec.ptr41> = getelementptr inbounds ir<%rrperm.0124>, ir<4>
    CLONE ir<%16> = load ir<%rrperm.0124>
    CLONE ir<%incdec.ptr42> = getelementptr inbounds ir<%rperm.0123>, ir<4>
    CLONE store ir<%16>, ir<%rperm.0123>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds ir<%l_rbeg.0120>, ir<4>
    CLONE store ir<0>, ir<%l_rbeg.0120>
    CLONE ir<%tobool39.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}

========== Loop: _ZN6soplex9CLUFactor12setupRowValsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    EMIT ir<%rrperm.0124> = WIDEN-POINTER-INDUCTION ir<%11>, 4
    EMIT ir<%rperm.0123> = WIDEN-POINTER-INDUCTION ir<%12>, 4
    EMIT ir<%rrorig.0122> = WIDEN-POINTER-INDUCTION ir<%13>, 4
    EMIT ir<%rorig.0121> = WIDEN-POINTER-INDUCTION ir<%14>, 4
    EMIT ir<%l_rbeg.0120> = WIDEN-POINTER-INDUCTION ir<%10>, 4
    WIDEN-INDUCTION %i.0119 = phi %dec, %0, ir<-1>
    CLONE ir<%dec> = add nsw ir<%i.0119>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%rrorig.0122>, ir<4>
    vp<%4> = vector-pointer ir<%rrorig.0122>
    WIDEN ir<%15> = load vp<%4>
    CLONE ir<%incdec.ptr40> = getelementptr inbounds ir<%rorig.0121>, ir<4>
    vp<%5> = vector-pointer ir<%rorig.0121>
    WIDEN store vp<%5>, ir<%15>
    CLONE ir<%incdec.ptr41> = getelementptr inbounds ir<%rrperm.0124>, ir<4>
    vp<%6> = vector-pointer ir<%rrperm.0124>
    WIDEN ir<%16> = load vp<%6>
    CLONE ir<%incdec.ptr42> = getelementptr inbounds ir<%rperm.0123>, ir<4>
    vp<%7> = vector-pointer ir<%rperm.0123>
    WIDEN store vp<%7>, ir<%16>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds ir<%l_rbeg.0120>, ir<4>
    vp<%8> = vector-pointer ir<%l_rbeg.0120>
    WIDEN store vp<%8>, ir<0>
    CLONE ir<%tobool39.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}

========== Loop: _ZN6soplex9CLUFactor12setupRowValsEv' from factor.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    EMIT ir<%rrperm.0124> = WIDEN-POINTER-INDUCTION ir<%11>, 4
    EMIT ir<%rperm.0123> = WIDEN-POINTER-INDUCTION ir<%12>, 4
    EMIT ir<%rrorig.0122> = WIDEN-POINTER-INDUCTION ir<%13>, 4
    EMIT ir<%rorig.0121> = WIDEN-POINTER-INDUCTION ir<%14>, 4
    EMIT ir<%l_rbeg.0120> = WIDEN-POINTER-INDUCTION ir<%10>, 4
    WIDEN-INDUCTION %i.0119 = phi %dec, %0, ir<-1>
    CLONE ir<%dec> = add nsw ir<%i.0119>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%rrorig.0122>, ir<4>
    vp<%4> = vector-pointer ir<%rrorig.0122>
    WIDEN ir<%15> = load vp<%4>
    CLONE ir<%incdec.ptr40> = getelementptr inbounds ir<%rorig.0121>, ir<4>
    vp<%5> = vector-pointer ir<%rorig.0121>
    WIDEN store vp<%5>, ir<%15>
    CLONE ir<%incdec.ptr41> = getelementptr inbounds ir<%rrperm.0124>, ir<4>
    vp<%6> = vector-pointer ir<%rrperm.0124>
    WIDEN ir<%16> = load vp<%6>
    CLONE ir<%incdec.ptr42> = getelementptr inbounds ir<%rperm.0123>, ir<4>
    vp<%7> = vector-pointer ir<%rperm.0123>
    WIDEN store vp<%7>, ir<%16>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds ir<%l_rbeg.0120>, ir<4>
    vp<%8> = vector-pointer ir<%l_rbeg.0120>
    WIDEN store vp<%8>, ir<0>
    CLONE ir<%tobool39.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor12setupRowValsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rrperm.0124 = phi ptr [ %incdec.ptr41, %for.body ], [ %11, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rperm.0123 = phi ptr [ %incdec.ptr42, %for.body ], [ %12, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rrorig.0122 = phi ptr [ %incdec.ptr, %for.body ], [ %13, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %rorig.0121 = phi ptr [ %incdec.ptr40, %for.body ], [ %14, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %l_rbeg.0120 = phi ptr [ %incdec.ptr43, %for.body ], [ %10, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0119 = phi i32 [ %dec, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %i.0119, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %rrorig.0122, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr40 = getelementptr inbounds i8, ptr %rorig.0121, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr41 = getelementptr inbounds i8, ptr %rrperm.0124, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr42 = getelementptr inbounds i8, ptr %rperm.0123, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %l_rbeg.0120, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool39.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool39.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor12setupRowValsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rrperm.0124 = phi ptr [ %incdec.ptr41, %for.body ], [ %11, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rperm.0123 = phi ptr [ %incdec.ptr42, %for.body ], [ %12, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rrorig.0122 = phi ptr [ %incdec.ptr, %for.body ], [ %13, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %rorig.0121 = phi ptr [ %incdec.ptr40, %for.body ], [ %14, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %l_rbeg.0120 = phi ptr [ %incdec.ptr43, %for.body ], [ %10, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0119 = phi i32 [ %dec, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %i.0119, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %rrorig.0122, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr40 = getelementptr inbounds i8, ptr %rorig.0121, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr41 = getelementptr inbounds i8, ptr %rrperm.0124, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr42 = getelementptr inbounds i8, ptr %rperm.0123, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %l_rbeg.0120, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool39.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool39.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 15032385541, RTCostB: 51539607540
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 15032385541, RTCostB: 51539607540
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12setupRowValsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rrperm.0124 = phi ptr [ %incdec.ptr41, %for.body ], [ %11, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rperm.0123 = phi ptr [ %incdec.ptr42, %for.body ], [ %12, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rrorig.0122 = phi ptr [ %incdec.ptr, %for.body ], [ %13, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %rorig.0121 = phi ptr [ %incdec.ptr40, %for.body ], [ %14, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %l_rbeg.0120 = phi ptr [ %incdec.ptr43, %for.body ], [ %10, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0119 = phi i32 [ %dec, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %i.0119, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %rrorig.0122, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr40 = getelementptr inbounds i8, ptr %rorig.0121, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr41 = getelementptr inbounds i8, ptr %rrperm.0124, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr42 = getelementptr inbounds i8, ptr %rperm.0123, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %l_rbeg.0120, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool39.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool39.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192797, RTCostB: 51539607540
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192797, RTCostB: 15032385541
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12setupRowValsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rrperm.0124 = phi ptr [ %incdec.ptr41, %for.body ], [ %11, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rperm.0123 = phi ptr [ %incdec.ptr42, %for.body ], [ %12, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rrorig.0122 = phi ptr [ %incdec.ptr, %for.body ], [ %13, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %rorig.0121 = phi ptr [ %incdec.ptr40, %for.body ], [ %14, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %l_rbeg.0120 = phi ptr [ %incdec.ptr43, %for.body ], [ %10, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0119 = phi i32 [ %dec, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %i.0119, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %rrorig.0122, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr40 = getelementptr inbounds i8, ptr %rorig.0121, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr41 = getelementptr inbounds i8, ptr %rrperm.0124, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr42 = getelementptr inbounds i8, ptr %rperm.0123, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %l_rbeg.0120, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool39.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool39.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 51539607540
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192797

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12setupRowValsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rrperm.0124 = phi ptr [ %incdec.ptr41, %for.body ], [ %11, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rperm.0123 = phi ptr [ %incdec.ptr42, %for.body ], [ %12, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rrorig.0122 = phi ptr [ %incdec.ptr, %for.body ], [ %13, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %rorig.0121 = phi ptr [ %incdec.ptr40, %for.body ], [ %14, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %l_rbeg.0120 = phi ptr [ %incdec.ptr43, %for.body ], [ %10, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0119 = phi i32 [ %dec, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %i.0119, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %rrorig.0122, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr40 = getelementptr inbounds i8, ptr %rorig.0121, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr41 = getelementptr inbounds i8, ptr %rrperm.0124, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr42 = getelementptr inbounds i8, ptr %rperm.0123, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %l_rbeg.0120, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool39.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool39.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192797, RTCostB: 51539607540
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192797, RTCostB: 7516192797
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12setupRowValsEv' from factor.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rrperm.0124 = phi ptr [ %incdec.ptr41, %for.body ], [ %11, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rperm.0123 = phi ptr [ %incdec.ptr42, %for.body ], [ %12, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rrorig.0122 = phi ptr [ %incdec.ptr, %for.body ], [ %13, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %rorig.0121 = phi ptr [ %incdec.ptr40, %for.body ], [ %14, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %l_rbeg.0120 = phi ptr [ %incdec.ptr43, %for.body ], [ %10, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0119 = phi i32 [ %dec, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i32 %i.0119, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %rrorig.0122, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %15 = load i32, ptr %rrorig.0122, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr40 = getelementptr inbounds i8, ptr %rorig.0121, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %15, ptr %rorig.0121, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr41 = getelementptr inbounds i8, ptr %rrperm.0124, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %16 = load i32, ptr %rrperm.0124, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr42 = getelementptr inbounds i8, ptr %rperm.0123, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %16, ptr %rperm.0123, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr43 = getelementptr inbounds i8, ptr %l_rbeg.0120, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 0, ptr %l_rbeg.0120, align 4, !tbaa !27 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool39.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool39.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3758096461, RTCostB: 51539607540
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 3758096461, RTCostB: 7516192797
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex9CLUFactor12setupRowValsEv at line: factor.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%24>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<4>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<4>
    EMIT vp<%6> = ptradd ir<%12>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<4>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<4>
    EMIT vp<%9> = ptradd ir<%14>, vp<%8>
    vp<%10>    = DERIVED-IV ir<0> + vp<%3> * ir<4>
    vp<%11> = SCALAR-STEPS vp<%10>, ir<4>
    EMIT vp<%12> = ptradd ir<%16>, vp<%11>
    vp<%13>    = DERIVED-IV ir<0> + vp<%3> * ir<4>
    vp<%14> = SCALAR-STEPS vp<%13>, ir<4>
    EMIT vp<%15> = ptradd ir<%18>, vp<%14>
    vp<%16>    = DERIVED-IV ir<0> + vp<%3> * ir<4>
    vp<%17> = SCALAR-STEPS vp<%16>, ir<4>
    EMIT vp<%18> = ptradd ir<%10>, vp<%17>
    vp<%19> = vector-pointer vp<%12>
    WIDEN ir<%40> = load vp<%19>
    vp<%20> = vector-pointer vp<%15>
    WIDEN store vp<%20>, ir<%40>
    vp<%21> = vector-pointer vp<%6>
    WIDEN ir<%41> = load vp<%21>
    vp<%22> = vector-pointer vp<%9>
    WIDEN store vp<%22>, ir<%41>
    CLONE ir<%incdec.ptr43> = getelementptr inbounds vp<%18>, ir<4>
    vp<%23> = vector-pointer vp<%18>
    WIDEN store vp<%23>, ir<0>
    EMIT vp<%24> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%24>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%26> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%26>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr43.lcssa = ir<%incdec.ptr43>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 43
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o forest.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           forest.cc
@@ Instruction =>  %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %13, ptr %arrayidx32, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %13, ptr %arrayidx32, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %13, ptr %arrayidx32, align 8, !tbaa !29 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %13, ptr %arrayidx32, align 8, !tbaa !29 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %13, ptr %arrayidx32, align 8, !tbaa !29 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor17forestPackColumnsEv' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body28.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %8 to i64))<nsw> + ((sext i32 (%8 + %9) to i64) smax (1 + (sext i32 %8 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv103 = phi %11, %indvars.iv.next104, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, ir<%indvars.iv103>
    CLONE ir<%13> = load ir<%arrayidx30>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    CLONE store ir<%13>, ir<%arrayidx32>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%1>, ir<%indvars.iv103>
    CLONE ir<%14> = load ir<%arrayidx34>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    CLONE store ir<%14>, ir<%arrayidx36>
    CLONE ir<%indvars.iv.next104> = add nsw ir<%indvars.iv103>, ir<1>
    CLONE ir<%cmp27> = icmp slt ir<%indvars.iv.next104>, ir<%12>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN6soplex9CLUFactor17forestPackColumnsEv' from forest.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body28.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %8 to i64))<nsw> + ((sext i32 (%8 + %9) to i64) smax (1 + (sext i32 %8 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv103 = phi %11, %indvars.iv.next104, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, ir<%indvars.iv103>
    vp<%4> = vector-pointer ir<%arrayidx30>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx32>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%1>, ir<%indvars.iv103>
    vp<%6> = vector-pointer ir<%arrayidx34>
    WIDEN ir<%14> = load vp<%6>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%7> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%7>, ir<%14>
    CLONE ir<%indvars.iv.next104> = add nsw ir<%indvars.iv103>, ir<1>
    CLONE ir<%cmp27> = icmp slt ir<%indvars.iv.next104>, ir<%12>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN6soplex9CLUFactor17forestPackColumnsEv' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body28.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %8 to i64))<nsw> + ((sext i32 (%8 + %9) to i64) smax (1 + (sext i32 %8 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv103 = phi %11, %indvars.iv.next104, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, ir<%indvars.iv103>
    vp<%4> = vector-pointer ir<%arrayidx30>
    WIDEN ir<%13> = load vp<%4>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx32>
    WIDEN store vp<%5>, ir<%13>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%1>, ir<%indvars.iv103>
    vp<%6> = vector-pointer ir<%arrayidx34>
    WIDEN ir<%14> = load vp<%6>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%7> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%7>, ir<%14>
    CLONE ir<%indvars.iv.next104> = add nsw ir<%indvars.iv103>, ir<1>
    CLONE ir<%cmp27> = icmp slt ir<%indvars.iv.next104>, ir<%12>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor17forestPackColumnsEv' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv103 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next104, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx30 = getelementptr inbounds double, ptr %0, i64 %indvars.iv103 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx32 = getelementptr inbounds double, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %13, ptr %arrayidx32, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx34 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv103 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx36 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next104 = add nsw i64 %indvars.iv103, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next104, %12 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor17forestPackColumnsEv' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv103 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next104, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx30 = getelementptr inbounds double, ptr %0, i64 %indvars.iv103 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx32 = getelementptr inbounds double, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %13, ptr %arrayidx32, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx34 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv103 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx36 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next104 = add nsw i64 %indvars.iv103, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next104, %12 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 15032385540, RTCostB: 47244640245
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 15032385540, RTCostB: 47244640245
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor17forestPackColumnsEv' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv103 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next104, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx30 = getelementptr inbounds double, ptr %0, i64 %indvars.iv103 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx32 = getelementptr inbounds double, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store double %13, ptr %arrayidx32, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx34 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv103 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx36 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next104 = add nsw i64 %indvars.iv103, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next104, %12 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 9663676440, RTCostB: 47244640245
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676440, RTCostB: 15032385540
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor17forestPackColumnsEv' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv103 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next104, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx30 = getelementptr inbounds double, ptr %0, i64 %indvars.iv103 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx32 = getelementptr inbounds double, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %13, ptr %arrayidx32, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx34 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv103 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx36 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next104 = add nsw i64 %indvars.iv103, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next104, %12 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 47244640245
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 9663676440

-----------------Function that is being costed:'_ZN6soplex9CLUFactor17forestPackColumnsEv' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv103 = phi i64 [ %11, %for.body28.preheader ], [ %indvars.iv.next104, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %10, %for.body28.preheader ], [ %indvars.iv.next, %for.body28 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx30 = getelementptr inbounds double, ptr %0, i64 %indvars.iv103 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %13 = load double, ptr %arrayidx30, align 8, !tbaa !29 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx32 = getelementptr inbounds double, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %13, ptr %arrayidx32, align 8, !tbaa !29 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx34 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv103 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %14 = load i32, ptr %arrayidx34, align 4, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx36 = getelementptr inbounds i32, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %14, ptr %arrayidx36, align 4, !tbaa !28 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next104 = add nsw i64 %indvars.iv103, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp27 = icmp slt i64 %indvars.iv.next104, %12 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp27, label %for.body28, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192794, RTCostB: 47244640245
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192794, RTCostB: 9663676440
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN6soplex9CLUFactor17forestPackColumnsEv at line: forest.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body28.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %8 to i64))<nsw> + ((sext i32 (%8 + %9) to i64) smax (1 + (sext i32 %8 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%11> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%10> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%arrayidx30> = getelementptr inbounds ir<%0>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx30>
    WIDEN ir<%23> = load vp<%8>
    CLONE ir<%arrayidx32> = getelementptr inbounds ir<%0>, vp<%7>
    vp<%9> = vector-pointer ir<%arrayidx32>
    WIDEN store vp<%9>, ir<%23>
    CLONE ir<%arrayidx34> = getelementptr inbounds ir<%1>, vp<%5>
    vp<%10> = vector-pointer ir<%arrayidx34>
    WIDEN ir<%24> = load vp<%10>
    CLONE ir<%indvars.iv.next> = add nsw vp<%7>, ir<1>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%1>, vp<%7>
    vp<%11> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%11>, ir<%24>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %40, ptr %arrayidx192, align 8, !tbaa !35 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %40, ptr %arrayidx192, align 8, !tbaa !35 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store double %40, ptr %arrayidx192, align 8, !tbaa !35 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %40, ptr %arrayidx192, align 8, !tbaa !35 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %40, ptr %arrayidx192, align 8, !tbaa !35 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor14forestReMaxColEii' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv241 = phi %39, %indvars.iv.next242, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %37, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx190> = getelementptr inbounds ir<%36>, ir<%indvars.iv>
    CLONE ir<%40> = load ir<%arrayidx190>
    CLONE ir<%arrayidx192> = getelementptr inbounds ir<%36>, ir<%indvars.iv241>
    CLONE store ir<%40>, ir<%arrayidx192>
    CLONE ir<%arrayidx194> = getelementptr inbounds ir<%35>, ir<%indvars.iv>
    CLONE ir<%41> = load ir<%arrayidx194>
    CLONE ir<%indvars.iv.next242> = add nsw ir<%indvars.iv241>, ir<1>
    CLONE ir<%arrayidx196> = getelementptr inbounds ir<%35>, ir<%indvars.iv241>
    CLONE store ir<%41>, ir<%arrayidx196>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp188> = icmp slt ir<%indvars.iv.next>, ir<%38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end198.loopexit>, scalar.ph

ir-bb<if.end198.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor14forestReMaxColEii' from forest.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv241 = phi %39, %indvars.iv.next242, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %37, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx190> = getelementptr inbounds ir<%36>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx190>
    WIDEN ir<%40> = load vp<%4>
    CLONE ir<%arrayidx192> = getelementptr inbounds ir<%36>, ir<%indvars.iv241>
    vp<%5> = vector-pointer ir<%arrayidx192>
    WIDEN store vp<%5>, ir<%40>
    CLONE ir<%arrayidx194> = getelementptr inbounds ir<%35>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx194>
    WIDEN ir<%41> = load vp<%6>
    CLONE ir<%indvars.iv.next242> = add nsw ir<%indvars.iv241>, ir<1>
    CLONE ir<%arrayidx196> = getelementptr inbounds ir<%35>, ir<%indvars.iv241>
    vp<%7> = vector-pointer ir<%arrayidx196>
    WIDEN store vp<%7>, ir<%41>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp188> = icmp slt ir<%indvars.iv.next>, ir<%38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end198.loopexit>, scalar.ph

ir-bb<if.end198.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor14forestReMaxColEii' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv241 = phi %39, %indvars.iv.next242, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi %37, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx190> = getelementptr inbounds ir<%36>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx190>
    WIDEN ir<%40> = load vp<%4>
    CLONE ir<%arrayidx192> = getelementptr inbounds ir<%36>, ir<%indvars.iv241>
    vp<%5> = vector-pointer ir<%arrayidx192>
    WIDEN store vp<%5>, ir<%40>
    CLONE ir<%arrayidx194> = getelementptr inbounds ir<%35>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx194>
    WIDEN ir<%41> = load vp<%6>
    CLONE ir<%indvars.iv.next242> = add nsw ir<%indvars.iv241>, ir<1>
    CLONE ir<%arrayidx196> = getelementptr inbounds ir<%35>, ir<%indvars.iv241>
    vp<%7> = vector-pointer ir<%arrayidx196>
    WIDEN store vp<%7>, ir<%41>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp188> = icmp slt ir<%indvars.iv.next>, ir<%38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end198.loopexit>, scalar.ph

ir-bb<if.end198.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor14forestReMaxColEii' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv241 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next242, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx190 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx192 = getelementptr inbounds double, ptr %36, i64 %indvars.iv241 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %40, ptr %arrayidx192, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx194 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next242 = add nsw i64 %indvars.iv241, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx196 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv241 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp188 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp188, label %for.body, label %if.end198.loopexit of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor14forestReMaxColEii' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv241 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next242, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx190 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx192 = getelementptr inbounds double, ptr %36, i64 %indvars.iv241 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %40, ptr %arrayidx192, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx194 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next242 = add nsw i64 %indvars.iv241, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx196 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv241 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp188 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp188, label %for.body, label %if.end198.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 15032385540, RTCostB: 47244640245
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 15032385540, RTCostB: 47244640245
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor14forestReMaxColEii' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv241 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next242, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx190 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx192 = getelementptr inbounds double, ptr %36, i64 %indvars.iv241 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store double %40, ptr %arrayidx192, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx194 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next242 = add nsw i64 %indvars.iv241, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx196 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv241 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp188 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp188, label %for.body, label %if.end198.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 9663676440, RTCostB: 47244640245
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676440, RTCostB: 15032385540
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor14forestReMaxColEii' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv241 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next242, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx190 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx192 = getelementptr inbounds double, ptr %36, i64 %indvars.iv241 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %40, ptr %arrayidx192, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx194 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next242 = add nsw i64 %indvars.iv241, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx196 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv241 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp188 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp188, label %for.body, label %if.end198.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 47244640245
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 9663676440

-----------------Function that is being costed:'_ZN6soplex9CLUFactor14forestReMaxColEii' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv241 = phi i64 [ %39, %for.body.preheader ], [ %indvars.iv.next242, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %37, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx190 = getelementptr inbounds double, ptr %36, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %40 = load double, ptr %arrayidx190, align 8, !tbaa !35 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx192 = getelementptr inbounds double, ptr %36, i64 %indvars.iv241 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %40, ptr %arrayidx192, align 8, !tbaa !35 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx194 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %41 = load i32, ptr %arrayidx194, align 4, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next242 = add nsw i64 %indvars.iv241, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx196 = getelementptr inbounds i32, ptr %35, i64 %indvars.iv241 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %41, ptr %arrayidx196, align 4, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp188 = icmp slt i64 %indvars.iv.next, %38 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp188, label %for.body, label %if.end198.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192794, RTCostB: 47244640245
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192794, RTCostB: 9663676440
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN6soplex9CLUFactor14forestReMaxColEii at line: forest.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (sext i32 %22 to i64))<nsw> + ((sext i32 (%22 + %24) to i64) smax (1 + (sext i32 %22 to i64))<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%39> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%37> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%arrayidx190> = getelementptr inbounds ir<%36>, vp<%7>
    vp<%8> = vector-pointer ir<%arrayidx190>
    WIDEN ir<%50> = load vp<%8>
    CLONE ir<%arrayidx192> = getelementptr inbounds ir<%36>, vp<%5>
    vp<%9> = vector-pointer ir<%arrayidx192>
    WIDEN store vp<%9>, ir<%50>
    CLONE ir<%arrayidx194> = getelementptr inbounds ir<%35>, vp<%7>
    vp<%10> = vector-pointer ir<%arrayidx194>
    WIDEN ir<%51> = load vp<%10>
    CLONE ir<%arrayidx196> = getelementptr inbounds ir<%35>, vp<%5>
    vp<%11> = vector-pointer ir<%arrayidx196>
    WIDEN store vp<%11>, ir<%51>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end198.loopexit>, scalar.ph

ir-bb<if.end198.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then256>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %r.4 to i64) + (-1 * (sext i32 %75 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1428 = phi %idxprom257, %indvars.iv.next1429, ir<1>
    CLONE ir<%indvars.iv.next1429> = add nsw ir<%indvars.iv1428>, ir<1>
    CLONE ir<%arrayidx264> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next1429>
    CLONE ir<%77> = load ir<%arrayidx264>
    CLONE ir<%arrayidx266> = getelementptr inbounds ir<%11>, ir<%indvars.iv1428>
    CLONE store ir<%77>, ir<%arrayidx266>
    CLONE ir<%exitcond1432.not> = icmp eq ir<%indvars.iv.next1429>, ir<%wide.trip.count1431>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end269>, scalar.ph

ir-bb<for.end269>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then256>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %r.4 to i64) + (-1 * (sext i32 %75 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1428 = phi %idxprom257, %indvars.iv.next1429, ir<1>
    CLONE ir<%indvars.iv.next1429> = add nsw ir<%indvars.iv1428>, ir<1>
    CLONE ir<%arrayidx264> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next1429>
    vp<%4> = vector-pointer ir<%arrayidx264>
    WIDEN ir<%77> = load vp<%4>
    CLONE ir<%arrayidx266> = getelementptr inbounds ir<%11>, ir<%indvars.iv1428>
    vp<%5> = vector-pointer ir<%arrayidx266>
    WIDEN store vp<%5>, ir<%77>
    CLONE ir<%exitcond1432.not> = icmp eq ir<%indvars.iv.next1429>, ir<%wide.trip.count1431>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end269>, scalar.ph

ir-bb<for.end269>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then256>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %r.4 to i64) + (-1 * (sext i32 %75 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1428 = phi %idxprom257, %indvars.iv.next1429, ir<1>
    CLONE ir<%indvars.iv.next1429> = add nsw ir<%indvars.iv1428>, ir<1>
    CLONE ir<%arrayidx264> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next1429>
    vp<%4> = vector-pointer ir<%arrayidx264>
    WIDEN ir<%77> = load vp<%4>
    CLONE ir<%arrayidx266> = getelementptr inbounds ir<%11>, ir<%indvars.iv1428>
    vp<%5> = vector-pointer ir<%arrayidx266>
    WIDEN store vp<%5>, ir<%77>
    CLONE ir<%exitcond1432.not> = icmp eq ir<%indvars.iv.next1429>, ir<%wide.trip.count1431>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end269>, scalar.ph

ir-bb<for.end269>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1428 = phi i64 [ %idxprom257, %if.then256 ], [ %indvars.iv.next1429, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1429 = add nsw i64 %indvars.iv1428, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx264 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv.next1429 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx266 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv1428 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1432.not = icmp eq i64 %indvars.iv.next1429, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1432.not, label %for.end269, label %for.body261 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1428 = phi i64 [ %idxprom257, %if.then256 ], [ %indvars.iv.next1429, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1429 = add nsw i64 %indvars.iv1428, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx264 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv.next1429 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx266 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv1428 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1432.not = icmp eq i64 %indvars.iv.next1429, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1432.not, label %for.end269, label %for.body261 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1428 = phi i64 [ %idxprom257, %if.then256 ], [ %indvars.iv.next1429, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1429 = add nsw i64 %indvars.iv1428, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx264 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv.next1429 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx266 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv1428 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1432.not = icmp eq i64 %indvars.iv.next1429, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1432.not, label %for.end269, label %for.body261 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1428 = phi i64 [ %idxprom257, %if.then256 ], [ %indvars.iv.next1429, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1429 = add nsw i64 %indvars.iv1428, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx264 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv.next1429 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx266 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv1428 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1432.not = icmp eq i64 %indvars.iv.next1429, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1432.not, label %for.end269, label %for.body261 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1428 = phi i64 [ %idxprom257, %if.then256 ], [ %indvars.iv.next1429, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1429 = add nsw i64 %indvars.iv1428, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx264 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv.next1429 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx266 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv1428 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1432.not = icmp eq i64 %indvars.iv.next1429, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1432.not, label %for.end269, label %for.body261 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1428 = phi i64 [ %idxprom257, %if.then256 ], [ %indvars.iv.next1429, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next1429 = add nsw i64 %indvars.iv1428, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx264 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv.next1429 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %77 = load i32, ptr %arrayidx264, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx266 = getelementptr inbounds i32, ptr %11, i64 %indvars.iv1428 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %77, ptr %arrayidx266, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1432.not = icmp eq i64 %indvars.iv.next1429, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1432.not, label %for.end269, label %for.body261 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi at line: forest.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then256>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %r.4 to i64) + (-1 * (sext i32 %75 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%idxprom257> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next1429> = add nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx264> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next1429>
    vp<%6> = vector-pointer ir<%arrayidx264>
    WIDEN ir<%77> = load vp<%6>
    CLONE ir<%arrayidx266> = getelementptr inbounds ir<%11>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx266>
    WIDEN store vp<%7>, ir<%77>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end269>, scalar.ph

ir-bb<for.end269>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body286.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %r.4 to i64) + (-1 * (sext i32 %75 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1438 = phi %idxprom257, %indvars.iv.next1439, ir<1>
    CLONE ir<%indvars.iv.next1439> = add nsw ir<%indvars.iv1438>, ir<1>
    CLONE ir<%arrayidx289> = getelementptr inbounds ir<%13>, ir<%indvars.iv.next1439>
    CLONE ir<%110> = load ir<%arrayidx289>
    CLONE ir<%arrayidx291> = getelementptr inbounds ir<%13>, ir<%indvars.iv1438>
    CLONE store ir<%110>, ir<%arrayidx291>
    CLONE ir<%exitcond1442.not> = icmp eq ir<%indvars.iv.next1439>, ir<%wide.trip.count1431>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end294>, scalar.ph

ir-bb<for.end294>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body286.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %r.4 to i64) + (-1 * (sext i32 %75 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1438 = phi %idxprom257, %indvars.iv.next1439, ir<1>
    CLONE ir<%indvars.iv.next1439> = add nsw ir<%indvars.iv1438>, ir<1>
    CLONE ir<%arrayidx289> = getelementptr inbounds ir<%13>, ir<%indvars.iv.next1439>
    vp<%4> = vector-pointer ir<%arrayidx289>
    WIDEN ir<%110> = load vp<%4>
    CLONE ir<%arrayidx291> = getelementptr inbounds ir<%13>, ir<%indvars.iv1438>
    vp<%5> = vector-pointer ir<%arrayidx291>
    WIDEN store vp<%5>, ir<%110>
    CLONE ir<%exitcond1442.not> = icmp eq ir<%indvars.iv.next1439>, ir<%wide.trip.count1431>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end294>, scalar.ph

ir-bb<for.end294>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body286.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %r.4 to i64) + (-1 * (sext i32 %75 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1438 = phi %idxprom257, %indvars.iv.next1439, ir<1>
    CLONE ir<%indvars.iv.next1439> = add nsw ir<%indvars.iv1438>, ir<1>
    CLONE ir<%arrayidx289> = getelementptr inbounds ir<%13>, ir<%indvars.iv.next1439>
    vp<%4> = vector-pointer ir<%arrayidx289>
    WIDEN ir<%110> = load vp<%4>
    CLONE ir<%arrayidx291> = getelementptr inbounds ir<%13>, ir<%indvars.iv1438>
    vp<%5> = vector-pointer ir<%arrayidx291>
    WIDEN store vp<%5>, ir<%110>
    CLONE ir<%exitcond1442.not> = icmp eq ir<%indvars.iv.next1439>, ir<%wide.trip.count1431>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end294>, scalar.ph

ir-bb<for.end294>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1438 = phi i64 [ %idxprom257, %for.body286.preheader ], [ %indvars.iv.next1439, %for.body286 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1439 = add nsw i64 %indvars.iv1438, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx289 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv.next1439 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx291 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1438 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1442.not = icmp eq i64 %indvars.iv.next1439, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1442.not, label %for.end294, label %for.body286 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1438 = phi i64 [ %idxprom257, %for.body286.preheader ], [ %indvars.iv.next1439, %for.body286 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1439 = add nsw i64 %indvars.iv1438, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx289 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv.next1439 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx291 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1438 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1442.not = icmp eq i64 %indvars.iv.next1439, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1442.not, label %for.end294, label %for.body286 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1438 = phi i64 [ %idxprom257, %for.body286.preheader ], [ %indvars.iv.next1439, %for.body286 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1439 = add nsw i64 %indvars.iv1438, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx289 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv.next1439 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx291 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1438 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1442.not = icmp eq i64 %indvars.iv.next1439, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1442.not, label %for.end294, label %for.body286 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1438 = phi i64 [ %idxprom257, %for.body286.preheader ], [ %indvars.iv.next1439, %for.body286 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1439 = add nsw i64 %indvars.iv1438, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx289 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv.next1439 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx291 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1438 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1442.not = icmp eq i64 %indvars.iv.next1439, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1442.not, label %for.end294, label %for.body286 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1438 = phi i64 [ %idxprom257, %for.body286.preheader ], [ %indvars.iv.next1439, %for.body286 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1439 = add nsw i64 %indvars.iv1438, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx289 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv.next1439 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx291 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1438 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1442.not = icmp eq i64 %indvars.iv.next1439, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1442.not, label %for.end294, label %for.body286 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1438 = phi i64 [ %idxprom257, %for.body286.preheader ], [ %indvars.iv.next1439, %for.body286 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next1439 = add nsw i64 %indvars.iv1438, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx289 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv.next1439 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %110 = load i32, ptr %arrayidx289, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx291 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1438 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %110, ptr %arrayidx291, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1442.not = icmp eq i64 %indvars.iv.next1439, %wide.trip.count1431 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1442.not, label %for.end294, label %for.body286 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi at line: forest.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body286.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %r.4 to i64) + (-1 * (sext i32 %75 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%idxprom257> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next1439> = add nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx289> = getelementptr inbounds ir<%13>, ir<%indvars.iv.next1439>
    vp<%6> = vector-pointer ir<%arrayidx289>
    WIDEN ir<%110> = load vp<%6>
    CLONE ir<%arrayidx291> = getelementptr inbounds ir<%13>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx291>
    WIDEN store vp<%7>, ir<%110>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end294>, scalar.ph

ir-bb<for.end294>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body648.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-2 + (-1 * %r.4) + %15) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1462 = phi %240, %indvars.iv.next1463, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.11382> = phi ir<0>, ir<%add655>
    CLONE ir<%arrayidx650> = getelementptr inbounds ir<%13>, ir<%indvars.iv1462>
    CLONE ir<%241> = load ir<%arrayidx650>
    CLONE ir<%idxprom651> = sext ir<%241>
    CLONE ir<%arrayidx652> = getelementptr inbounds ir<%p_work>, ir<%idxprom651>
    CLONE ir<%242> = load ir<%arrayidx652>
    CLONE ir<%cmp653> = fcmp une ir<%242>, ir<0.000000e+00>
    CLONE ir<%conv654> = zext ir<%cmp653>
    CLONE ir<%add655> = add ir<%n.11382>, ir<%conv654>
    CLONE ir<%indvars.iv.next1463> = add nuw nsw ir<%indvars.iv1462>, ir<1>
    CLONE ir<%243> = trunc ir<%indvars.iv.next1463>
    CLONE ir<%cmp647> = icmp sgt ir<%15>, ir<%243>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%n.11382>, ir<%add655>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end658.loopexit>, scalar.ph

ir-bb<for.end658.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add655.lcssa = vp<%6>
}

========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body648.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-2 + (-1 * %r.4) + %15) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1462 = phi %240, %indvars.iv.next1463, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.11382> = phi ir<0>, ir<%add655>
    CLONE ir<%arrayidx650> = getelementptr inbounds ir<%13>, ir<%indvars.iv1462>
    vp<%4> = vector-pointer ir<%arrayidx650>
    WIDEN ir<%241> = load vp<%4>
    WIDEN-CAST ir<%idxprom651> = sext  ir<%241> to i64
    REPLICATE ir<%arrayidx652> = getelementptr inbounds ir<%p_work>, ir<%idxprom651>
    REPLICATE ir<%242> = load ir<%arrayidx652>
    WIDEN ir<%cmp653> = fcmp une ir<%242>, ir<0.000000e+00>
    WIDEN-CAST ir<%conv654> = zext  ir<%cmp653> to i32
    WIDEN ir<%add655> = add ir<%n.11382>, ir<%conv654>
    CLONE ir<%indvars.iv.next1463> = add nuw nsw ir<%indvars.iv1462>, ir<1>
    CLONE ir<%243> = trunc ir<%indvars.iv.next1463>
    CLONE ir<%cmp647> = icmp sgt ir<%15>, ir<%243>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%n.11382>, ir<%add655>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end658.loopexit>, scalar.ph

ir-bb<for.end658.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add655.lcssa = vp<%7>
}

========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body648.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-2 + (-1 * %r.4) + %15) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1462 = phi %240, %indvars.iv.next1463, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.11382> = phi ir<0>, ir<%add655>
    CLONE ir<%arrayidx650> = getelementptr inbounds ir<%13>, ir<%indvars.iv1462>
    vp<%4> = vector-pointer ir<%arrayidx650>
    WIDEN ir<%241> = load vp<%4>
    WIDEN-CAST ir<%idxprom651> = sext  ir<%241> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx652> = getelementptr inbounds ir<%p_work>, ir<%idxprom651>
    REPLICATE ir<%242> = load ir<%arrayidx652>
    WIDEN ir<%cmp653> = fcmp une ir<%242>, ir<0.000000e+00>
    WIDEN-CAST ir<%conv654> = zext  ir<%cmp653> to i32
    WIDEN ir<%add655> = add ir<%n.11382>, ir<%conv654>
    CLONE ir<%indvars.iv.next1463> = add nuw nsw ir<%indvars.iv1462>, ir<1>
    CLONE ir<%243> = trunc ir<%indvars.iv.next1463>
    CLONE ir<%cmp647> = icmp sgt ir<%15>, ir<%243>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%n.11382>, ir<%add655>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end658.loopexit>, scalar.ph

ir-bb<for.end658.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add655.lcssa = vp<%7>
}

========== Loop: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body648.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-2 + (-1 * %r.4) + %15) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1462 = phi %240, %indvars.iv.next1463, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.11382> = phi ir<0>, ir<%add655>
    CLONE ir<%arrayidx650> = getelementptr inbounds ir<%13>, ir<%indvars.iv1462>
    vp<%4> = vector-pointer ir<%arrayidx650>
    WIDEN ir<%241> = load vp<%4>
    WIDEN-CAST ir<%idxprom651> = sext  ir<%241> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx652> = getelementptr inbounds ir<%p_work>, ir<%idxprom651>
    WIDEN ir<%242> = load ir<%arrayidx652>
    WIDEN ir<%cmp653> = fcmp une ir<%242>, ir<0.000000e+00>
    WIDEN-CAST ir<%conv654> = zext  ir<%cmp653> to i32
    WIDEN ir<%add655> = add ir<%n.11382>, ir<%conv654>
    CLONE ir<%indvars.iv.next1463> = add nuw nsw ir<%indvars.iv1462>, ir<1>
    CLONE ir<%243> = trunc ir<%indvars.iv.next1463>
    CLONE ir<%cmp647> = icmp sgt ir<%15>, ir<%243>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%n.11382>, ir<%add655>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end658.loopexit>, scalar.ph

ir-bb<for.end658.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add655.lcssa = vp<%7>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1462 = phi i64 [ %240, %for.body648.preheader ], [ %indvars.iv.next1463, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.11382 = phi i32 [ 0, %for.body648.preheader ], [ %add655, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx650 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1462 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom651 = sext i32 %241 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx652 = getelementptr inbounds double, ptr %p_work, i64 %idxprom651 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %242 = load double, ptr %arrayidx652, align 8, !tbaa !39 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp653 = fcmp une double %242, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv654 = zext i1 %cmp653 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add655 = add nuw nsw i32 %n.11382, %conv654 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1463 = add nuw nsw i64 %indvars.iv1462, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %243 = trunc nuw i64 %indvars.iv.next1463 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp647 = icmp sgt i32 %15, %243 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp647, label %for.body648, label %for.end658.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1462 = phi i64 [ %240, %for.body648.preheader ], [ %indvars.iv.next1463, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.11382 = phi i32 [ 0, %for.body648.preheader ], [ %add655, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx650 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1462 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom651 = sext i32 %241 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx652 = getelementptr inbounds double, ptr %p_work, i64 %idxprom651 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %242 = load double, ptr %arrayidx652, align 8, !tbaa !39 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp653 = fcmp une double %242, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv654 = zext i1 %cmp653 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add655 = add nuw nsw i32 %n.11382, %conv654 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1463 = add nuw nsw i64 %indvars.iv1462, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %243 = trunc nuw i64 %indvars.iv.next1463 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp647 = icmp sgt i32 %15, %243 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp647, label %for.body648, label %for.end658.loopexit of type:br
LV: Vector loop of width 2 costs: 17
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 34
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 34, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 34
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 34, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1462 = phi i64 [ %240, %for.body648.preheader ], [ %indvars.iv.next1463, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n.11382 = phi i32 [ 0, %for.body648.preheader ], [ %add655, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx650 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1462 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom651 = sext i32 %241 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx652 = getelementptr inbounds double, ptr %p_work, i64 %idxprom651 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %242 = load double, ptr %arrayidx652, align 8, !tbaa !39 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp653 = fcmp une double %242, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv654 = zext i1 %cmp653 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add655 = add nuw nsw i32 %n.11382, %conv654 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1463 = add nuw nsw i64 %indvars.iv1462, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %243 = trunc nuw i64 %indvars.iv.next1463 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp647 = icmp sgt i32 %15, %243 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp647, label %for.body648, label %for.end658.loopexit of type:br
LV: Vector loop of width 4 costs: 16
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 65
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 65, CostB * EstimatedWidthA: 36
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 65
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 65, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1462 = phi i64 [ %240, %for.body648.preheader ], [ %indvars.iv.next1463, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.11382 = phi i32 [ 0, %for.body648.preheader ], [ %add655, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx650 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1462 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom651 = sext i32 %241 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx652 = getelementptr inbounds double, ptr %p_work, i64 %idxprom651 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %242 = load double, ptr %arrayidx652, align 8, !tbaa !39 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp653 = fcmp une double %242, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv654 = zext i1 %cmp653 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add655 = add nuw nsw i32 %n.11382, %conv654 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1463 = add nuw nsw i64 %indvars.iv1462, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %243 = trunc nuw i64 %indvars.iv.next1463 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp647 = icmp sgt i32 %15, %243 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp647, label %for.body648, label %for.end658.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12forestUpdateEiPdiPi' from forest.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1462 = phi i64 [ %240, %for.body648.preheader ], [ %indvars.iv.next1463, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.11382 = phi i32 [ 0, %for.body648.preheader ], [ %add655, %for.body648 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx650 = getelementptr inbounds i32, ptr %13, i64 %indvars.iv1462 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %241 = load i32, ptr %arrayidx650, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom651 = sext i32 %241 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx652 = getelementptr inbounds double, ptr %p_work, i64 %idxprom651 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %242 = load double, ptr %arrayidx652, align 8, !tbaa !39 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp653 = fcmp une double %242, 0.000000e+00 of type:fcmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv654 = zext i1 %cmp653 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add655 = add nuw nsw i32 %n.11382, %conv654 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1463 = add nuw nsw i64 %indvars.iv1462, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %243 = trunc nuw i64 %indvars.iv.next1463 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp647 = icmp sgt i32 %15, %243 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp647, label %for.body648, label %for.end658.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 47
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 47, CostB * EstimatedWidthA: 36
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 47
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 47, CostB * EstimatedWidthA: 36
LV: Selecting VF: 1 With Cost: 9.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN6soplex9CLUFactor12forestUpdateEiPdiPi at line: forest.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body648.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-2 + (-1 * %r.4) + %15) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%n.11382> = phi ir<0>, ir<%add655>
    vp<%4>    = DERIVED-IV ir<%240> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx650> = getelementptr inbounds ir<%13>, vp<%5>
    CLONE ir<%241> = load ir<%arrayidx650>
    CLONE ir<%idxprom651> = sext ir<%241>
    CLONE ir<%arrayidx652> = getelementptr inbounds ir<%p_work>, ir<%idxprom651>
    CLONE ir<%242> = load ir<%arrayidx652>
    CLONE ir<%cmp653> = fcmp une ir<%242>, ir<0.000000e+00>
    CLONE ir<%conv654> = zext ir<%cmp653>
    CLONE ir<%add655> = add ir<%n.11382>, ir<%conv654>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%n.11382>, ir<%add655>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end658.loopexit>, scalar.ph

ir-bb<for.end658.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add655.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 18
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o idxset.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           idxset.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o leave.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           leave.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lpcolset.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           lpcolset.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lprow.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           lprow.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o lprowset.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           lprowset.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o message.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           message.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o mpsinput.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           mpsinput.cc
@@ Instruction =>  %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 95, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 95, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 95, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 95, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 95, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 95, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 95, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 95, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 95, ptr %arrayidx14, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: _ZN6soplexL11patch_fieldEPcii' from mpsinput.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.addr.0.lcssa) + %end.addr.0.lcssa) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv44 = phi %6, %indvars.iv.next45, ir<1>
    CLONE ir<%arrayidx14> = getelementptr inbounds ir<%buf>, ir<%indvars.iv44>
    CLONE ir<%8> = load ir<%arrayidx14>
    CLONE ir<%cmp16> = icmp eq ir<%8>, ir<32>
  Successor(s): if.then

  if.then:
    CLONE store ir<95>, ir<%arrayidx14>, ir<%cmp16>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp16>
    EMIT vp<%5> = or vp<%4>, ir<%cmp16>
    CLONE ir<%indvars.iv.next45> = add nsw ir<%indvars.iv44>, ir<1>
    CLONE ir<%lftr.wideiv47> = trunc ir<%indvars.iv.next45>
    CLONE ir<%exitcond48.not> = icmp eq ir<%7>, ir<%lftr.wideiv47>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplexL11patch_fieldEPcii' from mpsinput.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.addr.0.lcssa) + %end.addr.0.lcssa) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv44 = phi %6, %indvars.iv.next45, ir<1>
    CLONE ir<%arrayidx14> = getelementptr ir<%buf>, ir<%indvars.iv44>
    vp<%4> = vector-pointer ir<%arrayidx14>
    WIDEN ir<%8> = load vp<%4>
    WIDEN ir<%cmp16> = icmp eq ir<%8>, ir<32>
  Successor(s): if.then

  if.then:
    vp<%5> = vector-pointer ir<%arrayidx14>
    WIDEN store vp<%5>, ir<95>, ir<%cmp16>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp16>
    EMIT vp<%7> = or vp<%6>, ir<%cmp16>
    CLONE ir<%indvars.iv.next45> = add nsw ir<%indvars.iv44>, ir<1>
    CLONE ir<%lftr.wideiv47> = trunc ir<%indvars.iv.next45>
    CLONE ir<%exitcond48.not> = icmp eq ir<%7>, ir<%lftr.wideiv47>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplexL11patch_fieldEPcii' from mpsinput.cc==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.addr.0.lcssa) + %end.addr.0.lcssa) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv44 = phi %6, %indvars.iv.next45, ir<1>
    CLONE ir<%arrayidx14> = getelementptr ir<%buf>, ir<%indvars.iv44>
    vp<%4> = vector-pointer ir<%arrayidx14>
    WIDEN ir<%8> = load vp<%4>
    WIDEN ir<%cmp16> = icmp eq ir<%8>, ir<32>
  Successor(s): if.then

  if.then:
    vp<%5> = vector-pointer ir<%arrayidx14>
    WIDEN store vp<%5>, ir<95>, ir<%cmp16>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp16>
    EMIT vp<%7> = or vp<%6>, ir<%cmp16>
    CLONE ir<%indvars.iv.next45> = add nsw ir<%indvars.iv44>, ir<1>
    CLONE ir<%lftr.wideiv47> = trunc ir<%indvars.iv.next45>
    CLONE ir<%exitcond48.not> = icmp eq ir<%7>, ir<%lftr.wideiv47>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 25
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 25, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 5
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 44
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 44
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 5
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 84
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 84
B VF: 8, EstimatedWidthB: 8, CostB: 44
CostA * EstimatedWidthB: 672, CostB * EstimatedWidthA: 704
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 84
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 168

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 84
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 336
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 16

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: vscale x 4, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv44 = phi i64 [ %6, %for.body.preheader ], [ %indvars.iv.next45, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx14 = getelementptr inbounds i8, ptr %buf, i64 %indvars.iv44 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %8 = load i8, ptr %arrayidx14, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp16 = icmp eq i8 %8, 32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp16, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 95, ptr %arrayidx14, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'_ZN6soplexL11patch_fieldEPcii' from mpsinput.cc-----------------
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next45 = add nsw i64 %indvars.iv44, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %lftr.wideiv47 = trunc i64 %indvars.iv.next45 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond48.not = icmp eq i32 %7, %lftr.wideiv47 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond48.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 84
B VF: 8, EstimatedWidthB: 8, CostB: 44
CostA * EstimatedWidthB: 672, CostB * EstimatedWidthA: 704
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 84
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 336
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
A is scalable.	B is scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: vscale x 4, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: _ZN6soplexL11patch_fieldEPcii at line: mpsinput.cc
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: _ZN6soplexL11patch_fieldEPcii at line: mpsinput.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %beg.addr.0.lcssa) + %end.addr.0.lcssa) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%6> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx14> = getelementptr ir<%buf>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx14>
    WIDEN ir<%8> = load vp<%6>
    WIDEN ir<%cmp16> = icmp eq ir<%8>, ir<32>
    vp<%7> = vector-pointer ir<%arrayidx14>
    WIDEN store vp<%7>, ir<95>, ir<%cmp16>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: _ZN6soplexL11patch_fieldEPcii at line: mpsinput.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%10> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3>    = DERIVED-IV ir<%6> + vp<%2> * ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx14> = getelementptr ir<%buf>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx14>
    WIDEN ir<%38> = load vp<%5>
    WIDEN ir<%cmp16> = icmp eq ir<%38>, ir<32>
    vp<%6> = vector-pointer ir<%arrayidx14>
    WIDEN store vp<%6>, ir<95>, ir<%cmp16>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%10>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 5
Loops Epilogues Vectorized: 1
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o nameset.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           nameset.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o slufactor.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           slufactor.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o solve.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           solve.cc
@@ Instruction =>  %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load double, ptr %val.199, align 8, !tbaa !27 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load double, ptr %val.199, align 8, !tbaa !27 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load double, ptr %val.199, align 8, !tbaa !27 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %20 = load double, ptr %val.199, align 8, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %20 = load double, ptr %val.199, align 8, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor11solveLrightEPd' from solve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body44.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %16) + %17) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%idx.1101> = WIDEN-POINTER-INDUCTION ir<%arrayidx36>, 4
    WIDEN-INDUCTION %j.1100 = phi %dec50, %17, ir<-1>
    EMIT ir<%val.199> = WIDEN-POINTER-INDUCTION ir<%arrayidx38>, 8
    WIDEN-REDUCTION-PHI ir<%x.098> = phi ir<0.000000e+00>, ir<%21>.1
    CLONE ir<%incdec.ptr45> = getelementptr inbounds ir<%idx.1101>, ir<4>
    CLONE ir<%18> = load ir<%idx.1101>
    CLONE ir<%idxprom46> = sext ir<%18>
    CLONE ir<%arrayidx47> = getelementptr inbounds ir<%vec>, ir<%idxprom46>
    CLONE ir<%19> = load ir<%arrayidx47>
    CLONE ir<%incdec.ptr48> = getelementptr inbounds ir<%val.199>, ir<8>
    CLONE ir<%20> = load ir<%val.199>
    EMIT vp<%4> = fmul ir<%19>, ir<%20>
    CLONE ir<%21> = call @llvm.fmuladd.f64(ir<%19>, ir<%20>, ir<%x.098>)
    CLONE ir<%dec50> = add nsw ir<%j.1100>, ir<-1>
    CLONE ir<%cmp43> = icmp sgt ir<%dec50>, ir<%16>
    REDUCE ir<%21>.1 = ir<%x.098> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.098>, ir<%21>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end51.loopexit>, scalar.ph

ir-bb<for.end51.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%7>
}

========== Loop: _ZN6soplex9CLUFactor11solveLrightEPd' from solve.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body44.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %16) + %17) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.1101> = WIDEN-POINTER-INDUCTION ir<%arrayidx36>, 4
    WIDEN-INDUCTION %j.1100 = phi %dec50, %17, ir<-1>
    EMIT ir<%val.199> = WIDEN-POINTER-INDUCTION ir<%arrayidx38>, 8
    WIDEN-REDUCTION-PHI ir<%x.098> = phi ir<0.000000e+00>, ir<%21>.1
    CLONE ir<%incdec.ptr45> = getelementptr inbounds ir<%idx.1101>, ir<4>
    vp<%4> = vector-pointer ir<%idx.1101>
    WIDEN ir<%18> = load vp<%4>
    WIDEN-CAST ir<%idxprom46> = sext  ir<%18> to i64
    REPLICATE ir<%arrayidx47> = getelementptr inbounds ir<%vec>, ir<%idxprom46>
    REPLICATE ir<%19> = load ir<%arrayidx47>
    CLONE ir<%incdec.ptr48> = getelementptr inbounds ir<%val.199>, ir<8>
    vp<%5> = vector-pointer ir<%val.199>
    WIDEN ir<%20> = load vp<%5>
    EMIT vp<%6> = fmul ir<%19>, ir<%20>
    WIDEN-CALL ir<%21> = call @llvm.fmuladd.f64(ir<%19>, ir<%20>, ir<%x.098>) (using vector intrinsic)
    CLONE ir<%dec50> = add nsw ir<%j.1100>, ir<-1>
    CLONE ir<%cmp43> = icmp sgt ir<%dec50>, ir<%16>
    REDUCE ir<%21>.1 = ir<%x.098> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.098>, ir<%21>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end51.loopexit>, scalar.ph

ir-bb<for.end51.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor11solveLrightEPd' from solve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body44.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %16) + %17) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.1101> = WIDEN-POINTER-INDUCTION ir<%arrayidx36>, 4
    WIDEN-INDUCTION %j.1100 = phi %dec50, %17, ir<-1>
    EMIT ir<%val.199> = WIDEN-POINTER-INDUCTION ir<%arrayidx38>, 8
    WIDEN-REDUCTION-PHI ir<%x.098> = phi ir<0.000000e+00>, ir<%21>.1
    CLONE ir<%incdec.ptr45> = getelementptr inbounds ir<%idx.1101>, ir<4>
    vp<%4> = vector-pointer ir<%idx.1101>
    WIDEN ir<%18> = load vp<%4>
    WIDEN-CAST ir<%idxprom46> = sext  ir<%18> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx47> = getelementptr inbounds ir<%vec>, ir<%idxprom46>
    REPLICATE ir<%19> = load ir<%arrayidx47>
    CLONE ir<%incdec.ptr48> = getelementptr inbounds ir<%val.199>, ir<8>
    vp<%5> = vector-pointer ir<%val.199>
    WIDEN ir<%20> = load vp<%5>
    EMIT vp<%6> = fmul ir<%19>, ir<%20>
    WIDEN-CALL ir<%21> = call @llvm.fmuladd.f64(ir<%19>, ir<%20>, ir<%x.098>) (using vector intrinsic)
    CLONE ir<%dec50> = add nsw ir<%j.1100>, ir<-1>
    CLONE ir<%cmp43> = icmp sgt ir<%dec50>, ir<%16>
    REDUCE ir<%21>.1 = ir<%x.098> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.098>, ir<%21>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end51.loopexit>, scalar.ph

ir-bb<for.end51.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor11solveLrightEPd' from solve.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body44.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %16) + %17) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.1101> = WIDEN-POINTER-INDUCTION ir<%arrayidx36>, 4
    WIDEN-INDUCTION %j.1100 = phi %dec50, %17, ir<-1>
    EMIT ir<%val.199> = WIDEN-POINTER-INDUCTION ir<%arrayidx38>, 8
    WIDEN-REDUCTION-PHI ir<%x.098> = phi ir<0.000000e+00>, ir<%21>.1
    CLONE ir<%incdec.ptr45> = getelementptr inbounds ir<%idx.1101>, ir<4>
    vp<%4> = vector-pointer ir<%idx.1101>
    WIDEN ir<%18> = load vp<%4>
    WIDEN-CAST ir<%idxprom46> = sext  ir<%18> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx47> = getelementptr inbounds ir<%vec>, ir<%idxprom46>
    WIDEN ir<%19> = load ir<%arrayidx47>
    CLONE ir<%incdec.ptr48> = getelementptr inbounds ir<%val.199>, ir<8>
    vp<%5> = vector-pointer ir<%val.199>
    WIDEN ir<%20> = load vp<%5>
    EMIT vp<%6> = fmul ir<%19>, ir<%20>
    WIDEN-CALL ir<%21> = call @llvm.fmuladd.f64(ir<%19>, ir<%20>, ir<%x.098>) (using vector intrinsic)
    CLONE ir<%dec50> = add nsw ir<%j.1100>, ir<-1>
    CLONE ir<%cmp43> = icmp sgt ir<%dec50>, ir<%16>
    REDUCE ir<%21>.1 = ir<%x.098> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.098>, ir<%21>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end51.loopexit>, scalar.ph

ir-bb<for.end51.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor11solveLrightEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx.1101 = phi ptr [ %incdec.ptr45, %for.body44 ], [ %arrayidx36, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.1100 = phi i32 [ %dec50, %for.body44 ], [ %17, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %val.199 = phi ptr [ %incdec.ptr48, %for.body44 ], [ %arrayidx38, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.098 = phi double [ %21, %for.body44 ], [ 0.000000e+00, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr45 = getelementptr inbounds i8, ptr %idx.1101, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom46 = sext i32 %18 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx47 = getelementptr inbounds double, ptr %vec, i64 %idxprom46 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load double, ptr %arrayidx47, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr48 = getelementptr inbounds i8, ptr %val.199, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %20 = load double, ptr %val.199, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %19, double %20, double %x.098) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec50 = add nsw i32 %j.1100, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp43 = icmp sgt i32 %dec50, %16 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp43, label %for.body44, label %for.end51.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor11solveLrightEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx.1101 = phi ptr [ %incdec.ptr45, %for.body44 ], [ %arrayidx36, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.1100 = phi i32 [ %dec50, %for.body44 ], [ %17, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %val.199 = phi ptr [ %incdec.ptr48, %for.body44 ], [ %arrayidx38, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.098 = phi double [ %21, %for.body44 ], [ 0.000000e+00, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr45 = getelementptr inbounds i8, ptr %idx.1101, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom46 = sext i32 %18 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx47 = getelementptr inbounds double, ptr %vec, i64 %idxprom46 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %19 = load double, ptr %arrayidx47, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr48 = getelementptr inbounds i8, ptr %val.199, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %20 = load double, ptr %val.199, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %19, double %20, double %x.098) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec50 = add nsw i32 %j.1100, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp43 = icmp sgt i32 %dec50, %16 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp43, label %for.body44, label %for.end51.loopexit of type:br
LV: Vector loop of width 2 costs: 20
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 40
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 40
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor11solveLrightEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idx.1101 = phi ptr [ %incdec.ptr45, %for.body44 ], [ %arrayidx36, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.1100 = phi i32 [ %dec50, %for.body44 ], [ %17, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %val.199 = phi ptr [ %incdec.ptr48, %for.body44 ], [ %arrayidx38, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x.098 = phi double [ %21, %for.body44 ], [ 0.000000e+00, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr45 = getelementptr inbounds i8, ptr %idx.1101, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom46 = sext i32 %18 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx47 = getelementptr inbounds double, ptr %vec, i64 %idxprom46 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %19 = load double, ptr %arrayidx47, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr48 = getelementptr inbounds i8, ptr %val.199, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %20 = load double, ptr %val.199, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %19, double %20, double %x.098) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec50 = add nsw i32 %j.1100, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp43 = icmp sgt i32 %dec50, %16 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp43, label %for.body44, label %for.end51.loopexit of type:br
LV: Vector loop of width 4 costs: 19
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 79
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 79, CostB * EstimatedWidthA: 36
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 79
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 79, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'_ZN6soplex9CLUFactor11solveLrightEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx.1101 = phi ptr [ %incdec.ptr45, %for.body44 ], [ %arrayidx36, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.1100 = phi i32 [ %dec50, %for.body44 ], [ %17, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %val.199 = phi ptr [ %incdec.ptr48, %for.body44 ], [ %arrayidx38, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.098 = phi double [ %21, %for.body44 ], [ 0.000000e+00, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr45 = getelementptr inbounds i8, ptr %idx.1101, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom46 = sext i32 %18 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx47 = getelementptr inbounds double, ptr %vec, i64 %idxprom46 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %19 = load double, ptr %arrayidx47, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr48 = getelementptr inbounds i8, ptr %val.199, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %20 = load double, ptr %val.199, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %19, double %20, double %x.098) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec50 = add nsw i32 %j.1100, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp43 = icmp sgt i32 %dec50, %16 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp43, label %for.body44, label %for.end51.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor11solveLrightEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx.1101 = phi ptr [ %incdec.ptr45, %for.body44 ], [ %arrayidx36, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.1100 = phi i32 [ %dec50, %for.body44 ], [ %17, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %val.199 = phi ptr [ %incdec.ptr48, %for.body44 ], [ %arrayidx38, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.098 = phi double [ %21, %for.body44 ], [ 0.000000e+00, %for.body44.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr45 = getelementptr inbounds i8, ptr %idx.1101, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %18 = load i32, ptr %idx.1101, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom46 = sext i32 %18 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx47 = getelementptr inbounds double, ptr %vec, i64 %idxprom46 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %19 = load double, ptr %arrayidx47, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr48 = getelementptr inbounds i8, ptr %val.199, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %20 = load double, ptr %val.199, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %21 = tail call double @llvm.fmuladd.f64(double %19, double %20, double %x.098) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec50 = add nsw i32 %j.1100, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp43 = icmp sgt i32 %dec50, %16 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp43, label %for.body44, label %for.end51.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 51
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 51, CostB * EstimatedWidthA: 36
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 51
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 51, CostB * EstimatedWidthA: 36
LV: Selecting VF: 1 With Cost: 9.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load double, ptr %val.3221, align 8, !tbaa !27 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load double, ptr %val.3221, align 8, !tbaa !27 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load double, ptr %val.3221, align 8, !tbaa !27 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %36 = load double, ptr %val.3221, align 8, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %36 = load double, ptr %val.3221, align 8, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor12solveLright2EPdS1_' from solve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body99.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %32) + %33) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%idx.3223> = WIDEN-POINTER-INDUCTION ir<%arrayidx91>, 4
    WIDEN-INDUCTION %j.3222 = phi %dec107, %33, ir<-1>
    EMIT ir<%val.3221> = WIDEN-POINTER-INDUCTION ir<%arrayidx93>, 8
    WIDEN-REDUCTION-PHI ir<%x1.0220> = phi ir<0.000000e+00>, ir<%37>.1
    WIDEN-REDUCTION-PHI ir<%x2.0219> = phi ir<0.000000e+00>, ir<%39>.1
    CLONE ir<%34> = load ir<%idx.3223>
    CLONE ir<%idxprom100> = sext ir<%34>
    CLONE ir<%arrayidx101> = getelementptr inbounds ir<%vec1>, ir<%idxprom100>
    CLONE ir<%35> = load ir<%arrayidx101>
    CLONE ir<%36> = load ir<%val.3221>
    EMIT vp<%4> = fmul ir<%35>, ir<%36>
    CLONE ir<%37> = call @llvm.fmuladd.f64(ir<%35>, ir<%36>, ir<%x1.0220>)
    CLONE ir<%incdec.ptr102> = getelementptr inbounds ir<%idx.3223>, ir<4>
    CLONE ir<%arrayidx104> = getelementptr inbounds ir<%vec2>, ir<%idxprom100>
    CLONE ir<%38> = load ir<%arrayidx104>
    CLONE ir<%incdec.ptr105> = getelementptr inbounds ir<%val.3221>, ir<8>
    EMIT vp<%5> = fmul ir<%38>, ir<%36>
    CLONE ir<%39> = call @llvm.fmuladd.f64(ir<%38>, ir<%36>, ir<%x2.0219>)
    CLONE ir<%dec107> = add nsw ir<%j.3222>, ir<-1>
    CLONE ir<%cmp98> = icmp sgt ir<%dec107>, ir<%32>
    REDUCE ir<%37>.1 = ir<%x1.0220> + reduce.fadd (vp<%4>)
    REDUCE ir<%39>.1 = ir<%x2.0219> + reduce.fadd (vp<%5>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%x1.0220>, ir<%37>.1
  EMIT vp<%9> = compute-reduction-result ir<%x2.0219>, ir<%39>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end108.loopexit>, scalar.ph

ir-bb<for.end108.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa242 = vp<%8>
Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor12solveLright2EPdS1_' from solve.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body99.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %32) + %33) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%idx.3223> = WIDEN-POINTER-INDUCTION ir<%arrayidx91>, 4
    WIDEN-INDUCTION %j.3222 = phi %dec107, %33, ir<-1>
    EMIT ir<%val.3221> = WIDEN-POINTER-INDUCTION ir<%arrayidx93>, 8
    WIDEN-REDUCTION-PHI ir<%x1.0220> = phi ir<0.000000e+00>, ir<%37>.1
    WIDEN-REDUCTION-PHI ir<%x2.0219> = phi ir<0.000000e+00>, ir<%39>.1
    vp<%4> = vector-pointer ir<%idx.3223>
    WIDEN ir<%34> = load vp<%4>
    WIDEN-CAST ir<%idxprom100> = sext  ir<%34> to i64
    REPLICATE ir<%arrayidx101> = getelementptr inbounds ir<%vec1>, ir<%idxprom100>
    REPLICATE ir<%35> = load ir<%arrayidx101>
    vp<%5> = vector-pointer ir<%val.3221>
    WIDEN ir<%36> = load vp<%5>
    EMIT vp<%6> = fmul ir<%35>, ir<%36>
    WIDEN-CALL ir<%37> = call @llvm.fmuladd.f64(ir<%35>, ir<%36>, ir<%x1.0220>) (using vector intrinsic)
    CLONE ir<%incdec.ptr102> = getelementptr inbounds ir<%idx.3223>, ir<4>
    REPLICATE ir<%arrayidx104> = getelementptr inbounds ir<%vec2>, ir<%idxprom100>
    REPLICATE ir<%38> = load ir<%arrayidx104>
    CLONE ir<%incdec.ptr105> = getelementptr inbounds ir<%val.3221>, ir<8>
    EMIT vp<%7> = fmul ir<%38>, ir<%36>
    WIDEN-CALL ir<%39> = call @llvm.fmuladd.f64(ir<%38>, ir<%36>, ir<%x2.0219>) (using vector intrinsic)
    CLONE ir<%dec107> = add nsw ir<%j.3222>, ir<-1>
    CLONE ir<%cmp98> = icmp sgt ir<%dec107>, ir<%32>
    REDUCE ir<%37>.1 = ir<%x1.0220> + reduce.fadd (vp<%6>)
    REDUCE ir<%39>.1 = ir<%x2.0219> + reduce.fadd (vp<%7>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x1.0220>, ir<%37>.1
  EMIT vp<%11> = compute-reduction-result ir<%x2.0219>, ir<%39>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end108.loopexit>, scalar.ph

ir-bb<for.end108.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa242 = vp<%10>
Live-out double %.lcssa = vp<%11>
}

========== Loop: _ZN6soplex9CLUFactor12solveLright2EPdS1_' from solve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body99.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %32) + %33) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%idx.3223> = WIDEN-POINTER-INDUCTION ir<%arrayidx91>, 4
    WIDEN-INDUCTION %j.3222 = phi %dec107, %33, ir<-1>
    EMIT ir<%val.3221> = WIDEN-POINTER-INDUCTION ir<%arrayidx93>, 8
    WIDEN-REDUCTION-PHI ir<%x1.0220> = phi ir<0.000000e+00>, ir<%37>.1
    WIDEN-REDUCTION-PHI ir<%x2.0219> = phi ir<0.000000e+00>, ir<%39>.1
    vp<%4> = vector-pointer ir<%idx.3223>
    WIDEN ir<%34> = load vp<%4>
    WIDEN-CAST ir<%idxprom100> = sext  ir<%34> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx101> = getelementptr inbounds ir<%vec1>, ir<%idxprom100>
    REPLICATE ir<%35> = load ir<%arrayidx101>
    vp<%5> = vector-pointer ir<%val.3221>
    WIDEN ir<%36> = load vp<%5>
    EMIT vp<%6> = fmul ir<%35>, ir<%36>
    WIDEN-CALL ir<%37> = call @llvm.fmuladd.f64(ir<%35>, ir<%36>, ir<%x1.0220>) (using vector intrinsic)
    CLONE ir<%incdec.ptr102> = getelementptr inbounds ir<%idx.3223>, ir<4>
    WIDEN-GEP Inv[Var] ir<%arrayidx104> = getelementptr inbounds ir<%vec2>, ir<%idxprom100>
    REPLICATE ir<%38> = load ir<%arrayidx104>
    CLONE ir<%incdec.ptr105> = getelementptr inbounds ir<%val.3221>, ir<8>
    EMIT vp<%7> = fmul ir<%38>, ir<%36>
    WIDEN-CALL ir<%39> = call @llvm.fmuladd.f64(ir<%38>, ir<%36>, ir<%x2.0219>) (using vector intrinsic)
    CLONE ir<%dec107> = add nsw ir<%j.3222>, ir<-1>
    CLONE ir<%cmp98> = icmp sgt ir<%dec107>, ir<%32>
    REDUCE ir<%37>.1 = ir<%x1.0220> + reduce.fadd (vp<%6>)
    REDUCE ir<%39>.1 = ir<%x2.0219> + reduce.fadd (vp<%7>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x1.0220>, ir<%37>.1
  EMIT vp<%11> = compute-reduction-result ir<%x2.0219>, ir<%39>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end108.loopexit>, scalar.ph

ir-bb<for.end108.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa242 = vp<%10>
Live-out double %.lcssa = vp<%11>
}

========== Loop: _ZN6soplex9CLUFactor12solveLright2EPdS1_' from solve.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body99.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %32) + %33) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%idx.3223> = WIDEN-POINTER-INDUCTION ir<%arrayidx91>, 4
    WIDEN-INDUCTION %j.3222 = phi %dec107, %33, ir<-1>
    EMIT ir<%val.3221> = WIDEN-POINTER-INDUCTION ir<%arrayidx93>, 8
    WIDEN-REDUCTION-PHI ir<%x1.0220> = phi ir<0.000000e+00>, ir<%37>.1
    WIDEN-REDUCTION-PHI ir<%x2.0219> = phi ir<0.000000e+00>, ir<%39>.1
    vp<%4> = vector-pointer ir<%idx.3223>
    WIDEN ir<%34> = load vp<%4>
    WIDEN-CAST ir<%idxprom100> = sext  ir<%34> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx101> = getelementptr inbounds ir<%vec1>, ir<%idxprom100>
    WIDEN ir<%35> = load ir<%arrayidx101>
    vp<%5> = vector-pointer ir<%val.3221>
    WIDEN ir<%36> = load vp<%5>
    EMIT vp<%6> = fmul ir<%35>, ir<%36>
    WIDEN-CALL ir<%37> = call @llvm.fmuladd.f64(ir<%35>, ir<%36>, ir<%x1.0220>) (using vector intrinsic)
    CLONE ir<%incdec.ptr102> = getelementptr inbounds ir<%idx.3223>, ir<4>
    WIDEN-GEP Inv[Var] ir<%arrayidx104> = getelementptr inbounds ir<%vec2>, ir<%idxprom100>
    WIDEN ir<%38> = load ir<%arrayidx104>
    CLONE ir<%incdec.ptr105> = getelementptr inbounds ir<%val.3221>, ir<8>
    EMIT vp<%7> = fmul ir<%38>, ir<%36>
    WIDEN-CALL ir<%39> = call @llvm.fmuladd.f64(ir<%38>, ir<%36>, ir<%x2.0219>) (using vector intrinsic)
    CLONE ir<%dec107> = add nsw ir<%j.3222>, ir<-1>
    CLONE ir<%cmp98> = icmp sgt ir<%dec107>, ir<%32>
    REDUCE ir<%37>.1 = ir<%x1.0220> + reduce.fadd (vp<%6>)
    REDUCE ir<%39>.1 = ir<%x2.0219> + reduce.fadd (vp<%7>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x1.0220>, ir<%37>.1
  EMIT vp<%11> = compute-reduction-result ir<%x2.0219>, ir<%39>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end108.loopexit>, scalar.ph

ir-bb<for.end108.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa242 = vp<%10>
Live-out double %.lcssa = vp<%11>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor12solveLright2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx.3223 = phi ptr [ %incdec.ptr102, %for.body99 ], [ %arrayidx91, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.3222 = phi i32 [ %dec107, %for.body99 ], [ %33, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %val.3221 = phi ptr [ %incdec.ptr105, %for.body99 ], [ %arrayidx93, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x1.0220 = phi double [ %37, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x2.0219 = phi double [ %39, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom100 = sext i32 %34 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx101 = getelementptr inbounds double, ptr %vec1, i64 %idxprom100 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %35 = load double, ptr %arrayidx101, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %36 = load double, ptr %val.3221, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %37 = tail call double @llvm.fmuladd.f64(double %35, double %36, double %x1.0220) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr102 = getelementptr inbounds i8, ptr %idx.3223, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx104 = getelementptr inbounds double, ptr %vec2, i64 %idxprom100 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %38 = load double, ptr %arrayidx104, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %val.3221, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %39 = tail call double @llvm.fmuladd.f64(double %38, double %36, double %x2.0219) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec107 = add nsw i32 %j.3222, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp98 = icmp sgt i32 %dec107, %32 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp98, label %for.body99, label %for.end108.loopexit of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor12solveLright2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx.3223 = phi ptr [ %incdec.ptr102, %for.body99 ], [ %arrayidx91, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.3222 = phi i32 [ %dec107, %for.body99 ], [ %33, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %val.3221 = phi ptr [ %incdec.ptr105, %for.body99 ], [ %arrayidx93, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x1.0220 = phi double [ %37, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x2.0219 = phi double [ %39, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom100 = sext i32 %34 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx101 = getelementptr inbounds double, ptr %vec1, i64 %idxprom100 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %35 = load double, ptr %arrayidx101, align 8, !tbaa !27 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %36 = load double, ptr %val.3221, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %37 = tail call double @llvm.fmuladd.f64(double %35, double %36, double %x1.0220) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr102 = getelementptr inbounds i8, ptr %idx.3223, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx104 = getelementptr inbounds double, ptr %vec2, i64 %idxprom100 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %38 = load double, ptr %arrayidx104, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %val.3221, i64 8 of type:getelementptr
LV: Found an estimated cost of 8 for VF 2 For instruction:   %39 = tail call double @llvm.fmuladd.f64(double %38, double %36, double %x2.0219) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec107 = add nsw i32 %j.3222, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp98 = icmp sgt i32 %dec107, %32 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp98, label %for.body99, label %for.end108.loopexit of type:br
LV: Vector loop of width 2 costs: 38
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 76
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 76, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 76
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 76, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12solveLright2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idx.3223 = phi ptr [ %incdec.ptr102, %for.body99 ], [ %arrayidx91, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.3222 = phi i32 [ %dec107, %for.body99 ], [ %33, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %val.3221 = phi ptr [ %incdec.ptr105, %for.body99 ], [ %arrayidx93, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x1.0220 = phi double [ %37, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x2.0219 = phi double [ %39, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom100 = sext i32 %34 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx101 = getelementptr inbounds double, ptr %vec1, i64 %idxprom100 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %35 = load double, ptr %arrayidx101, align 8, !tbaa !27 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %36 = load double, ptr %val.3221, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %37 = tail call double @llvm.fmuladd.f64(double %35, double %36, double %x1.0220) of type:call
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr102 = getelementptr inbounds i8, ptr %idx.3223, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx104 = getelementptr inbounds double, ptr %vec2, i64 %idxprom100 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %38 = load double, ptr %arrayidx104, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %val.3221, i64 8 of type:getelementptr
LV: Found an estimated cost of 16 for VF 4 For instruction:   %39 = tail call double @llvm.fmuladd.f64(double %38, double %36, double %x2.0219) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec107 = add nsw i32 %j.3222, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp98 = icmp sgt i32 %dec107, %32 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp98, label %for.body99, label %for.end108.loopexit of type:br
LV: Vector loop of width 4 costs: 37
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 151
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 151, CostB * EstimatedWidthA: 48
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 151
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 151, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12solveLright2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx.3223 = phi ptr [ %incdec.ptr102, %for.body99 ], [ %arrayidx91, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.3222 = phi i32 [ %dec107, %for.body99 ], [ %33, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %val.3221 = phi ptr [ %incdec.ptr105, %for.body99 ], [ %arrayidx93, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x1.0220 = phi double [ %37, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x2.0219 = phi double [ %39, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom100 = sext i32 %34 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx101 = getelementptr inbounds double, ptr %vec1, i64 %idxprom100 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %35 = load double, ptr %arrayidx101, align 8, !tbaa !27 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %36 = load double, ptr %val.3221, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %37 = tail call double @llvm.fmuladd.f64(double %35, double %36, double %x1.0220) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr102 = getelementptr inbounds i8, ptr %idx.3223, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx104 = getelementptr inbounds double, ptr %vec2, i64 %idxprom100 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %38 = load double, ptr %arrayidx104, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %val.3221, i64 8 of type:getelementptr
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %39 = tail call double @llvm.fmuladd.f64(double %38, double %36, double %x2.0219) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec107 = add nsw i32 %j.3222, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp98 = icmp sgt i32 %dec107, %32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp98, label %for.body99, label %for.end108.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12solveLright2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx.3223 = phi ptr [ %incdec.ptr102, %for.body99 ], [ %arrayidx91, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.3222 = phi i32 [ %dec107, %for.body99 ], [ %33, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %val.3221 = phi ptr [ %incdec.ptr105, %for.body99 ], [ %arrayidx93, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x1.0220 = phi double [ %37, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x2.0219 = phi double [ %39, %for.body99 ], [ 0.000000e+00, %for.body99.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %34 = load i32, ptr %idx.3223, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom100 = sext i32 %34 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx101 = getelementptr inbounds double, ptr %vec1, i64 %idxprom100 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %35 = load double, ptr %arrayidx101, align 8, !tbaa !27 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %36 = load double, ptr %val.3221, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %37 = tail call double @llvm.fmuladd.f64(double %35, double %36, double %x1.0220) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr102 = getelementptr inbounds i8, ptr %idx.3223, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx104 = getelementptr inbounds double, ptr %vec2, i64 %idxprom100 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %38 = load double, ptr %arrayidx104, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr105 = getelementptr inbounds i8, ptr %val.3221, i64 8 of type:getelementptr
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %39 = tail call double @llvm.fmuladd.f64(double %38, double %36, double %x2.0219) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec107 = add nsw i32 %j.3222, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp98 = icmp sgt i32 %dec107, %32 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp98, label %for.body99, label %for.end108.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 24
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 98
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 98, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 98
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 98, CostB * EstimatedWidthA: 48
LV: Selecting VF: 1 With Cost: 12.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %10 = load i32, ptr %idx.043, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.040, align 8, !tbaa !28 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i32, ptr %idx.043, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.040, align 8, !tbaa !28 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i32, ptr %idx.043, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.040, align 8, !tbaa !28 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i32, ptr %idx.043, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %12 = load double, ptr %val.040, align 8, !tbaa !28 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %10 = load i32, ptr %idx.043, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.040, align 8, !tbaa !28 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor15solveUpdateLeftEPd' from solve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %9) + %8) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%idx.043> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.042 = phi %dec, %8, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x.041> = phi ir<0.000000e+00>, ir<%13>.1
    EMIT ir<%val.040> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.043>, ir<4>
    CLONE ir<%10> = load ir<%idx.043>
    CLONE ir<%idxprom18> = sext ir<%10>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%vec>, ir<%idxprom18>
    CLONE ir<%11> = load ir<%arrayidx19>
    CLONE ir<%incdec.ptr20> = getelementptr inbounds ir<%val.040>, ir<8>
    CLONE ir<%12> = load ir<%val.040>
    EMIT vp<%4> = fmul ir<%11>, ir<%12>
    CLONE ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x.041>)
    CLONE ir<%dec> = add nsw ir<%j.042>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%9>
    REDUCE ir<%13>.1 = ir<%x.041> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.041>, ir<%13>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%7>
}

========== Loop: _ZN6soplex9CLUFactor15solveUpdateLeftEPd' from solve.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %9) + %8) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.043> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.042 = phi %dec, %8, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x.041> = phi ir<0.000000e+00>, ir<%13>.1
    EMIT ir<%val.040> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.043>, ir<4>
    vp<%4> = vector-pointer ir<%idx.043>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%idxprom18> = sext  ir<%10> to i64
    REPLICATE ir<%arrayidx19> = getelementptr inbounds ir<%vec>, ir<%idxprom18>
    REPLICATE ir<%11> = load ir<%arrayidx19>
    CLONE ir<%incdec.ptr20> = getelementptr inbounds ir<%val.040>, ir<8>
    vp<%5> = vector-pointer ir<%val.040>
    WIDEN ir<%12> = load vp<%5>
    EMIT vp<%6> = fmul ir<%11>, ir<%12>
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x.041>) (using vector intrinsic)
    CLONE ir<%dec> = add nsw ir<%j.042>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%9>
    REDUCE ir<%13>.1 = ir<%x.041> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.041>, ir<%13>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor15solveUpdateLeftEPd' from solve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %9) + %8) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.043> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.042 = phi %dec, %8, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x.041> = phi ir<0.000000e+00>, ir<%13>.1
    EMIT ir<%val.040> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.043>, ir<4>
    vp<%4> = vector-pointer ir<%idx.043>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%idxprom18> = sext  ir<%10> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%vec>, ir<%idxprom18>
    REPLICATE ir<%11> = load ir<%arrayidx19>
    CLONE ir<%incdec.ptr20> = getelementptr inbounds ir<%val.040>, ir<8>
    vp<%5> = vector-pointer ir<%val.040>
    WIDEN ir<%12> = load vp<%5>
    EMIT vp<%6> = fmul ir<%11>, ir<%12>
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x.041>) (using vector intrinsic)
    CLONE ir<%dec> = add nsw ir<%j.042>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%9>
    REDUCE ir<%13>.1 = ir<%x.041> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.041>, ir<%13>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor15solveUpdateLeftEPd' from solve.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %9) + %8) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.043> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.042 = phi %dec, %8, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x.041> = phi ir<0.000000e+00>, ir<%13>.1
    EMIT ir<%val.040> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.043>, ir<4>
    vp<%4> = vector-pointer ir<%idx.043>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%idxprom18> = sext  ir<%10> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%vec>, ir<%idxprom18>
    WIDEN ir<%11> = load ir<%arrayidx19>
    CLONE ir<%incdec.ptr20> = getelementptr inbounds ir<%val.040>, ir<8>
    vp<%5> = vector-pointer ir<%val.040>
    WIDEN ir<%12> = load vp<%5>
    EMIT vp<%6> = fmul ir<%11>, ir<%12>
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x.041>) (using vector intrinsic)
    CLONE ir<%dec> = add nsw ir<%j.042>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%9>
    REDUCE ir<%13>.1 = ir<%x.041> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.041>, ir<%13>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx.043 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.042 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.041 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %val.040 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.043, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i32, ptr %idx.043, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.040, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load double, ptr %val.040, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.041) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %j.042, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx.043 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.042 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.041 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %val.040 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.043, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i32, ptr %idx.043, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.040, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %12 = load double, ptr %val.040, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.041) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %j.042, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 20
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 40
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 40
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idx.043 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.042 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x.041 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %val.040 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.043, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %10 = load i32, ptr %idx.043, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.040, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %12 = load double, ptr %val.040, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.041) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %j.042, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 19
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 79
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 79, CostB * EstimatedWidthA: 36
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 79
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 79, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx.043 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.042 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.041 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %val.040 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.043, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i32, ptr %idx.043, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.040, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load double, ptr %val.040, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.041) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %j.042, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEPd' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx.043 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.042 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.041 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %val.040 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.043, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load i32, ptr %idx.043, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.040, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %12 = load double, ptr %val.040, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.041) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %j.042, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 51
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 51, CostB * EstimatedWidthA: 36
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 51
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 51, CostB * EstimatedWidthA: 36
LV: Selecting VF: 1 With Cost: 9.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %10 = load i32, ptr %idx.057, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.054, align 8, !tbaa !28 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i32, ptr %idx.057, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.054, align 8, !tbaa !28 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i32, ptr %idx.057, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.054, align 8, !tbaa !28 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i32, ptr %idx.057, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %12 = load double, ptr %val.054, align 8, !tbaa !28 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %10 = load i32, ptr %idx.057, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.054, align 8, !tbaa !28 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor16solveUpdateLeft2EPdS1_' from solve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %9) + %8) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%idx.057> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.056 = phi %dec, %8, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x1.055> = phi ir<0.000000e+00>, ir<%13>.1
    EMIT ir<%val.054> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    WIDEN-REDUCTION-PHI ir<%x2.053> = phi ir<0.000000e+00>, ir<%15>.1
    CLONE ir<%10> = load ir<%idx.057>
    CLONE ir<%idxprom18> = sext ir<%10>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%vec1>, ir<%idxprom18>
    CLONE ir<%11> = load ir<%arrayidx19>
    CLONE ir<%12> = load ir<%val.054>
    EMIT vp<%4> = fmul ir<%11>, ir<%12>
    CLONE ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x1.055>)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.057>, ir<4>
    CLONE ir<%arrayidx21> = getelementptr inbounds ir<%vec2>, ir<%idxprom18>
    CLONE ir<%14> = load ir<%arrayidx21>
    CLONE ir<%incdec.ptr22> = getelementptr inbounds ir<%val.054>, ir<8>
    EMIT vp<%5> = fmul ir<%14>, ir<%12>
    CLONE ir<%15> = call @llvm.fmuladd.f64(ir<%14>, ir<%12>, ir<%x2.053>)
    CLONE ir<%dec> = add nsw ir<%j.056>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%9>
    REDUCE ir<%13>.1 = ir<%x1.055> + reduce.fadd (vp<%4>)
    REDUCE ir<%15>.1 = ir<%x2.053> + reduce.fadd (vp<%5>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%x1.055>, ir<%13>.1
  EMIT vp<%9> = compute-reduction-result ir<%x2.053>, ir<%15>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa66 = vp<%8>
Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor16solveUpdateLeft2EPdS1_' from solve.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %9) + %8) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%idx.057> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.056 = phi %dec, %8, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x1.055> = phi ir<0.000000e+00>, ir<%13>.1
    EMIT ir<%val.054> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    WIDEN-REDUCTION-PHI ir<%x2.053> = phi ir<0.000000e+00>, ir<%15>.1
    vp<%4> = vector-pointer ir<%idx.057>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%idxprom18> = sext  ir<%10> to i64
    REPLICATE ir<%arrayidx19> = getelementptr inbounds ir<%vec1>, ir<%idxprom18>
    REPLICATE ir<%11> = load ir<%arrayidx19>
    vp<%5> = vector-pointer ir<%val.054>
    WIDEN ir<%12> = load vp<%5>
    EMIT vp<%6> = fmul ir<%11>, ir<%12>
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x1.055>) (using vector intrinsic)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.057>, ir<4>
    REPLICATE ir<%arrayidx21> = getelementptr inbounds ir<%vec2>, ir<%idxprom18>
    REPLICATE ir<%14> = load ir<%arrayidx21>
    CLONE ir<%incdec.ptr22> = getelementptr inbounds ir<%val.054>, ir<8>
    EMIT vp<%7> = fmul ir<%14>, ir<%12>
    WIDEN-CALL ir<%15> = call @llvm.fmuladd.f64(ir<%14>, ir<%12>, ir<%x2.053>) (using vector intrinsic)
    CLONE ir<%dec> = add nsw ir<%j.056>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%9>
    REDUCE ir<%13>.1 = ir<%x1.055> + reduce.fadd (vp<%6>)
    REDUCE ir<%15>.1 = ir<%x2.053> + reduce.fadd (vp<%7>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x1.055>, ir<%13>.1
  EMIT vp<%11> = compute-reduction-result ir<%x2.053>, ir<%15>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa66 = vp<%10>
Live-out double %.lcssa = vp<%11>
}

========== Loop: _ZN6soplex9CLUFactor16solveUpdateLeft2EPdS1_' from solve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %9) + %8) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%idx.057> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.056 = phi %dec, %8, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x1.055> = phi ir<0.000000e+00>, ir<%13>.1
    EMIT ir<%val.054> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    WIDEN-REDUCTION-PHI ir<%x2.053> = phi ir<0.000000e+00>, ir<%15>.1
    vp<%4> = vector-pointer ir<%idx.057>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%idxprom18> = sext  ir<%10> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%vec1>, ir<%idxprom18>
    REPLICATE ir<%11> = load ir<%arrayidx19>
    vp<%5> = vector-pointer ir<%val.054>
    WIDEN ir<%12> = load vp<%5>
    EMIT vp<%6> = fmul ir<%11>, ir<%12>
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x1.055>) (using vector intrinsic)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.057>, ir<4>
    WIDEN-GEP Inv[Var] ir<%arrayidx21> = getelementptr inbounds ir<%vec2>, ir<%idxprom18>
    REPLICATE ir<%14> = load ir<%arrayidx21>
    CLONE ir<%incdec.ptr22> = getelementptr inbounds ir<%val.054>, ir<8>
    EMIT vp<%7> = fmul ir<%14>, ir<%12>
    WIDEN-CALL ir<%15> = call @llvm.fmuladd.f64(ir<%14>, ir<%12>, ir<%x2.053>) (using vector intrinsic)
    CLONE ir<%dec> = add nsw ir<%j.056>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%9>
    REDUCE ir<%13>.1 = ir<%x1.055> + reduce.fadd (vp<%6>)
    REDUCE ir<%15>.1 = ir<%x2.053> + reduce.fadd (vp<%7>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x1.055>, ir<%13>.1
  EMIT vp<%11> = compute-reduction-result ir<%x2.053>, ir<%15>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa66 = vp<%10>
Live-out double %.lcssa = vp<%11>
}

========== Loop: _ZN6soplex9CLUFactor16solveUpdateLeft2EPdS1_' from solve.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %9) + %8) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%idx.057> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.056 = phi %dec, %8, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x1.055> = phi ir<0.000000e+00>, ir<%13>.1
    EMIT ir<%val.054> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    WIDEN-REDUCTION-PHI ir<%x2.053> = phi ir<0.000000e+00>, ir<%15>.1
    vp<%4> = vector-pointer ir<%idx.057>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%idxprom18> = sext  ir<%10> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%vec1>, ir<%idxprom18>
    WIDEN ir<%11> = load ir<%arrayidx19>
    vp<%5> = vector-pointer ir<%val.054>
    WIDEN ir<%12> = load vp<%5>
    EMIT vp<%6> = fmul ir<%11>, ir<%12>
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x1.055>) (using vector intrinsic)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.057>, ir<4>
    WIDEN-GEP Inv[Var] ir<%arrayidx21> = getelementptr inbounds ir<%vec2>, ir<%idxprom18>
    WIDEN ir<%14> = load ir<%arrayidx21>
    CLONE ir<%incdec.ptr22> = getelementptr inbounds ir<%val.054>, ir<8>
    EMIT vp<%7> = fmul ir<%14>, ir<%12>
    WIDEN-CALL ir<%15> = call @llvm.fmuladd.f64(ir<%14>, ir<%12>, ir<%x2.053>) (using vector intrinsic)
    CLONE ir<%dec> = add nsw ir<%j.056>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%9>
    REDUCE ir<%13>.1 = ir<%x1.055> + reduce.fadd (vp<%6>)
    REDUCE ir<%15>.1 = ir<%x2.053> + reduce.fadd (vp<%7>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x1.055>, ir<%13>.1
  EMIT vp<%11> = compute-reduction-result ir<%x2.053>, ir<%15>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa66 = vp<%10>
Live-out double %.lcssa = vp<%11>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor16solveUpdateLeft2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx.057 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.056 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x1.055 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %val.054 = phi ptr [ %incdec.ptr22, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x2.053 = phi double [ %15, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i32, ptr %idx.057, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec1, i64 %idxprom18 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load double, ptr %val.054, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x1.055) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.057, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %vec2, i64 %idxprom18 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %14 = load double, ptr %arrayidx21, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr22 = getelementptr inbounds i8, ptr %val.054, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %15 = tail call double @llvm.fmuladd.f64(double %14, double %12, double %x2.053) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %j.056, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor16solveUpdateLeft2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx.057 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.056 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x1.055 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %val.054 = phi ptr [ %incdec.ptr22, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x2.053 = phi double [ %15, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i32, ptr %idx.057, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec1, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %12 = load double, ptr %val.054, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x1.055) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.057, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %vec2, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %14 = load double, ptr %arrayidx21, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr22 = getelementptr inbounds i8, ptr %val.054, i64 8 of type:getelementptr
LV: Found an estimated cost of 8 for VF 2 For instruction:   %15 = tail call double @llvm.fmuladd.f64(double %14, double %12, double %x2.053) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %j.056, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 38
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 76
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 76, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 76
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 76, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZN6soplex9CLUFactor16solveUpdateLeft2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idx.057 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.056 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x1.055 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %val.054 = phi ptr [ %incdec.ptr22, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x2.053 = phi double [ %15, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %10 = load i32, ptr %idx.057, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec1, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %12 = load double, ptr %val.054, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x1.055) of type:call
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.057, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %vec2, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %14 = load double, ptr %arrayidx21, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr22 = getelementptr inbounds i8, ptr %val.054, i64 8 of type:getelementptr
LV: Found an estimated cost of 16 for VF 4 For instruction:   %15 = tail call double @llvm.fmuladd.f64(double %14, double %12, double %x2.053) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %j.056, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 37
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 151
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 151, CostB * EstimatedWidthA: 48
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 151
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 151, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'_ZN6soplex9CLUFactor16solveUpdateLeft2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx.057 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.056 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x1.055 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %val.054 = phi ptr [ %incdec.ptr22, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x2.053 = phi double [ %15, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i32, ptr %idx.057, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec1, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load double, ptr %val.054, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x1.055) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.057, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %vec2, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %14 = load double, ptr %arrayidx21, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr22 = getelementptr inbounds i8, ptr %val.054, i64 8 of type:getelementptr
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %15 = tail call double @llvm.fmuladd.f64(double %14, double %12, double %x2.053) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %j.056, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZN6soplex9CLUFactor16solveUpdateLeft2EPdS1_' from solve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx.057 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.056 = phi i32 [ %dec, %for.body17 ], [ %8, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x1.055 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %val.054 = phi ptr [ %incdec.ptr22, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x2.053 = phi double [ %15, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load i32, ptr %idx.057, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec1, i64 %idxprom18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %12 = load double, ptr %val.054, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x1.055) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.057, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx21 = getelementptr inbounds double, ptr %vec2, i64 %idxprom18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %14 = load double, ptr %arrayidx21, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr22 = getelementptr inbounds i8, ptr %val.054, i64 8 of type:getelementptr
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %15 = tail call double @llvm.fmuladd.f64(double %14, double %12, double %x2.053) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %j.056, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp16 = icmp sgt i32 %dec, %9 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 24
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 98
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 98, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 98
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 98, CostB * EstimatedWidthA: 48
LV: Selecting VF: 1 With Cost: 12.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o soplex.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           soplex.cc
@@ Instruction =>  %3 = load double, ptr %arrayidx, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load double, ptr %arrayidx, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %3 = load double, ptr %arrayidx, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZNK6soplex6VectormlERKS0_' from soplex.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.010> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx4>
    EMIT vp<%4> = fmul ir<%3>, ir<%4>
    CLONE ir<%5> = call @llvm.fmuladd.f64(ir<%3>, ir<%4>, ir<%x.010>)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.010> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.010>, ir<%5>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%7>
}

========== Loop: _ZNK6soplex6VectormlERKS0_' from soplex.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.010> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%4> = load vp<%5>
    EMIT vp<%6> = fmul ir<%3>, ir<%4>
    WIDEN-CALL ir<%5> = call @llvm.fmuladd.f64(ir<%3>, ir<%4>, ir<%x.010>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.010> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.010>, ir<%5>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZNK6soplex6VectormlERKS0_' from soplex.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.010> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%4> = load vp<%5>
    EMIT vp<%6> = fmul ir<%3>, ir<%4>
    WIDEN-CALL ir<%5> = call @llvm.fmuladd.f64(ir<%3>, ir<%4>, ir<%x.010>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.010> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.010>, ir<%5>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}


-----------------Function that is being costed:'_ZNK6soplex6VectormlERKS0_' from soplex.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.010 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %3, double %4, double %x.010) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZNK6soplex6VectormlERKS0_' from soplex.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.010 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %3, double %4, double %x.010) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901883, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901883, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZNK6soplex6VectormlERKS0_' from soplex.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.010 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %3, double %4, double %x.010) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901883

-----------------Function that is being costed:'_ZNK6soplex6VectormlERKS0_' from soplex.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.010 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %3, double %4, double %x.010) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709131, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709131, RTCostB: 12884901883
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZNK6soplex6VectormlERKS0_ at line: soplex.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%x.010> = phi ir<0.000000e+00>, ir<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%5>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%2>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%4> = load vp<%6>
    EMIT vp<%7> = fmul ir<%3>, ir<%4>
    REDUCE ir<%5> = ir<%x.010> + reduce.fadd (vp<%7>)
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x.010>, ir<%5>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%10>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 10
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxaggregatesm.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxaggregatesm.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxbasis.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxbasis.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxbounds.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxbounds.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxchangebasis.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxchangebasis.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxdefaultpr.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxdefaultpr.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxdefaultrt.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxdefaultrt.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxdefines.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxdefines.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxdesc.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxdesc.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxdevexpr.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxdevexpr.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxequilisc.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxequilisc.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxfastrt.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxfastrt.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxgeneralsm.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxgeneralsm.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxharrisrt.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxharrisrt.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxhybridpr.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxhybridpr.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxid.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxid.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxio.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxio.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxlp.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxlp.cc
MVT: v2i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    CLONE ir<%4> = trunc ir<%indvars.iv.next>
    CLONE store ir<%4>, ir<%arrayidx>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 10737418239
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192773

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 7516192773
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3758096405, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 3758096405, RTCostB: 5368709127
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex5SPxLP10removeRowsEPNS_8SPxRowIdEiPi at line: spxlp.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 26
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
MVT: v2i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN6soplex5SPxLP10removeRowsEPiiS1_' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    CLONE ir<%4> = trunc ir<%indvars.iv.next>
    CLONE store ir<%4>, ir<%arrayidx>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP10removeRowsEPiiS1_' from spxlp.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP10removeRowsEPiiS1_' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 10737418239
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192773

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 7516192773
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeRowsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3758096405, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 3758096405, RTCostB: 5368709127
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex5SPxLP10removeRowsEPiiS1_ at line: spxlp.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 28
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex5SPxLP14removeRowRangeEiiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %start to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv>
    CLONE store ir<%9>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond12.preheader.loopexit>, scalar.ph

ir-bb<for.cond12.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP14removeRowRangeEiiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %start to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%9>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond12.preheader.loopexit>, scalar.ph

ir-bb<for.cond12.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP14removeRowRangeEiiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %start to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%9>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond12.preheader.loopexit>, scalar.ph

ir-bb<for.cond12.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeRowRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeRowRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeRowRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeRowRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483656

-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeRowRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 2147483656
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeRowRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741848, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex5SPxLP14removeRowRangeEiiPi at line: spxlp.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %start to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%9>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond12.preheader.loopexit>, scalar.ph

ir-bb<for.cond12.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 31
Loops Epilogues Vectorized: 0
================================================
MVT: v2i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    CLONE ir<%4> = trunc ir<%indvars.iv.next>
    CLONE store ir<%4>, ir<%arrayidx>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 10737418239
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192773

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 7516192773
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3758096405, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 3758096405, RTCostB: 5368709127
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex5SPxLP10removeColsEPNS_8SPxColIdEiPi at line: spxlp.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 33
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
MVT: v2i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %4, ptr %arrayidx, align 4, !tbaa !9 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN6soplex5SPxLP10removeColsEPiiS1_' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    CLONE ir<%4> = trunc ir<%indvars.iv.next>
    CLONE store ir<%4>, ir<%arrayidx>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP10removeColsEPiiS1_' from spxlp.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP10removeColsEPiiS1_' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%cmp6> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 10737418239
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192773

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 7516192773
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex5SPxLP10removeColsEPiiS1_' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %2, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %4 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %4, ptr %arrayidx, align 4, !tbaa !9 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp6 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp6, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3758096405, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 3758096405, RTCostB: 5368709127
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex5SPxLP10removeColsEPiiS1_ at line: spxlp.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%4> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%4>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 35
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %9, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex5SPxLP14removeColRangeEiiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %start to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv>
    CLONE store ir<%9>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond12.preheader.loopexit>, scalar.ph

ir-bb<for.cond12.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP14removeColRangeEiiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %start to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%9>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond12.preheader.loopexit>, scalar.ph

ir-bb<for.cond12.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SPxLP14removeColRangeEiiPi' from spxlp.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %start to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%9>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond12.preheader.loopexit>, scalar.ph

ir-bb<for.cond12.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeColRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeColRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225473, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeColRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483656, RTCostB: 3221225473
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeColRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2147483656

-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeColRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 2147483656
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex5SPxLP14removeColRangeEiiPi' from spxlp.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %9 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %9, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond12.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1073741848, RTCostB: 1610612745
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex5SPxLP14removeColRangeEiiPi at line: spxlp.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %start to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%9>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond12.preheader.loopexit>, scalar.ph

ir-bb<for.cond12.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 38
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxlpfread.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxlpfread.cc
@@ Instruction =>  %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %srt.0.lcssa) + {(-2 + (trunc i64 (ptrtoint ptr %call to i64) to i32) + (-1 * (trunc i64 (ptrtoint ptr %0 to i64) to i32))),+,-1}<%for.cond>) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv83 = phi %indvars.iv.next84, 0, ir<1>
    WIDEN-INDUCTION %i.0.in77 = phi %i.0, %srt.0.lcssa, ir<1>
    CLONE ir<%i.0> = add nsw ir<%i.0.in77>, ir<1>
    CLONE ir<%idxprom27> = zext nneg ir<%i.0>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%0>, ir<%idxprom27>
    CLONE ir<%7> = load ir<%arrayidx28>
    CLONE ir<%indvars.iv.next84> = add nuw nsw ir<%indvars.iv83>, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%name>, ir<0>, ir<%indvars.iv83>
    CLONE store ir<%7>, ir<%arrayidx31>
    CLONE ir<%cmp25.not.not> = icmp slt ir<%i.0>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end34.loopexit>, scalar.ph

ir-bb<for.end34.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next84.lcssa = ir<%indvars.iv.next84>
}

========== Loop: _ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %srt.0.lcssa) + {(-2 + (trunc i64 (ptrtoint ptr %call to i64) to i32) + (-1 * (trunc i64 (ptrtoint ptr %0 to i64) to i32))),+,-1}<%for.cond>) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv83 = phi %indvars.iv.next84, 0, ir<1>
    WIDEN-INDUCTION %i.0.in77 = phi %i.0, %srt.0.lcssa, ir<1>
    CLONE ir<%i.0> = add nsw ir<%i.0.in77>, ir<1>
    CLONE ir<%idxprom27> = zext nneg ir<%i.0>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%0>, ir<%idxprom27>
    vp<%4> = vector-pointer ir<%arrayidx28>
    WIDEN ir<%7> = load vp<%4>
    CLONE ir<%indvars.iv.next84> = add nuw nsw ir<%indvars.iv83>, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%name>, ir<0>, ir<%indvars.iv83>
    vp<%5> = vector-pointer ir<%arrayidx31>
    WIDEN store vp<%5>, ir<%7>
    CLONE ir<%cmp25.not.not> = icmp slt ir<%i.0>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end34.loopexit>, scalar.ph

ir-bb<for.end34.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next84.lcssa = ir<%indvars.iv.next84>
}

========== Loop: _ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %srt.0.lcssa) + {(-2 + (trunc i64 (ptrtoint ptr %call to i64) to i32) + (-1 * (trunc i64 (ptrtoint ptr %0 to i64) to i32))),+,-1}<%for.cond>) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv83 = phi %indvars.iv.next84, 0, ir<1>
    WIDEN-INDUCTION %i.0.in77 = phi %i.0, %srt.0.lcssa, ir<1>
    CLONE ir<%i.0> = add nsw ir<%i.0.in77>, ir<1>
    CLONE ir<%idxprom27> = zext nneg ir<%i.0>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%0>, ir<%idxprom27>
    vp<%4> = vector-pointer ir<%arrayidx28>
    WIDEN ir<%7> = load vp<%4>
    CLONE ir<%indvars.iv.next84> = add nuw nsw ir<%indvars.iv83>, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%name>, ir<0>, ir<%indvars.iv83>
    vp<%5> = vector-pointer ir<%arrayidx31>
    WIDEN store vp<%5>, ir<%7>
    CLONE ir<%cmp25.not.not> = icmp slt ir<%i.0>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end34.loopexit>, scalar.ph

ir-bb<for.end34.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next84.lcssa = ir<%indvars.iv.next84>
}


-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 11
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 44
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10

-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 112
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'_ZN6soplexL10hasRowNameERPcPNS_7NameSetE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv83 = phi i64 [ %indvars.iv.next84, %for.body26 ], [ 0, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.0.in77 = phi i32 [ %i.0, %for.body26 ], [ %srt.0.lcssa, %for.body26.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %i.0 = add nsw i32 %i.0.in77, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %idxprom27 = zext nneg i32 %i.0 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx28 = getelementptr inbounds i8, ptr %0, i64 %idxprom27 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %7 = load i8, ptr %arrayidx28, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx31 = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv83 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %7, ptr %arrayidx31, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp25.not.not = icmp slt i32 %i.0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp25.not.not, label %for.body26, label %for.end34.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 224
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 5
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=2 at function: _ZN6soplexL10hasRowNameERPcPNS_7NameSetE at line: spxlpfread.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body26.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 ((-1 * %srt.0.lcssa) + {(-2 + (trunc i64 (ptrtoint ptr %call to i64) to i32) + (-1 * (trunc i64 (ptrtoint ptr %0 to i64) to i32))),+,-1}<nw><%for.cond>) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    vp<%5>    = DERIVED-IV ir<%srt.0.lcssa> + vp<%3> * ir<1>
    vp<%6> = SCALAR-STEPS vp<%5>, ir<1>
    CLONE ir<%i.0> = add nsw vp<%6>, ir<1>
    CLONE ir<%idxprom27> = zext nneg ir<%i.0>
    CLONE ir<%arrayidx28> = getelementptr inbounds ir<%0>, ir<%idxprom27>
    vp<%7> = vector-pointer ir<%arrayidx28>
    WIDEN ir<%19> = load vp<%7>
    CLONE ir<%indvars.iv.next84> = add nuw nsw vp<%4>, ir<1>
    CLONE ir<%arrayidx31> = getelementptr inbounds ir<%name>, ir<0>, vp<%4>
    vp<%8> = vector-pointer ir<%arrayidx31>
    WIDEN store vp<%8>, ir<%19>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end34.loopexit>, scalar.ph

ir-bb<for.end34.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next84.lcssa = ir<%indvars.iv.next84>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %15 = load i8, ptr %14, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %15, ptr %t.088, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %15 = load i8, ptr %14, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %15, ptr %t.088, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %15 = load i8, ptr %14, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %15, ptr %t.088, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %15 = load i8, ptr %14, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %15, ptr %t.088, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %15 = load i8, ptr %14, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %15, ptr %t.088, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %15 = load i8, ptr %14, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %15, ptr %t.088, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %15 = load i8, ptr %14, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %15, ptr %t.088, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %15 = load i8, ptr %14, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %15, ptr %t.088, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %15 = load i8, ptr %14, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %15, ptr %t.088, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplexL9readValueERPc' from spxlpfread.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %0 to i64)) + (ptrtoint ptr %s.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%t.088> = WIDEN-POINTER-INDUCTION ir<%tmp>, 1
    EMIT ir<%14> = WIDEN-POINTER-INDUCTION ir<%0>, 1
    CLONE ir<%15> = load ir<%14>
    CLONE ir<%incdec.ptr50> = getelementptr inbounds ir<%t.088>, ir<1>
    CLONE store ir<%15>, ir<%t.088>
    CLONE ir<%incdec.ptr51> = getelementptr inbounds ir<%14>, ir<1>
    CLONE store ir<%incdec.ptr51>, ir<%pos>
    CLONE ir<%cmp49.not> = icmp eq ir<%incdec.ptr51>, ir<%s.6>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr50.lcssa = ir<%incdec.ptr50>
Live-out ptr %incdec.ptr51.lcssa = ir<%incdec.ptr51>
}

========== Loop: _ZN6soplexL9readValueERPc' from spxlpfread.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %0 to i64)) + (ptrtoint ptr %s.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%t.088> = WIDEN-POINTER-INDUCTION ir<%tmp>, 1
    EMIT ir<%14> = WIDEN-POINTER-INDUCTION ir<%0>, 1
    vp<%4> = vector-pointer ir<%14>
    WIDEN ir<%15> = load vp<%4>
    CLONE ir<%incdec.ptr50> = getelementptr inbounds ir<%t.088>, ir<1>
    vp<%5> = vector-pointer ir<%t.088>
    WIDEN store vp<%5>, ir<%15>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr51> = getelementptr inbounds ir<%14>, ir<1>
    REPLICATE store ir<%incdec.ptr51>, ir<%pos>
    CLONE ir<%cmp49.not> = icmp eq ir<%incdec.ptr51>, ir<%s.6>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr50.lcssa = ir<%incdec.ptr50>
Live-out ptr %incdec.ptr51.lcssa = ir<%incdec.ptr51>
}

========== Loop: _ZN6soplexL9readValueERPc' from spxlpfread.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %0 to i64)) + (ptrtoint ptr %s.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%t.088> = WIDEN-POINTER-INDUCTION ir<%tmp>, 1
    EMIT ir<%14> = WIDEN-POINTER-INDUCTION ir<%0>, 1
    vp<%4> = vector-pointer ir<%14>
    WIDEN ir<%15> = load vp<%4>
    CLONE ir<%incdec.ptr50> = getelementptr inbounds ir<%t.088>, ir<1>
    vp<%5> = vector-pointer ir<%t.088>
    WIDEN store vp<%5>, ir<%15>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr51> = getelementptr inbounds ir<%14>, ir<1>
    REPLICATE store ir<%incdec.ptr51>, ir<%pos>
    CLONE ir<%cmp49.not> = icmp eq ir<%incdec.ptr51>, ir<%s.6>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr50.lcssa = ir<%incdec.ptr50>
Live-out ptr %incdec.ptr51.lcssa = ir<%incdec.ptr51>
}


-----------------Function that is being costed:'_ZN6soplexL9readValueERPc' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %t.088 = phi ptr [ %incdec.ptr50, %for.body ], [ %tmp, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %14 = phi ptr [ %incdec.ptr51, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %15 = load i8, ptr %14, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr50 = getelementptr inbounds i8, ptr %t.088, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %15, ptr %t.088, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr51 = getelementptr inbounds i8, ptr %14, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %incdec.ptr51, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp49.not = icmp eq ptr %incdec.ptr51, %s.6 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp49.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZN6soplexL9readValueERPc' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %t.088 = phi ptr [ %incdec.ptr50, %for.body ], [ %tmp, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %14 = phi ptr [ %incdec.ptr51, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %15 = load i8, ptr %14, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr50 = getelementptr inbounds i8, ptr %t.088, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %15, ptr %t.088, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr51 = getelementptr inbounds i8, ptr %14, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %incdec.ptr51, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp49.not = icmp eq ptr %incdec.ptr51, %s.6 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp49.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplexL9readValueERPc' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %t.088 = phi ptr [ %incdec.ptr50, %for.body ], [ %tmp, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %14 = phi ptr [ %incdec.ptr51, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %15 = load i8, ptr %14, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr50 = getelementptr inbounds i8, ptr %t.088, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %15, ptr %t.088, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr51 = getelementptr inbounds i8, ptr %14, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %incdec.ptr51, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp49.not = icmp eq ptr %incdec.ptr51, %s.6 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp49.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 52
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplexL9readValueERPc' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %t.088 = phi ptr [ %incdec.ptr50, %for.body ], [ %tmp, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %14 = phi ptr [ %incdec.ptr51, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %15 = load i8, ptr %14, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr50 = getelementptr inbounds i8, ptr %t.088, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %15, ptr %t.088, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr51 = getelementptr inbounds i8, ptr %14, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 8 For instruction:   store ptr %incdec.ptr51, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp49.not = icmp eq ptr %incdec.ptr51, %s.6 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp49.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplexL9readValueERPc' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %t.088 = phi ptr [ %incdec.ptr50, %for.body ], [ %tmp, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %14 = phi ptr [ %incdec.ptr51, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %15 = load i8, ptr %14, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr50 = getelementptr inbounds i8, ptr %t.088, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %15, ptr %t.088, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr51 = getelementptr inbounds i8, ptr %14, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 16 For instruction:   store ptr %incdec.ptr51, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp49.not = icmp eq ptr %incdec.ptr51, %s.6 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp49.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN6soplexL9readValueERPc' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %t.088 = phi ptr [ %incdec.ptr50, %for.body ], [ %tmp, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %14 = phi ptr [ %incdec.ptr51, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %15 = load i8, ptr %14, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr50 = getelementptr inbounds i8, ptr %t.088, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %15, ptr %t.088, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr51 = getelementptr inbounds i8, ptr %14, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %incdec.ptr51, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp49.not = icmp eq ptr %incdec.ptr51, %s.6 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp49.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'_ZN6soplexL9readValueERPc' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %t.088 = phi ptr [ %incdec.ptr50, %for.body ], [ %tmp, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %14 = phi ptr [ %incdec.ptr51, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %15 = load i8, ptr %14, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr50 = getelementptr inbounds i8, ptr %t.088, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %15, ptr %t.088, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr51 = getelementptr inbounds i8, ptr %14, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %incdec.ptr51, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp49.not = icmp eq ptr %incdec.ptr51, %s.6 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp49.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 28
LV: Selecting VF: 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=16, UF=2 at function: _ZN6soplexL9readValueERPc at line: spxlpfread.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %0 to i64)) + (ptrtoint ptr %s.6 to i64))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%16> = WIDEN-POINTER-INDUCTION ir<%0>, 1
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%tmp>, vp<%4>
    vp<%6> = vector-pointer ir<%16>
    WIDEN ir<%17> = load vp<%6>
    CLONE ir<%incdec.ptr50> = getelementptr inbounds vp<%5>, ir<1>
    vp<%7> = vector-pointer vp<%5>
    WIDEN store vp<%7>, ir<%17>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr51> = getelementptr inbounds ir<%16>, ir<1>
    REPLICATE store ir<%incdec.ptr51>, ir<%pos>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out ptr %incdec.ptr50.lcssa = ir<%incdec.ptr50>
Live-out ptr %incdec.ptr51.lcssa = ir<%incdec.ptr51>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %6 = load i8, ptr %5, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %6, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %6 = load i8, ptr %5, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %5, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %5, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %6, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %6 = load i8, ptr %5, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %6, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %6 = load i8, ptr %5, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %5, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %5, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %6, ptr %arrayidx, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %6 = load i8, ptr %5, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><%while.cond>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    EMIT ir<%5> = WIDEN-POINTER-INDUCTION ir<%0>, 1
    CLONE ir<%6> = load ir<%5>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%name>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%6>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%incdec.ptr4> = getelementptr inbounds ir<%5>, ir<1>
    CLONE store ir<%incdec.ptr4>, ir<%pos>
    CLONE ir<%cmp3.not> = icmp eq ir<%incdec.ptr4>, ir<%s.0.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><%while.cond>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    EMIT ir<%5> = WIDEN-POINTER-INDUCTION ir<%0>, 1
    vp<%4> = vector-pointer ir<%5>
    WIDEN ir<%6> = load vp<%4>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%name>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%6>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr4> = getelementptr inbounds ir<%5>, ir<1>
    REPLICATE store ir<%incdec.ptr4>, ir<%pos>
    CLONE ir<%cmp3.not> = icmp eq ir<%incdec.ptr4>, ir<%s.0.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}

========== Loop: _ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><%while.cond>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    EMIT ir<%5> = WIDEN-POINTER-INDUCTION ir<%0>, 1
    vp<%4> = vector-pointer ir<%5>
    WIDEN ir<%6> = load vp<%4>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%name>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%6>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr4> = getelementptr inbounds ir<%5>, ir<1>
    REPLICATE store ir<%incdec.ptr4>, ir<%pos>
    CLONE ir<%cmp3.not> = icmp eq ir<%incdec.ptr4>, ir<%s.0.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}


-----------------Function that is being costed:'_ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %5 = phi ptr [ %incdec.ptr4, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %6 = load i8, ptr %5, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %6, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %5, i64 1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store ptr %incdec.ptr4, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp3.not = icmp eq ptr %incdec.ptr4, %s.0.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp3.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'_ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %5 = phi ptr [ %incdec.ptr4, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %6 = load i8, ptr %5, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %6, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %5, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %incdec.ptr4, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp3.not = icmp eq ptr %incdec.ptr4, %s.0.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp3.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 14
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 14
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %5 = phi ptr [ %incdec.ptr4, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %6 = load i8, ptr %5, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %6, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %5, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %incdec.ptr4, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp3.not = icmp eq ptr %incdec.ptr4, %s.0.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp3.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 14
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %5 = phi ptr [ %incdec.ptr4, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %6 = load i8, ptr %5, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %6, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %5, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 8 For instruction:   store ptr %incdec.ptr4, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp3.not = icmp eq ptr %incdec.ptr4, %s.0.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp3.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 64
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %5 = phi ptr [ %incdec.ptr4, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %6 = load i8, ptr %5, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %6, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %5, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 16 For instruction:   store ptr %incdec.ptr4, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp3.not = icmp eq ptr %incdec.ptr4, %s.0.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp3.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 128
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'_ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %5 = phi ptr [ %incdec.ptr4, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %6 = load i8, ptr %5, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %6, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %5, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %incdec.ptr4, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp3.not = icmp eq ptr %incdec.ptr4, %s.0.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp3.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'_ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE' from spxlpfread.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %5 = phi ptr [ %incdec.ptr4, %for.body ], [ %0, %for.body.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = load i8, ptr %5, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [257 x i8], ptr %name, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %6, ptr %arrayidx, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %5, i64 1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %incdec.ptr4, ptr %pos, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp3.not = icmp eq ptr %incdec.ptr4, %s.0.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp3.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 16, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 32
LV: Selecting VF: 16 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Unable to vectorize epilogue because the loop is not a supported candidate.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=16, UF=2 at function: _ZN6soplexL11readColNameERPcPNS_7NameSetERNS_8LPColSetEPNS_5LPColE at line: spxlpfread.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><%while.cond>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%5> = WIDEN-POINTER-INDUCTION ir<%0>, 1
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    vp<%5> = vector-pointer ir<%5>
    WIDEN ir<%6> = load vp<%5>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%name>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<%6>
    CLONE ir<%indvars.iv.next> = add nuw nsw vp<%4>, ir<1>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr4> = getelementptr inbounds ir<%5>, ir<1>
    REPLICATE store ir<%incdec.ptr4>, ir<%pos>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %indvars.iv.next.lcssa = ir<%indvars.iv.next>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxmpsread.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxmpsread.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxmpswrite.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxmpswrite.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxparmultpr.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxparmultpr.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxquality.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxquality.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxredundantsm.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxredundantsm.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxrem1sm.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxrem1sm.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxscaler.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxscaler.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxshift.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxshift.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxsolve.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxsolve.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxsolver.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxsolver.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxstarter.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxstarter.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxsteeppr.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxsteeppr.cc
MVT: v2f64
@@ Instruction =>  store double %coshift.shift, ptr %arrayidx, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  store double %coshift.shift, ptr %arrayidx, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %coshift.shift, ptr %arrayidx, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %re.addr.0 to i64) + (-1 * (sext i32 %rs to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %4, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4.call3>, ir<%indvars.iv.next>
    CLONE store ir<%coshift.shift>, ir<%arrayidx>
    CLONE ir<%cmp14.not.not> = icmp sgt ir<%indvars.iv.next>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %re.addr.0 to i64) + (-1 * (sext i32 %rs to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %4, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4.call3>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%coshift.shift>
    CLONE ir<%cmp14.not.not> = icmp sgt ir<%indvars.iv.next>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %re.addr.0 to i64) + (-1 * (sext i32 %rs to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %4, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4.call3>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%coshift.shift>
    CLONE ir<%cmp14.not.not> = icmp sgt ir<%indvars.iv.next>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %4, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %call4.call3, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %coshift.shift, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp14.not.not = icmp sgt i64 %indvars.iv.next, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp14.not.not, label %for.body, label %for.end.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %4, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %call4.call3, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store double %coshift.shift, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp14.not.not = icmp sgt i64 %indvars.iv.next, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp14.not.not, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %4, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %call4.call3, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %coshift.shift, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp14.not.not = icmp sgt i64 %indvars.iv.next, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp14.not.not, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934592

-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %4, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %call4.call3, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %coshift.shift, ptr %arrayidx, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp14.not.not = icmp sgt i64 %indvars.iv.next, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp14.not.not, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii at line: spxsteeppr.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %re.addr.0 to i64) + (-1 * (sext i32 %rs to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%4> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4.call3>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%6>, ir<%coshift.shift>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2f64
@@ Instruction =>  store double %shift.coshift, ptr %arrayidx25, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  store double %shift.coshift, ptr %arrayidx25, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %shift.coshift, ptr %arrayidx25, align 8, !tbaa !12 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body23.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %ce.addr.0 to i64) + (-1 * (sext i32 %cs to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv77 = phi %37, %indvars.iv.next78, ir<-1>
    CLONE ir<%indvars.iv.next78> = add nsw ir<%indvars.iv77>, ir<-1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%call3.call4>, ir<%indvars.iv.next78>
    CLONE store ir<%shift.coshift>, ir<%arrayidx25>
    CLONE ir<%cmp22.not.not> = icmp sgt ir<%indvars.iv.next78>, ir<%38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end26.loopexit>, scalar.ph

ir-bb<for.end26.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body23.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %ce.addr.0 to i64) + (-1 * (sext i32 %cs to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv77 = phi %37, %indvars.iv.next78, ir<-1>
    CLONE ir<%indvars.iv.next78> = add nsw ir<%indvars.iv77>, ir<-1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%call3.call4>, ir<%indvars.iv.next78>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx25>
    WIDEN store vp<%4>, ir<%shift.coshift>
    CLONE ir<%cmp22.not.not> = icmp sgt ir<%indvars.iv.next78>, ir<%38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end26.loopexit>, scalar.ph

ir-bb<for.end26.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body23.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %ce.addr.0 to i64) + (-1 * (sext i32 %cs to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv77 = phi %37, %indvars.iv.next78, ir<-1>
    CLONE ir<%indvars.iv.next78> = add nsw ir<%indvars.iv77>, ir<-1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%call3.call4>, ir<%indvars.iv.next78>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx25>
    WIDEN store vp<%4>, ir<%shift.coshift>
    CLONE ir<%cmp22.not.not> = icmp sgt ir<%indvars.iv.next78>, ir<%38>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end26.loopexit>, scalar.ph

ir-bb<for.end26.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv77 = phi i64 [ %37, %for.body23.preheader ], [ %indvars.iv.next78, %for.body23 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx25 = getelementptr inbounds double, ptr %call3.call4, i64 %indvars.iv.next78 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %shift.coshift, ptr %arrayidx25, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp22.not.not = icmp sgt i64 %indvars.iv.next78, %38 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp22.not.not, label %for.body23, label %for.end26.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv77 = phi i64 [ %37, %for.body23.preheader ], [ %indvars.iv.next78, %for.body23 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx25 = getelementptr inbounds double, ptr %call3.call4, i64 %indvars.iv.next78 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store double %shift.coshift, ptr %arrayidx25, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp22.not.not = icmp sgt i64 %indvars.iv.next78, %38 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp22.not.not, label %for.body23, label %for.end26.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv77 = phi i64 [ %37, %for.body23.preheader ], [ %indvars.iv.next78, %for.body23 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx25 = getelementptr inbounds double, ptr %call3.call4, i64 %indvars.iv.next78 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %shift.coshift, ptr %arrayidx25, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp22.not.not = icmp sgt i64 %indvars.iv.next78, %38 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp22.not.not, label %for.body23, label %for.end26.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934592

-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv77 = phi i64 [ %37, %for.body23.preheader ], [ %indvars.iv.next78, %for.body23 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx25 = getelementptr inbounds double, ptr %call3.call4, i64 %indvars.iv.next78 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %shift.coshift, ptr %arrayidx25, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp22.not.not = icmp sgt i64 %indvars.iv.next78, %38 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp22.not.not, label %for.body23, label %for.end26.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967304, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii at line: spxsteeppr.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body23.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %ce.addr.0 to i64) + (-1 * (sext i32 %cs to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%37> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next78> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%call3.call4>, ir<%indvars.iv.next78>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx25>
    WIDEN store vp<%6>, ir<%shift.coshift>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end26.loopexit>, scalar.ph

ir-bb<for.end26.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %70 = load double, ptr %cp.171, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %cp.171, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %70 = load double, ptr %cp.171, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %mul, ptr %cp.171, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %70 = load double, ptr %cp.171, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul, ptr %cp.171, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %call28 to i64)) + ((8 + (ptrtoint ptr %call28 to i64)) umax ((8 * (sext i32 %call30 to i64))<nsw> + (ptrtoint ptr %call28 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.272 = phi 0, %inc, ir<1>
    EMIT ir<%cp.171> = WIDEN-POINTER-INDUCTION ir<%call28>, 8
    CLONE ir<%inc> = add nuw nsw ir<%i.272>, ir<1>
    CLONE ir<%conv> = uitofp nneg ir<%i.272>
    CLONE ir<%69> = call @llvm.fmuladd.f64(ir<%neg>, ir<%conv>, ir<1.000000e+00>)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%cp.171>, ir<8>
    CLONE ir<%70> = load ir<%cp.171>
    CLONE ir<%mul> = fmul ir<%69>, ir<%70>
    CLONE store ir<%mul>, ir<%cp.171>
    CLONE ir<%cmp31> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %call28 to i64)) + ((8 + (ptrtoint ptr %call28 to i64)) umax ((8 * (sext i32 %call30 to i64))<nsw> + (ptrtoint ptr %call28 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %i.272 = phi 0, %inc, ir<1>
    EMIT ir<%cp.171> = WIDEN-POINTER-INDUCTION ir<%call28>, 8
    WIDEN ir<%inc> = add nuw nsw ir<%i.272>, ir<1>
    WIDEN-CAST ir<%conv> = uitofp  nneg ir<%i.272> to double
    WIDEN-CALL ir<%69> = call @llvm.fmuladd.f64(ir<%neg>, ir<%conv>, ir<1.000000e+00>) (using vector intrinsic)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%cp.171>, ir<8>
    vp<%4> = vector-pointer ir<%cp.171>
    WIDEN ir<%70> = load vp<%4>
    WIDEN ir<%mul> = fmul ir<%69>, ir<%70>
    vp<%5> = vector-pointer ir<%cp.171>
    WIDEN store vp<%5>, ir<%mul>
    CLONE ir<%cmp31> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %call28 to i64)) + ((8 + (ptrtoint ptr %call28 to i64)) umax ((8 * (sext i32 %call30 to i64))<nsw> + (ptrtoint ptr %call28 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %i.272 = phi 0, %inc, ir<1>
    EMIT ir<%cp.171> = WIDEN-POINTER-INDUCTION ir<%call28>, 8
    WIDEN ir<%inc> = add nuw nsw ir<%i.272>, ir<1>
    WIDEN-CAST ir<%conv> = uitofp  nneg ir<%i.272> to double
    WIDEN-CALL ir<%69> = call @llvm.fmuladd.f64(ir<%neg>, ir<%conv>, ir<1.000000e+00>) (using vector intrinsic)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%cp.171>, ir<8>
    vp<%4> = vector-pointer ir<%cp.171>
    WIDEN ir<%70> = load vp<%4>
    WIDEN ir<%mul> = fmul ir<%69>, ir<%70>
    vp<%5> = vector-pointer ir<%cp.171>
    WIDEN store vp<%5>, ir<%mul>
    CLONE ir<%cmp31> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.272 = phi i32 [ 0, %while.body.lr.ph ], [ %inc, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cp.171 = phi ptr [ %call28, %while.body.lr.ph ], [ %incdec.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nuw nsw i32 %i.272, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv = uitofp nneg i32 %i.272 to double of type:uitofp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %69 = tail call double @llvm.fmuladd.f64(double %neg, double %conv, double 1.000000e+00) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %cp.171, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %70 = load double, ptr %cp.171, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul double %69, %70 of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul, ptr %cp.171, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp31 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp31, label %while.body, label %while.end.loopexit of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.272 = phi i32 [ 0, %while.body.lr.ph ], [ %inc, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %cp.171 = phi ptr [ %call28, %while.body.lr.ph ], [ %incdec.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nuw nsw i32 %i.272, 1 of type:add
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv = uitofp nneg i32 %i.272 to double of type:uitofp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %69 = tail call double @llvm.fmuladd.f64(double %neg, double %conv, double 1.000000e+00) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %cp.171, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %70 = load double, ptr %cp.171, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul double %69, %70 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %mul, ptr %cp.171, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp31 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp31, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.272 = phi i32 [ 0, %while.body.lr.ph ], [ %inc, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %cp.171 = phi ptr [ %call28, %while.body.lr.ph ], [ %incdec.ptr, %while.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc = add nuw nsw i32 %i.272, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv = uitofp nneg i32 %i.272 to double of type:uitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %69 = tail call double @llvm.fmuladd.f64(double %neg, double %conv, double 1.000000e+00) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %cp.171, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %70 = load double, ptr %cp.171, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul double %69, %70 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul, ptr %cp.171, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp31 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp31, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.272 = phi i32 [ 0, %while.body.lr.ph ], [ %inc, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %cp.171 = phi ptr [ %call28, %while.body.lr.ph ], [ %incdec.ptr, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nuw nsw i32 %i.272, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv = uitofp nneg i32 %i.272 to double of type:uitofp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %69 = tail call double @llvm.fmuladd.f64(double %neg, double %conv, double 1.000000e+00) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %cp.171, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %70 = load double, ptr %cp.171, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul double %69, %70 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %mul, ptr %cp.171, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp31 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp31, label %while.body, label %while.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii at line: spxsteeppr.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %call28 to i64)) + ((8 + (ptrtoint ptr %call28 to i64)) umax ((8 * (sext i32 %call30 to i64))<nsw> + (ptrtoint ptr %call28 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %i.272 = phi 0, %inc, ir<1>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%call28>, vp<%5>
    WIDEN-CAST ir<%conv> = uitofp  nneg ir<%i.272> to double
    WIDEN-CALL ir<%69> = call @llvm.fmuladd.f64(ir<%neg>, ir<%conv>, ir<1.000000e+00>) (using vector intrinsic)
    vp<%7> = vector-pointer vp<%6>
    WIDEN ir<%70> = load vp<%7>
    WIDEN ir<%mul> = fmul ir<%69>, ir<%70>
    vp<%8> = vector-pointer vp<%6>
    WIDEN store vp<%8>, ir<%mul>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %112 = load double, ptr %p.174, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul47, ptr %p.174, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %112 = load double, ptr %p.174, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  store double %mul47, ptr %p.174, align 8, !tbaa !12 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %112 = load double, ptr %p.174, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store double %mul47, ptr %p.174, align 8, !tbaa !12 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %call33 to i64)) + ((8 + (ptrtoint ptr %call33 to i64)) umax ((8 * (sext i32 %call35 to i64))<nsw> + (ptrtoint ptr %call33 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.375 = phi %dec43, %call39, ir<-1>
    EMIT ir<%p.174> = WIDEN-POINTER-INDUCTION ir<%call33>, 8
    CLONE ir<%dec43> = add nsw ir<%i.375>, ir<-1>
    CLONE ir<%conv44> = sitofp ir<%i.375>
    CLONE ir<%111> = call @llvm.fmuladd.f64(ir<%mult>, ir<%conv44>, ir<1.000000e+00>)
    CLONE ir<%incdec.ptr46> = getelementptr inbounds ir<%p.174>, ir<8>
    CLONE ir<%112> = load ir<%p.174>
    CLONE ir<%mul47> = fmul ir<%111>, ir<%112>
    CLONE store ir<%mul47>, ir<%p.174>
    CLONE ir<%cmp41> = icmp ult ir<%incdec.ptr46>, ir<%add.ptr37>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end48.loopexit>, scalar.ph

ir-bb<while.end48.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %call33 to i64)) + ((8 + (ptrtoint ptr %call33 to i64)) umax ((8 * (sext i32 %call35 to i64))<nsw> + (ptrtoint ptr %call33 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %i.375 = phi %dec43, %call39, ir<-1>
    EMIT ir<%p.174> = WIDEN-POINTER-INDUCTION ir<%call33>, 8
    WIDEN ir<%dec43> = add nsw ir<%i.375>, ir<-1>
    WIDEN-CAST ir<%conv44> = sitofp  ir<%i.375> to double
    WIDEN-CALL ir<%111> = call @llvm.fmuladd.f64(ir<%mult>, ir<%conv44>, ir<1.000000e+00>) (using vector intrinsic)
    CLONE ir<%incdec.ptr46> = getelementptr inbounds ir<%p.174>, ir<8>
    vp<%4> = vector-pointer ir<%p.174>
    WIDEN ir<%112> = load vp<%4>
    WIDEN ir<%mul47> = fmul ir<%111>, ir<%112>
    vp<%5> = vector-pointer ir<%p.174>
    WIDEN store vp<%5>, ir<%mul47>
    CLONE ir<%cmp41> = icmp ult ir<%incdec.ptr46>, ir<%add.ptr37>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end48.loopexit>, scalar.ph

ir-bb<while.end48.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %call33 to i64)) + ((8 + (ptrtoint ptr %call33 to i64)) umax ((8 * (sext i32 %call35 to i64))<nsw> + (ptrtoint ptr %call33 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %i.375 = phi %dec43, %call39, ir<-1>
    EMIT ir<%p.174> = WIDEN-POINTER-INDUCTION ir<%call33>, 8
    WIDEN ir<%dec43> = add nsw ir<%i.375>, ir<-1>
    WIDEN-CAST ir<%conv44> = sitofp  ir<%i.375> to double
    WIDEN-CALL ir<%111> = call @llvm.fmuladd.f64(ir<%mult>, ir<%conv44>, ir<1.000000e+00>) (using vector intrinsic)
    CLONE ir<%incdec.ptr46> = getelementptr inbounds ir<%p.174>, ir<8>
    vp<%4> = vector-pointer ir<%p.174>
    WIDEN ir<%112> = load vp<%4>
    WIDEN ir<%mul47> = fmul ir<%111>, ir<%112>
    vp<%5> = vector-pointer ir<%p.174>
    WIDEN store vp<%5>, ir<%mul47>
    CLONE ir<%cmp41> = icmp ult ir<%incdec.ptr46>, ir<%add.ptr37>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end48.loopexit>, scalar.ph

ir-bb<while.end48.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.375 = phi i32 [ %dec43, %while.body42 ], [ %call39, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.174 = phi ptr [ %incdec.ptr46, %while.body42 ], [ %call33, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec43 = add nsw i32 %i.375, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv44 = sitofp i32 %i.375 to double of type:sitofp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %111 = tail call double @llvm.fmuladd.f64(double %mult, double %conv44, double 1.000000e+00) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr46 = getelementptr inbounds i8, ptr %p.174, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %112 = load double, ptr %p.174, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul47 = fmul double %111, %112 of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul47, ptr %p.174, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp41 = icmp ult ptr %incdec.ptr46, %add.ptr37 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp41, label %while.body42, label %while.end48.loopexit of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.375 = phi i32 [ %dec43, %while.body42 ], [ %call39, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.174 = phi ptr [ %incdec.ptr46, %while.body42 ], [ %call33, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec43 = add nsw i32 %i.375, -1 of type:add
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv44 = sitofp i32 %i.375 to double of type:sitofp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %111 = tail call double @llvm.fmuladd.f64(double %mult, double %conv44, double 1.000000e+00) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr46 = getelementptr inbounds i8, ptr %p.174, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %112 = load double, ptr %p.174, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul47 = fmul double %111, %112 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store double %mul47, ptr %p.174, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp41 = icmp ult ptr %incdec.ptr46, %add.ptr37 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp41, label %while.body42, label %while.end48.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.375 = phi i32 [ %dec43, %while.body42 ], [ %call39, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.174 = phi ptr [ %incdec.ptr46, %while.body42 ], [ %call33, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %dec43 = add nsw i32 %i.375, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv44 = sitofp i32 %i.375 to double of type:sitofp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %111 = tail call double @llvm.fmuladd.f64(double %mult, double %conv44, double 1.000000e+00) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr46 = getelementptr inbounds i8, ptr %p.174, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %112 = load double, ptr %p.174, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul47 = fmul double %111, %112 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul47, ptr %p.174, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp41 = icmp ult ptr %incdec.ptr46, %add.ptr37 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp41, label %while.body42, label %while.end48.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii' from spxsteeppr.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.375 = phi i32 [ %dec43, %while.body42 ], [ %call39, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.174 = phi ptr [ %incdec.ptr46, %while.body42 ], [ %call33, %while.body42.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec43 = add nsw i32 %i.375, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv44 = sitofp i32 %i.375 to double of type:sitofp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %111 = tail call double @llvm.fmuladd.f64(double %mult, double %conv44, double 1.000000e+00) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr46 = getelementptr inbounds i8, ptr %p.174, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %112 = load double, ptr %p.174, align 8, !tbaa !12 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul47 = fmul double %111, %112 of type:fmul
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store double %mul47, ptr %p.174, align 8, !tbaa !12 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp41 = icmp ult ptr %incdec.ptr46, %add.ptr37 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp41, label %while.body42, label %while.end48.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZN6soplex10SPxSteepPR10setupPrefsEdddddiiii at line: spxsteeppr.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body42.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %call33 to i64)) + ((8 + (ptrtoint ptr %call33 to i64)) umax ((8 * (sext i32 %call35 to i64))<nsw> + (ptrtoint ptr %call33 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %i.375 = phi %dec43, %call39, ir<-1>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%call33>, vp<%5>
    WIDEN-CAST ir<%conv44> = sitofp  ir<%i.375> to double
    WIDEN-CALL ir<%111> = call @llvm.fmuladd.f64(ir<%mult>, ir<%conv44>, ir<1.000000e+00>) (using vector intrinsic)
    vp<%7> = vector-pointer vp<%6>
    WIDEN ir<%112> = load vp<%7>
    WIDEN ir<%mul47> = fmul ir<%111>, ir<%112>
    vp<%8> = vector-pointer vp<%6>
    WIDEN store vp<%8>, ir<%mul47>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<while.end48.loopexit>, scalar.ph

ir-bb<while.end48.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 10
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxsumst.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxsumst.cc
MVT: v2f64
@@ Instruction =>  %16 = load double, ptr %arrayidx77, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  %17 = load double, ptr %arrayidx79, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  store double %17, ptr %arrayidx77, align 8, !tbaa !6 -> Cost: 9 -> VectorType: <2 x double> -> ttilog -> MaskedMemoryOpCost(8)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  %19 = load double, ptr %arrayidx90, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: v2f64
@@ Instruction =>  store double %19, ptr %arrayidx77, align 8, !tbaa !6 -> Cost: 9 -> VectorType: <2 x double> -> ttilog -> MaskedMemoryOpCost(8)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [EXT]
MVT: nxv2f64
@@ Instruction =>  %16 = load double, ptr %arrayidx77, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %17 = load double, ptr %arrayidx79, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %17, ptr %arrayidx77, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %19 = load double, ptr %arrayidx90, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %19, ptr %arrayidx77, align 8, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %16 = load double, ptr %arrayidx77, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %17 = load double, ptr %arrayidx79, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %17, ptr %arrayidx77, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  %19 = load double, ptr %arrayidx90, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2f64
@@ Instruction =>  store double %19, ptr %arrayidx77, align 8, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x double> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body75.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call71 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv251 = phi %15, %indvars.iv.next252, ir<-1>
    CLONE ir<%indvars.iv.next252> = add nsw ir<%indvars.iv251>, ir<-1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<%call15>, ir<%indvars.iv.next252>
    CLONE ir<%16> = load ir<%arrayidx77>
    CLONE ir<%arrayidx79> = getelementptr inbounds ir<%call30>, ir<%indvars.iv.next252>
    CLONE ir<%17> = load ir<%arrayidx79>
    CLONE ir<%cmp80> = fcmp ogt ir<%16>, ir<%17>
  Successor(s): if.then81

  if.then81:
    CLONE store ir<%17>, ir<%arrayidx77>, ir<%cmp80>
  Successor(s): if.end86

  if.end86:
    EMIT vp<%4> = not ir<%cmp80>
    EMIT vp<%5> = or ir<%cmp80>, vp<%4>
    BLEND ir<%18> = ir<%17> ir<%16>/vp<%4>
    CLONE ir<%arrayidx90> = getelementptr inbounds ir<%call35>, ir<%indvars.iv.next252>
    CLONE ir<%19> = load ir<%arrayidx90>
    CLONE ir<%cmp91> = fcmp olt ir<%18>, ir<%19>
  Successor(s): if.then92

  if.then92:
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp91>
    CLONE store ir<%19>, ir<%arrayidx77>, vp<%6>
  Successor(s): if.end97

  if.end97:
    EMIT vp<%7> = not ir<%cmp91>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    CLONE ir<%cmp74> = icmp ugt ir<%indvars.iv251>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end98.loopexit>, scalar.ph

ir-bb<for.end98.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body75.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call71 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv251 = phi %15, %indvars.iv.next252, ir<-1>
    CLONE ir<%indvars.iv.next252> = add ir<%indvars.iv251>, ir<-1>
    CLONE ir<%arrayidx77> = getelementptr ir<%call15>, ir<%indvars.iv.next252>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx77>
    WIDEN ir<%16> = load vp<%4>
    CLONE ir<%arrayidx79> = getelementptr inbounds ir<%call30>, ir<%indvars.iv.next252>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx79>
    WIDEN ir<%17> = load vp<%5>
    WIDEN ir<%cmp80> = fcmp ogt ir<%16>, ir<%17>
  Successor(s): if.then81

  if.then81:
    vp<%6> = vector-pointer (reverse) ir<%arrayidx77>
    WIDEN store vp<%6>, ir<%17>, ir<%cmp80>
  Successor(s): if.end86

  if.end86:
    EMIT vp<%7> = not ir<%cmp80>
    EMIT vp<%8> = or ir<%cmp80>, vp<%7>
    BLEND ir<%18> = ir<%17> ir<%16>/vp<%7>
    CLONE ir<%arrayidx90> = getelementptr inbounds ir<%call35>, ir<%indvars.iv.next252>
    vp<%9> = vector-pointer (reverse) ir<%arrayidx90>
    WIDEN ir<%19> = load vp<%9>
    WIDEN ir<%cmp91> = fcmp olt ir<%18>, ir<%19>
  Successor(s): if.then92

  if.then92:
    EMIT vp<%10> = logical-and vp<%8>, ir<%cmp91>
    vp<%11> = vector-pointer (reverse) ir<%arrayidx77>
    WIDEN store vp<%11>, ir<%19>, vp<%10>
  Successor(s): if.end97

  if.end97:
    EMIT vp<%12> = not ir<%cmp91>
    EMIT vp<%13> = logical-and vp<%8>, vp<%12>
    EMIT vp<%14> = or vp<%10>, vp<%13>
    CLONE ir<%cmp74> = icmp ugt ir<%indvars.iv251>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.end98.loopexit>, scalar.ph

ir-bb<for.end98.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body75.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call71 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv251 = phi %15, %indvars.iv.next252, ir<-1>
    CLONE ir<%indvars.iv.next252> = add ir<%indvars.iv251>, ir<-1>
    CLONE ir<%arrayidx77> = getelementptr ir<%call15>, ir<%indvars.iv.next252>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx77>
    WIDEN ir<%16> = load vp<%4>
    CLONE ir<%arrayidx79> = getelementptr inbounds ir<%call30>, ir<%indvars.iv.next252>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx79>
    WIDEN ir<%17> = load vp<%5>
    WIDEN ir<%cmp80> = fcmp ogt ir<%16>, ir<%17>
  Successor(s): if.then81

  if.then81:
    vp<%6> = vector-pointer (reverse) ir<%arrayidx77>
    WIDEN store vp<%6>, ir<%17>, ir<%cmp80>
  Successor(s): if.end86

  if.end86:
    EMIT vp<%7> = not ir<%cmp80>
    EMIT vp<%8> = or ir<%cmp80>, vp<%7>
    BLEND ir<%18> = ir<%17> ir<%16>/vp<%7>
    CLONE ir<%arrayidx90> = getelementptr inbounds ir<%call35>, ir<%indvars.iv.next252>
    vp<%9> = vector-pointer (reverse) ir<%arrayidx90>
    WIDEN ir<%19> = load vp<%9>
    WIDEN ir<%cmp91> = fcmp olt ir<%18>, ir<%19>
  Successor(s): if.then92

  if.then92:
    EMIT vp<%10> = logical-and vp<%8>, ir<%cmp91>
    vp<%11> = vector-pointer (reverse) ir<%arrayidx77>
    WIDEN store vp<%11>, ir<%19>, vp<%10>
  Successor(s): if.end97

  if.end97:
    EMIT vp<%12> = not ir<%cmp91>
    EMIT vp<%13> = logical-and vp<%8>, vp<%12>
    EMIT vp<%14> = or vp<%10>, vp<%13>
    CLONE ir<%cmp74> = icmp ugt ir<%indvars.iv251>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.end98.loopexit>, scalar.ph

ir-bb<for.end98.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv251 = phi i64 [ %15, %for.body75.preheader ], [ %indvars.iv.next252, %if.end97 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next252 = add nsw i64 %indvars.iv251, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx77 = getelementptr inbounds double, ptr %call15, i64 %indvars.iv.next252 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %16 = load double, ptr %arrayidx77, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx79 = getelementptr inbounds double, ptr %call30, i64 %indvars.iv.next252 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %17 = load double, ptr %arrayidx79, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp80 = fcmp ogt double %16, %17 of type:fcmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp80, label %if.then81, label %if.end86 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %17, ptr %arrayidx77, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end86 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %18 = phi double [ %17, %if.then81 ], [ %16, %for.body75 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx90 = getelementptr inbounds double, ptr %call35, i64 %indvars.iv.next252 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load double, ptr %arrayidx90, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp91 = fcmp olt double %18, %19 of type:fcmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp91, label %if.then92, label %if.end97 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %19, ptr %arrayidx77, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end97 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp74 = icmp ugt i64 %indvars.iv251, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp74, label %for.body75, label %for.end98.loopexit of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv251 = phi i64 [ %15, %for.body75.preheader ], [ %indvars.iv.next252, %if.end97 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next252 = add nsw i64 %indvars.iv251, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx77 = getelementptr inbounds double, ptr %call15, i64 %indvars.iv.next252 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %16 = load double, ptr %arrayidx77, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx79 = getelementptr inbounds double, ptr %call30, i64 %indvars.iv.next252 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %17 = load double, ptr %arrayidx79, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp80 = fcmp ogt double %16, %17 of type:fcmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp80, label %if.then81, label %if.end86 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 9 for VF 2 For instruction:   store double %17, ptr %arrayidx77, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end86 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   %18 = phi double [ %17, %if.then81 ], [ %16, %for.body75 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx90 = getelementptr inbounds double, ptr %call35, i64 %indvars.iv.next252 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   %19 = load double, ptr %arrayidx90, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp91 = fcmp olt double %18, %19 of type:fcmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp91, label %if.then92, label %if.end97 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 9 for VF 2 For instruction:   store double %19, ptr %arrayidx77, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end97 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp74 = icmp ugt i64 %indvars.iv251, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp74, label %for.body75, label %for.end98.loopexit of type:br
LV: Vector loop of width 2 costs: 15
A is not scalable.	B is not scalable.	
RTCostA: 64424509422, RTCostB: 51539607540
A is not scalable.	B is not scalable.	
RTCostA: 64424509422, RTCostB: 51539607540

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv251 = phi i64 [ %15, %for.body75.preheader ], [ %indvars.iv.next252, %if.end97 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next252 = add nsw i64 %indvars.iv251, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx77 = getelementptr inbounds double, ptr %call15, i64 %indvars.iv.next252 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %16 = load double, ptr %arrayidx77, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx79 = getelementptr inbounds double, ptr %call30, i64 %indvars.iv.next252 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %17 = load double, ptr %arrayidx79, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp80 = fcmp ogt double %16, %17 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp80, label %if.then81, label %if.end86 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %17, ptr %arrayidx77, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end86 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %18 = phi double [ %17, %if.then81 ], [ %16, %for.body75 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx90 = getelementptr inbounds double, ptr %call35, i64 %indvars.iv.next252 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %19 = load double, ptr %arrayidx90, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp91 = fcmp olt double %18, %19 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp91, label %if.then92, label %if.end97 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %19, ptr %arrayidx77, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end97 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp74 = icmp ugt i64 %indvars.iv251, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp74, label %for.body75, label %for.end98.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 51539607540
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 51539607540

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv251 = phi i64 [ %15, %for.body75.preheader ], [ %indvars.iv.next252, %if.end97 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next252 = add nsw i64 %indvars.iv251, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx77 = getelementptr inbounds double, ptr %call15, i64 %indvars.iv.next252 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %16 = load double, ptr %arrayidx77, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx79 = getelementptr inbounds double, ptr %call30, i64 %indvars.iv.next252 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %17 = load double, ptr %arrayidx79, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp80 = fcmp ogt double %16, %17 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp80, label %if.then81, label %if.end86 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %17, ptr %arrayidx77, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end86 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %18 = phi double [ %17, %if.then81 ], [ %16, %for.body75 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx90 = getelementptr inbounds double, ptr %call35, i64 %indvars.iv.next252 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %19 = load double, ptr %arrayidx90, align 8, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp91 = fcmp olt double %18, %19 of type:fcmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp91, label %if.then92, label %if.end97 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store double %19, ptr %arrayidx77, align 8, !tbaa !6 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end97 of type:br

-----------------Function that is being costed:'_ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE' from spxsumst.cc-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp74 = icmp ugt i64 %indvars.iv251, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp74, label %for.body75, label %for.end98.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 16106127381, RTCostB: 51539607540
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 16106127381, RTCostB: 51539607540
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: _ZN6soplex8SPxSumST12setupWeightsERNS_6SoPlexE at line: spxsumst.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body75.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call71 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    vp<%4>    = DERIVED-IV ir<%15> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next252> = add vp<%5>, ir<-1>
    CLONE ir<%arrayidx77> = getelementptr ir<%call15>, ir<%indvars.iv.next252>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx77>
    WIDEN ir<%17> = load vp<%6>
    CLONE ir<%arrayidx79> = getelementptr inbounds ir<%call30>, ir<%indvars.iv.next252>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx79>
    WIDEN ir<%18> = load vp<%7>
    WIDEN ir<%cmp80> = fcmp ogt ir<%17>, ir<%18>
    vp<%8> = vector-pointer (reverse) ir<%arrayidx77>
    WIDEN store vp<%8>, ir<%18>, ir<%cmp80>
    EMIT vp<%9> = not ir<%cmp80>
    EMIT vp<%10> = or ir<%cmp80>, vp<%9>
    BLEND ir<%19> = ir<%18> ir<%17>/vp<%9>
    CLONE ir<%arrayidx90> = getelementptr inbounds ir<%call35>, ir<%indvars.iv.next252>
    vp<%11> = vector-pointer (reverse) ir<%arrayidx90>
    WIDEN ir<%20> = load vp<%11>
    WIDEN ir<%cmp91> = fcmp olt ir<%19>, ir<%20>
    EMIT vp<%12> = logical-and vp<%10>, ir<%cmp91>
    vp<%13> = vector-pointer (reverse) ir<%arrayidx77>
    WIDEN store vp<%13>, ir<%20>, vp<%12>
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%16>
Successor(s): ir-bb<for.end98.loopexit>, scalar.ph

ir-bb<for.end98.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2f64
MVT: nxv2i1
MVT: nxv2f64
MVT: nxv2i1
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxvecs.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxvecs.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxvectorst.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxvectorst.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxweightpr.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxweightpr.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spxweightst.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           spxweightst.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o ssvector.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           ssvector.cc
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex8SSVector5clearEv' from ssvector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%idxprom3> = sext ir<%3>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    CLONE store ir<0.000000e+00>, ir<%arrayidx4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex8SSVector5clearEv' from ssvector.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%3> to i64
    REPLICATE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex8SSVector5clearEv' from ssvector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%3> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    REPLICATE store ir<0.000000e+00>, ir<%arrayidx4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex8SSVector5clearEv' from ssvector.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%3> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    WIDEN store ir<%arrayidx4>, ir<0.000000e+00>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex8SSVector5clearEv' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double 0.000000e+00, ptr %arrayidx4, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZN6soplex8SSVector5clearEv' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store double 0.000000e+00, ptr %arrayidx4, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 31138512873, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 31138512873, RTCostB: 12884901882

-----------------Function that is being costed:'_ZN6soplex8SSVector5clearEv' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store double 0.000000e+00, ptr %arrayidx4, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 14
A is not scalable.	B is not scalable.	
RTCostA: 30601641945, RTCostB: 12884901882
A is not scalable.	B is not scalable.	
RTCostA: 30601641945, RTCostB: 12884901882

-----------------Function that is being costed:'_ZN6soplex8SSVector5clearEv' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double 0.000000e+00, ptr %arrayidx4, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882

-----------------Function that is being costed:'_ZN6soplex8SSVector5clearEv' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double 0.000000e+00, ptr %arrayidx4, align 8, !tbaa !16 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 23622320102, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: 23622320102, RTCostB: 12884901882
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN6soplex8SSVector5clearEv at line: ssvector.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, vp<%4>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%idxprom3> = sext ir<%3>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    CLONE store ir<0.000000e+00>, ir<%arrayidx4>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZNK6soplex8SSVector7length2Ev' from ssvector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.018> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%idxprom3> = sext ir<%3>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    CLONE ir<%4> = load ir<%arrayidx4>
    EMIT vp<%4> = fmul ir<%4>, ir<%4>
    CLONE ir<%5> = call @llvm.fmuladd.f64(ir<%4>, ir<%4>, ir<%x.018>)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.018> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.018>, ir<%5>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%7>
}

========== Loop: _ZNK6soplex8SSVector7length2Ev' from ssvector.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.018> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%3> to i64
    REPLICATE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    REPLICATE ir<%4> = load ir<%arrayidx4>
    EMIT vp<%5> = fmul ir<%4>, ir<%4>
    WIDEN-CALL ir<%5> = call @llvm.fmuladd.f64(ir<%4>, ir<%4>, ir<%x.018>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.018> + reduce.fadd (vp<%5>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%x.018>, ir<%5>.1
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%8>
}

========== Loop: _ZNK6soplex8SSVector7length2Ev' from ssvector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.018> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%3> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    REPLICATE ir<%4> = load ir<%arrayidx4>
    EMIT vp<%5> = fmul ir<%4>, ir<%4>
    WIDEN-CALL ir<%5> = call @llvm.fmuladd.f64(ir<%4>, ir<%4>, ir<%x.018>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.018> + reduce.fadd (vp<%5>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%x.018>, ir<%5>.1
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%8>
}

========== Loop: _ZNK6soplex8SSVector7length2Ev' from ssvector.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.018> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%3> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    WIDEN ir<%4> = load ir<%arrayidx4>
    EMIT vp<%5> = fmul ir<%4>, ir<%4>
    WIDEN-CALL ir<%5> = call @llvm.fmuladd.f64(ir<%4>, ir<%4>, ir<%x.018>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.018> + reduce.fadd (vp<%5>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%x.018>, ir<%5>.1
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%8>
}


-----------------Function that is being costed:'_ZNK6soplex8SSVector7length2Ev' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.018 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %4, double %4, double %x.018) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZNK6soplex8SSVector7length2Ev' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.018 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %4, double %4, double %x.018) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 19
A is not scalable.	B is not scalable.	
RTCostA: 41875931104, RTCostB: 15032385529
A is not scalable.	B is not scalable.	
RTCostA: 41875931104, RTCostB: 15032385529

-----------------Function that is being costed:'_ZNK6soplex8SSVector7length2Ev' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x.018 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %4, double %4, double %x.018) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 19
A is not scalable.	B is not scalable.	
RTCostA: 41339060168, RTCostB: 15032385529
A is not scalable.	B is not scalable.	
RTCostA: 41339060168, RTCostB: 15032385529

-----------------Function that is being costed:'_ZNK6soplex8SSVector7length2Ev' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.018 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %4, double %4, double %x.018) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529

-----------------Function that is being costed:'_ZNK6soplex8SSVector7length2Ev' from ssvector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.018 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load i32, ptr %arrayidx, align 4, !tbaa !15 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom3 = sext i32 %3 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %4, double %4, double %x.018) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
RTCostA: 26843545571, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: 26843545571, RTCostB: 15032385529
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZNK6soplex8SSVector7length2Ev at line: ssvector.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%x.018> = phi ir<0.000000e+00>, ir<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%2>, vp<%4>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%idxprom3> = sext ir<%3>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    CLONE ir<%4> = load ir<%arrayidx4>
    EMIT vp<%5> = fmul ir<%4>, ir<%4>
    REDUCE ir<%5> = ir<%x.018> + reduce.fadd (vp<%5>)
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%x.018>, ir<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o svector.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           svector.cc
@@ Instruction =>  %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex7SVector3addEiPKiPKd' from svector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%e.012> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 16
    EMIT ir<%v.addr.011> = WIDEN-POINTER-INDUCTION ir<%v>, 8
    EMIT ir<%i.addr.010> = WIDEN-POINTER-INDUCTION ir<%i>, 4
    WIDEN-INDUCTION %n.addr.09 = phi %dec, %n, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.addr.09>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.addr.010>, ir<4>
    CLONE ir<%1> = load ir<%i.addr.010>
    CLONE ir<%idx> = getelementptr inbounds ir<%e.012>, ir<8>
    CLONE store ir<%1>, ir<%idx>
    CLONE ir<%incdec.ptr3> = getelementptr inbounds ir<%v.addr.011>, ir<8>
    CLONE ir<%2> = load ir<%v.addr.011>
    CLONE store ir<%2>, ir<%e.012>
    CLONE ir<%incdec.ptr4> = getelementptr inbounds ir<%e.012>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex7SVector3addEiPKiPKd' from svector.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%e.012> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 16
    EMIT ir<%v.addr.011> = WIDEN-POINTER-INDUCTION ir<%v>, 8
    EMIT ir<%i.addr.010> = WIDEN-POINTER-INDUCTION ir<%i>, 4
    WIDEN-INDUCTION %n.addr.09 = phi %dec, %n, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.addr.09>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.addr.010>, ir<4>
    vp<%4> = vector-pointer ir<%i.addr.010>
    WIDEN ir<%1> = load vp<%4>
    REPLICATE ir<%idx> = getelementptr inbounds ir<%e.012>, ir<8>
    REPLICATE store ir<%1>, ir<%idx>
    CLONE ir<%incdec.ptr3> = getelementptr inbounds ir<%v.addr.011>, ir<8>
    vp<%5> = vector-pointer ir<%v.addr.011>
    WIDEN ir<%2> = load vp<%5>
    REPLICATE store ir<%2>, ir<%e.012>
    REPLICATE ir<%incdec.ptr4> = getelementptr inbounds ir<%e.012>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex7SVector3addEiPKiPKd' from svector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%e.012> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 16
    EMIT ir<%v.addr.011> = WIDEN-POINTER-INDUCTION ir<%v>, 8
    EMIT ir<%i.addr.010> = WIDEN-POINTER-INDUCTION ir<%i>, 4
    WIDEN-INDUCTION %n.addr.09 = phi %dec, %n, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.addr.09>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.addr.010>, ir<4>
    vp<%4> = vector-pointer ir<%i.addr.010>
    WIDEN ir<%1> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%idx> = getelementptr inbounds ir<%e.012>, ir<8>
    REPLICATE store ir<%1>, ir<%idx>
    CLONE ir<%incdec.ptr3> = getelementptr inbounds ir<%v.addr.011>, ir<8>
    vp<%5> = vector-pointer ir<%v.addr.011>
    WIDEN ir<%2> = load vp<%5>
    REPLICATE store ir<%2>, ir<%e.012>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr4> = getelementptr inbounds ir<%e.012>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex7SVector3addEiPKiPKd' from svector.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%e.012> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 16
    EMIT ir<%v.addr.011> = WIDEN-POINTER-INDUCTION ir<%v>, 8
    EMIT ir<%i.addr.010> = WIDEN-POINTER-INDUCTION ir<%i>, 4
    WIDEN-INDUCTION %n.addr.09 = phi %dec, %n, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.addr.09>, ir<-1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.addr.010>, ir<4>
    vp<%4> = vector-pointer ir<%i.addr.010>
    WIDEN ir<%1> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%idx> = getelementptr inbounds ir<%e.012>, ir<8>
    WIDEN store ir<%idx>, ir<%1>
    CLONE ir<%incdec.ptr3> = getelementptr inbounds ir<%v.addr.011>, ir<8>
    vp<%5> = vector-pointer ir<%v.addr.011>
    WIDEN ir<%2> = load vp<%5>
    WIDEN store ir<%e.012>, ir<%2>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr4> = getelementptr inbounds ir<%e.012>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex7SVector3addEiPKiPKd' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %e.012 = phi ptr [ %incdec.ptr4, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %v.addr.011 = phi ptr [ %incdec.ptr3, %while.body ], [ %v, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.addr.010 = phi ptr [ %incdec.ptr, %while.body ], [ %i, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.addr.09 = phi i32 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %n.addr.09, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.addr.010, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx = getelementptr inbounds i8, ptr %e.012, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %1, ptr %idx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %v.addr.011, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %2, ptr %e.012, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %e.012, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'_ZN6soplex7SVector3addEiPKiPKd' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %e.012 = phi ptr [ %incdec.ptr4, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %v.addr.011 = phi ptr [ %incdec.ptr3, %while.body ], [ %v, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.addr.010 = phi ptr [ %incdec.ptr, %while.body ], [ %i, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.addr.09 = phi i32 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %n.addr.09, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.addr.010, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx = getelementptr inbounds i8, ptr %e.012, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   store i32 %1, ptr %idx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %v.addr.011, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   store double %2, ptr %e.012, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %e.012, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 22
A is not scalable.	B is not scalable.	
RTCostA: 94489280478, RTCostB: 42949672950
A is not scalable.	B is not scalable.	
RTCostA: 94489280478, RTCostB: 42949672950

-----------------Function that is being costed:'_ZN6soplex7SVector3addEiPKiPKd' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %e.012 = phi ptr [ %incdec.ptr4, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %v.addr.011 = phi ptr [ %incdec.ptr3, %while.body ], [ %v, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.addr.010 = phi ptr [ %incdec.ptr, %while.body ], [ %i, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n.addr.09 = phi i32 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %n.addr.09, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.addr.010, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idx = getelementptr inbounds i8, ptr %e.012, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 24 for VF 4 For instruction:   store i32 %1, ptr %idx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %v.addr.011, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   store double %2, ptr %e.012, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %e.012, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 21
A is not scalable.	B is not scalable.	
RTCostA: 91268054985, RTCostB: 42949672950
A is not scalable.	B is not scalable.	
RTCostA: 91268054985, RTCostB: 42949672950

-----------------Function that is being costed:'_ZN6soplex7SVector3addEiPKiPKd' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %e.012 = phi ptr [ %incdec.ptr4, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %v.addr.011 = phi ptr [ %incdec.ptr3, %while.body ], [ %v, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.addr.010 = phi ptr [ %incdec.ptr, %while.body ], [ %i, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.addr.09 = phi i32 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %n.addr.09, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.addr.010, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx = getelementptr inbounds i8, ptr %e.012, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %1, ptr %idx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %v.addr.011, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %2, ptr %e.012, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %e.012, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 42949672950
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 42949672950

-----------------Function that is being costed:'_ZN6soplex7SVector3addEiPKiPKd' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %e.012 = phi ptr [ %incdec.ptr4, %while.body ], [ %add.ptr, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %v.addr.011 = phi ptr [ %incdec.ptr3, %while.body ], [ %v, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.addr.010 = phi ptr [ %incdec.ptr, %while.body ], [ %i, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.addr.09 = phi i32 [ %dec, %while.body ], [ %n, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %n.addr.09, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.addr.010, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i32, ptr %i.addr.010, align 4, !tbaa !11 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx = getelementptr inbounds i8, ptr %e.012, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %1, ptr %idx, align 8, !tbaa !13 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr3 = getelementptr inbounds i8, ptr %v.addr.011, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load double, ptr %v.addr.011, align 8, !tbaa !16 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double %2, ptr %e.012, align 8, !tbaa !17 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr4 = getelementptr inbounds i8, ptr %e.012, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 92341796808, RTCostB: 42949672950
A is scalable.	B is not scalable.	
RTCostA: 92341796808, RTCostB: 42949672950
LV: Selecting VF: 1 With Cost: 10.
maxbefore: 2
maxafter: 2
========== Loop: _ZNK6soplex7SVector3dimEv' from svector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %n.010 = phi %dec, %call, ir<-1>
    WIDEN-REDUCTION-PHI ir<%d.09> = phi ir<-1>, ir<%d.0.>
    EMIT ir<%e.08> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    CLONE ir<%dec> = add nsw ir<%n.010>, ir<-1>
    CLONE ir<%idx> = getelementptr inbounds ir<%e.08>, ir<8>
    CLONE ir<%1> = load ir<%idx>
    CLONE ir<%d.0.> = call @llvm.smax.i32(ir<%d.09>, ir<%1>)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%e.08>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%d.09>, ir<%d.0.>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %d.0..lcssa = vp<%6>
}

========== Loop: _ZNK6soplex7SVector3dimEv' from svector.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %n.010 = phi %dec, %call, ir<-1>
    WIDEN-REDUCTION-PHI ir<%d.09> = phi ir<-1>, ir<%d.0.>
    EMIT ir<%e.08> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    CLONE ir<%dec> = add nsw ir<%n.010>, ir<-1>
    CLONE ir<%idx> = getelementptr inbounds ir<%e.08>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %1, ir<%idx>
      ir<%1> = load from index 0
    WIDEN-CALL ir<%d.0.> = call @llvm.smax.i32(ir<%d.09>, ir<%1>) (using vector intrinsic)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%e.08>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%d.09>, ir<%d.0.>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZNK6soplex7SVector3dimEv' from svector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %n.010 = phi %dec, %call, ir<-1>
    WIDEN-REDUCTION-PHI ir<%d.09> = phi ir<-1>, ir<%d.0.>
    EMIT ir<%e.08> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    CLONE ir<%dec> = add nsw ir<%n.010>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%idx> = getelementptr inbounds ir<%e.08>, ir<8>
    REPLICATE ir<%1> = load ir<%idx>
    WIDEN-CALL ir<%d.0.> = call @llvm.smax.i32(ir<%d.09>, ir<%1>) (using vector intrinsic)
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%e.08>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%d.09>, ir<%d.0.>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZNK6soplex7SVector3dimEv' from svector.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %n.010 = phi %dec, %call, ir<-1>
    WIDEN-REDUCTION-PHI ir<%d.09> = phi ir<-1>, ir<%d.0.>
    EMIT ir<%e.08> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    CLONE ir<%dec> = add nsw ir<%n.010>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%idx> = getelementptr inbounds ir<%e.08>, ir<8>
    WIDEN ir<%1> = load ir<%idx>
    WIDEN-CALL ir<%d.0.> = call @llvm.smax.i32(ir<%d.09>, ir<%1>) (using vector intrinsic)
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%e.08>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%d.09>, ir<%d.0.>
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZNK6soplex7SVector3dimEv' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.010 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %d.09 = phi i32 [ %d.0., %while.body ], [ -1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %e.08 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %n.010, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx = getelementptr inbounds i8, ptr %e.08, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load i32, ptr %idx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %d.0. = tail call i32 @llvm.smax.i32(i32 %d.09, i32 %1) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.08, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'_ZNK6soplex7SVector3dimEv' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.010 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %d.09 = phi i32 [ %d.0., %while.body ], [ -1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %e.08 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %n.010, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx = getelementptr inbounds i8, ptr %e.08, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 2 For instruction:   %1 = load i32, ptr %idx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %d.0. = tail call i32 @llvm.smax.i32(i32 %d.09, i32 %1) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.08, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 15032385535, RTCostB: 25769803770
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 15032385535, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZNK6soplex7SVector3dimEv' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n.010 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %d.09 = phi i32 [ %d.0., %while.body ], [ -1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %e.08 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %n.010, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idx = getelementptr inbounds i8, ptr %e.08, i64 8 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 4 for VF 4 For instruction:   %1 = load i32, ptr %idx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %d.0. = tail call i32 @llvm.smax.i32(i32 %d.09, i32 %1) of type:call
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.08, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192779, RTCostB: 25769803770
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192779, RTCostB: 15032385535
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZNK6soplex7SVector3dimEv' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.010 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %d.09 = phi i32 [ %d.0., %while.body ], [ -1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %e.08 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %n.010, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx = getelementptr inbounds i8, ptr %e.08, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load i32, ptr %idx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %d.0. = tail call i32 @llvm.smax.i32(i32 %d.09, i32 %1) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.08, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 25769803770
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192779

-----------------Function that is being costed:'_ZNK6soplex7SVector3dimEv' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.010 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %d.09 = phi i32 [ %d.0., %while.body ], [ -1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %e.08 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %n.010, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx = getelementptr inbounds i8, ptr %e.08, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %1 = load i32, ptr %idx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %d.0. = tail call i32 @llvm.smax.i32(i32 %d.09, i32 %1) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.08, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 47244640230, RTCostB: 25769803770
A is scalable.	B is not scalable.	
RTCostA: 47244640230, RTCostB: 7516192779

-----------------Function that is being costed:'_ZNK6soplex7SVector3dimEv' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %n.010 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %d.09 = phi i32 [ %d.0., %while.body ], [ -1, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %e.08 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i32 %n.010, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %idx = getelementptr inbounds i8, ptr %e.08, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %1 = load i32, ptr %idx, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %d.0. = tail call i32 @llvm.smax.i32(i32 %d.09, i32 %1) of type:call
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.08, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 45097156566, RTCostB: 25769803770
A is scalable.	B is not scalable.	
RTCostA: 45097156566, RTCostB: 7516192779
LV: Selecting VF: 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=4, UF=2 at function: _ZNK6soplex7SVector3dimEv at line: svector.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%d.09> = phi ir<-1>, ir<%d.0.>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<16>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<16>
    EMIT vp<%6> = ptradd ir<%0>, vp<%5>
    CLONE ir<%idx> = getelementptr inbounds vp<%6>, ir<8>
    INTERLEAVE-GROUP with factor 4 at %1, ir<%idx>
      ir<%1> = load from index 0
    WIDEN-CALL ir<%d.0.> = call @llvm.smax.i32(ir<%d.09>, ir<%1>) (using vector intrinsic)
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%d.09>, ir<%d.0.>
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZNK6soplex7SVector7length2Ev' from svector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%e.09> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    WIDEN-INDUCTION %n.08 = phi %dec, %call, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x.07> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%dec> = add nsw ir<%n.08>, ir<-1>
    CLONE ir<%1> = load ir<%e.09>
    EMIT vp<%4> = fmul ir<%1>, ir<%1>
    CLONE ir<%2> = call @llvm.fmuladd.f64(ir<%1>, ir<%1>, ir<%x.07>)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%e.09>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
    REDUCE ir<%2>.1 = ir<%x.07> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.07>, ir<%2>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%7>
}

========== Loop: _ZNK6soplex7SVector7length2Ev' from svector.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%e.09> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    WIDEN-INDUCTION %n.08 = phi %dec, %call, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x.07> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%dec> = add nsw ir<%n.08>, ir<-1>
    INTERLEAVE-GROUP with factor 2 at %1, ir<%e.09>
      ir<%1> = load from index 0
    EMIT vp<%4> = fmul ir<%1>, ir<%1>
    WIDEN-CALL ir<%2> = call @llvm.fmuladd.f64(ir<%1>, ir<%1>, ir<%x.07>) (using vector intrinsic)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%e.09>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
    REDUCE ir<%2>.1 = ir<%x.07> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.07>, ir<%2>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZNK6soplex7SVector7length2Ev' from svector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%e.09> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    WIDEN-INDUCTION %n.08 = phi %dec, %call, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x.07> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%dec> = add nsw ir<%n.08>, ir<-1>
    REPLICATE ir<%1> = load ir<%e.09>
    EMIT vp<%4> = fmul ir<%1>, ir<%1>
    WIDEN-CALL ir<%2> = call @llvm.fmuladd.f64(ir<%1>, ir<%1>, ir<%x.07>) (using vector intrinsic)
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%e.09>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
    REDUCE ir<%2>.1 = ir<%x.07> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.07>, ir<%2>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZNK6soplex7SVector7length2Ev' from svector.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%e.09> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    WIDEN-INDUCTION %n.08 = phi %dec, %call, ir<-1>
    WIDEN-REDUCTION-PHI ir<%x.07> = phi ir<0.000000e+00>, ir<%2>.1
    CLONE ir<%dec> = add nsw ir<%n.08>, ir<-1>
    INTERLEAVE-GROUP with factor 2 at %1, ir<%e.09>
      ir<%1> = load from index 0
    EMIT vp<%4> = fmul ir<%1>, ir<%1>
    WIDEN-CALL ir<%2> = call @llvm.fmuladd.f64(ir<%1>, ir<%1>, ir<%x.07>) (using vector intrinsic)
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%e.09>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
    REDUCE ir<%2>.1 = ir<%x.07> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.07>, ir<%2>.1
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZNK6soplex7SVector7length2Ev' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %e.09 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.08 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.07 = phi double [ %2, %while.body ], [ 0.000000e+00, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %n.08, -1 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load double, ptr %e.09, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = tail call double @llvm.fmuladd.f64(double %1, double %1, double %x.07) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.09, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'_ZNK6soplex7SVector7length2Ev' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %e.09 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.08 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.07 = phi double [ %2, %while.body ], [ 0.000000e+00, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %n.08, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %1 = load double, ptr %e.09, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %2 = tail call double @llvm.fmuladd.f64(double %1, double %1, double %x.07) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.09, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 25769803769, RTCostB: 21474836475
A is not scalable.	B is not scalable.	
RTCostA: 25769803769, RTCostB: 21474836475

-----------------Function that is being costed:'_ZNK6soplex7SVector7length2Ev' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %e.09 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.08 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.07 = phi double [ %2, %while.body ], [ 0.000000e+00, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %n.08, -1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load double, ptr %e.09, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %2 = tail call double @llvm.fmuladd.f64(double %1, double %1, double %x.07) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.09, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836475
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 21474836475

-----------------Function that is being costed:'_ZNK6soplex7SVector7length2Ev' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %e.09 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.08 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.07 = phi double [ %2, %while.body ], [ 0.000000e+00, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %n.08, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %1 = load double, ptr %e.09, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %2 = tail call double @llvm.fmuladd.f64(double %1, double %1, double %x.07) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.09, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 10737418245, RTCostB: 21474836475
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10737418245, RTCostB: 21474836475
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZNK6soplex7SVector7length2Ev at line: svector.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%x.07> = phi ir<0.000000e+00>, ir<%2>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<16>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<16>
    EMIT vp<%6> = ptradd ir<%0>, vp<%5>
    INTERLEAVE-GROUP with factor 2 at %1, vp<%6>
      ir<%1> = load from index 0
    EMIT vp<%7> = fmul ir<%1>, ir<%1>
    REDUCE ir<%2> = ir<%x.07> + reduce.fadd (vp<%7>)
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x.07>, ir<%2>
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 6
Loops Epilogues Vectorized: 0
================================================
========== Loop: _ZN6soplex7SVectormLEd' from svector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%e.05> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    WIDEN-INDUCTION %n.04 = phi %dec, %call, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.04>, ir<-1>
    CLONE ir<%1> = load ir<%e.05>
    CLONE ir<%mul> = fmul ir<%1>, ir<%x>
    CLONE store ir<%mul>, ir<%e.05>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%e.05>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex7SVectormLEd' from svector.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%e.05> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    WIDEN-INDUCTION %n.04 = phi %dec, %call, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.04>, ir<-1>
    INTERLEAVE-GROUP with factor 2 at %1, ir<%e.05>
      ir<%1> = load from index 0
    WIDEN ir<%mul> = fmul ir<%1>, ir<%x>
    REPLICATE store ir<%mul>, ir<%e.05>
    REPLICATE ir<%incdec.ptr> = getelementptr inbounds ir<%e.05>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN6soplex7SVectormLEd' from svector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%e.05> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    WIDEN-INDUCTION %n.04 = phi %dec, %call, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.04>, ir<-1>
    REPLICATE ir<%1> = load ir<%e.05>
    WIDEN ir<%mul> = fmul ir<%1>, ir<%x>
    REPLICATE store ir<%mul>, ir<%e.05>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%e.05>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: _ZN6soplex7SVectormLEd' from svector.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%e.05> = WIDEN-POINTER-INDUCTION ir<%0>, 16
    WIDEN-INDUCTION %n.04 = phi %dec, %call, ir<-1>
    CLONE ir<%dec> = add nsw ir<%n.04>, ir<-1>
    INTERLEAVE-GROUP with factor 2 at %1, ir<%e.05>
      ir<%1> = load from index 0
    WIDEN ir<%mul> = fmul ir<%1>, ir<%x>
    WIDEN store ir<%e.05>, ir<%mul>
    WIDEN-GEP Var[Inv] ir<%incdec.ptr> = getelementptr inbounds ir<%e.05>, ir<16>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex7SVectormLEd' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %e.05 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.04 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %n.04, -1 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1 = load double, ptr %e.05, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %mul = fmul double %1, %x of type:fmul
LV: Found an estimated cost of 2 for VF 1 For instruction:   store double %mul, ptr %e.05, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.05, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'_ZN6soplex7SVectormLEd' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %e.05 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.04 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %n.04, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %1 = load double, ptr %e.05, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF 2 For instruction:   %mul = fmul double %1, %x of type:fmul
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   store double %mul, ptr %e.05, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.05, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width 2 costs: 17
A is not scalable.	B is not scalable.	
RTCostA: 73014444006, RTCostB: 34359738360
A is not scalable.	B is not scalable.	
RTCostA: 73014444006, RTCostB: 34359738360

-----------------Function that is being costed:'_ZN6soplex7SVectormLEd' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %e.05 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.04 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %n.04, -1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1 = load double, ptr %e.05, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %mul = fmul double %1, %x of type:fmul
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store double %mul, ptr %e.05, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.05, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 34359738360
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 34359738360

-----------------Function that is being costed:'_ZN6soplex7SVectormLEd' from svector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %e.05 = phi ptr [ %incdec.ptr, %while.body ], [ %0, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.04 = phi i32 [ %dec, %while.body ], [ %call, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %n.04, -1 of type:add
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %1 = load double, ptr %e.05, align 8, !tbaa !11 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = fmul double %1, %x of type:fmul
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store double %mul, ptr %e.05, align 8, !tbaa !11 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %e.05, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %while.end.loopexit, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 50465865705, RTCostB: 34359738360
A is scalable.	B is not scalable.	
RTCostA: 50465865705, RTCostB: 34359738360
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: _ZN6soplex7SVectormLEd at line: svector.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<16>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<16>
    EMIT vp<%6> = ptradd ir<%0>, vp<%5>
    CLONE ir<%1> = load vp<%6>
    CLONE ir<%mul> = fmul ir<%1>, ir<%x>
    CLONE store ir<%mul>, vp<%6>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end.loopexit>, scalar.ph

ir-bb<while.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o svset.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           svset.cc
MVT: v2i32
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi' from svset.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    CLONE ir<%1> = trunc ir<%indvars.iv.next>
    CLONE store ir<%1>, ir<%arrayidx>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi' from svset.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%1> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%1>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi' from svset.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%1> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%1>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 10737418239
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192773

-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 7516192773
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3758096405, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 3758096405, RTCostB: 5368709127
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex5SVSet6removeEPNS_7DataKeyEiPi at line: svset.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%1> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%1>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
MVT: v2i32
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %1, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: _ZN6soplex5SVSet6removeEPiiS1_' from svset.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    CLONE ir<%1> = trunc ir<%indvars.iv.next>
    CLONE store ir<%1>, ir<%arrayidx>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SVSet6removeEPiiS1_' from svset.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%1> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%1>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex5SVSet6removeEPiiS1_' from svset.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%1> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%1>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPiiS1_' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPiiS1_' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418239, RTCostB: 17179869180
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPiiS1_' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 17179869180
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192773, RTCostB: 10737418239
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPiiS1_' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869180
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 7516192773

-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPiiS1_' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 17179869180
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709127, RTCostB: 7516192773
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex5SVSet6removeEPiiS1_' from svset.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %perm, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %1 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %1, ptr %arrayidx, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp, label %for.body, label %while.cond.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 3758096405, RTCostB: 17179869180
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 3758096405, RTCostB: 5368709127
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex5SVSet6removeEPiiS1_ at line: svset.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %call to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%perm>, ir<%indvars.iv.next>
    WIDEN-CAST ir<%1> = trunc  ir<%indvars.iv.next> to i32
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%1>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 15
Loops Epilogues Vectorized: 0
================================================
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
MVT: nxv4i32
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o timer.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           timer.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o unitvector.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           unitvector.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o update.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           update.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o updatevector.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           updatevector.cc
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o vector.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           vector.cc
@@ Instruction =>  %3 = load double, ptr %arrayidx, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load double, ptr %arrayidx, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %3 = load double, ptr %arrayidx, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZNK6soplex6VectormlERKS0_' from vector.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.010> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx4>
    EMIT vp<%4> = fmul ir<%3>, ir<%4>
    CLONE ir<%5> = call @llvm.fmuladd.f64(ir<%3>, ir<%4>, ir<%x.010>)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.010> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.010>, ir<%5>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%7>
}

========== Loop: _ZNK6soplex6VectormlERKS0_' from vector.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.010> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%4> = load vp<%5>
    EMIT vp<%6> = fmul ir<%3>, ir<%4>
    WIDEN-CALL ir<%5> = call @llvm.fmuladd.f64(ir<%3>, ir<%4>, ir<%x.010>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.010> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.010>, ir<%5>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZNK6soplex6VectormlERKS0_' from vector.cc==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%x.010> = phi ir<0.000000e+00>, ir<%5>.1
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%2>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%4> = load vp<%5>
    EMIT vp<%6> = fmul ir<%3>, ir<%4>
    WIDEN-CALL ir<%5> = call @llvm.fmuladd.f64(ir<%3>, ir<%4>, ir<%x.010>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
    REDUCE ir<%5>.1 = ir<%x.010> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.010>, ir<%5>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}


-----------------Function that is being costed:'_ZNK6soplex6VectormlERKS0_' from vector.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.010 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %3, double %4, double %x.010) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'_ZNK6soplex6VectormlERKS0_' from vector.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.010 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %3, double %4, double %x.010) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901883, RTCostB: 15032385529
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901883, RTCostB: 15032385529
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZNK6soplex6VectormlERKS0_' from vector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.010 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %3, double %4, double %x.010) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 15032385529
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901883

-----------------Function that is being costed:'_ZNK6soplex6VectormlERKS0_' from vector.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.010 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %5, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds double, ptr %1, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %3 = load double, ptr %arrayidx, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds double, ptr %2, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load double, ptr %arrayidx4, align 8, !tbaa !13 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %5 = tail call double @llvm.fmuladd.f64(double %3, double %4, double %x.010) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709131, RTCostB: 15032385529
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709131, RTCostB: 12884901883
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 2
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=2 at function: _ZNK6soplex6VectormlERKS0_ at line: vector.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%x.010> = phi ir<0.000000e+00>, ir<%5>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%1>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%5>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%2>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx4>
    WIDEN ir<%4> = load vp<%6>
    EMIT vp<%7> = fmul ir<%3>, ir<%4>
    REDUCE ir<%5> = ir<%x.010> + reduce.fadd (vp<%7>)
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x.010>, ir<%5>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.cond.cleanup.loopexit>, scalar.ph

ir-bb<for.cond.cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%10>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o vsolve.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           vsolve.cc
@@ Instruction =>  %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load double, ptr %val.1148, align 8, !tbaa !27 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load double, ptr %val.1148, align 8, !tbaa !27 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load double, ptr %val.1148, align 8, !tbaa !27 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %21 = load double, ptr %val.1148, align 8, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load double, ptr %val.1148, align 8, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor12vSolveLrightEPdPiid' from vsolve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %17) + %18) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%idx.1150> = WIDEN-POINTER-INDUCTION ir<%arrayidx48>, 4
    WIDEN-INDUCTION %j.1149 = phi %dec62, %18, ir<-1>
    EMIT ir<%val.1148> = WIDEN-POINTER-INDUCTION ir<%arrayidx50>, 8
    WIDEN-REDUCTION-PHI ir<%x.0147> = phi ir<0.000000e+00>, ir<%22>.1
    CLONE ir<%incdec.ptr57> = getelementptr inbounds ir<%idx.1150>, ir<4>
    CLONE ir<%19> = load ir<%idx.1150>
    CLONE ir<%idxprom58> = sext ir<%19>
    CLONE ir<%arrayidx59> = getelementptr inbounds ir<%vec>, ir<%idxprom58>
    CLONE ir<%20> = load ir<%arrayidx59>
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%val.1148>, ir<8>
    CLONE ir<%21> = load ir<%val.1148>
    EMIT vp<%4> = fmul ir<%20>, ir<%21>
    CLONE ir<%22> = call @llvm.fmuladd.f64(ir<%20>, ir<%21>, ir<%x.0147>)
    CLONE ir<%dec62> = add nsw ir<%j.1149>, ir<-1>
    CLONE ir<%cmp55> = icmp sgt ir<%dec62>, ir<%17>
    REDUCE ir<%22>.1 = ir<%x.0147> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.0147>, ir<%22>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end63.loopexit>, scalar.ph

ir-bb<for.end63.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%7>
}

========== Loop: _ZN6soplex9CLUFactor12vSolveLrightEPdPiid' from vsolve.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %17) + %18) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.1150> = WIDEN-POINTER-INDUCTION ir<%arrayidx48>, 4
    WIDEN-INDUCTION %j.1149 = phi %dec62, %18, ir<-1>
    EMIT ir<%val.1148> = WIDEN-POINTER-INDUCTION ir<%arrayidx50>, 8
    WIDEN-REDUCTION-PHI ir<%x.0147> = phi ir<0.000000e+00>, ir<%22>.1
    CLONE ir<%incdec.ptr57> = getelementptr inbounds ir<%idx.1150>, ir<4>
    vp<%4> = vector-pointer ir<%idx.1150>
    WIDEN ir<%19> = load vp<%4>
    WIDEN-CAST ir<%idxprom58> = sext  ir<%19> to i64
    REPLICATE ir<%arrayidx59> = getelementptr inbounds ir<%vec>, ir<%idxprom58>
    REPLICATE ir<%20> = load ir<%arrayidx59>
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%val.1148>, ir<8>
    vp<%5> = vector-pointer ir<%val.1148>
    WIDEN ir<%21> = load vp<%5>
    EMIT vp<%6> = fmul ir<%20>, ir<%21>
    WIDEN-CALL ir<%22> = call @llvm.fmuladd.f64(ir<%20>, ir<%21>, ir<%x.0147>) (using vector intrinsic)
    CLONE ir<%dec62> = add nsw ir<%j.1149>, ir<-1>
    CLONE ir<%cmp55> = icmp sgt ir<%dec62>, ir<%17>
    REDUCE ir<%22>.1 = ir<%x.0147> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.0147>, ir<%22>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end63.loopexit>, scalar.ph

ir-bb<for.end63.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor12vSolveLrightEPdPiid' from vsolve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %17) + %18) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.1150> = WIDEN-POINTER-INDUCTION ir<%arrayidx48>, 4
    WIDEN-INDUCTION %j.1149 = phi %dec62, %18, ir<-1>
    EMIT ir<%val.1148> = WIDEN-POINTER-INDUCTION ir<%arrayidx50>, 8
    WIDEN-REDUCTION-PHI ir<%x.0147> = phi ir<0.000000e+00>, ir<%22>.1
    CLONE ir<%incdec.ptr57> = getelementptr inbounds ir<%idx.1150>, ir<4>
    vp<%4> = vector-pointer ir<%idx.1150>
    WIDEN ir<%19> = load vp<%4>
    WIDEN-CAST ir<%idxprom58> = sext  ir<%19> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx59> = getelementptr inbounds ir<%vec>, ir<%idxprom58>
    REPLICATE ir<%20> = load ir<%arrayidx59>
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%val.1148>, ir<8>
    vp<%5> = vector-pointer ir<%val.1148>
    WIDEN ir<%21> = load vp<%5>
    EMIT vp<%6> = fmul ir<%20>, ir<%21>
    WIDEN-CALL ir<%22> = call @llvm.fmuladd.f64(ir<%20>, ir<%21>, ir<%x.0147>) (using vector intrinsic)
    CLONE ir<%dec62> = add nsw ir<%j.1149>, ir<-1>
    CLONE ir<%cmp55> = icmp sgt ir<%dec62>, ir<%17>
    REDUCE ir<%22>.1 = ir<%x.0147> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.0147>, ir<%22>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end63.loopexit>, scalar.ph

ir-bb<for.end63.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor12vSolveLrightEPdPiid' from vsolve.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body56.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %17) + %18) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.1150> = WIDEN-POINTER-INDUCTION ir<%arrayidx48>, 4
    WIDEN-INDUCTION %j.1149 = phi %dec62, %18, ir<-1>
    EMIT ir<%val.1148> = WIDEN-POINTER-INDUCTION ir<%arrayidx50>, 8
    WIDEN-REDUCTION-PHI ir<%x.0147> = phi ir<0.000000e+00>, ir<%22>.1
    CLONE ir<%incdec.ptr57> = getelementptr inbounds ir<%idx.1150>, ir<4>
    vp<%4> = vector-pointer ir<%idx.1150>
    WIDEN ir<%19> = load vp<%4>
    WIDEN-CAST ir<%idxprom58> = sext  ir<%19> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx59> = getelementptr inbounds ir<%vec>, ir<%idxprom58>
    WIDEN ir<%20> = load ir<%arrayidx59>
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%val.1148>, ir<8>
    vp<%5> = vector-pointer ir<%val.1148>
    WIDEN ir<%21> = load vp<%5>
    EMIT vp<%6> = fmul ir<%20>, ir<%21>
    WIDEN-CALL ir<%22> = call @llvm.fmuladd.f64(ir<%20>, ir<%21>, ir<%x.0147>) (using vector intrinsic)
    CLONE ir<%dec62> = add nsw ir<%j.1149>, ir<-1>
    CLONE ir<%cmp55> = icmp sgt ir<%dec62>, ir<%17>
    REDUCE ir<%22>.1 = ir<%x.0147> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.0147>, ir<%22>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end63.loopexit>, scalar.ph

ir-bb<for.end63.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor12vSolveLrightEPdPiid' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx.1150 = phi ptr [ %incdec.ptr57, %for.body56 ], [ %arrayidx48, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.1149 = phi i32 [ %dec62, %for.body56 ], [ %18, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %val.1148 = phi ptr [ %incdec.ptr60, %for.body56 ], [ %arrayidx50, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.0147 = phi double [ %22, %for.body56 ], [ 0.000000e+00, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr57 = getelementptr inbounds i8, ptr %idx.1150, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom58 = sext i32 %19 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx59 = getelementptr inbounds double, ptr %vec, i64 %idxprom58 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %20 = load double, ptr %arrayidx59, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %val.1148, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %21 = load double, ptr %val.1148, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %20, double %21, double %x.0147) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec62 = add nsw i32 %j.1149, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp55 = icmp sgt i32 %dec62, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp55, label %for.body56, label %for.end63.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor12vSolveLrightEPdPiid' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx.1150 = phi ptr [ %incdec.ptr57, %for.body56 ], [ %arrayidx48, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.1149 = phi i32 [ %dec62, %for.body56 ], [ %18, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %val.1148 = phi ptr [ %incdec.ptr60, %for.body56 ], [ %arrayidx50, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.0147 = phi double [ %22, %for.body56 ], [ 0.000000e+00, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr57 = getelementptr inbounds i8, ptr %idx.1150, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom58 = sext i32 %19 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx59 = getelementptr inbounds double, ptr %vec, i64 %idxprom58 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %20 = load double, ptr %arrayidx59, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %val.1148, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %21 = load double, ptr %val.1148, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %20, double %21, double %x.0147) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec62 = add nsw i32 %j.1149, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp55 = icmp sgt i32 %dec62, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp55, label %for.body56, label %for.end63.loopexit of type:br
LV: Vector loop of width 2 costs: 20
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 40
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 40
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12vSolveLrightEPdPiid' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idx.1150 = phi ptr [ %incdec.ptr57, %for.body56 ], [ %arrayidx48, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.1149 = phi i32 [ %dec62, %for.body56 ], [ %18, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %val.1148 = phi ptr [ %incdec.ptr60, %for.body56 ], [ %arrayidx50, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x.0147 = phi double [ %22, %for.body56 ], [ 0.000000e+00, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr57 = getelementptr inbounds i8, ptr %idx.1150, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom58 = sext i32 %19 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx59 = getelementptr inbounds double, ptr %vec, i64 %idxprom58 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %20 = load double, ptr %arrayidx59, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %val.1148, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %21 = load double, ptr %val.1148, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %20, double %21, double %x.0147) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec62 = add nsw i32 %j.1149, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp55 = icmp sgt i32 %dec62, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp55, label %for.body56, label %for.end63.loopexit of type:br
LV: Vector loop of width 4 costs: 19
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 79
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 79, CostB * EstimatedWidthA: 36
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 79
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 79, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12vSolveLrightEPdPiid' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx.1150 = phi ptr [ %incdec.ptr57, %for.body56 ], [ %arrayidx48, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.1149 = phi i32 [ %dec62, %for.body56 ], [ %18, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %val.1148 = phi ptr [ %incdec.ptr60, %for.body56 ], [ %arrayidx50, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.0147 = phi double [ %22, %for.body56 ], [ 0.000000e+00, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr57 = getelementptr inbounds i8, ptr %idx.1150, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom58 = sext i32 %19 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx59 = getelementptr inbounds double, ptr %vec, i64 %idxprom58 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %20 = load double, ptr %arrayidx59, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %val.1148, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %21 = load double, ptr %val.1148, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %20, double %21, double %x.0147) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec62 = add nsw i32 %j.1149, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp55 = icmp sgt i32 %dec62, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp55, label %for.body56, label %for.end63.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor12vSolveLrightEPdPiid' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx.1150 = phi ptr [ %incdec.ptr57, %for.body56 ], [ %arrayidx48, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.1149 = phi i32 [ %dec62, %for.body56 ], [ %18, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %val.1148 = phi ptr [ %incdec.ptr60, %for.body56 ], [ %arrayidx50, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.0147 = phi double [ %22, %for.body56 ], [ 0.000000e+00, %for.body56.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr57 = getelementptr inbounds i8, ptr %idx.1150, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %19 = load i32, ptr %idx.1150, align 4, !tbaa !26 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom58 = sext i32 %19 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx59 = getelementptr inbounds double, ptr %vec, i64 %idxprom58 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %20 = load double, ptr %arrayidx59, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %val.1148, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %21 = load double, ptr %val.1148, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %22 = tail call double @llvm.fmuladd.f64(double %20, double %21, double %x.0147) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec62 = add nsw i32 %j.1149, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp55 = icmp sgt i32 %dec62, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp55, label %for.body56, label %for.end63.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 51
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 51, CostB * EstimatedWidthA: 36
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 51
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 51, CostB * EstimatedWidthA: 36
LV: Selecting VF: 1 With Cost: 9.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %39 = load double, ptr %val.3334, align 8, !tbaa !27 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %39 = load double, ptr %val.3334, align 8, !tbaa !27 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %39 = load double, ptr %val.3334, align 8, !tbaa !27 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %39 = load double, ptr %val.3334, align 8, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %39 = load double, ptr %val.3334, align 8, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor13vSolveLright2EPdPiS2_dS1_S2_S2_d' from vsolve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body128.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %35) + %36) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%idx.3336> = WIDEN-POINTER-INDUCTION ir<%arrayidx120>, 4
    WIDEN-INDUCTION %j.3335 = phi %dec136, %36, ir<-1>
    EMIT ir<%val.3334> = WIDEN-POINTER-INDUCTION ir<%arrayidx122>, 8
    WIDEN-REDUCTION-PHI ir<%x2.0333> = phi ir<0.000000e+00>, ir<%42>.1
    WIDEN-REDUCTION-PHI ir<%x.0332> = phi ir<0.000000e+00>, ir<%40>.1
    CLONE ir<%37> = load ir<%idx.3336>
    CLONE ir<%idxprom129> = sext ir<%37>
    CLONE ir<%arrayidx130> = getelementptr inbounds ir<%vec>, ir<%idxprom129>
    CLONE ir<%38> = load ir<%arrayidx130>
    CLONE ir<%39> = load ir<%val.3334>
    EMIT vp<%4> = fmul ir<%38>, ir<%39>
    CLONE ir<%40> = call @llvm.fmuladd.f64(ir<%38>, ir<%39>, ir<%x.0332>)
    CLONE ir<%incdec.ptr131> = getelementptr inbounds ir<%idx.3336>, ir<4>
    CLONE ir<%arrayidx133> = getelementptr inbounds ir<%vec2>, ir<%idxprom129>
    CLONE ir<%41> = load ir<%arrayidx133>
    CLONE ir<%incdec.ptr134> = getelementptr inbounds ir<%val.3334>, ir<8>
    EMIT vp<%5> = fmul ir<%41>, ir<%39>
    CLONE ir<%42> = call @llvm.fmuladd.f64(ir<%41>, ir<%39>, ir<%x2.0333>)
    CLONE ir<%dec136> = add nsw ir<%j.3335>, ir<-1>
    CLONE ir<%cmp127> = icmp sgt ir<%dec136>, ir<%35>
    REDUCE ir<%42>.1 = ir<%x2.0333> + reduce.fadd (vp<%5>)
    REDUCE ir<%40>.1 = ir<%x.0332> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%x2.0333>, ir<%42>.1
  EMIT vp<%9> = compute-reduction-result ir<%x.0332>, ir<%40>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end137.loopexit>, scalar.ph

ir-bb<for.end137.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa359 = vp<%9>
Live-out double %.lcssa = vp<%8>
}

========== Loop: _ZN6soplex9CLUFactor13vSolveLright2EPdPiS2_dS1_S2_S2_d' from vsolve.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body128.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %35) + %36) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%idx.3336> = WIDEN-POINTER-INDUCTION ir<%arrayidx120>, 4
    WIDEN-INDUCTION %j.3335 = phi %dec136, %36, ir<-1>
    EMIT ir<%val.3334> = WIDEN-POINTER-INDUCTION ir<%arrayidx122>, 8
    WIDEN-REDUCTION-PHI ir<%x2.0333> = phi ir<0.000000e+00>, ir<%42>.1
    WIDEN-REDUCTION-PHI ir<%x.0332> = phi ir<0.000000e+00>, ir<%40>.1
    vp<%4> = vector-pointer ir<%idx.3336>
    WIDEN ir<%37> = load vp<%4>
    WIDEN-CAST ir<%idxprom129> = sext  ir<%37> to i64
    REPLICATE ir<%arrayidx130> = getelementptr inbounds ir<%vec>, ir<%idxprom129>
    REPLICATE ir<%38> = load ir<%arrayidx130>
    vp<%5> = vector-pointer ir<%val.3334>
    WIDEN ir<%39> = load vp<%5>
    EMIT vp<%6> = fmul ir<%38>, ir<%39>
    WIDEN-CALL ir<%40> = call @llvm.fmuladd.f64(ir<%38>, ir<%39>, ir<%x.0332>) (using vector intrinsic)
    CLONE ir<%incdec.ptr131> = getelementptr inbounds ir<%idx.3336>, ir<4>
    REPLICATE ir<%arrayidx133> = getelementptr inbounds ir<%vec2>, ir<%idxprom129>
    REPLICATE ir<%41> = load ir<%arrayidx133>
    CLONE ir<%incdec.ptr134> = getelementptr inbounds ir<%val.3334>, ir<8>
    EMIT vp<%7> = fmul ir<%41>, ir<%39>
    WIDEN-CALL ir<%42> = call @llvm.fmuladd.f64(ir<%41>, ir<%39>, ir<%x2.0333>) (using vector intrinsic)
    CLONE ir<%dec136> = add nsw ir<%j.3335>, ir<-1>
    CLONE ir<%cmp127> = icmp sgt ir<%dec136>, ir<%35>
    REDUCE ir<%42>.1 = ir<%x2.0333> + reduce.fadd (vp<%7>)
    REDUCE ir<%40>.1 = ir<%x.0332> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x2.0333>, ir<%42>.1
  EMIT vp<%11> = compute-reduction-result ir<%x.0332>, ir<%40>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end137.loopexit>, scalar.ph

ir-bb<for.end137.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa359 = vp<%11>
Live-out double %.lcssa = vp<%10>
}

========== Loop: _ZN6soplex9CLUFactor13vSolveLright2EPdPiS2_dS1_S2_S2_d' from vsolve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body128.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %35) + %36) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%idx.3336> = WIDEN-POINTER-INDUCTION ir<%arrayidx120>, 4
    WIDEN-INDUCTION %j.3335 = phi %dec136, %36, ir<-1>
    EMIT ir<%val.3334> = WIDEN-POINTER-INDUCTION ir<%arrayidx122>, 8
    WIDEN-REDUCTION-PHI ir<%x2.0333> = phi ir<0.000000e+00>, ir<%42>.1
    WIDEN-REDUCTION-PHI ir<%x.0332> = phi ir<0.000000e+00>, ir<%40>.1
    vp<%4> = vector-pointer ir<%idx.3336>
    WIDEN ir<%37> = load vp<%4>
    WIDEN-CAST ir<%idxprom129> = sext  ir<%37> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx130> = getelementptr inbounds ir<%vec>, ir<%idxprom129>
    REPLICATE ir<%38> = load ir<%arrayidx130>
    vp<%5> = vector-pointer ir<%val.3334>
    WIDEN ir<%39> = load vp<%5>
    EMIT vp<%6> = fmul ir<%38>, ir<%39>
    WIDEN-CALL ir<%40> = call @llvm.fmuladd.f64(ir<%38>, ir<%39>, ir<%x.0332>) (using vector intrinsic)
    CLONE ir<%incdec.ptr131> = getelementptr inbounds ir<%idx.3336>, ir<4>
    WIDEN-GEP Inv[Var] ir<%arrayidx133> = getelementptr inbounds ir<%vec2>, ir<%idxprom129>
    REPLICATE ir<%41> = load ir<%arrayidx133>
    CLONE ir<%incdec.ptr134> = getelementptr inbounds ir<%val.3334>, ir<8>
    EMIT vp<%7> = fmul ir<%41>, ir<%39>
    WIDEN-CALL ir<%42> = call @llvm.fmuladd.f64(ir<%41>, ir<%39>, ir<%x2.0333>) (using vector intrinsic)
    CLONE ir<%dec136> = add nsw ir<%j.3335>, ir<-1>
    CLONE ir<%cmp127> = icmp sgt ir<%dec136>, ir<%35>
    REDUCE ir<%42>.1 = ir<%x2.0333> + reduce.fadd (vp<%7>)
    REDUCE ir<%40>.1 = ir<%x.0332> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x2.0333>, ir<%42>.1
  EMIT vp<%11> = compute-reduction-result ir<%x.0332>, ir<%40>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end137.loopexit>, scalar.ph

ir-bb<for.end137.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa359 = vp<%11>
Live-out double %.lcssa = vp<%10>
}

========== Loop: _ZN6soplex9CLUFactor13vSolveLright2EPdPiS2_dS1_S2_S2_d' from vsolve.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body128.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %35) + %36) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%idx.3336> = WIDEN-POINTER-INDUCTION ir<%arrayidx120>, 4
    WIDEN-INDUCTION %j.3335 = phi %dec136, %36, ir<-1>
    EMIT ir<%val.3334> = WIDEN-POINTER-INDUCTION ir<%arrayidx122>, 8
    WIDEN-REDUCTION-PHI ir<%x2.0333> = phi ir<0.000000e+00>, ir<%42>.1
    WIDEN-REDUCTION-PHI ir<%x.0332> = phi ir<0.000000e+00>, ir<%40>.1
    vp<%4> = vector-pointer ir<%idx.3336>
    WIDEN ir<%37> = load vp<%4>
    WIDEN-CAST ir<%idxprom129> = sext  ir<%37> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx130> = getelementptr inbounds ir<%vec>, ir<%idxprom129>
    WIDEN ir<%38> = load ir<%arrayidx130>
    vp<%5> = vector-pointer ir<%val.3334>
    WIDEN ir<%39> = load vp<%5>
    EMIT vp<%6> = fmul ir<%38>, ir<%39>
    WIDEN-CALL ir<%40> = call @llvm.fmuladd.f64(ir<%38>, ir<%39>, ir<%x.0332>) (using vector intrinsic)
    CLONE ir<%incdec.ptr131> = getelementptr inbounds ir<%idx.3336>, ir<4>
    WIDEN-GEP Inv[Var] ir<%arrayidx133> = getelementptr inbounds ir<%vec2>, ir<%idxprom129>
    WIDEN ir<%41> = load ir<%arrayidx133>
    CLONE ir<%incdec.ptr134> = getelementptr inbounds ir<%val.3334>, ir<8>
    EMIT vp<%7> = fmul ir<%41>, ir<%39>
    WIDEN-CALL ir<%42> = call @llvm.fmuladd.f64(ir<%41>, ir<%39>, ir<%x2.0333>) (using vector intrinsic)
    CLONE ir<%dec136> = add nsw ir<%j.3335>, ir<-1>
    CLONE ir<%cmp127> = icmp sgt ir<%dec136>, ir<%35>
    REDUCE ir<%42>.1 = ir<%x2.0333> + reduce.fadd (vp<%7>)
    REDUCE ir<%40>.1 = ir<%x.0332> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%x2.0333>, ir<%42>.1
  EMIT vp<%11> = compute-reduction-result ir<%x.0332>, ir<%40>.1
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end137.loopexit>, scalar.ph

ir-bb<for.end137.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa359 = vp<%11>
Live-out double %.lcssa = vp<%10>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor13vSolveLright2EPdPiS2_dS1_S2_S2_d' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx.3336 = phi ptr [ %incdec.ptr131, %for.body128 ], [ %arrayidx120, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.3335 = phi i32 [ %dec136, %for.body128 ], [ %36, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %val.3334 = phi ptr [ %incdec.ptr134, %for.body128 ], [ %arrayidx122, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x2.0333 = phi double [ %42, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.0332 = phi double [ %40, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 1 For instruction:   %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom129 = sext i32 %37 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx130 = getelementptr inbounds double, ptr %vec, i64 %idxprom129 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %38 = load double, ptr %arrayidx130, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %39 = load double, ptr %val.3334, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %40 = tail call double @llvm.fmuladd.f64(double %38, double %39, double %x.0332) of type:call
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %idx.3336, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx133 = getelementptr inbounds double, ptr %vec2, i64 %idxprom129 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %41 = load double, ptr %arrayidx133, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr134 = getelementptr inbounds i8, ptr %val.3334, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %42 = tail call double @llvm.fmuladd.f64(double %41, double %39, double %x2.0333) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec136 = add nsw i32 %j.3335, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp127 = icmp sgt i32 %dec136, %35 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp127, label %for.body128, label %for.end137.loopexit of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor13vSolveLright2EPdPiS2_dS1_S2_S2_d' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx.3336 = phi ptr [ %incdec.ptr131, %for.body128 ], [ %arrayidx120, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.3335 = phi i32 [ %dec136, %for.body128 ], [ %36, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %val.3334 = phi ptr [ %incdec.ptr134, %for.body128 ], [ %arrayidx122, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x2.0333 = phi double [ %42, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.0332 = phi double [ %40, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom129 = sext i32 %37 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx130 = getelementptr inbounds double, ptr %vec, i64 %idxprom129 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %38 = load double, ptr %arrayidx130, align 8, !tbaa !27 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %39 = load double, ptr %val.3334, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %40 = tail call double @llvm.fmuladd.f64(double %38, double %39, double %x.0332) of type:call
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %idx.3336, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx133 = getelementptr inbounds double, ptr %vec2, i64 %idxprom129 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %41 = load double, ptr %arrayidx133, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr134 = getelementptr inbounds i8, ptr %val.3334, i64 8 of type:getelementptr
LV: Found an estimated cost of 8 for VF 2 For instruction:   %42 = tail call double @llvm.fmuladd.f64(double %41, double %39, double %x2.0333) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec136 = add nsw i32 %j.3335, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp127 = icmp sgt i32 %dec136, %35 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp127, label %for.body128, label %for.end137.loopexit of type:br
LV: Vector loop of width 2 costs: 38
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 76
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 76, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 76
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 76, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZN6soplex9CLUFactor13vSolveLright2EPdPiS2_dS1_S2_S2_d' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idx.3336 = phi ptr [ %incdec.ptr131, %for.body128 ], [ %arrayidx120, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.3335 = phi i32 [ %dec136, %for.body128 ], [ %36, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %val.3334 = phi ptr [ %incdec.ptr134, %for.body128 ], [ %arrayidx122, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x2.0333 = phi double [ %42, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x.0332 = phi double [ %40, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom129 = sext i32 %37 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx130 = getelementptr inbounds double, ptr %vec, i64 %idxprom129 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %38 = load double, ptr %arrayidx130, align 8, !tbaa !27 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %39 = load double, ptr %val.3334, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %40 = tail call double @llvm.fmuladd.f64(double %38, double %39, double %x.0332) of type:call
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %idx.3336, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx133 = getelementptr inbounds double, ptr %vec2, i64 %idxprom129 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %41 = load double, ptr %arrayidx133, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr134 = getelementptr inbounds i8, ptr %val.3334, i64 8 of type:getelementptr
LV: Found an estimated cost of 16 for VF 4 For instruction:   %42 = tail call double @llvm.fmuladd.f64(double %41, double %39, double %x2.0333) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec136 = add nsw i32 %j.3335, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp127 = icmp sgt i32 %dec136, %35 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp127, label %for.body128, label %for.end137.loopexit of type:br
LV: Vector loop of width 4 costs: 37
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 151
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 151, CostB * EstimatedWidthA: 48
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 151
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 151, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'_ZN6soplex9CLUFactor13vSolveLright2EPdPiS2_dS1_S2_S2_d' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx.3336 = phi ptr [ %incdec.ptr131, %for.body128 ], [ %arrayidx120, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.3335 = phi i32 [ %dec136, %for.body128 ], [ %36, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %val.3334 = phi ptr [ %incdec.ptr134, %for.body128 ], [ %arrayidx122, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x2.0333 = phi double [ %42, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.0332 = phi double [ %40, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom129 = sext i32 %37 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx130 = getelementptr inbounds double, ptr %vec, i64 %idxprom129 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %38 = load double, ptr %arrayidx130, align 8, !tbaa !27 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %39 = load double, ptr %val.3334, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %40 = tail call double @llvm.fmuladd.f64(double %38, double %39, double %x.0332) of type:call
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %idx.3336, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx133 = getelementptr inbounds double, ptr %vec2, i64 %idxprom129 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %41 = load double, ptr %arrayidx133, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr134 = getelementptr inbounds i8, ptr %val.3334, i64 8 of type:getelementptr
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %42 = tail call double @llvm.fmuladd.f64(double %41, double %39, double %x2.0333) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec136 = add nsw i32 %j.3335, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp127 = icmp sgt i32 %dec136, %35 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp127, label %for.body128, label %for.end137.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'_ZN6soplex9CLUFactor13vSolveLright2EPdPiS2_dS1_S2_S2_d' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx.3336 = phi ptr [ %incdec.ptr131, %for.body128 ], [ %arrayidx120, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.3335 = phi i32 [ %dec136, %for.body128 ], [ %36, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %val.3334 = phi ptr [ %incdec.ptr134, %for.body128 ], [ %arrayidx122, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x2.0333 = phi double [ %42, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.0332 = phi double [ %40, %for.body128 ], [ 0.000000e+00, %for.body128.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %37 = load i32, ptr %idx.3336, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom129 = sext i32 %37 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx130 = getelementptr inbounds double, ptr %vec, i64 %idxprom129 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %38 = load double, ptr %arrayidx130, align 8, !tbaa !27 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %39 = load double, ptr %val.3334, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %40 = tail call double @llvm.fmuladd.f64(double %38, double %39, double %x.0332) of type:call
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr131 = getelementptr inbounds i8, ptr %idx.3336, i64 4 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx133 = getelementptr inbounds double, ptr %vec2, i64 %idxprom129 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %41 = load double, ptr %arrayidx133, align 8, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr134 = getelementptr inbounds i8, ptr %val.3334, i64 8 of type:getelementptr
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %42 = tail call double @llvm.fmuladd.f64(double %41, double %39, double %x2.0333) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec136 = add nsw i32 %j.3335, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp127 = icmp sgt i32 %dec136, %35 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp127, label %for.body128, label %for.end137.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 24
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 98
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 98, CostB * EstimatedWidthA: 48
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 98
B VF: 1, EstimatedWidthB: 1, CostB: 12
CostA * EstimatedWidthB: 98, CostB * EstimatedWidthA: 48
LV: Selecting VF: 1 With Cost: 12.
maxbefore: 2
maxafter: 2
@@ Instruction =>  %21 = load i32, ptr %last.2109, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i32, ptr %last.2109, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i32, ptr %last.2109, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %21 = load i32, ptr %last.2109, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i32, ptr %last.2109, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor10solveLleftEdPdPii' from vsolve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body59.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%nonz.addr.0110> = WIDEN-POINTER-INDUCTION ir<%nonz>, 4
    EMIT ir<%last.2109> = WIDEN-POINTER-INDUCTION ir<%last.1.lcssa>, 4
    WIDEN-INDUCTION %storemerge108 = phi %inc62, 0, ir<1>
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%last.2109>, ir<4>
    CLONE ir<%21> = load ir<%last.2109>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%nonz.addr.0110>, ir<4>
    CLONE store ir<%21>, ir<%nonz.addr.0110>
    CLONE ir<%inc62> = add nuw nsw ir<%storemerge108>, ir<1>
    CLONE store ir<%inc62>, ir<%i>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc62>, ir<%n.1.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end63.loopexit>, scalar.ph

ir-bb<for.end63.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor10solveLleftEdPdPii' from vsolve.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body59.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%nonz.addr.0110> = WIDEN-POINTER-INDUCTION ir<%nonz>, 4
    EMIT ir<%last.2109> = WIDEN-POINTER-INDUCTION ir<%last.1.lcssa>, 4
    WIDEN-INDUCTION %storemerge108 = phi %inc62, 0, ir<1>
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%last.2109>, ir<4>
    vp<%4> = vector-pointer ir<%last.2109>
    WIDEN ir<%21> = load vp<%4>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%nonz.addr.0110>, ir<4>
    vp<%5> = vector-pointer ir<%nonz.addr.0110>
    WIDEN store vp<%5>, ir<%21>
    WIDEN ir<%inc62> = add nuw nsw ir<%storemerge108>, ir<1>
    REPLICATE store ir<%inc62>, ir<%i>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc62>, ir<%n.1.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end63.loopexit>, scalar.ph

ir-bb<for.end63.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: _ZN6soplex9CLUFactor10solveLleftEdPdPii' from vsolve.cc==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body59.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    EMIT ir<%nonz.addr.0110> = WIDEN-POINTER-INDUCTION ir<%nonz>, 4
    EMIT ir<%last.2109> = WIDEN-POINTER-INDUCTION ir<%last.1.lcssa>, 4
    WIDEN-INDUCTION %storemerge108 = phi %inc62, 0, ir<1>
    CLONE ir<%incdec.ptr60> = getelementptr inbounds ir<%last.2109>, ir<4>
    vp<%4> = vector-pointer ir<%last.2109>
    WIDEN ir<%21> = load vp<%4>
    CLONE ir<%incdec.ptr61> = getelementptr inbounds ir<%nonz.addr.0110>, ir<4>
    vp<%5> = vector-pointer ir<%nonz.addr.0110>
    WIDEN store vp<%5>, ir<%21>
    WIDEN ir<%inc62> = add nuw nsw ir<%storemerge108>, ir<1>
    REPLICATE store ir<%inc62>, ir<%i>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc62>, ir<%n.1.lcssa>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end63.loopexit>, scalar.ph

ir-bb<for.end63.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor10solveLleftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nonz.addr.0110 = phi ptr [ %incdec.ptr61, %for.body59 ], [ %nonz, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %last.2109 = phi ptr [ %incdec.ptr60, %for.body59 ], [ %last.1.lcssa, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %storemerge108 = phi i32 [ %inc62, %for.body59 ], [ 0, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %last.2109, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %21 = load i32, ptr %last.2109, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %nonz.addr.0110, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc62 = add nuw nsw i32 %storemerge108, 1 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %inc62, ptr %i, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc62, %n.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end63.loopexit, label %for.body59 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor10solveLleftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %nonz.addr.0110 = phi ptr [ %incdec.ptr61, %for.body59 ], [ %nonz, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %last.2109 = phi ptr [ %incdec.ptr60, %for.body59 ], [ %last.1.lcssa, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %storemerge108 = phi i32 [ %inc62, %for.body59 ], [ 0, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %last.2109, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %21 = load i32, ptr %last.2109, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %nonz.addr.0110, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc62 = add nuw nsw i32 %storemerge108, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i32 %inc62, ptr %i, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc62, %n.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end63.loopexit, label %for.body59 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934592, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'_ZN6soplex9CLUFactor10solveLleftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %nonz.addr.0110 = phi ptr [ %incdec.ptr61, %for.body59 ], [ %nonz, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %last.2109 = phi ptr [ %incdec.ptr60, %for.body59 ], [ %last.1.lcssa, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %storemerge108 = phi i32 [ %inc62, %for.body59 ], [ 0, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %last.2109, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %21 = load i32, ptr %last.2109, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %nonz.addr.0110, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc62 = add nuw nsw i32 %storemerge108, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %inc62, ptr %i, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i32 %inc62, %n.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end63.loopexit, label %for.body59 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967312, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967312, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'_ZN6soplex9CLUFactor10solveLleftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %nonz.addr.0110 = phi ptr [ %incdec.ptr61, %for.body59 ], [ %nonz, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %last.2109 = phi ptr [ %incdec.ptr60, %for.body59 ], [ %last.1.lcssa, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %storemerge108 = phi i32 [ %inc62, %for.body59 ], [ 0, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %last.2109, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %21 = load i32, ptr %last.2109, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %nonz.addr.0110, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc62 = add nuw nsw i32 %storemerge108, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %inc62, ptr %i, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc62, %n.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end63.loopexit, label %for.body59 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 4294967312

-----------------Function that is being costed:'_ZN6soplex9CLUFactor10solveLleftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %nonz.addr.0110 = phi ptr [ %incdec.ptr61, %for.body59 ], [ %nonz, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %last.2109 = phi ptr [ %incdec.ptr60, %for.body59 ], [ %last.1.lcssa, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %storemerge108 = phi i32 [ %inc62, %for.body59 ], [ 0, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %last.2109, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %21 = load i32, ptr %last.2109, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %nonz.addr.0110, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc62 = add nuw nsw i32 %storemerge108, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %inc62, ptr %i, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc62, %n.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end63.loopexit, label %for.body59 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967312, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967312, RTCostB: 4294967312
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'_ZN6soplex9CLUFactor10solveLleftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %nonz.addr.0110 = phi ptr [ %incdec.ptr61, %for.body59 ], [ %nonz, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %last.2109 = phi ptr [ %incdec.ptr60, %for.body59 ], [ %last.1.lcssa, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %storemerge108 = phi i32 [ %inc62, %for.body59 ], [ 0, %for.body59.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr60 = getelementptr inbounds i8, ptr %last.2109, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %21 = load i32, ptr %last.2109, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr61 = getelementptr inbounds i8, ptr %nonz.addr.0110, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %21, ptr %nonz.addr.0110, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc62 = add nuw nsw i32 %storemerge108, 1 of type:add
LV: Decision: Scalarize
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   store i32 %inc62, ptr %i, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i32 %inc62, %n.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end63.loopexit, label %for.body59 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483696, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2147483696, RTCostB: 4294967312
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: _ZN6soplex9CLUFactor10solveLleftEdPdPii at line: vsolve.cc
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body59.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n.1 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %storemerge108 = phi %inc62, 0, ir<1>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<4>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<4>
    EMIT vp<%6> = ptradd ir<%nonz>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<4>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<4>
    EMIT vp<%9> = ptradd ir<%last.1.lcssa>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%24> = load vp<%10>
    vp<%11> = vector-pointer vp<%6>
    WIDEN store vp<%11>, ir<%24>
    WIDEN ir<%inc62> = add nuw nsw ir<%storemerge108>, ir<1>
    REPLICATE store ir<%inc62>, ir<%i>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.end63.loopexit>, scalar.ph

ir-bb<for.end63.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 37
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %10 = load i32, ptr %idx.067, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.065, align 8, !tbaa !28 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i32, ptr %idx.067, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.065, align 8, !tbaa !28 -> Cost: 1 -> VectorType: <2 x double> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i32, ptr %idx.067, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.065, align 8, !tbaa !28 -> Cost: 2 -> VectorType: <4 x double> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i32, ptr %idx.067, align 4, !tbaa !27 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %12 = load double, ptr %val.065, align 8, !tbaa !28 -> Cost: Invalid -> VectorType: <vscale x 1 x double> -> ttilog -> 
@@ Instruction =>  %10 = load i32, ptr %idx.067, align 4, !tbaa !27 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %12 = load double, ptr %val.065, align 8, !tbaa !28 -> Cost: 1 -> VectorType: <vscale x 2 x double> -> ttilog -> MemoryOpCost(1)
========== Loop: _ZN6soplex9CLUFactor15solveUpdateLeftEdPdPii' from vsolve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %8) + %9) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    EMIT ir<%idx.067> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.066 = phi %dec, %9, ir<-1>
    EMIT ir<%val.065> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    WIDEN-REDUCTION-PHI ir<%x.064> = phi ir<0.000000e+00>, ir<%13>.1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.067>, ir<4>
    CLONE ir<%10> = load ir<%idx.067>
    CLONE ir<%idxprom18> = sext ir<%10>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%vec>, ir<%idxprom18>
    CLONE ir<%11> = load ir<%arrayidx19>
    CLONE ir<%incdec.ptr20> = getelementptr inbounds ir<%val.065>, ir<8>
    CLONE ir<%12> = load ir<%val.065>
    EMIT vp<%4> = fmul ir<%11>, ir<%12>
    CLONE ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x.064>)
    CLONE ir<%dec> = add nsw ir<%j.066>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%8>
    REDUCE ir<%13>.1 = ir<%x.064> + reduce.fadd (vp<%4>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%x.064>, ir<%13>.1
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%7>
}

========== Loop: _ZN6soplex9CLUFactor15solveUpdateLeftEdPdPii' from vsolve.cc==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %8) + %9) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.067> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.066 = phi %dec, %9, ir<-1>
    EMIT ir<%val.065> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    WIDEN-REDUCTION-PHI ir<%x.064> = phi ir<0.000000e+00>, ir<%13>.1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.067>, ir<4>
    vp<%4> = vector-pointer ir<%idx.067>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%idxprom18> = sext  ir<%10> to i64
    REPLICATE ir<%arrayidx19> = getelementptr inbounds ir<%vec>, ir<%idxprom18>
    REPLICATE ir<%11> = load ir<%arrayidx19>
    CLONE ir<%incdec.ptr20> = getelementptr inbounds ir<%val.065>, ir<8>
    vp<%5> = vector-pointer ir<%val.065>
    WIDEN ir<%12> = load vp<%5>
    EMIT vp<%6> = fmul ir<%11>, ir<%12>
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x.064>) (using vector intrinsic)
    CLONE ir<%dec> = add nsw ir<%j.066>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%8>
    REDUCE ir<%13>.1 = ir<%x.064> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.064>, ir<%13>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor15solveUpdateLeftEdPdPii' from vsolve.cc==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %8) + %9) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.067> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.066 = phi %dec, %9, ir<-1>
    EMIT ir<%val.065> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    WIDEN-REDUCTION-PHI ir<%x.064> = phi ir<0.000000e+00>, ir<%13>.1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.067>, ir<4>
    vp<%4> = vector-pointer ir<%idx.067>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%idxprom18> = sext  ir<%10> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%vec>, ir<%idxprom18>
    REPLICATE ir<%11> = load ir<%arrayidx19>
    CLONE ir<%incdec.ptr20> = getelementptr inbounds ir<%val.065>, ir<8>
    vp<%5> = vector-pointer ir<%val.065>
    WIDEN ir<%12> = load vp<%5>
    EMIT vp<%6> = fmul ir<%11>, ir<%12>
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x.064>) (using vector intrinsic)
    CLONE ir<%dec> = add nsw ir<%j.066>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%8>
    REDUCE ir<%13>.1 = ir<%x.064> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.064>, ir<%13>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}

========== Loop: _ZN6soplex9CLUFactor15solveUpdateLeftEdPdPii' from vsolve.cc==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %8) + %9) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%idx.067> = WIDEN-POINTER-INDUCTION ir<%arrayidx12>, 4
    WIDEN-INDUCTION %j.066 = phi %dec, %9, ir<-1>
    EMIT ir<%val.065> = WIDEN-POINTER-INDUCTION ir<%arrayidx10>, 8
    WIDEN-REDUCTION-PHI ir<%x.064> = phi ir<0.000000e+00>, ir<%13>.1
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%idx.067>, ir<4>
    vp<%4> = vector-pointer ir<%idx.067>
    WIDEN ir<%10> = load vp<%4>
    WIDEN-CAST ir<%idxprom18> = sext  ir<%10> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%vec>, ir<%idxprom18>
    WIDEN ir<%11> = load ir<%arrayidx19>
    CLONE ir<%incdec.ptr20> = getelementptr inbounds ir<%val.065>, ir<8>
    vp<%5> = vector-pointer ir<%val.065>
    WIDEN ir<%12> = load vp<%5>
    EMIT vp<%6> = fmul ir<%11>, ir<%12>
    WIDEN-CALL ir<%13> = call @llvm.fmuladd.f64(ir<%11>, ir<%12>, ir<%x.064>) (using vector intrinsic)
    CLONE ir<%dec> = add nsw ir<%j.066>, ir<-1>
    CLONE ir<%cmp16> = icmp sgt ir<%dec>, ir<%8>
    REDUCE ir<%13>.1 = ir<%x.064> + reduce.fadd (vp<%6>)
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%x.064>, ir<%13>.1
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out double %.lcssa = vp<%9>
}


-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idx.067 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.066 = phi i32 [ %dec, %for.body17 ], [ %9, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %val.065 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %x.064 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.067, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i32, ptr %idx.067, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.065, i64 8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %12 = load double, ptr %val.065, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.064) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %j.066, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp16 = icmp sgt i32 %dec, %8 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idx.067 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.066 = phi i32 [ %dec, %for.body17 ], [ %9, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %val.065 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %x.064 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.067, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i32, ptr %idx.067, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 28 for VF 2 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.065, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %12 = load double, ptr %val.065, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 8 for VF 2 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.064) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %j.066, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp16 = icmp sgt i32 %dec, %8 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 20
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 40
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 18
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 40
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idx.067 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.066 = phi i32 [ %dec, %for.body17 ], [ %9, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %val.065 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %x.064 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.067, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %10 = load i32, ptr %idx.067, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 56 for VF 4 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.065, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %12 = load double, ptr %val.065, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 16 for VF 4 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.064) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %j.066, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp16 = icmp sgt i32 %dec, %8 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 19
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 79
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 79, CostB * EstimatedWidthA: 36
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 79
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 79, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idx.067 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.066 = phi i32 [ %dec, %for.body17 ], [ %9, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %val.065 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %x.064 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.067, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i32, ptr %idx.067, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.065, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %12 = load double, ptr %val.065, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.064) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %j.066, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp16 = icmp sgt i32 %dec, %8 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'_ZN6soplex9CLUFactor15solveUpdateLeftEdPdPii' from vsolve.cc-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idx.067 = phi ptr [ %incdec.ptr, %for.body17 ], [ %arrayidx12, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.066 = phi i32 [ %dec, %for.body17 ], [ %9, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %val.065 = phi ptr [ %incdec.ptr20, %for.body17 ], [ %arrayidx10, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %x.064 = phi double [ %13, %for.body17 ], [ 0.000000e+00, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %idx.067, i64 4 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = load i32, ptr %idx.067, align 4, !tbaa !27 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom18 = sext i32 %10 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds double, ptr %vec, i64 %idxprom18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %11 = load double, ptr %arrayidx19, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr20 = getelementptr inbounds i8, ptr %val.065, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %12 = load double, ptr %val.065, align 8, !tbaa !28 of type:load
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %13 = tail call double @llvm.fmuladd.f64(double %11, double %12, double %x.064) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %j.066, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp16 = icmp sgt i32 %dec, %8 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp16, label %for.body17, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 12
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 51
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 51, CostB * EstimatedWidthA: 36
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 51
B VF: 1, EstimatedWidthB: 1, CostB: 9
CostA * EstimatedWidthB: 51, CostB * EstimatedWidthA: 36
LV: Selecting VF: 1 With Cost: 9.
maxbefore: 2
maxafter: 2
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang++ -std=c++98 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration     -march=armv8-a+sve -O3   -fno-slp-vectorize -fno-inline-functions -include cstddef -include cstdlib -include cstring           changesoplex.o didxset.o dsvector.o dvector.o enter.o example.o factor.o forest.o idxset.o leave.o lpcolset.o lprow.o lprowset.o message.o mpsinput.o nameset.o slufactor.o solve.o soplex.o spxaggregatesm.o spxbasis.o spxbounds.o spxchangebasis.o spxdefaultpr.o spxdefaultrt.o spxdefines.o spxdesc.o spxdevexpr.o spxequilisc.o spxfastrt.o spxgeneralsm.o spxharrisrt.o spxhybridpr.o spxid.o spxio.o spxlp.o spxlpfread.o spxmpsread.o spxmpswrite.o spxparmultpr.o spxquality.o spxredundantsm.o spxrem1sm.o spxscaler.o spxshift.o spxsolve.o spxsolver.o spxstarter.o spxsteeppr.o spxsumst.o spxvecs.o spxvectorst.o spxweightpr.o spxweightst.o ssvector.o svector.o svset.o timer.o unitvector.o update.o updatevector.o vector.o vsolve.o                     -o soplex
