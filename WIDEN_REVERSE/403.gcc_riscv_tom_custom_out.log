/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o alloca.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         alloca.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o asprintf.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         asprintf.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o vasprintf.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         vasprintf.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-parse.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-parse.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-lang.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-lang.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o attribs.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         attribs.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-errors.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-errors.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-lex.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-lex.c
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 3 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(3)
========== Loop: lex_string' from c-lex.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader167>:
  EMIT vp<%2> = EXPAND SCEV (-4 + (zext i6 (trunc i32 (%bf.load30114 /u 8) to i6) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 4, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%q.0120>, ir<%indvars.iv>
    CLONE store ir<0>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp33> = icmp ult ir<%indvars.iv.next>, ir<%14>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: lex_string' from c-lex.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader167>:
  EMIT vp<%2> = EXPAND SCEV (-4 + (zext i6 (trunc i32 (%bf.load30114 /u 8) to i6) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 4, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%q.0120>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp33> = icmp ult ir<%indvars.iv.next>, ir<%14>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: lex_string' from c-lex.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader167>:
  EMIT vp<%2> = EXPAND SCEV (-4 + (zext i6 (trunc i32 (%bf.load30114 /u 8) to i6) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 4, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%q.0120>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp33> = icmp ult ir<%indvars.iv.next>, ir<%14>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 119, RTCostB: 177
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 119, RTCostB: 177
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 65, RTCostB: 177
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 65, RTCostB: 119
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 37, RTCostB: 177
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 37, RTCostB: 65
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 16 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 45, RTCostB: 177
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 45, RTCostB: 37

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 32 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 86, RTCostB: 177
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 86, RTCostB: 37

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 119, RTCostB: 177
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 119, RTCostB: 37

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 65, RTCostB: 177
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 65, RTCostB: 37

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 37, RTCostB: 177
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 37, RTCostB: 37
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 45, RTCostB: 177
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 45, RTCostB: 37

-----------------Function that is being costed:'lex_string' from c-lex.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 4, %for.body.preheader167 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %q.0120, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 0, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp33 = icmp ult i64 %indvars.iv.next, %14 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp33, label %for.body, label %for.end.loopexit, !llvm.loop !9 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 86, RTCostB: 177
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 86, RTCostB: 37
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: lex_string at line: c-lex.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader167>:
  EMIT vp<%2> = EXPAND SCEV (-4 + (zext i6 (trunc i32 (%bf.load30114 /u 8) to i6) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<4> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%q.0120>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<0>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-pragma.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-pragma.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-decl.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-decl.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-typeck.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-typeck.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-convert.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-convert.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-aux-info.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-aux-info.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-common.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-common.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-format.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-format.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-semantics.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-semantics.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o c-objc-common.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         c-objc-common.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o main.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         main.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cpplib.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cpplib.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cpplex.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cpplex.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cppmacro.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cppmacro.c
@@ Instruction =>  %6 = load ptr, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: cpp_macro_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%len.0276> = phi ir<%add9>, ir<%add16>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    CLONE ir<%6> = load ir<%arrayidx>
    CLONE ir<%7> = load ir<%6>
    CLONE ir<%add15> = add ir<%len.0276>, ir<1>
    CLONE ir<%add16> = add ir<%add15>, ir<%7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%len.0276>, ir<%add16>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add16.lcssa = vp<%6>
}

========== Loop: cpp_macro_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%len.0276> = phi ir<%add9>, ir<%add16>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%6> = load vp<%4>
    WIDEN ir<%7> = load ir<%6>
    WIDEN ir<%add15> = add ir<%len.0276>, ir<1>
    WIDEN ir<%add16> = add ir<%add15>, ir<%7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%len.0276>, ir<%add16>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add16.lcssa = vp<%7>
}

========== Loop: cpp_macro_definition' from cppmacro.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%len.0276> = phi ir<%add9>, ir<%add16>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%6> = load vp<%4>
    WIDEN ir<%7> = load ir<%6>
    WIDEN ir<%add15> = add ir<%len.0276>, ir<1>
    WIDEN ir<%add16> = add ir<%add15>, ir<%7>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%len.0276>, ir<%add16>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add16.lcssa = vp<%7>
}


-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %6 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %7 = load i32, ptr %6, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %6 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %7 = load i32, ptr %6, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 229375, RTCostB: 393210
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 229375, RTCostB: 393210
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %6 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %7 = load i32, ptr %6, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 163848, RTCostB: 393210
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 163848, RTCostB: 229375
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %6 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %7 = load i32, ptr %6, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 229375, RTCostB: 393210
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 229375, RTCostB: 163848

-----------------Function that is being costed:'cpp_macro_definition' from cppmacro.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %len.0276 = phi i32 [ %add9, %for.body.lr.ph ], [ %add16, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %6 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %7 = load i32, ptr %6, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add15 = add i32 %len.0276, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add16 = add i32 %add15, %7 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end17.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 163848, RTCostB: 393210
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 163848, RTCostB: 163848
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: cpp_macro_definition at line: cppmacro.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %4 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%len.0276> = phi ir<%add9>, ir<%add16>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%5>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%6> = load vp<%5>
    WIDEN ir<%7> = load ir<%6>
    WIDEN ir<%add15> = add ir<%len.0276>, ir<1>
    WIDEN ir<%add16> = add ir<%add15>, ir<%7>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%len.0276>, ir<%add16>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end17.loopexit>, scalar.ph

ir-bb<if.end17.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add16.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 14
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cppexp.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cppexp.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cppfiles.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cppfiles.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cpphash.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cpphash.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cpperror.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cpperror.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cppinit.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cppinit.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cppdefault.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cppdefault.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o line-map.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         line-map.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o mkdeps.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         mkdeps.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o prefix.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         prefix.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o version.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         version.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o mbchar.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         mbchar.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o alias.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         alias.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o bb-reorder.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         bb-reorder.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o bitmap.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         bitmap.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o builtins.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         builtins.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o caller-save.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         caller-save.c
@@ Instruction =>  store i32 0, ptr %arrayidx23, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx23, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx23, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i32 0, ptr %arrayidx23, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx23, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx23, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<for.body8.peel.next>:
  EMIT vp<%3> = EXPAND SCEV (-1 + (2 umax %div.peel))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi 2, %indvars.iv.next, ir<1>
    EMIT vp<%5> = WIDEN-CANONICAL-INDUCTION vp<%4>
    EMIT vp<%6> = active lane mask vp<%5>, vp<%3>
    EMIT vp<%7> = icmp ule vp<%5>, vp<%2>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvar>, ir<%indvars.iv>
    CLONE store ir<0>, ir<%arrayidx23>, vp<%6>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp6.not.not> = icmp ult ir<%indvars.iv>, ir<%div.peel>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add vp<%4>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.inc40.loopexit384>, scalar.ph

ir-bb<for.inc40.loopexit384>:
No successors

scalar.ph:
No successors
}

========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<for.body8.peel.next>:
  EMIT vp<%3> = EXPAND SCEV (-1 + (2 umax %div.peel))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 2, %indvars.iv.next, ir<1>
    EMIT vp<%5> = WIDEN-CANONICAL-INDUCTION vp<%4>
    EMIT vp<%6> = active lane mask vp<%5>, vp<%3>
    EMIT vp<%7> = icmp ule vp<%5>, vp<%2>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvar>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%8>, ir<0>, vp<%6>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp6.not.not> = icmp ult ir<%indvars.iv>, ir<%div.peel>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add vp<%4>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.inc40.loopexit384>, scalar.ph

ir-bb<for.inc40.loopexit384>:
No successors

scalar.ph:
No successors
}

========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<for.body8.peel.next>:
  EMIT vp<%3> = EXPAND SCEV (-1 + (2 umax %div.peel))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 2, %indvars.iv.next, ir<1>
    EMIT vp<%5> = WIDEN-CANONICAL-INDUCTION vp<%4>
    EMIT vp<%6> = active lane mask vp<%5>, vp<%3>
    EMIT vp<%7> = icmp ule vp<%5>, vp<%2>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvar>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%8>, ir<0>, vp<%6>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp6.not.not> = icmp ult ir<%indvars.iv>, ir<%div.peel>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add vp<%4>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.inc40.loopexit384>, scalar.ph

ir-bb<for.inc40.loopexit384>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 2, %for.body8.peel.next ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvar, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 0, ptr %arrayidx23, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp6.not.not = icmp ult i64 %indvars.iv, %div.peel of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp6.not.not, label %for.inc, label %for.inc40.loopexit384, !llvm.loop !9 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 2, %for.body8.peel.next ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvar, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 0, ptr %arrayidx23, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp6.not.not = icmp ult i64 %indvars.iv, %div.peel of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp6.not.not, label %for.inc, label %for.inc40.loopexit384, !llvm.loop !9 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 9, RTCostB: 15
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9, RTCostB: 15
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 2, %for.body8.peel.next ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx23 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvar, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 0, ptr %arrayidx23, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp6.not.not = icmp ult i64 %indvars.iv, %div.peel of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp6.not.not, label %for.inc, label %for.inc40.loopexit384, !llvm.loop !9 of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 6, RTCostB: 15
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6, RTCostB: 9
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 2, %for.body8.peel.next ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx23 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvar, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 0, ptr %arrayidx23, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp6.not.not = icmp ult i64 %indvars.iv, %div.peel of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp6.not.not, label %for.inc, label %for.inc40.loopexit384, !llvm.loop !9 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 4, RTCostB: 15
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4, RTCostB: 6
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 2, %for.body8.peel.next ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvar, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx23, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp6.not.not = icmp ult i64 %indvars.iv, %div.peel of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp6.not.not, label %for.inc, label %for.inc40.loopexit384, !llvm.loop !9 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 9, RTCostB: 15
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 9, RTCostB: 4

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 2, %for.body8.peel.next ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvar, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx23, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp6.not.not = icmp ult i64 %indvars.iv, %div.peel of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp6.not.not, label %for.inc, label %for.inc40.loopexit384, !llvm.loop !9 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 6, RTCostB: 15
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6, RTCostB: 4

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 2, %for.body8.peel.next ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx23 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvar, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx23, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp6.not.not = icmp ult i64 %indvars.iv, %div.peel of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp6.not.not, label %for.inc, label %for.inc40.loopexit384, !llvm.loop !9 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 4, RTCostB: 15
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4, RTCostB: 4
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
LEV: Unable to vectorize epilogue because no epilogue is allowed.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: init_caller_save at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 4},UF={1}' {
Live-in vp<%0> = VF * UF
vp<%3> = original trip-count

ir-bb<for.body8.peel.next>:
  EMIT vp<%3> = EXPAND SCEV (-1 + (2 umax %div.peel))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%5>    = DERIVED-IV ir<2> + vp<%4> * ir<1>
    vp<%6> = SCALAR-STEPS vp<%5>, ir<1>
    EMIT vp<%7> = WIDEN-CANONICAL-INDUCTION vp<%4>
    EMIT vp<%8> = active lane mask vp<%7>, vp<%3>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvar>, vp<%6>
    vp<%9> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%9>, ir<0>, vp<%8>
    EMIT vp<%10> = add vp<%4>, vp<%0>
    EMIT branch-on-cond ir<true>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.inc40.loopexit384>, scalar.ph

ir-bb<for.inc40.loopexit384>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %36 = load i32, ptr %arrayidx211, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %36 = load i32, ptr %arrayidx211, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %36 = load i32, ptr %arrayidx211, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  %36 = load i32, ptr %arrayidx211, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %36 = load i32, ptr %arrayidx211, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %36 = load i32, ptr %arrayidx211, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 0, ptr %arrayidx211, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body205.peel.next>:
  EMIT vp<%2> = EXPAND SCEV (-2 + %wide.trip.count374)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv371 = phi 2, %indvars.iv.next372, ir<1>
    CLONE ir<%arrayidx211> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv377>, ir<%indvars.iv371>
    CLONE ir<%36> = load ir<%arrayidx211>
    CLONE ir<%idxprom212> = zext ir<%36>
    CLONE ir<%arrayidx213> = getelementptr inbounds ir<@reg_save_code>, ir<0>, ir<%indvars.iv377>, ir<%idxprom212>
    CLONE ir<%37> = load ir<%arrayidx213>
    CLONE ir<%cmp214> = icmp eq ir<%37>, ir<-1>
  Successor(s): if.then216

  if.then216:
    CLONE store ir<0>, ir<%arrayidx211>, ir<%cmp214>
  Successor(s): for.inc231

  for.inc231:
    EMIT vp<%4> = not ir<%cmp214>
    EMIT vp<%5> = or ir<%cmp214>, vp<%4>
    CLONE ir<%indvars.iv.next372> = add nuw nsw ir<%indvars.iv371>, ir<1>
    CLONE ir<%exitcond375.not> = icmp eq ir<%indvars.iv.next372>, ir<%wide.trip.count374>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc234>, scalar.ph

ir-bb<for.inc234>:
No successors

scalar.ph:
No successors
}

========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body205.peel.next>:
  EMIT vp<%2> = EXPAND SCEV (-2 + %wide.trip.count374)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv371 = phi 2, %indvars.iv.next372, ir<1>
    CLONE ir<%arrayidx211> = getelementptr ir<@regno_save_mode>, ir<0>, ir<%indvars.iv377>, ir<%indvars.iv371>
    vp<%4> = vector-pointer ir<%arrayidx211>
    WIDEN ir<%36> = load vp<%4>
    WIDEN-CAST ir<%idxprom212> = zext  ir<%36> to i64
    WIDEN-GEP Inv[Inv][Inv][Var] ir<%arrayidx213> = getelementptr inbounds ir<@reg_save_code>, ir<0>, ir<%indvars.iv377>, ir<%idxprom212>
    WIDEN ir<%37> = load ir<%arrayidx213>
    WIDEN ir<%cmp214> = icmp eq ir<%37>, ir<-1>
  Successor(s): if.then216

  if.then216:
    vp<%5> = vector-pointer ir<%arrayidx211>
    WIDEN store vp<%5>, ir<0>, ir<%cmp214>
  Successor(s): for.inc231

  for.inc231:
    EMIT vp<%6> = not ir<%cmp214>
    EMIT vp<%7> = or ir<%cmp214>, vp<%6>
    CLONE ir<%indvars.iv.next372> = add nuw nsw ir<%indvars.iv371>, ir<1>
    CLONE ir<%exitcond375.not> = icmp eq ir<%indvars.iv.next372>, ir<%wide.trip.count374>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc234>, scalar.ph

ir-bb<for.inc234>:
No successors

scalar.ph:
No successors
}

========== Loop: init_caller_save' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body205.peel.next>:
  EMIT vp<%2> = EXPAND SCEV (-2 + %wide.trip.count374)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv371 = phi 2, %indvars.iv.next372, ir<1>
    CLONE ir<%arrayidx211> = getelementptr ir<@regno_save_mode>, ir<0>, ir<%indvars.iv377>, ir<%indvars.iv371>
    vp<%4> = vector-pointer ir<%arrayidx211>
    WIDEN ir<%36> = load vp<%4>
    WIDEN-CAST ir<%idxprom212> = zext  ir<%36> to i64
    WIDEN-GEP Inv[Inv][Inv][Var] ir<%arrayidx213> = getelementptr inbounds ir<@reg_save_code>, ir<0>, ir<%indvars.iv377>, ir<%idxprom212>
    WIDEN ir<%37> = load ir<%arrayidx213>
    WIDEN ir<%cmp214> = icmp eq ir<%37>, ir<-1>
  Successor(s): if.then216

  if.then216:
    vp<%5> = vector-pointer ir<%arrayidx211>
    WIDEN store vp<%5>, ir<0>, ir<%cmp214>
  Successor(s): for.inc231

  for.inc231:
    EMIT vp<%6> = not ir<%cmp214>
    EMIT vp<%7> = or ir<%cmp214>, vp<%6>
    CLONE ir<%indvars.iv.next372> = add nuw nsw ir<%indvars.iv371>, ir<1>
    CLONE ir<%exitcond375.not> = icmp eq ir<%indvars.iv.next372>, ir<%wide.trip.count374>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc234>, scalar.ph

ir-bb<for.inc234>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv371 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next372, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv377, i64 %indvars.iv371 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %36 = load i32, ptr %arrayidx211, align 4 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom212 = zext i32 %36 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv377, i64 %idxprom212 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %37 = load i32, ptr %arrayidx213, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp214 = icmp eq i32 %37, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 0, ptr %arrayidx211, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next372 = add nuw nsw i64 %indvars.iv371, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond375.not = icmp eq i64 %indvars.iv.next372, %wide.trip.count374 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond375.not, label %for.inc234, label %for.body205, !llvm.loop !14 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv371 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next372, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv377, i64 %indvars.iv371 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %36 = load i32, ptr %arrayidx211, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom212 = zext i32 %36 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv377, i64 %idxprom212 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %37 = load i32, ptr %arrayidx213, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp214 = icmp eq i32 %37, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 0, ptr %arrayidx211, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next372 = add nuw nsw i64 %indvars.iv371, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond375.not = icmp eq i64 %indvars.iv.next372, %wide.trip.count374 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond375.not, label %for.inc234, label %for.body205, !llvm.loop !14 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv371 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next372, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv377, i64 %indvars.iv371 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %36 = load i32, ptr %arrayidx211, align 4 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom212 = zext i32 %36 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv377, i64 %idxprom212 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %37 = load i32, ptr %arrayidx213, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp214 = icmp eq i32 %37, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 0, ptr %arrayidx211, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next372 = add nuw nsw i64 %indvars.iv371, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond375.not = icmp eq i64 %indvars.iv.next372, %wide.trip.count374 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond375.not, label %for.inc234, label %for.body205, !llvm.loop !14 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 2, EstimatedWidthB: 2, CostB: 8
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv371 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next372, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv377, i64 %indvars.iv371 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %36 = load i32, ptr %arrayidx211, align 4 of type:load
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom212 = zext i32 %36 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv377, i64 %idxprom212 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %37 = load i32, ptr %arrayidx213, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp214 = icmp eq i32 %37, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 0, ptr %arrayidx211, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next372 = add nuw nsw i64 %indvars.iv371, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond375.not = icmp eq i64 %indvars.iv.next372, %wide.trip.count374 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond375.not, label %for.inc234, label %for.body205, !llvm.loop !14 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 20
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 88
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv371 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next372, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv377, i64 %indvars.iv371 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %36 = load i32, ptr %arrayidx211, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom212 = zext i32 %36 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv377, i64 %idxprom212 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %37 = load i32, ptr %arrayidx213, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp214 = icmp eq i32 %37, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx211, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next372 = add nuw nsw i64 %indvars.iv371, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond375.not = icmp eq i64 %indvars.iv.next372, %wide.trip.count374 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond375.not, label %for.inc234, label %for.body205, !llvm.loop !14 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 20
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv371 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next372, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv377, i64 %indvars.iv371 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %36 = load i32, ptr %arrayidx211, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %idxprom212 = zext i32 %36 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv377, i64 %idxprom212 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %37 = load i32, ptr %arrayidx213, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp214 = icmp eq i32 %37, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx211, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next372 = add nuw nsw i64 %indvars.iv371, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond375.not = icmp eq i64 %indvars.iv.next372, %wide.trip.count374 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond375.not, label %for.inc234, label %for.body205, !llvm.loop !14 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 8, EstimatedWidthB: 8, CostB: 20
CostA * EstimatedWidthB: 88, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv371 = phi i64 [ 2, %for.body205.peel.next ], [ %indvars.iv.next372, %for.inc231 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx211 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv377, i64 %indvars.iv371 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %36 = load i32, ptr %arrayidx211, align 4 of type:load
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %idxprom212 = zext i32 %36 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx213 = getelementptr inbounds [53 x [59 x i32]], ptr @reg_save_code, i64 0, i64 %indvars.iv377, i64 %idxprom212 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %37 = load i32, ptr %arrayidx213, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp214 = icmp eq i32 %37, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp214, label %if.then216, label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx211, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc231 of type:br

-----------------Function that is being costed:'init_caller_save' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next372 = add nuw nsw i64 %indvars.iv371, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond375.not = icmp eq i64 %indvars.iv.next372, %wide.trip.count374 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond375.not, label %for.inc234, label %for.body205, !llvm.loop !14 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 20
B VF: 8, EstimatedWidthB: 8, CostB: 20
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: init_caller_save at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body205.peel.next>:
  EMIT vp<%2> = EXPAND SCEV (-2 + %wide.trip.count374)<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<2> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx211> = getelementptr ir<@regno_save_mode>, ir<0>, ir<%indvars.iv377>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx211>
    WIDEN ir<%36> = load vp<%6>
    WIDEN-CAST ir<%idxprom212> = zext  ir<%36> to i64
    WIDEN-GEP Inv[Inv][Inv][Var] ir<%arrayidx213> = getelementptr inbounds ir<@reg_save_code>, ir<0>, ir<%indvars.iv377>, ir<%idxprom212>
    WIDEN ir<%37> = load ir<%arrayidx213>
    WIDEN ir<%cmp214> = icmp eq ir<%37>, ir<-1>
    vp<%7> = vector-pointer ir<%arrayidx211>
    WIDEN store vp<%7>, ir<0>, ir<%cmp214>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc234>, scalar.ph

ir-bb<for.inc234>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i8, ptr %arrayidx102, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: setup_save_areas' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 (sext i16 %6 to i32) to i64))<nsw> + ((1 + (zext i32 (sext i16 %6 to i32) to i64))<nuw><nsw> umax ((zext i32 (sext i16 %6 to i32) to i64) + (zext i32 %cond95364 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %19, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%hard_regs_used.1318> = phi ir<%hard_regs_used.0320>, ir<%hard_regs_used.2>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%21> = load ir<%arrayidx102>
    CLONE ir<%tobool103.not> = icmp eq ir<%21>, ir<0>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    CLONE ir<%or> = select ir<%tobool103.not>, ir<0>, ir<%shl>
    CLONE ir<%hard_regs_used.2> = or ir<%or>, ir<%hard_regs_used.1318>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp98> = icmp ult ir<%indvars.iv.next>, ir<%20>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hard_regs_used.1318>, ir<%hard_regs_used.2>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.inc106.loopexit>, scalar.ph

ir-bb<for.inc106.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %hard_regs_used.2.lcssa = vp<%6>
}

========== Loop: setup_save_areas' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 (sext i16 %6 to i32) to i64))<nsw> + ((1 + (zext i32 (sext i16 %6 to i32) to i64))<nuw><nsw> umax ((zext i32 (sext i16 %6 to i32) to i64) + (zext i32 %cond95364 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %19, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%hard_regs_used.1318> = phi ir<%hard_regs_used.0320>, ir<%hard_regs_used.2>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx102>
    WIDEN ir<%21> = load vp<%4>
    WIDEN ir<%tobool103.not> = icmp eq ir<%21>, ir<0>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN-SELECT ir<%or> = select ir<%tobool103.not>, ir<0>, ir<%shl>
    WIDEN ir<%hard_regs_used.2> = or ir<%or>, ir<%hard_regs_used.1318>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp98> = icmp ult ir<%indvars.iv.next>, ir<%20>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hard_regs_used.1318>, ir<%hard_regs_used.2>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc106.loopexit>, scalar.ph

ir-bb<for.inc106.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %hard_regs_used.2.lcssa = vp<%7>
}

========== Loop: setup_save_areas' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 (sext i16 %6 to i32) to i64))<nsw> + ((1 + (zext i32 (sext i16 %6 to i32) to i64))<nuw><nsw> umax ((zext i32 (sext i16 %6 to i32) to i64) + (zext i32 %cond95364 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %19, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%hard_regs_used.1318> = phi ir<%hard_regs_used.0320>, ir<%hard_regs_used.2>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx102>
    WIDEN ir<%21> = load vp<%4>
    WIDEN ir<%tobool103.not> = icmp eq ir<%21>, ir<0>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN-SELECT ir<%or> = select ir<%tobool103.not>, ir<0>, ir<%shl>
    WIDEN ir<%hard_regs_used.2> = or ir<%or>, ir<%hard_regs_used.1318>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp98> = icmp ult ir<%indvars.iv.next>, ir<%20>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hard_regs_used.1318>, ir<%hard_regs_used.2>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.inc106.loopexit>, scalar.ph

ir-bb<for.inc106.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %hard_regs_used.2.lcssa = vp<%7>
}


-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %21 = load i8, ptr %arrayidx102, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %21 = load i8, ptr %arrayidx102, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %21 = load i8, ptr %arrayidx102, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 2 for VF 4 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %21 = load i8, ptr %arrayidx102, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'setup_save_areas' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %19, %for.body100.preheader ], [ %indvars.iv.next, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hard_regs_used.1318 = phi i64 [ %hard_regs_used.0320, %for.body100.preheader ], [ %hard_regs_used.2, %for.body100 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx102 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %21 = load i8, ptr %arrayidx102, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool103.not = icmp eq i8 %21, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = select i1 %tobool103.not, i64 0, i64 %shl of type:select
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %hard_regs_used.2 = or i64 %or, %hard_regs_used.1318 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp98 = icmp ult i64 %indvars.iv.next, %20 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp98, label %for.body100, label %for.inc106.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 44
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: setup_save_areas at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body100.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 (sext i16 %6 to i32) to i64))<nsw> + ((1 + (zext i32 (sext i16 %6 to i32) to i64))<nuw><nsw> umax ((zext i32 (sext i16 %6 to i32) to i64) + (zext i32 %cond95364 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %19, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%hard_regs_used.1318> = phi ir<%hard_regs_used.0320>, ir<%hard_regs_used.2>
    vp<%4>    = DERIVED-IV ir<%19> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx102>
    WIDEN ir<%21> = load vp<%6>
    WIDEN ir<%tobool103.not> = icmp eq ir<%21>, ir<0>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN-SELECT ir<%or> = select ir<%tobool103.not>, ir<0>, ir<%shl>
    WIDEN ir<%hard_regs_used.2> = or ir<%or>, ir<%hard_regs_used.1318>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hard_regs_used.1318>, ir<%hard_regs_used.2>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.inc106.loopexit>, scalar.ph

ir-bb<for.inc106.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %hard_regs_used.2.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 10
Loops Epilogues Vectorized: 0
================================================
========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv522 = phi %47, %indvars.iv.next523, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507> = phi ir<%hard_regs_to_save.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next523> = add nsw ir<%indvars.iv522>, ir<-1>
    CLONE ir<%49> = add nsw ir<%indvars.iv.next523>, ir<%48>
    CLONE ir<%shl295> = shl nuw ir<1>, ir<%49>
    CLONE ir<%or> = or ir<%or505507>, ir<%shl295>
    CLONE ir<%cmp290> = icmp ugt ir<%indvars.iv522>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv522 = phi %47, %indvars.iv.next523, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507> = phi ir<%hard_regs_to_save.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next523> = add nsw ir<%indvars.iv522>, ir<-1>
    WIDEN ir<%49> = add nsw ir<%indvars.iv.next523>, ir<%48>
    WIDEN ir<%shl295> = shl nuw ir<1>, ir<%49>
    WIDEN ir<%or> = or ir<%or505507>, ir<%shl295>
    CLONE ir<%cmp290> = icmp ugt ir<%indvars.iv522>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv522 = phi %47, %indvars.iv.next523, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507> = phi ir<%hard_regs_to_save.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next523> = add nsw ir<%indvars.iv522>, ir<-1>
    WIDEN ir<%49> = add nsw ir<%indvars.iv.next523>, ir<%48>
    WIDEN ir<%shl295> = shl nuw ir<1>, ir<%49>
    WIDEN ir<%or> = or ir<%or505507>, ir<%shl295>
    CLONE ir<%cmp290> = icmp ugt ir<%indvars.iv522>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv522 = phi i64 [ %47, %while.body292.preheader ], [ %indvars.iv.next523, %while.body292 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or505507 = phi i64 [ %hard_regs_to_save.promoted, %while.body292.preheader ], [ %or, %while.body292 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next523 = add nsw i64 %indvars.iv522, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %49 = add nsw i64 %indvars.iv.next523, %48 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl295 = shl nuw i64 1, %49 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or505507, %shl295 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp290 = icmp ugt i64 %indvars.iv522, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp290, label %while.body292, label %while.cond289.while.end296_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv522 = phi i64 [ %47, %while.body292.preheader ], [ %indvars.iv.next523, %while.body292 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or505507 = phi i64 [ %hard_regs_to_save.promoted, %while.body292.preheader ], [ %or, %while.body292 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next523 = add nsw i64 %indvars.iv522, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %49 = add nsw i64 %indvars.iv.next523, %48 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl295 = shl nuw i64 1, %49 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or505507, %shl295 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp290 = icmp ugt i64 %indvars.iv522, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp290, label %while.body292, label %while.cond289.while.end296_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv522 = phi i64 [ %47, %while.body292.preheader ], [ %indvars.iv.next523, %while.body292 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or505507 = phi i64 [ %hard_regs_to_save.promoted, %while.body292.preheader ], [ %or, %while.body292 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next523 = add nsw i64 %indvars.iv522, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %49 = add nsw i64 %indvars.iv.next523, %48 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl295 = shl nuw i64 1, %49 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or505507, %shl295 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp290 = icmp ugt i64 %indvars.iv522, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp290, label %while.body292, label %while.cond289.while.end296_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv522 = phi i64 [ %47, %while.body292.preheader ], [ %indvars.iv.next523, %while.body292 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or505507 = phi i64 [ %hard_regs_to_save.promoted, %while.body292.preheader ], [ %or, %while.body292 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next523 = add nsw i64 %indvars.iv522, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %49 = add nsw i64 %indvars.iv.next523, %48 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl295 = shl nuw i64 1, %49 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or505507, %shl295 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp290 = icmp ugt i64 %indvars.iv522, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp290, label %while.body292, label %while.cond289.while.end296_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv522 = phi i64 [ %47, %while.body292.preheader ], [ %indvars.iv.next523, %while.body292 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or505507 = phi i64 [ %hard_regs_to_save.promoted, %while.body292.preheader ], [ %or, %while.body292 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next523 = add nsw i64 %indvars.iv522, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %49 = add nsw i64 %indvars.iv.next523, %48 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl295 = shl nuw i64 1, %49 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or505507, %shl295 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp290 = icmp ugt i64 %indvars.iv522, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp290, label %while.body292, label %while.cond289.while.end296_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: save_call_clobbered_regs at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body292.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond192 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv522 = phi %47, %indvars.iv.next523, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or505507> = phi ir<%hard_regs_to_save.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next523> = add nsw ir<%indvars.iv522>, ir<-1>
    WIDEN ir<%49> = add nsw ir<%indvars.iv.next523>, ir<%48>
    WIDEN ir<%shl295> = shl nuw ir<1>, ir<%49>
    WIDEN ir<%or> = or ir<%or505507>, ir<%shl295>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or505507>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond289.while.end296_crit_edge>, scalar.ph

ir-bb<while.cond289.while.end296_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %.sink, ptr %16, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%shl35> = shl nuw nsw ir<1>, ir<%indvars.iv>
    CLONE ir<%and36> = and ir<%14>, ir<%shl35>
    CLONE ir<%tobool37.not> = icmp eq ir<%and36>, ir<0>
  Successor(s): if.then38

  if.then38:
    EMIT vp<%3> = not ir<%tobool37.not>
    CLONE ir<%arrayidx41> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv>, ir<1>
    CLONE ir<%15> = load ir<%arrayidx41>, vp<%3>
  Successor(s): for.inc48

  for.inc48:
    EMIT vp<%4> = or ir<%tobool37.not>, vp<%3>
    BLEND ir<%.sink> = ir<%15> ir<0>/ir<%tobool37.not>
    CLONE ir<%16> = getelementptr inbounds ir<%save_mode>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%.sink>, ir<%16>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<do.body51>, scalar.ph

ir-bb<do.body51>:
No successors

scalar.ph:
No successors
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%shl35> = shl nuw nsw ir<1>, ir<%indvars.iv>
    WIDEN ir<%and36> = and ir<%14>, ir<%shl35>
    WIDEN ir<%tobool37.not> = icmp eq ir<%and36>, ir<0>
  Successor(s): if.then38

  if.then38:
    EMIT vp<%3> = not ir<%tobool37.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx41> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv>, ir<1>
    WIDEN ir<%15> = load ir<%arrayidx41>, vp<%3>
  Successor(s): for.inc48

  for.inc48:
    EMIT vp<%4> = or ir<%tobool37.not>, vp<%3>
    BLEND ir<%.sink> = ir<%15> ir<0>/ir<%tobool37.not>
    CLONE ir<%16> = getelementptr inbounds ir<%save_mode>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%16>
    WIDEN store vp<%5>, ir<%.sink>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.body51>, scalar.ph

ir-bb<do.body51>:
No successors

scalar.ph:
No successors
}

========== Loop: save_call_clobbered_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN ir<%shl35> = shl nuw nsw ir<1>, ir<%indvars.iv>
    WIDEN ir<%and36> = and ir<%14>, ir<%shl35>
    WIDEN ir<%tobool37.not> = icmp eq ir<%and36>, ir<0>
  Successor(s): if.then38

  if.then38:
    EMIT vp<%3> = not ir<%tobool37.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx41> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv>, ir<1>
    WIDEN ir<%15> = load ir<%arrayidx41>, vp<%3>
  Successor(s): for.inc48

  for.inc48:
    EMIT vp<%4> = or ir<%tobool37.not>, vp<%3>
    BLEND ir<%.sink> = ir<%15> ir<0>/ir<%tobool37.not>
    CLONE ir<%16> = getelementptr inbounds ir<%save_mode>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%16>
    WIDEN store vp<%5>, ir<%.sink>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.body51>, scalar.ph

ir-bb<do.body51>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %15 = load i32, ptr %arrayidx41, align 4 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %15 = load i32, ptr %arrayidx41, align 4 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 240, RTCostB: 318
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 240, RTCostB: 318
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %15 = load i32, ptr %arrayidx41, align 4 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 201, RTCostB: 318
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 201, RTCostB: 240
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %15 = load i32, ptr %arrayidx41, align 4 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 2 for VF 8 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 204, RTCostB: 318
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 204, RTCostB: 201

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %15 = load i32, ptr %arrayidx41, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 240, RTCostB: 318
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 240, RTCostB: 201

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %15 = load i32, ptr %arrayidx41, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 201, RTCostB: 318
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 201, RTCostB: 201
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %if.then28 ], [ %indvars.iv.next, %for.inc48 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %shl35 = shl nuw nsw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %and36 = and i64 %14, %shl35 of type:and
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %tobool37.not = icmp eq i64 %and36, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool37.not, label %for.inc48, label %if.then38 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx41 = getelementptr inbounds [53 x [5 x i32]], ptr @regno_save_mode, i64 0, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %15 = load i32, ptr %arrayidx41, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc48 of type:br

-----------------Function that is being costed:'save_call_clobbered_regs' from caller-save.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %.sink = phi i32 [ %15, %if.then38 ], [ 0, %for.body33 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %16 = getelementptr inbounds [53 x i32], ptr %save_mode, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %.sink, ptr %16, align 4 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %do.body51, label %for.body33 of type:br
LV: Vector loop of width vscale x 4 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 204, RTCostB: 318
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 204, RTCostB: 201
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: save_call_clobbered_regs at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl35> = shl nuw nsw ir<1>, ir<%indvars.iv>
    WIDEN ir<%and36> = and ir<%14>, ir<%shl35>
    WIDEN ir<%tobool37.not> = icmp eq ir<%and36>, ir<0>
    EMIT vp<%4> = not ir<%tobool37.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx41> = getelementptr inbounds ir<@regno_save_mode>, ir<0>, ir<%indvars.iv>, ir<1>
    WIDEN ir<%15> = load ir<%arrayidx41>, vp<%4>
    BLEND ir<%.sink> = ir<%15> ir<0>/ir<%tobool37.not>
    CLONE ir<%16> = getelementptr inbounds ir<%save_mode>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%16>
    WIDEN store vp<%5>, ir<%.sink>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<do.body51>, scalar.ph

ir-bb<do.body51>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 16
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_referenced_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond150318 to i64) + (-1 * (1 umin (zext i32 %cond150318 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv311 = phi %24, %indvars.iv.next312, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or302304> = phi ir<%referenced_regs.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next312> = add nsw ir<%indvars.iv311>, ir<-1>
    CLONE ir<%26> = add nsw ir<%indvars.iv.next312>, ir<%25>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%26>
    CLONE ir<%or> = or ir<%or302304>, ir<%shl>
    CLONE ir<%cmp151> = icmp ugt ir<%indvars.iv311>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or302304>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_referenced_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond150318 to i64) + (-1 * (1 umin (zext i32 %cond150318 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv311 = phi %24, %indvars.iv.next312, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or302304> = phi ir<%referenced_regs.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next312> = add nsw ir<%indvars.iv311>, ir<-1>
    WIDEN ir<%26> = add nsw ir<%indvars.iv.next312>, ir<%25>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%26>
    WIDEN ir<%or> = or ir<%or302304>, ir<%shl>
    CLONE ir<%cmp151> = icmp ugt ir<%indvars.iv311>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or302304>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_referenced_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond150318 to i64) + (-1 * (1 umin (zext i32 %cond150318 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv311 = phi %24, %indvars.iv.next312, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or302304> = phi ir<%referenced_regs.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next312> = add nsw ir<%indvars.iv311>, ir<-1>
    WIDEN ir<%26> = add nsw ir<%indvars.iv.next312>, ir<%25>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%26>
    WIDEN ir<%or> = or ir<%or302304>, ir<%shl>
    CLONE ir<%cmp151> = icmp ugt ir<%indvars.iv311>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or302304>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_referenced_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv311 = phi i64 [ %24, %while.body.preheader ], [ %indvars.iv.next312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or302304 = phi i64 [ %referenced_regs.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next312 = add nsw i64 %indvars.iv311, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %26 = add nsw i64 %indvars.iv.next312, %25 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %26 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or302304, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp151 = icmp ugt i64 %indvars.iv311, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp151, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'mark_referenced_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv311 = phi i64 [ %24, %while.body.preheader ], [ %indvars.iv.next312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or302304 = phi i64 [ %referenced_regs.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next312 = add nsw i64 %indvars.iv311, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %26 = add nsw i64 %indvars.iv.next312, %25 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %26 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or302304, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp151 = icmp ugt i64 %indvars.iv311, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp151, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_referenced_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv311 = phi i64 [ %24, %while.body.preheader ], [ %indvars.iv.next312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or302304 = phi i64 [ %referenced_regs.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next312 = add nsw i64 %indvars.iv311, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %26 = add nsw i64 %indvars.iv.next312, %25 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %26 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or302304, %shl of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp151 = icmp ugt i64 %indvars.iv311, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp151, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_referenced_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv311 = phi i64 [ %24, %while.body.preheader ], [ %indvars.iv.next312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or302304 = phi i64 [ %referenced_regs.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next312 = add nsw i64 %indvars.iv311, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %26 = add nsw i64 %indvars.iv.next312, %25 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %26 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or302304, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp151 = icmp ugt i64 %indvars.iv311, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp151, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'mark_referenced_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv311 = phi i64 [ %24, %while.body.preheader ], [ %indvars.iv.next312, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or302304 = phi i64 [ %referenced_regs.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next312 = add nsw i64 %indvars.iv311, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %26 = add nsw i64 %indvars.iv.next312, %25 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %26 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or302304, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp151 = icmp ugt i64 %indvars.iv311, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp151, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_referenced_regs at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond150318 to i64) + (-1 * (1 umin (zext i32 %cond150318 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv311 = phi %24, %indvars.iv.next312, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or302304> = phi ir<%referenced_regs.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next312> = add nsw ir<%indvars.iv311>, ir<-1>
    WIDEN ir<%26> = add nsw ir<%indvars.iv.next312>, ir<%25>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%26>
    WIDEN ir<%or> = or ir<%or302304>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or302304>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_set_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno.1.fr) + ((1 + %regno.1.fr) smax (%cond64.ph.pn + %regno.1.fr)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0111 = phi %inc, %regno.1.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or108110> = phi ir<%this_insn_sets.promoted>, ir<%or>
    CLONE ir<%sh_prom> = zext nneg ir<%i.0111>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%or108110>, ir<%shl>
    CLONE ir<%inc> = add nsw ir<%i.0111>, ir<1>
    CLONE ir<%cmp66> = icmp slt ir<%inc>, ir<%add65115>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or108110>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup68.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup68.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_set_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno.1.fr) + ((1 + %regno.1.fr) smax (%cond64.ph.pn + %regno.1.fr)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0111 = phi %inc, %regno.1.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or108110> = phi ir<%this_insn_sets.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0111> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or108110>, ir<%shl>
    WIDEN ir<%inc> = add nsw ir<%i.0111>, ir<1>
    CLONE ir<%cmp66> = icmp slt ir<%inc>, ir<%add65115>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or108110>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup68.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup68.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_set_regs' from caller-save.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno.1.fr) + ((1 + %regno.1.fr) smax (%cond64.ph.pn + %regno.1.fr)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0111 = phi %inc, %regno.1.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or108110> = phi ir<%this_insn_sets.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0111> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or108110>, ir<%shl>
    WIDEN ir<%inc> = add nsw ir<%i.0111>, ir<1>
    CLONE ir<%cmp66> = icmp slt ir<%inc>, ir<%add65115>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or108110>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup68.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup68.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_set_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0111 = phi i32 [ %inc, %for.body ], [ %regno.1.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or108110 = phi i64 [ %or, %for.body ], [ %this_insn_sets.promoted, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom = zext nneg i32 %i.0111 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or108110, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %i.0111, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp66 = icmp slt i32 %inc, %add65115 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup68.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'mark_set_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0111 = phi i32 [ %inc, %for.body ], [ %regno.1.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or108110 = phi i64 [ %or, %for.body ], [ %this_insn_sets.promoted, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom = zext nneg i32 %i.0111 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or108110, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %i.0111, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp66 = icmp slt i32 %inc, %add65115 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup68.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_set_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0111 = phi i32 [ %inc, %for.body ], [ %regno.1.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or108110 = phi i64 [ %or, %for.body ], [ %this_insn_sets.promoted, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom = zext nneg i32 %i.0111 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or108110, %shl of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nsw i32 %i.0111, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp66 = icmp slt i32 %inc, %add65115 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup68.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_set_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0111 = phi i32 [ %inc, %for.body ], [ %regno.1.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or108110 = phi i64 [ %or, %for.body ], [ %this_insn_sets.promoted, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %i.0111 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or108110, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nsw i32 %i.0111, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp66 = icmp slt i32 %inc, %add65115 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup68.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'mark_set_regs' from caller-save.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0111 = phi i32 [ %inc, %for.body ], [ %regno.1.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or108110 = phi i64 [ %or, %for.body ], [ %this_insn_sets.promoted, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %i.0111 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or108110, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %i.0111, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp66 = icmp slt i32 %inc, %add65115 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup68.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_set_regs at line: caller-save.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno.1.fr) + ((1 + %regno.1.fr) smax (%cond64.ph.pn + %regno.1.fr)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0111 = phi %inc, %regno.1.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or108110> = phi ir<%this_insn_sets.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0111> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or108110>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or108110>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup68.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup68.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 22
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o calls.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         calls.c
========== Loop: expand_call' from calls.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_actuals.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1929 = phi %indvars.iv.next1930, 0, ir<1>
    CLONE ir<%arrayidx1247> = getelementptr inbounds ir<%42>, ir<%indvars.iv1929>
    CLONE ir<%value> = getelementptr inbounds ir<%arrayidx1247>, ir<16>
    CLONE store ir<null>, ir<%value>
    CLONE ir<%aligned_regs1250> = getelementptr inbounds ir<%arrayidx1247>, ir<136>
    CLONE store ir<null>, ir<%aligned_regs1250>
    CLONE ir<%stack> = getelementptr inbounds ir<%arrayidx1247>, ir<112>
    CLONE store ir<null>, ir<%stack>
    CLONE ir<%indvars.iv.next1930> = add nuw nsw ir<%indvars.iv1929>, ir<1>
    CLONE ir<%exitcond1932.not> = icmp eq ir<%indvars.iv.next1930>, ir<%conv168>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1255.loopexit>, scalar.ph

ir-bb<for.end1255.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: expand_call' from calls.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_actuals.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1929 = phi %indvars.iv.next1930, 0, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx1247> = getelementptr inbounds ir<%42>, ir<%indvars.iv1929>
    WIDEN-GEP Var[Inv] ir<%value> = getelementptr inbounds ir<%arrayidx1247>, ir<16>
    WIDEN store ir<%value>, ir<null>
    WIDEN-GEP Var[Inv] ir<%aligned_regs1250> = getelementptr inbounds ir<%arrayidx1247>, ir<136>
    WIDEN store ir<%aligned_regs1250>, ir<null>
    WIDEN-GEP Var[Inv] ir<%stack> = getelementptr inbounds ir<%arrayidx1247>, ir<112>
    WIDEN store ir<%stack>, ir<null>
    WIDEN ir<%indvars.iv.next1930> = add nuw nsw ir<%indvars.iv1929>, ir<1>
    CLONE ir<%exitcond1932.not> = icmp eq ir<%indvars.iv.next1930>, ir<%conv168>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1255.loopexit>, scalar.ph

ir-bb<for.end1255.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: expand_call' from calls.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_actuals.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1929 = phi %indvars.iv.next1930, 0, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx1247> = getelementptr inbounds ir<%42>, ir<%indvars.iv1929>
    WIDEN-GEP Var[Inv] ir<%value> = getelementptr inbounds ir<%arrayidx1247>, ir<16>
    WIDEN store ir<%value>, ir<null>
    WIDEN-GEP Var[Inv] ir<%aligned_regs1250> = getelementptr inbounds ir<%arrayidx1247>, ir<136>
    WIDEN store ir<%aligned_regs1250>, ir<null>
    WIDEN-GEP Var[Inv] ir<%stack> = getelementptr inbounds ir<%arrayidx1247>, ir<112>
    WIDEN store ir<%stack>, ir<null>
    WIDEN ir<%indvars.iv.next1930> = add nuw nsw ir<%indvars.iv1929>, ir<1>
    CLONE ir<%exitcond1932.not> = icmp eq ir<%indvars.iv.next1930>, ir<%conv168>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1255.loopexit>, scalar.ph

ir-bb<for.end1255.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'expand_call' from calls.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1929 = phi i64 [ %indvars.iv.next1930, %for.body1245 ], [ 0, %for.body1245.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1247 = getelementptr inbounds %struct.arg_data, ptr %42, i64 %indvars.iv1929 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %value = getelementptr inbounds i8, ptr %arrayidx1247, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr null, ptr %value, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %aligned_regs1250 = getelementptr inbounds i8, ptr %arrayidx1247, i64 136 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr null, ptr %aligned_regs1250, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %stack = getelementptr inbounds i8, ptr %arrayidx1247, i64 112 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr null, ptr %stack, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1930 = add nuw nsw i64 %indvars.iv1929, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1932.not = icmp eq i64 %indvars.iv.next1930, %conv168 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1932.not, label %for.end1255.loopexit, label %for.body1245 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'expand_call' from calls.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1929 = phi i64 [ %indvars.iv.next1930, %for.body1245 ], [ 0, %for.body1245.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1247 = getelementptr inbounds %struct.arg_data, ptr %42, i64 %indvars.iv1929 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %value = getelementptr inbounds i8, ptr %arrayidx1247, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr null, ptr %value, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %aligned_regs1250 = getelementptr inbounds i8, ptr %arrayidx1247, i64 136 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr null, ptr %aligned_regs1250, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %stack = getelementptr inbounds i8, ptr %arrayidx1247, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr null, ptr %stack, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1930 = add nuw nsw i64 %indvars.iv1929, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1932.not = icmp eq i64 %indvars.iv.next1930, %conv168 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1932.not, label %for.end1255.loopexit, label %for.body1245 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 17179869181, RTCostB: 21474836475
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 17179869181, RTCostB: 21474836475
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'expand_call' from calls.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1929 = phi i64 [ %indvars.iv.next1930, %for.body1245 ], [ 0, %for.body1245.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1247 = getelementptr inbounds %struct.arg_data, ptr %42, i64 %indvars.iv1929 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %value = getelementptr inbounds i8, ptr %arrayidx1247, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr null, ptr %value, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %aligned_regs1250 = getelementptr inbounds i8, ptr %arrayidx1247, i64 136 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr null, ptr %aligned_regs1250, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %stack = getelementptr inbounds i8, ptr %arrayidx1247, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr null, ptr %stack, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1930 = add nuw nsw i64 %indvars.iv1929, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1932.not = icmp eq i64 %indvars.iv.next1930, %conv168 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1932.not, label %for.end1255.loopexit, label %for.body1245 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 16106127360, RTCostB: 21474836475
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 16106127360, RTCostB: 17179869181
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'expand_call' from calls.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1929 = phi i64 [ %indvars.iv.next1930, %for.body1245 ], [ 0, %for.body1245.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1247 = getelementptr inbounds %struct.arg_data, ptr %42, i64 %indvars.iv1929 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %value = getelementptr inbounds i8, ptr %arrayidx1247, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr null, ptr %value, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %aligned_regs1250 = getelementptr inbounds i8, ptr %arrayidx1247, i64 136 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr null, ptr %aligned_regs1250, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %stack = getelementptr inbounds i8, ptr %arrayidx1247, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr null, ptr %stack, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1930 = add nuw nsw i64 %indvars.iv1929, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1932.not = icmp eq i64 %indvars.iv.next1930, %conv168 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1932.not, label %for.end1255.loopexit, label %for.body1245 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 17179869181, RTCostB: 21474836475
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 17179869181, RTCostB: 16106127360

-----------------Function that is being costed:'expand_call' from calls.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1929 = phi i64 [ %indvars.iv.next1930, %for.body1245 ], [ 0, %for.body1245.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1247 = getelementptr inbounds %struct.arg_data, ptr %42, i64 %indvars.iv1929 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %value = getelementptr inbounds i8, ptr %arrayidx1247, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr null, ptr %value, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %aligned_regs1250 = getelementptr inbounds i8, ptr %arrayidx1247, i64 136 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr null, ptr %aligned_regs1250, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %stack = getelementptr inbounds i8, ptr %arrayidx1247, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr null, ptr %stack, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1930 = add nuw nsw i64 %indvars.iv1929, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1932.not = icmp eq i64 %indvars.iv.next1930, %conv168 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1932.not, label %for.end1255.loopexit, label %for.body1245 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 16106127360, RTCostB: 21474836475
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 16106127360, RTCostB: 16106127360
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: expand_call at line: calls.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %num_actuals.0.lcssa to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1929 = phi %indvars.iv.next1930, 0, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx1247> = getelementptr inbounds ir<%42>, ir<%indvars.iv1929>
    WIDEN-GEP Var[Inv] ir<%value> = getelementptr inbounds ir<%arrayidx1247>, ir<16>
    WIDEN store ir<%value>, ir<null>
    WIDEN-GEP Var[Inv] ir<%aligned_regs1250> = getelementptr inbounds ir<%arrayidx1247>, ir<136>
    WIDEN store ir<%aligned_regs1250>, ir<null>
    WIDEN-GEP Var[Inv] ir<%stack> = getelementptr inbounds ir<%arrayidx1247>, ir<112>
    WIDEN store ir<%stack>, ir<null>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end1255.loopexit>, scalar.ph

ir-bb<for.end1255.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 13
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cfg.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cfg.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cfganal.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cfganal.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cfgbuild.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cfgbuild.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cfgcleanup.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cfgcleanup.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cfglayout.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cfglayout.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cfgloop.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cfgloop.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cfgrtl.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cfgrtl.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o combine.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         combine.c
@@ Instruction =>  store ptr %insn, ptr %arrayidx89, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %insn, ptr %arrayidx89, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %insn, ptr %arrayidx89, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %insn, ptr %arrayidx89, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: record_dead_and_set_regs' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body87.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%2 + %cond82) to i64) + (-1 * (zext i32 %2 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %14, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx89> = getelementptr inbounds ir<%13>, ir<%indvars.iv>
    CLONE store ir<%insn>, ir<%arrayidx89>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc99.loopexit>, scalar.ph

ir-bb<for.inc99.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_dead_and_set_regs' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body87.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%2 + %cond82) to i64) + (-1 * (zext i32 %2 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %14, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx89> = getelementptr inbounds ir<%13>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx89>
    WIDEN store vp<%4>, ir<%insn>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.inc99.loopexit>, scalar.ph

ir-bb<for.inc99.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_dead_and_set_regs' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body87.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%2 + %cond82) to i64) + (-1 * (zext i32 %2 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %14, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx89> = getelementptr inbounds ir<%13>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx89>
    WIDEN store vp<%4>, ir<%insn>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.inc99.loopexit>, scalar.ph

ir-bb<for.inc99.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_dead_and_set_regs' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %14, %for.body87.lr.ph ], [ %indvars.iv.next, %for.body87 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx89 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %insn, ptr %arrayidx89, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.inc99.loopexit, label %for.body87 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'record_dead_and_set_regs' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %14, %for.body87.lr.ph ], [ %indvars.iv.next, %for.body87 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx89 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %insn, ptr %arrayidx89, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.inc99.loopexit, label %for.body87 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_dead_and_set_regs' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %14, %for.body87.lr.ph ], [ %indvars.iv.next, %for.body87 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx89 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %insn, ptr %arrayidx89, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.inc99.loopexit, label %for.body87 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'record_dead_and_set_regs' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %14, %for.body87.lr.ph ], [ %indvars.iv.next, %for.body87 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx89 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %insn, ptr %arrayidx89, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.inc99.loopexit, label %for.body87 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'record_dead_and_set_regs' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %14, %for.body87.lr.ph ], [ %indvars.iv.next, %for.body87 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx89 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %insn, ptr %arrayidx89, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.inc99.loopexit, label %for.body87 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: record_dead_and_set_regs at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body87.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%2 + %cond82) to i64) + (-1 * (zext i32 %2 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%14> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx89> = getelementptr inbounds ir<%13>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx89>
    WIDEN store vp<%6>, ir<%insn>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.inc99.loopexit>, scalar.ph

ir-bb<for.inc99.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_used_regs_combine' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %1 to i64))<nsw> + ((1 + (zext i32 %1 to i64))<nuw><nsw> umax ((zext i32 %1 to i64) + (zext i32 %cond94278 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %15, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or257259> = phi ir<%newpat_used_regs.promoted>, ir<%or>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    CLONE ir<%or> = or ir<%or257259>, ir<%shl>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp96> = icmp ult ir<%indvars.iv.next>, ir<%16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or257259>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup179.loopexit250_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup179.loopexit250_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_used_regs_combine' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %1 to i64))<nsw> + ((1 + (zext i32 %1 to i64))<nuw><nsw> umax ((zext i32 %1 to i64) + (zext i32 %cond94278 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %15, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or257259> = phi ir<%newpat_used_regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or257259>, ir<%shl>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp96> = icmp ult ir<%indvars.iv.next>, ir<%16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or257259>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup179.loopexit250_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup179.loopexit250_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_used_regs_combine' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %1 to i64))<nsw> + ((1 + (zext i32 %1 to i64))<nuw><nsw> umax ((zext i32 %1 to i64) + (zext i32 %cond94278 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %15, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or257259> = phi ir<%newpat_used_regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or257259>, ir<%shl>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp96> = icmp ult ir<%indvars.iv.next>, ir<%16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or257259>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup179.loopexit250_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup179.loopexit250_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_used_regs_combine' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %15, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or257259 = phi i64 [ %newpat_used_regs.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or257259, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp96 = icmp ult i64 %indvars.iv.next, %16 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp96, label %for.body, label %for.cond.cleanup179.loopexit250_crit_edge of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_used_regs_combine' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %15, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or257259 = phi i64 [ %newpat_used_regs.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or257259, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp96 = icmp ult i64 %indvars.iv.next, %16 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp96, label %for.body, label %for.cond.cleanup179.loopexit250_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_used_regs_combine' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %15, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or257259 = phi i64 [ %newpat_used_regs.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or257259, %shl of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp96 = icmp ult i64 %indvars.iv.next, %16 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp96, label %for.body, label %for.cond.cleanup179.loopexit250_crit_edge of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_used_regs_combine' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %15, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or257259 = phi i64 [ %newpat_used_regs.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or257259, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp96 = icmp ult i64 %indvars.iv.next, %16 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp96, label %for.body, label %for.cond.cleanup179.loopexit250_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'mark_used_regs_combine' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %15, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or257259 = phi i64 [ %newpat_used_regs.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or257259, %shl of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp96 = icmp ult i64 %indvars.iv.next, %16 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp96, label %for.body, label %for.cond.cleanup179.loopexit250_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_used_regs_combine at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %1 to i64))<nsw> + ((1 + (zext i32 %1 to i64))<nuw><nsw> umax ((zext i32 %1 to i64) + (zext i32 %cond94278 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %15, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or257259> = phi ir<%newpat_used_regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or257259>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or257259>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup179.loopexit250_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup179.loopexit250_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 42
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %insn, ptr %arrayidx121.us, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %insn, ptr %arrayidx121.us, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %insn, ptr %arrayidx121.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %insn, ptr %arrayidx121.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %25, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx121.us> = getelementptr inbounds ir<%19>, ir<%indvars.iv>
    CLONE store ir<%insn>, ir<%arrayidx121.us>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %25, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx121.us> = getelementptr inbounds ir<%19>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx121.us>
    WIDEN store vp<%4>, ir<%insn>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %25, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx121.us> = getelementptr inbounds ir<%19>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx121.us>
    WIDEN store vp<%4>, ir<%insn>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %25, %for.body.us.preheader ], [ %indvars.iv.next, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx121.us = getelementptr inbounds ptr, ptr %19, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %insn, ptr %arrayidx121.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body.us of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %25, %for.body.us.preheader ], [ %indvars.iv.next, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx121.us = getelementptr inbounds ptr, ptr %19, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %insn, ptr %arrayidx121.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body.us of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %25, %for.body.us.preheader ], [ %indvars.iv.next, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx121.us = getelementptr inbounds ptr, ptr %19, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %insn, ptr %arrayidx121.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body.us of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %25, %for.body.us.preheader ], [ %indvars.iv.next, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx121.us = getelementptr inbounds ptr, ptr %19, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %insn, ptr %arrayidx121.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body.us of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %25, %for.body.us.preheader ], [ %indvars.iv.next, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx121.us = getelementptr inbounds ptr, ptr %19, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %insn, ptr %arrayidx121.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body.us of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: record_value_for_reg at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%25> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx121.us> = getelementptr inbounds ir<%19>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx121.us>
    WIDEN store vp<%6>, ir<%insn>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %46, ptr %arrayidx141, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load i32, ptr %arrayidx145, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select344, ptr %59, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %46, ptr %arrayidx141, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load i32, ptr %arrayidx145, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select344, ptr %59, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %46, ptr %arrayidx141, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %58 = load i32, ptr %arrayidx145, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select344, ptr %59, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %46, ptr %arrayidx141, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load i32, ptr %arrayidx145, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select344, ptr %59, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %46, ptr %arrayidx141, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %58 = load i32, ptr %arrayidx145, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.select344, ptr %59, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %46, ptr %arrayidx141, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %58 = load i32, ptr %arrayidx145, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.select344, ptr %59, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv310 = phi %50, %indvars.iv.next311, ir<1>
    CLONE ir<%arrayidx141> = getelementptr inbounds ir<%47>, ir<%indvars.iv310>
    CLONE store ir<%46>, ir<%arrayidx141>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%48>, ir<%indvars.iv310>
    CLONE ir<%58> = load ir<%arrayidx145>
    CLONE ir<%cmp146> = icmp eq ir<%58>, ir<%46>
    CLONE ir<%spec.select344> = zext ir<%cmp146>
    CLONE ir<%59> = getelementptr inbounds ir<%49>, ir<%indvars.iv310>
    CLONE store ir<%spec.select344>, ir<%59>
    CLONE ir<%indvars.iv.next311> = add nuw nsw ir<%indvars.iv310>, ir<1>
    CLONE ir<%exitcond313.not> = icmp eq ir<%indvars.iv.next311>, ir<%wide.trip.count312>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<land.lhs.true158.loopexit>, scalar.ph

ir-bb<land.lhs.true158.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv310 = phi %50, %indvars.iv.next311, ir<1>
    CLONE ir<%arrayidx141> = getelementptr inbounds ir<%47>, ir<%indvars.iv310>
    vp<%4> = vector-pointer ir<%arrayidx141>
    WIDEN store vp<%4>, ir<%46>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%48>, ir<%indvars.iv310>
    vp<%5> = vector-pointer ir<%arrayidx145>
    WIDEN ir<%58> = load vp<%5>
    WIDEN ir<%cmp146> = icmp eq ir<%58>, ir<%46>
    WIDEN-CAST ir<%spec.select344> = zext  ir<%cmp146> to i8
    CLONE ir<%59> = getelementptr inbounds ir<%49>, ir<%indvars.iv310>
    vp<%6> = vector-pointer ir<%59>
    WIDEN store vp<%6>, ir<%spec.select344>
    CLONE ir<%indvars.iv.next311> = add nuw nsw ir<%indvars.iv310>, ir<1>
    CLONE ir<%exitcond313.not> = icmp eq ir<%indvars.iv.next311>, ir<%wide.trip.count312>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<land.lhs.true158.loopexit>, scalar.ph

ir-bb<land.lhs.true158.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv310 = phi %50, %indvars.iv.next311, ir<1>
    CLONE ir<%arrayidx141> = getelementptr inbounds ir<%47>, ir<%indvars.iv310>
    vp<%4> = vector-pointer ir<%arrayidx141>
    WIDEN store vp<%4>, ir<%46>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%48>, ir<%indvars.iv310>
    vp<%5> = vector-pointer ir<%arrayidx145>
    WIDEN ir<%58> = load vp<%5>
    WIDEN ir<%cmp146> = icmp eq ir<%58>, ir<%46>
    WIDEN-CAST ir<%spec.select344> = zext  ir<%cmp146> to i8
    CLONE ir<%59> = getelementptr inbounds ir<%49>, ir<%indvars.iv310>
    vp<%6> = vector-pointer ir<%59>
    WIDEN store vp<%6>, ir<%spec.select344>
    CLONE ir<%indvars.iv.next311> = add nuw nsw ir<%indvars.iv310>, ir<1>
    CLONE ir<%exitcond313.not> = icmp eq ir<%indvars.iv.next311>, ir<%wide.trip.count312>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<land.lhs.true158.loopexit>, scalar.ph

ir-bb<land.lhs.true158.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv310 = phi i64 [ %50, %for.body139.preheader ], [ %indvars.iv.next311, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %47, i64 %indvars.iv310 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %46, ptr %arrayidx141, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %48, i64 %indvars.iv310 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %58 = load i32, ptr %arrayidx145, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp146 = icmp eq i32 %58, %46 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select344 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %59 = getelementptr inbounds i8, ptr %49, i64 %indvars.iv310 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %spec.select344, ptr %59, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next311 = add nuw nsw i64 %indvars.iv310, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond313.not = icmp eq i64 %indvars.iv.next311, %wide.trip.count312 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond313.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv310 = phi i64 [ %50, %for.body139.preheader ], [ %indvars.iv.next311, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %47, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %46, ptr %arrayidx141, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %48, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %58 = load i32, ptr %arrayidx145, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp146 = icmp eq i32 %58, %46 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %spec.select344 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %59 = getelementptr inbounds i8, ptr %49, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %spec.select344, ptr %59, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next311 = add nuw nsw i64 %indvars.iv310, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond313.not = icmp eq i64 %indvars.iv.next311, %wide.trip.count312 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond313.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv310 = phi i64 [ %50, %for.body139.preheader ], [ %indvars.iv.next311, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %47, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %46, ptr %arrayidx141, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %48, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %58 = load i32, ptr %arrayidx145, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp146 = icmp eq i32 %58, %46 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %spec.select344 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %59 = getelementptr inbounds i8, ptr %49, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %spec.select344, ptr %59, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next311 = add nuw nsw i64 %indvars.iv310, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond313.not = icmp eq i64 %indvars.iv.next311, %wide.trip.count312 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond313.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 8
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv310 = phi i64 [ %50, %for.body139.preheader ], [ %indvars.iv.next311, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %47, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %46, ptr %arrayidx141, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %48, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %58 = load i32, ptr %arrayidx145, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp146 = icmp eq i32 %58, %46 of type:icmp
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select344 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %59 = getelementptr inbounds i8, ptr %49, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.select344, ptr %59, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next311 = add nuw nsw i64 %indvars.iv310, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond313.not = icmp eq i64 %indvars.iv.next311, %wide.trip.count312 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond313.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 11
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv310 = phi i64 [ %50, %for.body139.preheader ], [ %indvars.iv.next311, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %47, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %46, ptr %arrayidx141, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %48, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %58 = load i32, ptr %arrayidx145, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp146 = icmp eq i32 %58, %46 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %spec.select344 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %59 = getelementptr inbounds i8, ptr %49, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %spec.select344, ptr %59, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next311 = add nuw nsw i64 %indvars.iv310, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond313.not = icmp eq i64 %indvars.iv.next311, %wide.trip.count312 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond313.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 14
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 11
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv310 = phi i64 [ %50, %for.body139.preheader ], [ %indvars.iv.next311, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %47, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %46, ptr %arrayidx141, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %48, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %58 = load i32, ptr %arrayidx145, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp146 = icmp eq i32 %58, %46 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %spec.select344 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %59 = getelementptr inbounds i8, ptr %49, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %spec.select344, ptr %59, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next311 = add nuw nsw i64 %indvars.iv310, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond313.not = icmp eq i64 %indvars.iv.next311, %wide.trip.count312 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond313.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 11
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 44

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv310 = phi i64 [ %50, %for.body139.preheader ], [ %indvars.iv.next311, %for.body139 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx141 = getelementptr inbounds i32, ptr %47, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %46, ptr %arrayidx141, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %48, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %58 = load i32, ptr %arrayidx145, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp146 = icmp eq i32 %58, %46 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %spec.select344 = zext i1 %cmp146 to i8 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %59 = getelementptr inbounds i8, ptr %49, i64 %indvars.iv310 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %spec.select344, ptr %59, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next311 = add nuw nsw i64 %indvars.iv310, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond313.not = icmp eq i64 %indvars.iv.next311, %wide.trip.count312 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond313.not, label %land.lhs.true158.loopexit, label %for.body139 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 11
B VF: 8, EstimatedWidthB: 8, CostB: 11
CostA * EstimatedWidthB: 88, CostB * EstimatedWidthA: 88
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: record_value_for_reg at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%50> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx141> = getelementptr inbounds ir<%47>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx141>
    WIDEN store vp<%6>, ir<%46>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%48>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx145>
    WIDEN ir<%60> = load vp<%7>
    WIDEN ir<%cmp146> = icmp eq ir<%60>, ir<%46>
    WIDEN-CAST ir<%spec.select344> = zext  ir<%cmp146> to i8
    CLONE ir<%61> = getelementptr inbounds ir<%49>, vp<%5>
    vp<%8> = vector-pointer ir<%61>
    WIDEN store vp<%8>, ir<%spec.select344>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<land.lhs.true158.loopexit>, scalar.ph

ir-bb<land.lhs.true158.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %71, ptr %arrayidx141.us, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %71, ptr %arrayidx141.us, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %71, ptr %arrayidx141.us, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %71, ptr %arrayidx141.us, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %71, ptr %arrayidx141.us, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %71, ptr %arrayidx141.us, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv315 = phi %74, %indvars.iv.next316, ir<1>
    CLONE ir<%arrayidx141.us> = getelementptr inbounds ir<%72>, ir<%indvars.iv315>
    CLONE store ir<%71>, ir<%arrayidx141.us>
    CLONE ir<%indvars.iv.next316> = add nuw nsw ir<%indvars.iv315>, ir<1>
    CLONE ir<%exitcond318.not> = icmp eq ir<%indvars.iv.next316>, ir<%wide.trip.count317>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end171.thread321.loopexit>, scalar.ph

ir-bb<if.end171.thread321.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv315 = phi %74, %indvars.iv.next316, ir<1>
    CLONE ir<%arrayidx141.us> = getelementptr inbounds ir<%72>, ir<%indvars.iv315>
    vp<%4> = vector-pointer ir<%arrayidx141.us>
    WIDEN store vp<%4>, ir<%71>
    CLONE ir<%indvars.iv.next316> = add nuw nsw ir<%indvars.iv315>, ir<1>
    CLONE ir<%exitcond318.not> = icmp eq ir<%indvars.iv.next316>, ir<%wide.trip.count317>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end171.thread321.loopexit>, scalar.ph

ir-bb<if.end171.thread321.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: record_value_for_reg' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv315 = phi %74, %indvars.iv.next316, ir<1>
    CLONE ir<%arrayidx141.us> = getelementptr inbounds ir<%72>, ir<%indvars.iv315>
    vp<%4> = vector-pointer ir<%arrayidx141.us>
    WIDEN store vp<%4>, ir<%71>
    CLONE ir<%indvars.iv.next316> = add nuw nsw ir<%indvars.iv315>, ir<1>
    CLONE ir<%exitcond318.not> = icmp eq ir<%indvars.iv.next316>, ir<%wide.trip.count317>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end171.thread321.loopexit>, scalar.ph

ir-bb<if.end171.thread321.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv315 = phi i64 [ %74, %for.body139.us.preheader ], [ %indvars.iv.next316, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %72, i64 %indvars.iv315 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %71, ptr %arrayidx141.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next316 = add nuw nsw i64 %indvars.iv315, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond318.not = icmp eq i64 %indvars.iv.next316, %wide.trip.count317 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond318.not, label %if.end171.thread321.loopexit, label %for.body139.us of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv315 = phi i64 [ %74, %for.body139.us.preheader ], [ %indvars.iv.next316, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %72, i64 %indvars.iv315 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %71, ptr %arrayidx141.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next316 = add nuw nsw i64 %indvars.iv315, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond318.not = icmp eq i64 %indvars.iv.next316, %wide.trip.count317 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond318.not, label %if.end171.thread321.loopexit, label %for.body139.us of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv315 = phi i64 [ %74, %for.body139.us.preheader ], [ %indvars.iv.next316, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %72, i64 %indvars.iv315 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %71, ptr %arrayidx141.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next316 = add nuw nsw i64 %indvars.iv315, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond318.not = icmp eq i64 %indvars.iv.next316, %wide.trip.count317 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond318.not, label %if.end171.thread321.loopexit, label %for.body139.us of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv315 = phi i64 [ %74, %for.body139.us.preheader ], [ %indvars.iv.next316, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %72, i64 %indvars.iv315 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %71, ptr %arrayidx141.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next316 = add nuw nsw i64 %indvars.iv315, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond318.not = icmp eq i64 %indvars.iv.next316, %wide.trip.count317 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond318.not, label %if.end171.thread321.loopexit, label %for.body139.us of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv315 = phi i64 [ %74, %for.body139.us.preheader ], [ %indvars.iv.next316, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %72, i64 %indvars.iv315 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %71, ptr %arrayidx141.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next316 = add nuw nsw i64 %indvars.iv315, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond318.not = icmp eq i64 %indvars.iv.next316, %wide.trip.count317 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond318.not, label %if.end171.thread321.loopexit, label %for.body139.us of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv315 = phi i64 [ %74, %for.body139.us.preheader ], [ %indvars.iv.next316, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %72, i64 %indvars.iv315 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %71, ptr %arrayidx141.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next316 = add nuw nsw i64 %indvars.iv315, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond318.not = icmp eq i64 %indvars.iv.next316, %wide.trip.count317 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond318.not, label %if.end171.thread321.loopexit, label %for.body139.us of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'record_value_for_reg' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv315 = phi i64 [ %74, %for.body139.us.preheader ], [ %indvars.iv.next316, %for.body139.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx141.us = getelementptr inbounds i32, ptr %72, i64 %indvars.iv315 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %71, ptr %arrayidx141.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next316 = add nuw nsw i64 %indvars.iv315, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond318.not = icmp eq i64 %indvars.iv.next316, %wide.trip.count317 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond318.not, label %if.end171.thread321.loopexit, label %for.body139.us of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: record_value_for_reg at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body139.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%0 + %cond57) to i64) + (-1 * (zext i32 %0 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%74> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx141.us> = getelementptr inbounds ir<%72>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx141.us>
    WIDEN store vp<%6>, ir<%71>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end171.thread321.loopexit>, scalar.ph

ir-bb<if.end171.thread321.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 65
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %13, ptr %arrayidx67, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: update_table_tick' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%1 + %cond62) to i64) + (-1 * (zext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv129 = phi %15, %indvars.iv.next130, ir<1>
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%14>, ir<%indvars.iv129>
    CLONE store ir<%13>, ir<%arrayidx67>
    CLONE ir<%indvars.iv.next130> = add nuw nsw ir<%indvars.iv129>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next130>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: update_table_tick' from combine.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%1 + %cond62) to i64) + (-1 * (zext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv129 = phi %15, %indvars.iv.next130, ir<1>
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%14>, ir<%indvars.iv129>
    vp<%4> = vector-pointer ir<%arrayidx67>
    WIDEN store vp<%4>, ir<%13>
    CLONE ir<%indvars.iv.next130> = add nuw nsw ir<%indvars.iv129>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next130>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: update_table_tick' from combine.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%1 + %cond62) to i64) + (-1 * (zext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv129 = phi %15, %indvars.iv.next130, ir<1>
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%14>, ir<%indvars.iv129>
    vp<%4> = vector-pointer ir<%arrayidx67>
    WIDEN store vp<%4>, ir<%13>
    CLONE ir<%indvars.iv.next130> = add nuw nsw ir<%indvars.iv129>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next130>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv129 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next130, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv129 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %13, ptr %arrayidx67, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next130 = add nuw nsw i64 %indvars.iv129, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next130, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv129 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next130, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv129 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %13, ptr %arrayidx67, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next130 = add nuw nsw i64 %indvars.iv129, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next130, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv129 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next130, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv129 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %13, ptr %arrayidx67, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next130 = add nuw nsw i64 %indvars.iv129, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next130, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 0
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 3
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv129 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next130, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv129 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %13, ptr %arrayidx67, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next130 = add nuw nsw i64 %indvars.iv129, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next130, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 3
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv129 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next130, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv129 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %13, ptr %arrayidx67, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next130 = add nuw nsw i64 %indvars.iv129, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next130, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv129 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next130, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv129 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %13, ptr %arrayidx67, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next130 = add nuw nsw i64 %indvars.iv129, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next130, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'update_table_tick' from combine.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv129 = phi i64 [ %15, %for.body.lr.ph ], [ %indvars.iv.next130, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx67 = getelementptr inbounds i32, ptr %14, i64 %indvars.iv129 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %13, ptr %arrayidx67, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next130 = add nuw nsw i64 %indvars.iv129, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next130, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: update_table_tick at line: combine.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%1 + %cond62) to i64) + (-1 * (zext i32 %1 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%15> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx67> = getelementptr inbounds ir<%14>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx67>
    WIDEN store vp<%6>, ir<%13>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 87
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o conflict.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         conflict.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o convert.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         convert.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cse.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cse.c
@@ Instruction =>  %21 = load i64, ptr %arrayidx85, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i64, ptr %arrayidx85, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %21 = load i64, ptr %arrayidx85, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %21 = load i64, ptr %arrayidx85, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: canon_hash' from cse.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %20 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv880 = phi 2, %indvars.iv.next881, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1813> = phi ir<%add72>, ir<%conv88>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%fld83>, ir<0>, ir<%indvars.iv880>
    CLONE ir<%21> = load ir<%arrayidx85>
    CLONE ir<%22> = trunc ir<%21>
    CLONE ir<%conv88> = add ir<%hash.1813>, ir<%22>
    CLONE ir<%indvars.iv.next881> = add nuw nsw ir<%indvars.iv880>, ir<1>
    CLONE ir<%exitcond883.not> = icmp eq ir<%indvars.iv.next881>, ir<%wide.trip.count882>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hash.1813>, ir<%conv88>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup539.loopexit>, scalar.ph

ir-bb<cleanup539.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv88.lcssa = vp<%6>
}

========== Loop: canon_hash' from cse.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %20 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv880 = phi 2, %indvars.iv.next881, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1813> = phi ir<%add72>, ir<%conv88>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%fld83>, ir<0>, ir<%indvars.iv880>
    vp<%4> = vector-pointer ir<%arrayidx85>
    WIDEN ir<%21> = load vp<%4>
    WIDEN-CAST ir<%22> = trunc  ir<%21> to i32
    WIDEN ir<%conv88> = add ir<%hash.1813>, ir<%22>
    CLONE ir<%indvars.iv.next881> = add nuw nsw ir<%indvars.iv880>, ir<1>
    CLONE ir<%exitcond883.not> = icmp eq ir<%indvars.iv.next881>, ir<%wide.trip.count882>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.1813>, ir<%conv88>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup539.loopexit>, scalar.ph

ir-bb<cleanup539.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv88.lcssa = vp<%7>
}

========== Loop: canon_hash' from cse.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %20 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv880 = phi 2, %indvars.iv.next881, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1813> = phi ir<%add72>, ir<%conv88>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%fld83>, ir<0>, ir<%indvars.iv880>
    vp<%4> = vector-pointer ir<%arrayidx85>
    WIDEN ir<%21> = load vp<%4>
    WIDEN-CAST ir<%22> = trunc  ir<%21> to i32
    WIDEN ir<%conv88> = add ir<%hash.1813>, ir<%22>
    CLONE ir<%indvars.iv.next881> = add nuw nsw ir<%indvars.iv880>, ir<1>
    CLONE ir<%exitcond883.not> = icmp eq ir<%indvars.iv.next881>, ir<%wide.trip.count882>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.1813>, ir<%conv88>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup539.loopexit>, scalar.ph

ir-bb<cleanup539.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv88.lcssa = vp<%7>
}


-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv880 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next881, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv880 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %21 = load i64, ptr %arrayidx85, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next881 = add nuw nsw i64 %indvars.iv880, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next881, %wide.trip.count882 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond883.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv880 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next881, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv880 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %21 = load i64, ptr %arrayidx85, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next881 = add nuw nsw i64 %indvars.iv880, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next881, %wide.trip.count882 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond883.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 1012
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 1012
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv880 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next881, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv880 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %21 = load i64, ptr %arrayidx85, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next881 = add nuw nsw i64 %indvars.iv880, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next881, %wide.trip.count882 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond883.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 1012
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 634
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv880 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next881, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv880 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %21 = load i64, ptr %arrayidx85, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next881 = add nuw nsw i64 %indvars.iv880, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next881, %wide.trip.count882 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond883.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 1012
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 382

-----------------Function that is being costed:'canon_hash' from cse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv880 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next881, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hash.1813 = phi i32 [ %add72, %for.body.lr.ph ], [ %conv88, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx85 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld83, i64 0, i64 %indvars.iv880 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %21 = load i64, ptr %arrayidx85, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %22 = trunc i64 %21 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv88 = add i32 %hash.1813, %22 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next881 = add nuw nsw i64 %indvars.iv880, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next881, %wide.trip.count882 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond883.not, label %cleanup539.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 1012
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 382
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: canon_hash at line: cse.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %20 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%hash.1813> = phi ir<%add72>, ir<%conv88>
    vp<%4>    = DERIVED-IV ir<2> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx85> = getelementptr inbounds ir<%fld83>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx85>
    WIDEN ir<%21> = load vp<%6>
    WIDEN-CAST ir<%22> = trunc  ir<%21> to i32
    WIDEN ir<%conv88> = add ir<%hash.1813>, ir<%22>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hash.1813>, ir<%conv88>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup539.loopexit>, scalar.ph

ir-bb<cleanup539.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv88.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 55
Loops Epilogues Vectorized: 0
================================================
========== Loop: insert' from cse.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %5 to i64))<nsw> + ((1 + (zext i32 %5 to i64))<nuw><nsw> umax ((zext i32 %5 to i64) + (zext i32 %cond78719 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or698700> = phi ir<%hard_regs_in_table.promoted>, ir<%or>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    CLONE ir<%or> = or ir<%or698700>, ir<%shl>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp80> = icmp ult ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or698700>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end82.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.if.end82.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: insert' from cse.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %5 to i64))<nsw> + ((1 + (zext i32 %5 to i64))<nuw><nsw> umax ((zext i32 %5 to i64) + (zext i32 %cond78719 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or698700> = phi ir<%hard_regs_in_table.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or698700>, ir<%shl>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp80> = icmp ult ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or698700>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end82.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.if.end82.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: insert' from cse.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %5 to i64))<nsw> + ((1 + (zext i32 %5 to i64))<nuw><nsw> umax ((zext i32 %5 to i64) + (zext i32 %cond78719 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or698700> = phi ir<%hard_regs_in_table.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or698700>, ir<%shl>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%cmp80> = icmp ult ir<%indvars.iv.next>, ir<%17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or698700>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end82.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.if.end82.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'insert' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or698700 = phi i64 [ %hard_regs_in_table.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or698700, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp80 = icmp ult i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp80, label %for.body, label %for.cond.if.end82.loopexit_crit_edge of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'insert' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or698700 = phi i64 [ %hard_regs_in_table.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or698700, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp80 = icmp ult i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp80, label %for.body, label %for.cond.if.end82.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'insert' from cse.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or698700 = phi i64 [ %hard_regs_in_table.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or698700, %shl of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp80 = icmp ult i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp80, label %for.body, label %for.cond.if.end82.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'insert' from cse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or698700 = phi i64 [ %hard_regs_in_table.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or698700, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp80 = icmp ult i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp80, label %for.body, label %for.cond.if.end82.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'insert' from cse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %16, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or698700 = phi i64 [ %hard_regs_in_table.promoted, %for.body.preheader ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or698700, %shl of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp80 = icmp ult i64 %indvars.iv.next, %17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp80, label %for.body, label %for.cond.if.end82.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: insert at line: cse.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %5 to i64))<nsw> + ((1 + (zext i32 %5 to i64))<nuw><nsw> umax ((zext i32 %5 to i64) + (zext i32 %cond78719 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %16, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%or698700> = phi ir<%hard_regs_in_table.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv>
    WIDEN ir<%or> = or ir<%or698700>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or698700>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end82.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.if.end82.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 87
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o cselib.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         cselib.c
@@ Instruction =>  %5 = load i64, ptr %arrayidx29, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i64, ptr %arrayidx29, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %5 = load i64, ptr %arrayidx29, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i64, ptr %arrayidx29, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: hash_rtx' from cselib.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %4 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv331 = phi 2, %indvars.iv.next332, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.0312> = phi ir<%add19>, ir<%conv32>
    CLONE ir<%arrayidx29> = getelementptr inbounds ir<%fld28>, ir<0>, ir<%indvars.iv331>
    CLONE ir<%5> = load ir<%arrayidx29>
    CLONE ir<%6> = trunc ir<%5>
    CLONE ir<%conv32> = add ir<%hash.0312>, ir<%6>
    CLONE ir<%indvars.iv.next332> = add nuw nsw ir<%indvars.iv331>, ir<1>
    CLONE ir<%exitcond334.not> = icmp eq ir<%indvars.iv.next332>, ir<%wide.trip.count333>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hash.0312>, ir<%conv32>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end41.loopexit>, scalar.ph

ir-bb<if.end41.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv32.lcssa = vp<%6>
}

========== Loop: hash_rtx' from cselib.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %4 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv331 = phi 2, %indvars.iv.next332, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.0312> = phi ir<%add19>, ir<%conv32>
    CLONE ir<%arrayidx29> = getelementptr inbounds ir<%fld28>, ir<0>, ir<%indvars.iv331>
    vp<%4> = vector-pointer ir<%arrayidx29>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-CAST ir<%6> = trunc  ir<%5> to i32
    WIDEN ir<%conv32> = add ir<%hash.0312>, ir<%6>
    CLONE ir<%indvars.iv.next332> = add nuw nsw ir<%indvars.iv331>, ir<1>
    CLONE ir<%exitcond334.not> = icmp eq ir<%indvars.iv.next332>, ir<%wide.trip.count333>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.0312>, ir<%conv32>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end41.loopexit>, scalar.ph

ir-bb<if.end41.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv32.lcssa = vp<%7>
}

========== Loop: hash_rtx' from cselib.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %4 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv331 = phi 2, %indvars.iv.next332, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.0312> = phi ir<%add19>, ir<%conv32>
    CLONE ir<%arrayidx29> = getelementptr inbounds ir<%fld28>, ir<0>, ir<%indvars.iv331>
    vp<%4> = vector-pointer ir<%arrayidx29>
    WIDEN ir<%5> = load vp<%4>
    WIDEN-CAST ir<%6> = trunc  ir<%5> to i32
    WIDEN ir<%conv32> = add ir<%hash.0312>, ir<%6>
    CLONE ir<%indvars.iv.next332> = add nuw nsw ir<%indvars.iv331>, ir<1>
    CLONE ir<%exitcond334.not> = icmp eq ir<%indvars.iv.next332>, ir<%wide.trip.count333>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.0312>, ir<%conv32>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end41.loopexit>, scalar.ph

ir-bb<if.end41.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv32.lcssa = vp<%7>
}


-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv331 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next332, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv331 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = load i64, ptr %arrayidx29, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next332 = add nuw nsw i64 %indvars.iv331, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond334.not = icmp eq i64 %indvars.iv.next332, %wide.trip.count333 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond334.not, label %if.end41.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv331 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next332, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv331 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = load i64, ptr %arrayidx29, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next332 = add nuw nsw i64 %indvars.iv331, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond334.not = icmp eq i64 %indvars.iv.next332, %wide.trip.count333 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond334.not, label %if.end41.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 1012
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 1012
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv331 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next332, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv331 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %5 = load i64, ptr %arrayidx29, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next332 = add nuw nsw i64 %indvars.iv331, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond334.not = icmp eq i64 %indvars.iv.next332, %wide.trip.count333 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond334.not, label %if.end41.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 1012
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 634
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv331 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next332, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv331 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %5 = load i64, ptr %arrayidx29, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next332 = add nuw nsw i64 %indvars.iv331, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond334.not = icmp eq i64 %indvars.iv.next332, %wide.trip.count333 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond334.not, label %if.end41.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 1012
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 382

-----------------Function that is being costed:'hash_rtx' from cselib.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv331 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next332, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hash.0312 = phi i32 [ %add19, %for.body.lr.ph ], [ %conv32, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx29 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld28, i64 0, i64 %indvars.iv331 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %5 = load i64, ptr %arrayidx29, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = trunc i64 %5 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv32 = add i32 %hash.0312, %6 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next332 = add nuw nsw i64 %indvars.iv331, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond334.not = icmp eq i64 %indvars.iv.next332, %wide.trip.count333 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond334.not, label %if.end41.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 1012
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 382
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: hash_rtx at line: cselib.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %4 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%hash.0312> = phi ir<%add19>, ir<%conv32>
    vp<%4>    = DERIVED-IV ir<2> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx29> = getelementptr inbounds ir<%fld28>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx29>
    WIDEN ir<%5> = load vp<%6>
    WIDEN-CAST ir<%6> = trunc  ir<%5> to i32
    WIDEN ir<%conv32> = add ir<%hash.0312>, ir<%6>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hash.0312>, ir<%conv32>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end41.loopexit>, scalar.ph

ir-bb<if.end41.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %conv32.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 12
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o dbxout.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         dbxout.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o debug.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         debug.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o dependence.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         dependence.c
========== Loop: check_node_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body142.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %i.0.lcssa to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv469 = phi 1, %indvars.iv.next470, ir<1>
    WIDEN-REDUCTION-PHI ir<%have_dependence.0441> = phi ir<false>, vp<%5>
    CLONE ir<%arrayidx144> = getelementptr inbounds ir<%direction>, ir<0>, ir<%indvars.iv469>
    CLONE ir<%24> = load ir<%arrayidx144>
    CLONE ir<%cmp146.not> = icmp eq ir<%24>, ir<6>
    EMIT vp<%4> = not ir<%cmp146.not>
    EMIT vp<%5> = or ir<%have_dependence.0441>, vp<%4>
    CLONE ir<%spec.select399> = select ir<%cmp146.not>, ir<%have_dependence.0441>, ir<1>
    CLONE ir<%indvars.iv.next470> = add nuw nsw ir<%indvars.iv469>, ir<1>
    CLONE ir<%exitcond472.not> = icmp eq ir<%indvars.iv.next470>, ir<%wide.trip.count471>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%have_dependence.0441>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end152>, scalar.ph

ir-bb<for.end152>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select399.lcssa = vp<%8>
}

========== Loop: check_node_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body142.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %i.0.lcssa to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv469 = phi 1, %indvars.iv.next470, ir<1>
    WIDEN-REDUCTION-PHI ir<%have_dependence.0441> = phi ir<false>, vp<%5>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx144> = getelementptr inbounds ir<%direction>, ir<0>, ir<%indvars.iv469>
    WIDEN ir<%24> = load ir<%arrayidx144>
    WIDEN ir<%cmp146.not> = icmp eq ir<%24>, ir<6>
    EMIT vp<%4> = not ir<%cmp146.not>
    EMIT vp<%5> = or ir<%have_dependence.0441>, vp<%4>
    WIDEN-SELECT ir<%spec.select399> = select ir<%cmp146.not>, ir<%have_dependence.0441>, ir<1>
    WIDEN ir<%indvars.iv.next470> = add nuw nsw ir<%indvars.iv469>, ir<1>
    CLONE ir<%exitcond472.not> = icmp eq ir<%indvars.iv.next470>, ir<%wide.trip.count471>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%have_dependence.0441>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end152>, scalar.ph

ir-bb<for.end152>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select399.lcssa = vp<%8>
}

========== Loop: check_node_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body142.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %i.0.lcssa to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv469 = phi 1, %indvars.iv.next470, ir<1>
    WIDEN-REDUCTION-PHI ir<%have_dependence.0441> = phi ir<false>, vp<%5>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx144> = getelementptr inbounds ir<%direction>, ir<0>, ir<%indvars.iv469>
    WIDEN ir<%24> = load ir<%arrayidx144>
    WIDEN ir<%cmp146.not> = icmp eq ir<%24>, ir<6>
    EMIT vp<%4> = not ir<%cmp146.not>
    EMIT vp<%5> = or ir<%have_dependence.0441>, vp<%4>
    WIDEN-SELECT ir<%spec.select399> = select ir<%cmp146.not>, ir<%have_dependence.0441>, ir<1>
    WIDEN ir<%indvars.iv.next470> = add nuw nsw ir<%indvars.iv469>, ir<1>
    CLONE ir<%exitcond472.not> = icmp eq ir<%indvars.iv.next470>, ir<%wide.trip.count471>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%have_dependence.0441>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end152>, scalar.ph

ir-bb<for.end152>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select399.lcssa = vp<%8>
}


-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv469 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next470, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv469 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %24 = load i32, ptr %arrayidx144, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next470 = add nuw nsw i64 %indvars.iv469, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond472.not = icmp eq i64 %indvars.iv.next470, %wide.trip.count471 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond472.not, label %for.end152, label %for.body142 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv469 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next470, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv469 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %24 = load i32, ptr %arrayidx144, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next470 = add nuw nsw i64 %indvars.iv469, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond472.not = icmp eq i64 %indvars.iv.next470, %wide.trip.count471 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond472.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901882, RTCostB: 21474836470
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901882, RTCostB: 21474836470
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv469 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next470, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv469 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %24 = load i32, ptr %arrayidx144, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next470 = add nuw nsw i64 %indvars.iv469, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond472.not = icmp eq i64 %indvars.iv.next470, %wide.trip.count471 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond472.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 9663676417, RTCostB: 21474836470
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676417, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv469 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next470, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv469 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %24 = load i32, ptr %arrayidx144, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next470 = add nuw nsw i64 %indvars.iv469, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond472.not = icmp eq i64 %indvars.iv.next470, %wide.trip.count471 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond472.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 9126805517, RTCostB: 21474836470
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9126805517, RTCostB: 9663676417
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv469 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next470, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv469 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %24 = load i32, ptr %arrayidx144, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next470 = add nuw nsw i64 %indvars.iv469, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond472.not = icmp eq i64 %indvars.iv.next470, %wide.trip.count471 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond472.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901882, RTCostB: 21474836470
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901882, RTCostB: 9126805517

-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv469 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next470, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv469 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %24 = load i32, ptr %arrayidx144, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next470 = add nuw nsw i64 %indvars.iv469, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond472.not = icmp eq i64 %indvars.iv.next470, %wide.trip.count471 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond472.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 9663676417, RTCostB: 21474836470
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 9663676417, RTCostB: 9126805517

-----------------Function that is being costed:'check_node_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv469 = phi i64 [ 1, %for.body142.preheader ], [ %indvars.iv.next470, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %have_dependence.0441 = phi i32 [ 0, %for.body142.preheader ], [ %spec.select399, %for.body142 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx144 = getelementptr inbounds [13 x [13 x i32]], ptr %direction, i64 0, i64 %indvars.iv469 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %24 = load i32, ptr %arrayidx144, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp146.not = icmp eq i32 %24, 6 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %spec.select399 = select i1 %cmp146.not, i32 %have_dependence.0441, i32 1 of type:select
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next470 = add nuw nsw i64 %indvars.iv469, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond472.not = icmp eq i64 %indvars.iv.next470, %wide.trip.count471 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond472.not, label %for.end152, label %for.body142 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 9126805517, RTCostB: 21474836470
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 9126805517, RTCostB: 9126805517
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: check_node_dependence at line: dependence.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body142.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 %i.0.lcssa to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv469 = phi 1, %indvars.iv.next470, ir<1>
    WIDEN-REDUCTION-PHI ir<%have_dependence.0441> = phi ir<false>, vp<%5>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx144> = getelementptr inbounds ir<%direction>, ir<0>, ir<%indvars.iv469>
    WIDEN ir<%24> = load ir<%arrayidx144>
    WIDEN ir<%cmp146.not> = icmp eq ir<%24>, ir<6>
    EMIT vp<%4> = not ir<%cmp146.not>
    EMIT vp<%5> = or ir<%have_dependence.0441>, vp<%4>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%have_dependence.0441>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end152>, scalar.ph

ir-bb<for.end152>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select399.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 21
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %3 = load ptr, ptr %arrayidx6, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store ptr %2, ptr %arrayidx6, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 %4, ptr %arrayidx16, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx24, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store ptr %5, ptr %arrayidx24, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 %7, ptr %arrayidx36, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx6, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store ptr %2, ptr %arrayidx6, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i32 %4, ptr %arrayidx16, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx24, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store ptr %5, ptr %arrayidx24, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i32 %7, ptr %arrayidx36, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx6, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store ptr %2, ptr %arrayidx6, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 %4, ptr %arrayidx16, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx24, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store ptr %5, ptr %arrayidx24, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 %7, ptr %arrayidx36, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx6, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store ptr %2, ptr %arrayidx6, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i32 %4, ptr %arrayidx16, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %6 = load ptr, ptr %arrayidx24, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store ptr %5, ptr %arrayidx24, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i32 %7, ptr %arrayidx36, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%icoefficients>, ir<%indvars.iv>
    CLONE ir<%variable> = getelementptr inbounds ir<%arrayidx>, ir<16>
    CLONE ir<%2> = load ir<%variable>
    CLONE ir<%cmp4.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp4.not>
    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%iiv_used>, ir<0>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx6>, vp<%4>
    CLONE ir<%tobool.not> = icmp eq ir<%3>, ir<null>
  Successor(s): if.then7

  if.then7:
    EMIT vp<%5> = logical-and vp<%4>, ir<%tobool.not>
    CLONE store ir<%2>, ir<%arrayidx6>, vp<%5>
    CLONE ir<%coefficient> = getelementptr inbounds ir<%arrayidx>, ir<4>
    CLONE ir<%4> = load ir<%coefficient>, vp<%5>
    CLONE ir<%arrayidx16> = getelementptr inbounds ir<%icoeff>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%4>, ir<%arrayidx16>, vp<%5>
  Successor(s): if.end17

  if.end17:
    EMIT vp<%6> = not ir<%tobool.not>
    EMIT vp<%7> = logical-and vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, vp<%5>
    EMIT vp<%9> = or vp<%8>, ir<%cmp4.not>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%ocoefficients>, ir<%indvars.iv>
    CLONE ir<%variable20> = getelementptr inbounds ir<%arrayidx19>, ir<16>
    CLONE ir<%5> = load ir<%variable20>
    CLONE ir<%cmp21.not> = icmp eq ir<%5>, ir<null>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%10> = not ir<%cmp21.not>
    EMIT vp<%11> = logical-and vp<%9>, vp<%10>
    CLONE ir<%arrayidx24> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv>
    CLONE ir<%6> = load ir<%arrayidx24>, vp<%11>
    CLONE ir<%tobool25.not> = icmp eq ir<%6>, ir<null>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%12> = logical-and vp<%11>, ir<%tobool25.not>
    CLONE store ir<%5>, ir<%arrayidx24>, vp<%12>
    CLONE ir<%coefficient34> = getelementptr inbounds ir<%arrayidx19>, ir<4>
    CLONE ir<%7> = load ir<%coefficient34>, vp<%12>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%ocoeff>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%7>, ir<%arrayidx36>, vp<%12>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%13> = logical-and vp<%9>, ir<%cmp21.not>
    EMIT vp<%14> = or vp<%13>, vp<%12>
    EMIT vp<%15> = not ir<%tobool25.not>
    EMIT vp<%16> = logical-and vp<%11>, vp<%15>
    EMIT vp<%17> = or vp<%14>, vp<%16>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%20> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%20>
Successor(s): ir-bb<for.cond39.preheader>, scalar.ph

ir-bb<for.cond39.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%24>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%icoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable> = getelementptr inbounds ir<%arrayidx>, ir<16>
    WIDEN ir<%2> = load ir<%variable>
    WIDEN ir<%cmp4.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp4.not>
    CLONE ir<%arrayidx6> = getelementptr ir<%iiv_used>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx6>
    WIDEN ir<%3> = load vp<%5>, vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%3>, ir<null>
  Successor(s): if.then7

  if.then7:
    EMIT vp<%6> = logical-and vp<%4>, ir<%tobool.not>
    vp<%7> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%7>, ir<%2>, vp<%6>
    WIDEN-GEP Var[Inv] ir<%coefficient> = getelementptr inbounds ir<%arrayidx>, ir<4>
    WIDEN ir<%4> = load ir<%coefficient>, vp<%6>
    CLONE ir<%arrayidx16> = getelementptr ir<%icoeff>, ir<0>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%8>, ir<%4>, vp<%6>
  Successor(s): if.end17

  if.end17:
    EMIT vp<%9> = not ir<%tobool.not>
    EMIT vp<%10> = logical-and vp<%4>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    EMIT vp<%12> = or vp<%11>, ir<%cmp4.not>
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%ocoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable20> = getelementptr inbounds ir<%arrayidx19>, ir<16>
    WIDEN ir<%5> = load ir<%variable20>
    WIDEN ir<%cmp21.not> = icmp eq ir<%5>, ir<null>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%13> = not ir<%cmp21.not>
    EMIT vp<%14> = logical-and vp<%12>, vp<%13>
    CLONE ir<%arrayidx24> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv>
    vp<%15> = vector-pointer ir<%arrayidx24>
    WIDEN ir<%6> = load vp<%15>, vp<%14>
    WIDEN ir<%tobool25.not> = icmp eq ir<%6>, ir<null>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%16> = logical-and vp<%14>, ir<%tobool25.not>
    vp<%17> = vector-pointer ir<%arrayidx24>
    WIDEN store vp<%17>, ir<%5>, vp<%16>
    WIDEN-GEP Var[Inv] ir<%coefficient34> = getelementptr inbounds ir<%arrayidx19>, ir<4>
    WIDEN ir<%7> = load ir<%coefficient34>, vp<%16>
    CLONE ir<%arrayidx36> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv>
    vp<%18> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%18>, ir<%7>, vp<%16>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%19> = logical-and vp<%12>, ir<%cmp21.not>
    EMIT vp<%20> = or vp<%19>, vp<%16>
    EMIT vp<%21> = not ir<%tobool25.not>
    EMIT vp<%22> = logical-and vp<%14>, vp<%21>
    EMIT vp<%23> = or vp<%20>, vp<%22>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%24> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%24>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%24>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%icoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable> = getelementptr inbounds ir<%arrayidx>, ir<16>
    WIDEN ir<%2> = load ir<%variable>
    WIDEN ir<%cmp4.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%cmp4.not>
    CLONE ir<%arrayidx6> = getelementptr ir<%iiv_used>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx6>
    WIDEN ir<%3> = load vp<%5>, vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%3>, ir<null>
  Successor(s): if.then7

  if.then7:
    EMIT vp<%6> = logical-and vp<%4>, ir<%tobool.not>
    vp<%7> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%7>, ir<%2>, vp<%6>
    WIDEN-GEP Var[Inv] ir<%coefficient> = getelementptr inbounds ir<%arrayidx>, ir<4>
    WIDEN ir<%4> = load ir<%coefficient>, vp<%6>
    CLONE ir<%arrayidx16> = getelementptr ir<%icoeff>, ir<0>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%8>, ir<%4>, vp<%6>
  Successor(s): if.end17

  if.end17:
    EMIT vp<%9> = not ir<%tobool.not>
    EMIT vp<%10> = logical-and vp<%4>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    EMIT vp<%12> = or vp<%11>, ir<%cmp4.not>
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%ocoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable20> = getelementptr inbounds ir<%arrayidx19>, ir<16>
    WIDEN ir<%5> = load ir<%variable20>
    WIDEN ir<%cmp21.not> = icmp eq ir<%5>, ir<null>
  Successor(s): if.then22

  if.then22:
    EMIT vp<%13> = not ir<%cmp21.not>
    EMIT vp<%14> = logical-and vp<%12>, vp<%13>
    CLONE ir<%arrayidx24> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv>
    vp<%15> = vector-pointer ir<%arrayidx24>
    WIDEN ir<%6> = load vp<%15>, vp<%14>
    WIDEN ir<%tobool25.not> = icmp eq ir<%6>, ir<null>
  Successor(s): if.then26

  if.then26:
    EMIT vp<%16> = logical-and vp<%14>, ir<%tobool25.not>
    vp<%17> = vector-pointer ir<%arrayidx24>
    WIDEN store vp<%17>, ir<%5>, vp<%16>
    WIDEN-GEP Var[Inv] ir<%coefficient34> = getelementptr inbounds ir<%arrayidx19>, ir<4>
    WIDEN ir<%7> = load ir<%coefficient34>, vp<%16>
    CLONE ir<%arrayidx36> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv>
    vp<%18> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%18>, ir<%7>, vp<%16>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%19> = logical-and vp<%12>, ir<%cmp21.not>
    EMIT vp<%20> = or vp<%19>, vp<%16>
    EMIT vp<%21> = not ir<%tobool25.not>
    EMIT vp<%22> = logical-and vp<%14>, vp<%21>
    EMIT vp<%23> = or vp<%20>, vp<%22>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%24> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%24>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = load ptr, ptr %variable, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %2, ptr %arrayidx6, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = load i32, ptr %coefficient, align 4 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %4, ptr %arrayidx16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = load ptr, ptr %variable20, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %5, ptr %arrayidx24, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %7 = load i32, ptr %coefficient34, align 4 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %7, ptr %arrayidx36, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %2 = load ptr, ptr %variable, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %2, ptr %arrayidx6, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %4 = load i32, ptr %coefficient, align 4 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %4, ptr %arrayidx16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %5 = load ptr, ptr %variable20, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %5, ptr %arrayidx24, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %7 = load i32, ptr %coefficient34, align 4 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %7, ptr %arrayidx36, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Vector loop of width 2 costs: 10
A is not scalable.	B is not scalable.	
RTCostA: 21474836470, RTCostB: 21474836470
A is not scalable.	B is not scalable.	
RTCostA: 21474836470, RTCostB: 21474836470

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %2 = load ptr, ptr %variable, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %2, ptr %arrayidx6, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %4 = load i32, ptr %coefficient, align 4 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %4, ptr %arrayidx16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %5 = load ptr, ptr %variable20, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %5, ptr %arrayidx24, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %7 = load i32, ptr %coefficient34, align 4 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %7, ptr %arrayidx36, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Vector loop of width 4 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 19864223737, RTCostB: 21474836470
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 19864223737, RTCostB: 21474836470
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %2 = load ptr, ptr %variable, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %2, ptr %arrayidx6, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %4 = load i32, ptr %coefficient, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %4, ptr %arrayidx16, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %5 = load ptr, ptr %variable20, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %5, ptr %arrayidx24, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %7 = load i32, ptr %coefficient34, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %7, ptr %arrayidx36, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 21474836470, RTCostB: 21474836470
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 21474836470, RTCostB: 19864223737

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %struct.subscript, ptr %icoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %variable = getelementptr inbounds i8, ptr %arrayidx, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %2 = load ptr, ptr %variable, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp4.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp4.not, label %if.end17, label %if.then of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx6 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %3 = load ptr, ptr %arrayidx6, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool.not = icmp eq ptr %3, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %if.then7, label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %2, ptr %arrayidx6, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %coefficient = getelementptr inbounds i8, ptr %arrayidx, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %4 = load i32, ptr %coefficient, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx16 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %4, ptr %arrayidx16, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end17 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds %struct.subscript, ptr %ocoefficients, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %variable20 = getelementptr inbounds i8, ptr %arrayidx19, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %5 = load ptr, ptr %variable20, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp21.not = icmp eq ptr %5, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp21.not, label %for.inc, label %if.then22 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx24 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %6 = load ptr, ptr %arrayidx24, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool25.not = icmp eq ptr %6, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool25.not, label %if.then26, label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %5, ptr %arrayidx24, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %coefficient34 = getelementptr inbounds i8, ptr %arrayidx19, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %7 = load i32, ptr %coefficient34, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx36 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %7, ptr %arrayidx36, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond39.preheader, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 9
A is scalable.	B is not scalable.	
RTCostA: 19864223737, RTCostB: 21474836470
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 19864223737, RTCostB: 19864223737
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 9.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: classify_dependence at line: dependence.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%18>
    WIDEN-INDUCTION %indvars.iv = phi 1, %indvars.iv.next, ir<1>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%icoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable> = getelementptr inbounds ir<%arrayidx>, ir<16>
    WIDEN ir<%2> = load ir<%variable>
    WIDEN ir<%cmp4.not> = icmp eq ir<%2>, ir<null>
    EMIT vp<%6> = not ir<%cmp4.not>
    CLONE ir<%arrayidx6> = getelementptr ir<%iiv_used>, ir<0>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx6>
    WIDEN ir<%3> = load vp<%7>, vp<%6>
    WIDEN ir<%tobool.not> = icmp eq ir<%3>, ir<null>
    EMIT vp<%8> = logical-and vp<%6>, ir<%tobool.not>
    vp<%9> = vector-pointer ir<%arrayidx6>
    WIDEN store vp<%9>, ir<%2>, vp<%8>
    WIDEN-GEP Var[Inv] ir<%coefficient> = getelementptr inbounds ir<%arrayidx>, ir<4>
    WIDEN ir<%4> = load ir<%coefficient>, vp<%8>
    CLONE ir<%arrayidx16> = getelementptr ir<%icoeff>, ir<0>, vp<%5>
    vp<%10> = vector-pointer ir<%arrayidx16>
    WIDEN store vp<%10>, ir<%4>, vp<%8>
    EMIT vp<%11> = or vp<%6>, ir<%cmp4.not>
    WIDEN-GEP Inv[Var] ir<%arrayidx19> = getelementptr inbounds ir<%ocoefficients>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%variable20> = getelementptr inbounds ir<%arrayidx19>, ir<16>
    WIDEN ir<%5> = load ir<%variable20>
    WIDEN ir<%cmp21.not> = icmp eq ir<%5>, ir<null>
    EMIT vp<%12> = not ir<%cmp21.not>
    EMIT vp<%13> = logical-and vp<%11>, vp<%12>
    CLONE ir<%arrayidx24> = getelementptr ir<%oiv_used>, ir<0>, vp<%5>
    vp<%14> = vector-pointer ir<%arrayidx24>
    WIDEN ir<%6> = load vp<%14>, vp<%13>
    WIDEN ir<%tobool25.not> = icmp eq ir<%6>, ir<null>
    EMIT vp<%15> = logical-and vp<%13>, ir<%tobool25.not>
    vp<%16> = vector-pointer ir<%arrayidx24>
    WIDEN store vp<%16>, ir<%5>, vp<%15>
    WIDEN-GEP Var[Inv] ir<%coefficient34> = getelementptr inbounds ir<%arrayidx19>, ir<4>
    WIDEN ir<%7> = load ir<%coefficient34>, vp<%15>
    CLONE ir<%arrayidx36> = getelementptr ir<%ocoeff>, ir<0>, vp<%5>
    vp<%17> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%17>, ir<%7>, vp<%15>
    EMIT vp<%18> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%18>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %49 = load ptr, ptr %arrayidx43, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %50 = load ptr, ptr %arrayidx46, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %51 = load i32, ptr %arrayidx58, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %53 = load i32, ptr %arrayidx84, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 5, ptr %arrayidx91, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 3, ptr %arrayidx88, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %52 = load i32, ptr %arrayidx60, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 2, ptr %arrayidx73, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 4, ptr %arrayidx73, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx64, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx50, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %49 = load ptr, ptr %arrayidx43, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %50 = load ptr, ptr %arrayidx46, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %51 = load i32, ptr %arrayidx58, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %53 = load i32, ptr %arrayidx84, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 5, ptr %arrayidx91, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 3, ptr %arrayidx88, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %52 = load i32, ptr %arrayidx60, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 2, ptr %arrayidx73, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 4, ptr %arrayidx73, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx64, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx50, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %49 = load ptr, ptr %arrayidx43, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %50 = load ptr, ptr %arrayidx46, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %51 = load i32, ptr %arrayidx58, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %53 = load i32, ptr %arrayidx84, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 5, ptr %arrayidx91, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 3, ptr %arrayidx88, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %52 = load i32, ptr %arrayidx60, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 2, ptr %arrayidx73, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 4, ptr %arrayidx73, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx64, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx50, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %49 = load ptr, ptr %arrayidx43, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %50 = load ptr, ptr %arrayidx46, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %51 = load i32, ptr %arrayidx58, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %53 = load i32, ptr %arrayidx84, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 5, ptr %arrayidx91, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 3, ptr %arrayidx88, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %52 = load i32, ptr %arrayidx60, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 2, ptr %arrayidx73, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 4, ptr %arrayidx73, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 1, ptr %arrayidx64, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx50, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%26>
    WIDEN-INDUCTION %indvars.iv193 = phi 1, %indvars.iv.next194, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<%iiv_used>, ir<0>, ir<%indvars.iv193>
    CLONE ir<%49> = load ir<%arrayidx43>
    CLONE ir<%cmp44> = icmp eq ir<%49>, ir<null>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv193>
    CLONE ir<%50> = load ir<%arrayidx46>
    CLONE ir<%cmp47> = icmp eq ir<%50>, ir<null>
    CLONE ir<%or.cond> = select ir<%cmp44>, ir<%cmp47>, ir<false>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%or.cond>
    CLONE ir<%cmp55> = icmp eq ir<%49>, ir<%50>
    CLONE ir<%arrayidx58> = getelementptr inbounds ir<%icoeff>, ir<0>, ir<%indvars.iv193>
    CLONE ir<%51> = load ir<%arrayidx58>, vp<%4>
  Successor(s): if.else79

  if.else79:
    EMIT vp<%5> = not ir<%cmp55>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%cmp82> = icmp eq ir<%51>, ir<0>
  Successor(s): lor.lhs.false

  lor.lhs.false:
    EMIT vp<%7> = not ir<%cmp82>
    EMIT vp<%8> = logical-and vp<%6>, vp<%7>
    CLONE ir<%arrayidx84> = getelementptr inbounds ir<%ocoeff>, ir<0>, ir<%indvars.iv193>
    CLONE ir<%53> = load ir<%arrayidx84>, vp<%8>
    CLONE ir<%cmp85> = icmp eq ir<%53>, ir<0>
  Successor(s): if.else89

  if.else89:
    EMIT vp<%9> = not ir<%cmp85>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    CLONE ir<%arrayidx91> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv193>
    CLONE store ir<5>, ir<%arrayidx91>, vp<%10>
  Successor(s): if.then86

  if.then86:
    EMIT vp<%11> = logical-and vp<%8>, ir<%cmp85>
    EMIT vp<%12> = logical-and vp<%6>, ir<%cmp82>
    EMIT vp<%13> = or vp<%11>, vp<%12>
    CLONE ir<%arrayidx88> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv193>
    CLONE store ir<3>, ir<%arrayidx88>, vp<%13>
  Successor(s): if.then56

  if.then56:
    EMIT vp<%14> = logical-and vp<%4>, ir<%cmp55>
    CLONE ir<%arrayidx60> = getelementptr inbounds ir<%ocoeff>, ir<0>, ir<%indvars.iv193>
    CLONE ir<%52> = load ir<%arrayidx60>, vp<%14>
    CLONE ir<%cmp61> = icmp eq ir<%51>, ir<%52>
  Successor(s): if.else65

  if.else65:
    EMIT vp<%15> = not ir<%cmp61>
    EMIT vp<%16> = logical-and vp<%14>, vp<%15>
    CLONE ir<%mul> = sub nsw ir<0>, ir<%52>
    CLONE ir<%cmp70> = icmp eq ir<%51>, ir<%mul>
    CLONE ir<%arrayidx73> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv193>
  Successor(s): if.else74

  if.else74:
    EMIT vp<%17> = not ir<%cmp70>
    EMIT vp<%18> = logical-and vp<%16>, vp<%17>
    CLONE store ir<2>, ir<%arrayidx73>, vp<%18>
  Successor(s): if.then71

  if.then71:
    EMIT vp<%19> = logical-and vp<%16>, ir<%cmp70>
    CLONE store ir<4>, ir<%arrayidx73>, vp<%19>
  Successor(s): if.then62

  if.then62:
    EMIT vp<%20> = logical-and vp<%14>, ir<%cmp61>
    CLONE ir<%arrayidx64> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv193>
    CLONE store ir<1>, ir<%arrayidx64>, vp<%20>
  Successor(s): if.then48

  if.then48:
    CLONE ir<%arrayidx50> = getelementptr inbounds ir<%complexity>, ir<%indvars.iv193>
    CLONE store ir<0>, ir<%arrayidx50>, ir<%or.cond>
  Successor(s): for.inc95

  for.inc95:
    EMIT vp<%21> = or ir<%or.cond>, vp<%13>
    EMIT vp<%22> = or vp<%21>, vp<%10>
    EMIT vp<%23> = or vp<%22>, vp<%20>
    EMIT vp<%24> = or vp<%23>, vp<%18>
    EMIT vp<%25> = or vp<%24>, vp<%19>
    CLONE ir<%indvars.iv.next194> = add nuw nsw ir<%indvars.iv193>, ir<1>
    CLONE ir<%exitcond196.not> = icmp eq ir<%indvars.iv.next194>, ir<%wide.trip.count195>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%26> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%26>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%28> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%28>
Successor(s): ir-bb<for.end97>, scalar.ph

ir-bb<for.end97>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%37>
    WIDEN-INDUCTION %indvars.iv193 = phi 1, %indvars.iv.next194, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<%iiv_used>, ir<0>, ir<%indvars.iv193>
    vp<%4> = vector-pointer ir<%arrayidx43>
    WIDEN ir<%49> = load vp<%4>
    WIDEN ir<%cmp44> = icmp eq ir<%49>, ir<null>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv193>
    vp<%5> = vector-pointer ir<%arrayidx46>
    WIDEN ir<%50> = load vp<%5>
    WIDEN ir<%cmp47> = icmp eq ir<%50>, ir<null>
    WIDEN-SELECT ir<%or.cond> = select ir<%cmp44>, ir<%cmp47>, ir<false>
  Successor(s): if.else

  if.else:
    EMIT vp<%6> = not ir<%or.cond>
    WIDEN ir<%cmp55> = icmp eq ir<%49>, ir<%50>
    CLONE ir<%arrayidx58> = getelementptr ir<%icoeff>, ir<0>, ir<%indvars.iv193>
    vp<%7> = vector-pointer ir<%arrayidx58>
    WIDEN ir<%51> = load vp<%7>, vp<%6>
  Successor(s): if.else79

  if.else79:
    EMIT vp<%8> = not ir<%cmp55>
    EMIT vp<%9> = logical-and vp<%6>, vp<%8>
    WIDEN ir<%cmp82> = icmp eq ir<%51>, ir<0>
  Successor(s): lor.lhs.false

  lor.lhs.false:
    EMIT vp<%10> = not ir<%cmp82>
    EMIT vp<%11> = logical-and vp<%9>, vp<%10>
    CLONE ir<%arrayidx84> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv193>
    vp<%12> = vector-pointer ir<%arrayidx84>
    WIDEN ir<%53> = load vp<%12>, vp<%11>
    WIDEN ir<%cmp85> = icmp eq ir<%53>, ir<0>
  Successor(s): if.else89

  if.else89:
    EMIT vp<%13> = not ir<%cmp85>
    EMIT vp<%14> = logical-and vp<%11>, vp<%13>
    CLONE ir<%arrayidx91> = getelementptr ir<%complexity>, ir<%indvars.iv193>
    vp<%15> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%15>, ir<5>, vp<%14>
  Successor(s): if.then86

  if.then86:
    EMIT vp<%16> = logical-and vp<%11>, ir<%cmp85>
    EMIT vp<%17> = logical-and vp<%9>, ir<%cmp82>
    EMIT vp<%18> = or vp<%16>, vp<%17>
    CLONE ir<%arrayidx88> = getelementptr ir<%complexity>, ir<%indvars.iv193>
    vp<%19> = vector-pointer ir<%arrayidx88>
    WIDEN store vp<%19>, ir<3>, vp<%18>
  Successor(s): if.then56

  if.then56:
    EMIT vp<%20> = logical-and vp<%6>, ir<%cmp55>
    CLONE ir<%arrayidx60> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv193>
    vp<%21> = vector-pointer ir<%arrayidx60>
    WIDEN ir<%52> = load vp<%21>, vp<%20>
    WIDEN ir<%cmp61> = icmp eq ir<%51>, ir<%52>
  Successor(s): if.else65

  if.else65:
    EMIT vp<%22> = not ir<%cmp61>
    EMIT vp<%23> = logical-and vp<%20>, vp<%22>
    WIDEN ir<%mul> = sub nsw ir<0>, ir<%52>
    WIDEN ir<%cmp70> = icmp eq ir<%51>, ir<%mul>
    CLONE ir<%arrayidx73> = getelementptr ir<%complexity>, ir<%indvars.iv193>
  Successor(s): if.else74

  if.else74:
    EMIT vp<%24> = not ir<%cmp70>
    EMIT vp<%25> = logical-and vp<%23>, vp<%24>
    vp<%26> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%26>, ir<2>, vp<%25>
  Successor(s): if.then71

  if.then71:
    EMIT vp<%27> = logical-and vp<%23>, ir<%cmp70>
    vp<%28> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%28>, ir<4>, vp<%27>
  Successor(s): if.then62

  if.then62:
    EMIT vp<%29> = logical-and vp<%20>, ir<%cmp61>
    CLONE ir<%arrayidx64> = getelementptr ir<%complexity>, ir<%indvars.iv193>
    vp<%30> = vector-pointer ir<%arrayidx64>
    WIDEN store vp<%30>, ir<1>, vp<%29>
  Successor(s): if.then48

  if.then48:
    CLONE ir<%arrayidx50> = getelementptr ir<%complexity>, ir<%indvars.iv193>
    vp<%31> = vector-pointer ir<%arrayidx50>
    WIDEN store vp<%31>, ir<0>, ir<%or.cond>
  Successor(s): for.inc95

  for.inc95:
    EMIT vp<%32> = or ir<%or.cond>, vp<%18>
    EMIT vp<%33> = or vp<%32>, vp<%14>
    EMIT vp<%34> = or vp<%33>, vp<%29>
    EMIT vp<%35> = or vp<%34>, vp<%25>
    EMIT vp<%36> = or vp<%35>, vp<%27>
    CLONE ir<%indvars.iv.next194> = add nuw nsw ir<%indvars.iv193>, ir<1>
    CLONE ir<%exitcond196.not> = icmp eq ir<%indvars.iv.next194>, ir<%wide.trip.count195>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%37> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%37>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%39> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%39>
Successor(s): ir-bb<for.end97>, scalar.ph

ir-bb<for.end97>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%37>
    WIDEN-INDUCTION %indvars.iv193 = phi 1, %indvars.iv.next194, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<%iiv_used>, ir<0>, ir<%indvars.iv193>
    vp<%4> = vector-pointer ir<%arrayidx43>
    WIDEN ir<%49> = load vp<%4>
    WIDEN ir<%cmp44> = icmp eq ir<%49>, ir<null>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv193>
    vp<%5> = vector-pointer ir<%arrayidx46>
    WIDEN ir<%50> = load vp<%5>
    WIDEN ir<%cmp47> = icmp eq ir<%50>, ir<null>
    WIDEN-SELECT ir<%or.cond> = select ir<%cmp44>, ir<%cmp47>, ir<false>
  Successor(s): if.else

  if.else:
    EMIT vp<%6> = not ir<%or.cond>
    WIDEN ir<%cmp55> = icmp eq ir<%49>, ir<%50>
    CLONE ir<%arrayidx58> = getelementptr ir<%icoeff>, ir<0>, ir<%indvars.iv193>
    vp<%7> = vector-pointer ir<%arrayidx58>
    WIDEN ir<%51> = load vp<%7>, vp<%6>
  Successor(s): if.else79

  if.else79:
    EMIT vp<%8> = not ir<%cmp55>
    EMIT vp<%9> = logical-and vp<%6>, vp<%8>
    WIDEN ir<%cmp82> = icmp eq ir<%51>, ir<0>
  Successor(s): lor.lhs.false

  lor.lhs.false:
    EMIT vp<%10> = not ir<%cmp82>
    EMIT vp<%11> = logical-and vp<%9>, vp<%10>
    CLONE ir<%arrayidx84> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv193>
    vp<%12> = vector-pointer ir<%arrayidx84>
    WIDEN ir<%53> = load vp<%12>, vp<%11>
    WIDEN ir<%cmp85> = icmp eq ir<%53>, ir<0>
  Successor(s): if.else89

  if.else89:
    EMIT vp<%13> = not ir<%cmp85>
    EMIT vp<%14> = logical-and vp<%11>, vp<%13>
    CLONE ir<%arrayidx91> = getelementptr ir<%complexity>, ir<%indvars.iv193>
    vp<%15> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%15>, ir<5>, vp<%14>
  Successor(s): if.then86

  if.then86:
    EMIT vp<%16> = logical-and vp<%11>, ir<%cmp85>
    EMIT vp<%17> = logical-and vp<%9>, ir<%cmp82>
    EMIT vp<%18> = or vp<%16>, vp<%17>
    CLONE ir<%arrayidx88> = getelementptr ir<%complexity>, ir<%indvars.iv193>
    vp<%19> = vector-pointer ir<%arrayidx88>
    WIDEN store vp<%19>, ir<3>, vp<%18>
  Successor(s): if.then56

  if.then56:
    EMIT vp<%20> = logical-and vp<%6>, ir<%cmp55>
    CLONE ir<%arrayidx60> = getelementptr ir<%ocoeff>, ir<0>, ir<%indvars.iv193>
    vp<%21> = vector-pointer ir<%arrayidx60>
    WIDEN ir<%52> = load vp<%21>, vp<%20>
    WIDEN ir<%cmp61> = icmp eq ir<%51>, ir<%52>
  Successor(s): if.else65

  if.else65:
    EMIT vp<%22> = not ir<%cmp61>
    EMIT vp<%23> = logical-and vp<%20>, vp<%22>
    WIDEN ir<%mul> = sub nsw ir<0>, ir<%52>
    WIDEN ir<%cmp70> = icmp eq ir<%51>, ir<%mul>
    CLONE ir<%arrayidx73> = getelementptr ir<%complexity>, ir<%indvars.iv193>
  Successor(s): if.else74

  if.else74:
    EMIT vp<%24> = not ir<%cmp70>
    EMIT vp<%25> = logical-and vp<%23>, vp<%24>
    vp<%26> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%26>, ir<2>, vp<%25>
  Successor(s): if.then71

  if.then71:
    EMIT vp<%27> = logical-and vp<%23>, ir<%cmp70>
    vp<%28> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%28>, ir<4>, vp<%27>
  Successor(s): if.then62

  if.then62:
    EMIT vp<%29> = logical-and vp<%20>, ir<%cmp61>
    CLONE ir<%arrayidx64> = getelementptr ir<%complexity>, ir<%indvars.iv193>
    vp<%30> = vector-pointer ir<%arrayidx64>
    WIDEN store vp<%30>, ir<1>, vp<%29>
  Successor(s): if.then48

  if.then48:
    CLONE ir<%arrayidx50> = getelementptr ir<%complexity>, ir<%indvars.iv193>
    vp<%31> = vector-pointer ir<%arrayidx50>
    WIDEN store vp<%31>, ir<0>, ir<%or.cond>
  Successor(s): for.inc95

  for.inc95:
    EMIT vp<%32> = or ir<%or.cond>, vp<%18>
    EMIT vp<%33> = or vp<%32>, vp<%14>
    EMIT vp<%34> = or vp<%33>, vp<%29>
    EMIT vp<%35> = or vp<%34>, vp<%25>
    EMIT vp<%36> = or vp<%35>, vp<%27>
    CLONE ir<%indvars.iv.next194> = add nuw nsw ir<%indvars.iv193>, ir<1>
    CLONE ir<%exitcond196.not> = icmp eq ir<%indvars.iv.next194>, ir<%wide.trip.count195>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%37> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%37>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%39> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%39>
Successor(s): ir-bb<for.end97>, scalar.ph

ir-bb<for.end97>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv193 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next194, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %49 = load ptr, ptr %arrayidx43, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp44 = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %50 = load ptr, ptr %arrayidx46, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp47 = icmp eq ptr %50, null of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp55 = icmp eq ptr %49, %50 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %51 = load i32, ptr %arrayidx58, align 4 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp82 = icmp eq i32 %51, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %53 = load i32, ptr %arrayidx84, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp85 = icmp eq i32 %53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 5, ptr %arrayidx91, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 3, ptr %arrayidx88, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %52 = load i32, ptr %arrayidx60, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp61 = icmp eq i32 %51, %52 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul = sub nsw i32 0, %52 of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp70 = icmp eq i32 %51, %mul of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 2, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 4, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1, ptr %arrayidx64, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 0, ptr %arrayidx50, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next194 = add nuw nsw i64 %indvars.iv193, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond196.not = icmp eq i64 %indvars.iv.next194, %wide.trip.count195 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond196.not, label %for.end97, label %for.body41 of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv193 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next194, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %49 = load ptr, ptr %arrayidx43, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp44 = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %50 = load ptr, ptr %arrayidx46, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp47 = icmp eq ptr %50, null of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp55 = icmp eq ptr %49, %50 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %51 = load i32, ptr %arrayidx58, align 4 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp82 = icmp eq i32 %51, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %53 = load i32, ptr %arrayidx84, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp85 = icmp eq i32 %53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 5, ptr %arrayidx91, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 3, ptr %arrayidx88, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %52 = load i32, ptr %arrayidx60, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp61 = icmp eq i32 %51, %52 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul = sub nsw i32 0, %52 of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp70 = icmp eq i32 %51, %mul of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 2, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 4, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 1, ptr %arrayidx64, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 0, ptr %arrayidx50, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next194 = add nuw nsw i64 %indvars.iv193, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond196.not = icmp eq i64 %indvars.iv.next194, %wide.trip.count195 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond196.not, label %for.end97, label %for.body41 of type:br
LV: Vector loop of width 2 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 23622320117, RTCostB: 23622320117
A is not scalable.	B is not scalable.	
RTCostA: 23622320117, RTCostB: 23622320117

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv193 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next194, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %49 = load ptr, ptr %arrayidx43, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp44 = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %50 = load ptr, ptr %arrayidx46, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp47 = icmp eq ptr %50, null of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp55 = icmp eq ptr %49, %50 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %51 = load i32, ptr %arrayidx58, align 4 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp82 = icmp eq i32 %51, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %53 = load i32, ptr %arrayidx84, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp85 = icmp eq i32 %53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 5, ptr %arrayidx91, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 3, ptr %arrayidx88, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %52 = load i32, ptr %arrayidx60, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp61 = icmp eq i32 %51, %52 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul = sub nsw i32 0, %52 of type:sub
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp70 = icmp eq i32 %51, %mul of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 2, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 4, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 1, ptr %arrayidx64, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 0, ptr %arrayidx50, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next194 = add nuw nsw i64 %indvars.iv193, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond196.not = icmp eq i64 %indvars.iv.next194, %wide.trip.count195 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond196.not, label %for.end97, label %for.body41 of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 14495514630, RTCostB: 23622320117
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 14495514630, RTCostB: 23622320117
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv193 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next194, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %49 = load ptr, ptr %arrayidx43, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp44 = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %50 = load ptr, ptr %arrayidx46, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp47 = icmp eq ptr %50, null of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp55 = icmp eq ptr %49, %50 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %51 = load i32, ptr %arrayidx58, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp82 = icmp eq i32 %51, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %53 = load i32, ptr %arrayidx84, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp85 = icmp eq i32 %53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 5, ptr %arrayidx91, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 3, ptr %arrayidx88, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %52 = load i32, ptr %arrayidx60, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp61 = icmp eq i32 %51, %52 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %mul = sub nsw i32 0, %52 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp70 = icmp eq i32 %51, %mul of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 2, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 4, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 1, ptr %arrayidx64, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx50, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next194 = add nuw nsw i64 %indvars.iv193, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond196.not = icmp eq i64 %indvars.iv.next194, %wide.trip.count195 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond196.not, label %for.end97, label %for.body41 of type:br
LV: Vector loop of width vscale x 1 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 23622320117, RTCostB: 23622320117
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 23622320117, RTCostB: 14495514630

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv193 = phi i64 [ 1, %for.body41.preheader ], [ %indvars.iv.next194, %for.inc95 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx43 = getelementptr inbounds [13 x ptr], ptr %iiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %49 = load ptr, ptr %arrayidx43, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp44 = icmp eq ptr %49, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx46 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %50 = load ptr, ptr %arrayidx46, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp47 = icmp eq ptr %50, null of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond = select i1 %cmp44, i1 %cmp47, i1 false of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond, label %if.then48, label %if.else of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp55 = icmp eq ptr %49, %50 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx58 = getelementptr inbounds [13 x i32], ptr %icoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %51 = load i32, ptr %arrayidx58, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp55, label %if.then56, label %if.else79 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp82 = icmp eq i32 %51, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp82, label %if.then86, label %lor.lhs.false of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx84 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %53 = load i32, ptr %arrayidx84, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp85 = icmp eq i32 %53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp85, label %if.then86, label %if.else89 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx91 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 5, ptr %arrayidx91, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx88 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 3, ptr %arrayidx88, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx60 = getelementptr inbounds [13 x i32], ptr %ocoeff, i64 0, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %52 = load i32, ptr %arrayidx60, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp61 = icmp eq i32 %51, %52 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp61, label %if.then62, label %if.else65 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul = sub nsw i32 0, %52 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp70 = icmp eq i32 %51, %mul of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx73 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp70, label %if.then71, label %if.else74 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 2, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 4, ptr %arrayidx73, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx64 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 1, ptr %arrayidx64, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx50 = getelementptr inbounds i32, ptr %complexity, i64 %indvars.iv193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx50, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc95 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next194 = add nuw nsw i64 %indvars.iv193, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond196.not = icmp eq i64 %indvars.iv.next194, %wide.trip.count195 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond196.not, label %for.end97, label %for.body41 of type:br
LV: Vector loop of width vscale x 2 costs: 6
A is scalable.	B is not scalable.	
RTCostA: 14495514630, RTCostB: 23622320117
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 14495514630, RTCostB: 14495514630
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 6.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: classify_dependence at line: dependence.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body41.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%34>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<%iiv_used>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx43>
    WIDEN ir<%49> = load vp<%6>
    WIDEN ir<%cmp44> = icmp eq ir<%49>, ir<null>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%oiv_used>, ir<0>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx46>
    WIDEN ir<%50> = load vp<%7>
    WIDEN ir<%cmp47> = icmp eq ir<%50>, ir<null>
    WIDEN-SELECT ir<%or.cond> = select ir<%cmp44>, ir<%cmp47>, ir<false>
    EMIT vp<%8> = not ir<%or.cond>
    WIDEN ir<%cmp55> = icmp eq ir<%49>, ir<%50>
    CLONE ir<%arrayidx58> = getelementptr ir<%icoeff>, ir<0>, vp<%5>
    vp<%9> = vector-pointer ir<%arrayidx58>
    WIDEN ir<%51> = load vp<%9>, vp<%8>
    EMIT vp<%10> = not ir<%cmp55>
    EMIT vp<%11> = logical-and vp<%8>, vp<%10>
    WIDEN ir<%cmp82> = icmp eq ir<%51>, ir<0>
    EMIT vp<%12> = not ir<%cmp82>
    EMIT vp<%13> = logical-and vp<%11>, vp<%12>
    CLONE ir<%arrayidx84> = getelementptr ir<%ocoeff>, ir<0>, vp<%5>
    vp<%14> = vector-pointer ir<%arrayidx84>
    WIDEN ir<%53> = load vp<%14>, vp<%13>
    WIDEN ir<%cmp85> = icmp eq ir<%53>, ir<0>
    EMIT vp<%15> = not ir<%cmp85>
    EMIT vp<%16> = logical-and vp<%13>, vp<%15>
    CLONE ir<%arrayidx91> = getelementptr ir<%complexity>, vp<%5>
    vp<%17> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%17>, ir<5>, vp<%16>
    EMIT vp<%18> = logical-and vp<%13>, ir<%cmp85>
    EMIT vp<%19> = logical-and vp<%11>, ir<%cmp82>
    EMIT vp<%20> = or vp<%18>, vp<%19>
    CLONE ir<%arrayidx88> = getelementptr ir<%complexity>, vp<%5>
    vp<%21> = vector-pointer ir<%arrayidx88>
    WIDEN store vp<%21>, ir<3>, vp<%20>
    EMIT vp<%22> = logical-and vp<%8>, ir<%cmp55>
    CLONE ir<%arrayidx60> = getelementptr ir<%ocoeff>, ir<0>, vp<%5>
    vp<%23> = vector-pointer ir<%arrayidx60>
    WIDEN ir<%52> = load vp<%23>, vp<%22>
    WIDEN ir<%cmp61> = icmp eq ir<%51>, ir<%52>
    EMIT vp<%24> = not ir<%cmp61>
    EMIT vp<%25> = logical-and vp<%22>, vp<%24>
    WIDEN ir<%mul> = sub nsw ir<0>, ir<%52>
    WIDEN ir<%cmp70> = icmp eq ir<%51>, ir<%mul>
    CLONE ir<%arrayidx73> = getelementptr ir<%complexity>, vp<%5>
    EMIT vp<%26> = not ir<%cmp70>
    EMIT vp<%27> = logical-and vp<%25>, vp<%26>
    vp<%28> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%28>, ir<2>, vp<%27>
    EMIT vp<%29> = logical-and vp<%25>, ir<%cmp70>
    vp<%30> = vector-pointer ir<%arrayidx73>
    WIDEN store vp<%30>, ir<4>, vp<%29>
    EMIT vp<%31> = logical-and vp<%22>, ir<%cmp61>
    CLONE ir<%arrayidx64> = getelementptr ir<%complexity>, vp<%5>
    vp<%32> = vector-pointer ir<%arrayidx64>
    WIDEN store vp<%32>, ir<1>, vp<%31>
    CLONE ir<%arrayidx50> = getelementptr ir<%complexity>, vp<%5>
    vp<%33> = vector-pointer ir<%arrayidx50>
    WIDEN store vp<%33>, ir<0>, ir<%or.cond>
    EMIT vp<%34> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%34>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%36> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%36>
Successor(s): ir-bb<for.end97>, scalar.ph

ir-bb<for.end97>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %101 = load ptr, ptr %arrayidx111, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %101 = load ptr, ptr %arrayidx111, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  %101 = load ptr, ptr %arrayidx111, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %101 = load ptr, ptr %arrayidx111, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond101.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    WIDEN-INDUCTION %indvars.iv197 = phi 1, %indvars.iv.next198, ir<1>
    CLONE ir<%cmp104.not> = icmp eq ir<%indvars.iv201>, ir<%indvars.iv197>
  Successor(s): land.lhs.true105

  land.lhs.true105:
    EMIT vp<%4> = not ir<%cmp104.not>
    CLONE ir<%100> = load ir<%arrayidx107>, vp<%4>
    CLONE ir<%tobool108.not> = icmp eq ir<%100>, ir<null>
  Successor(s): land.lhs.true109

  land.lhs.true109:
    EMIT vp<%5> = not ir<%tobool108.not>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%arrayidx111> = getelementptr inbounds ir<%oiv_used>, ir<0>, ir<%indvars.iv197>
    CLONE ir<%101> = load ir<%arrayidx111>, vp<%6>
    CLONE ir<%cmp118> = icmp eq ir<%100>, ir<%101>
  Successor(s): if.then119

  if.then119:
    EMIT vp<%7> = logical-and vp<%6>, ir<%cmp118>
    CLONE store ir<0>, ir<%separability>, vp<%7>
  Successor(s): for.inc121

  for.inc121:
    EMIT vp<%8> = logical-and vp<%4>, ir<%tobool108.not>
    EMIT vp<%9> = or ir<%cmp104.not>, vp<%8>
    EMIT vp<%10> = not ir<%cmp118>
    EMIT vp<%11> = logical-and vp<%6>, vp<%10>
    EMIT vp<%12> = or vp<%9>, vp<%11>
    EMIT vp<%13> = or vp<%12>, vp<%7>
    CLONE ir<%indvars.iv.next198> = add nuw nsw ir<%indvars.iv197>, ir<1>
    CLONE ir<%exitcond200.not> = icmp eq ir<%indvars.iv.next198>, ir<%wide.trip.count203>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%16>
Successor(s): ir-bb<for.cond101.for.inc124_crit_edge>, scalar.ph

ir-bb<for.cond101.for.inc124_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond101.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv197 = phi 1, %indvars.iv.next198, ir<1>
    WIDEN ir<%cmp104.not> = icmp eq ir<%indvars.iv201>, ir<%indvars.iv197>
  Successor(s): land.lhs.true105

  land.lhs.true105:
    EMIT vp<%4> = not ir<%cmp104.not>
    WIDEN ir<%100> = load ir<%arrayidx107>, vp<%4>
    WIDEN ir<%tobool108.not> = icmp eq ir<%100>, ir<null>
  Successor(s): land.lhs.true109

  land.lhs.true109:
    EMIT vp<%5> = not ir<%tobool108.not>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%arrayidx111> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv197>
    vp<%7> = vector-pointer ir<%arrayidx111>
    WIDEN ir<%101> = load vp<%7>, vp<%6>
    WIDEN ir<%cmp118> = icmp eq ir<%100>, ir<%101>
  Successor(s): if.then119

  if.then119:
    EMIT vp<%8> = logical-and vp<%6>, ir<%cmp118>
    WIDEN store ir<%separability>, ir<0>, vp<%8>
  Successor(s): for.inc121

  for.inc121:
    EMIT vp<%9> = logical-and vp<%4>, ir<%tobool108.not>
    EMIT vp<%10> = or ir<%cmp104.not>, vp<%9>
    EMIT vp<%11> = not ir<%cmp118>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    EMIT vp<%14> = or vp<%13>, vp<%8>
    WIDEN ir<%indvars.iv.next198> = add nuw nsw ir<%indvars.iv197>, ir<1>
    CLONE ir<%exitcond200.not> = icmp eq ir<%indvars.iv.next198>, ir<%wide.trip.count203>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.cond101.for.inc124_crit_edge>, scalar.ph

ir-bb<for.cond101.for.inc124_crit_edge>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_dependence' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond101.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv197 = phi 1, %indvars.iv.next198, ir<1>
    WIDEN ir<%cmp104.not> = icmp eq ir<%indvars.iv201>, ir<%indvars.iv197>
  Successor(s): land.lhs.true105

  land.lhs.true105:
    EMIT vp<%4> = not ir<%cmp104.not>
    WIDEN ir<%100> = load ir<%arrayidx107>, vp<%4>
    WIDEN ir<%tobool108.not> = icmp eq ir<%100>, ir<null>
  Successor(s): land.lhs.true109

  land.lhs.true109:
    EMIT vp<%5> = not ir<%tobool108.not>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    CLONE ir<%arrayidx111> = getelementptr ir<%oiv_used>, ir<0>, ir<%indvars.iv197>
    vp<%7> = vector-pointer ir<%arrayidx111>
    WIDEN ir<%101> = load vp<%7>, vp<%6>
    WIDEN ir<%cmp118> = icmp eq ir<%100>, ir<%101>
  Successor(s): if.then119

  if.then119:
    EMIT vp<%8> = logical-and vp<%6>, ir<%cmp118>
    WIDEN store ir<%separability>, ir<0>, vp<%8>
  Successor(s): for.inc121

  for.inc121:
    EMIT vp<%9> = logical-and vp<%4>, ir<%tobool108.not>
    EMIT vp<%10> = or ir<%cmp104.not>, vp<%9>
    EMIT vp<%11> = not ir<%cmp118>
    EMIT vp<%12> = logical-and vp<%6>, vp<%11>
    EMIT vp<%13> = or vp<%10>, vp<%12>
    EMIT vp<%14> = or vp<%13>, vp<%8>
    WIDEN ir<%indvars.iv.next198> = add nuw nsw ir<%indvars.iv197>, ir<1>
    CLONE ir<%exitcond200.not> = icmp eq ir<%indvars.iv.next198>, ir<%wide.trip.count203>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.cond101.for.inc124_crit_edge>, scalar.ph

ir-bb<for.cond101.for.inc124_crit_edge>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv197 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next198, %for.inc121 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv201, %indvars.iv197 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %100 = load ptr, ptr %arrayidx107, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool108.not = icmp eq ptr %100, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv197 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %101 = load ptr, ptr %arrayidx111, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp118 = icmp eq ptr %100, %101 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 0, ptr %separability, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next198 = add nuw nsw i64 %indvars.iv197, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next198, %wide.trip.count203 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond200.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv197 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next198, %for.inc121 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv201, %indvars.iv197 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %100 = load ptr, ptr %arrayidx107, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool108.not = icmp eq ptr %100, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv197 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %101 = load ptr, ptr %arrayidx111, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp118 = icmp eq ptr %100, %101 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 0, ptr %separability, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next198 = add nuw nsw i64 %indvars.iv197, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next198, %wide.trip.count203 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond200.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418235, RTCostB: 10737418235
A is not scalable.	B is not scalable.	
RTCostA: 10737418235, RTCostB: 10737418235

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv197 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next198, %for.inc121 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv201, %indvars.iv197 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %100 = load ptr, ptr %arrayidx107, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool108.not = icmp eq ptr %100, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv197 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %101 = load ptr, ptr %arrayidx111, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp118 = icmp eq ptr %100, %101 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 0, ptr %separability, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next198 = add nuw nsw i64 %indvars.iv197, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next198, %wide.trip.count203 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond200.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 10200547324, RTCostB: 10737418235
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10200547324, RTCostB: 10737418235
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv197 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next198, %for.inc121 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv201, %indvars.iv197 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %100 = load ptr, ptr %arrayidx107, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool108.not = icmp eq ptr %100, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv197 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %101 = load ptr, ptr %arrayidx111, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp118 = icmp eq ptr %100, %101 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 0, ptr %separability, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next198 = add nuw nsw i64 %indvars.iv197, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next198, %wide.trip.count203 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond200.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Vector loop of width vscale x 1 costs: 5
A is scalable.	B is not scalable.	
RTCostA: 10737418235, RTCostB: 10737418235
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10737418235, RTCostB: 10200547324

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv197 = phi i64 [ 1, %for.cond101.preheader ], [ %indvars.iv.next198, %for.inc121 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp104.not = icmp eq i64 %indvars.iv201, %indvars.iv197 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp104.not, label %for.inc121, label %land.lhs.true105 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %100 = load ptr, ptr %arrayidx107, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool108.not = icmp eq ptr %100, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool108.not, label %for.inc121, label %land.lhs.true109 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx111 = getelementptr inbounds [13 x ptr], ptr %oiv_used, i64 0, i64 %indvars.iv197 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %101 = load ptr, ptr %arrayidx111, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp118 = icmp eq ptr %100, %101 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp118, label %if.then119, label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 0, ptr %separability, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc121 of type:br

-----------------Function that is being costed:'classify_dependence' from dependence.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next198 = add nuw nsw i64 %indvars.iv197, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond200.not = icmp eq i64 %indvars.iv.next198, %wide.trip.count203 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond200.not, label %for.cond101.for.inc124_crit_edge, label %for.body103 of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 10200547324, RTCostB: 10737418235
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10200547324, RTCostB: 10200547324
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 4.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: classify_dependence at line: dependence.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.cond101.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%11>
    WIDEN-INDUCTION %indvars.iv197 = phi 1, %indvars.iv.next198, ir<1>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    WIDEN ir<%cmp104.not> = icmp eq ir<%indvars.iv201>, ir<%indvars.iv197>
    EMIT vp<%6> = not ir<%cmp104.not>
    WIDEN ir<%100> = load ir<%arrayidx107>, vp<%6>
    WIDEN ir<%tobool108.not> = icmp eq ir<%100>, ir<null>
    EMIT vp<%7> = not ir<%tobool108.not>
    EMIT vp<%8> = logical-and vp<%6>, vp<%7>
    CLONE ir<%arrayidx111> = getelementptr ir<%oiv_used>, ir<0>, vp<%5>
    vp<%9> = vector-pointer ir<%arrayidx111>
    WIDEN ir<%101> = load vp<%9>, vp<%8>
    WIDEN ir<%cmp118> = icmp eq ir<%100>, ir<%101>
    EMIT vp<%10> = logical-and vp<%8>, ir<%cmp118>
    WIDEN store ir<%separability>, ir<0>, vp<%10>
    EMIT vp<%11> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%11>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<for.cond101.for.inc124_crit_edge>, scalar.ph

ir-bb<for.cond101.for.inc124_crit_edge>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 27
Loops Epilogues Vectorized: 0
================================================
========== Loop: merge_dependencies' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %loop_count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv114 = phi 1, %indvars.iv.next115, ir<1>
    CLONE ir<%arrayidx.us> = getelementptr inbounds ir<%distance>, ir<%indvars.iv114>
    CLONE store ir<2147483647>, ir<%arrayidx.us>
    CLONE ir<%arrayidx3.us> = getelementptr inbounds ir<%direction>, ir<%indvars.iv114>
    CLONE store ir<5>, ir<%arrayidx3.us>
    CLONE ir<%indvars.iv.next115> = add nuw nsw ir<%indvars.iv114>, ir<1>
    CLONE ir<%exitcond117.not> = icmp eq ir<%indvars.iv.next115>, ir<%wide.trip.count116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end65.loopexit>, scalar.ph

ir-bb<for.end65.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: merge_dependencies' from dependence.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %loop_count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv114 = phi 1, %indvars.iv.next115, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx.us> = getelementptr inbounds ir<%distance>, ir<%indvars.iv114>
    WIDEN store ir<%arrayidx.us>, ir<2147483647>
    WIDEN-GEP Inv[Var] ir<%arrayidx3.us> = getelementptr inbounds ir<%direction>, ir<%indvars.iv114>
    WIDEN store ir<%arrayidx3.us>, ir<5>
    WIDEN ir<%indvars.iv.next115> = add nuw nsw ir<%indvars.iv114>, ir<1>
    CLONE ir<%exitcond117.not> = icmp eq ir<%indvars.iv.next115>, ir<%wide.trip.count116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end65.loopexit>, scalar.ph

ir-bb<for.end65.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: merge_dependencies' from dependence.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %loop_count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv114 = phi 1, %indvars.iv.next115, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx.us> = getelementptr inbounds ir<%distance>, ir<%indvars.iv114>
    WIDEN store ir<%arrayidx.us>, ir<2147483647>
    WIDEN-GEP Inv[Var] ir<%arrayidx3.us> = getelementptr inbounds ir<%direction>, ir<%indvars.iv114>
    WIDEN store ir<%arrayidx3.us>, ir<5>
    WIDEN ir<%indvars.iv.next115> = add nuw nsw ir<%indvars.iv114>, ir<1>
    CLONE ir<%exitcond117.not> = icmp eq ir<%indvars.iv.next115>, ir<%wide.trip.count116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end65.loopexit>, scalar.ph

ir-bb<for.end65.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv114 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next115, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv114 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv114 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 5, ptr %arrayidx3.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next115 = add nuw nsw i64 %indvars.iv114, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond117.not = icmp eq i64 %indvars.iv.next115, %wide.trip.count116 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond117.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv114 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next115, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 5, ptr %arrayidx3.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next115 = add nuw nsw i64 %indvars.iv114, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond117.not = icmp eq i64 %indvars.iv.next115, %wide.trip.count116 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond117.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv114 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next115, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 5, ptr %arrayidx3.us, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next115 = add nuw nsw i64 %indvars.iv114, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond117.not = icmp eq i64 %indvars.iv.next115, %wide.trip.count116 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond117.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5905580033, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5905580033, RTCostB: 6442450942
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv114 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next115, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 5, ptr %arrayidx3.us, align 4 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next115 = add nuw nsw i64 %indvars.iv114, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond117.not = icmp eq i64 %indvars.iv.next115, %wide.trip.count116 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond117.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5637144583, RTCostB: 8589934588
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5637144583, RTCostB: 5905580033
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv114 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next115, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 5, ptr %arrayidx3.us, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next115 = add nuw nsw i64 %indvars.iv114, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond117.not = icmp eq i64 %indvars.iv.next115, %wide.trip.count116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond117.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 5637144583

-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv114 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next115, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 5, ptr %arrayidx3.us, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next115 = add nuw nsw i64 %indvars.iv114, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond117.not = icmp eq i64 %indvars.iv.next115, %wide.trip.count116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond117.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5905580033, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5905580033, RTCostB: 5637144583

-----------------Function that is being costed:'merge_dependencies' from dependence.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv114 = phi i64 [ 1, %for.body.us.preheader ], [ %indvars.iv.next115, %for.body.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx.us = getelementptr inbounds [13 x i32], ptr %distance, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 2147483647, ptr %arrayidx.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3.us = getelementptr inbounds [13 x i32], ptr %direction, i64 %indvars.iv114 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 5, ptr %arrayidx3.us, align 4 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next115 = add nuw nsw i64 %indvars.iv114, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond117.not = icmp eq i64 %indvars.iv.next115, %wide.trip.count116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond117.not, label %for.end65.loopexit, label %for.body.us of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5637144583, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5637144583, RTCostB: 5637144583
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: merge_dependencies at line: dependence.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %loop_count) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv114 = phi 1, %indvars.iv.next115, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx.us> = getelementptr inbounds ir<%distance>, ir<%indvars.iv114>
    WIDEN store ir<%arrayidx.us>, ir<2147483647>
    WIDEN-GEP Inv[Var] ir<%arrayidx3.us> = getelementptr inbounds ir<%direction>, ir<%indvars.iv114>
    WIDEN store ir<%arrayidx3.us>, ir<5>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end65.loopexit>, scalar.ph

ir-bb<for.end65.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 29
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o df.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         df.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o diagnostic.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         diagnostic.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o doloop.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         doloop.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o dominance.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         dominance.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o dwarf2asm.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         dwarf2asm.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o dwarf2out.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         dwarf2out.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o dwarfout.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         dwarfout.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o emit-rtl.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         emit-rtl.c
@@ Instruction =>  %1 = load ptr, ptr %argp.next1315, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %1, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load ptr, ptr %argp.next1315, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %1, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1 = load ptr, ptr %argp.next1315, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %1, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load ptr, ptr %argp.next1315, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %1, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: gen_rtvec' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.next1315> = WIDEN-POINTER-INDUCTION ir<%p.promoted>, 8
    CLONE ir<%argp.next> = getelementptr inbounds ir<%argp.next1315>, ir<8>
    CLONE store ir<%argp.next>, ir<%p>
    CLONE ir<%1> = load ir<%argp.next1315>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    CLONE store ir<%1>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_rtvec' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.next1315> = WIDEN-POINTER-INDUCTION ir<%p.promoted>, 8
    WIDEN-GEP Var[Inv] ir<%argp.next> = getelementptr inbounds ir<%argp.next1315>, ir<8>
    WIDEN store ir<%p>, ir<%argp.next>
    vp<%4> = vector-pointer ir<%argp.next1315>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_rtvec' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 4 to 8==========
VPlan 'Initial VPlan for VF={4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.next1315> = WIDEN-POINTER-INDUCTION ir<%p.promoted>, 8
    WIDEN-GEP Var[Inv] ir<%argp.next> = getelementptr inbounds ir<%argp.next1315>, ir<8>
    REPLICATE store ir<%argp.next>, ir<%p>
    vp<%4> = vector-pointer ir<%argp.next1315>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_rtvec' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.next1315> = WIDEN-POINTER-INDUCTION ir<%p.promoted>, 8
    WIDEN-GEP Var[Inv] ir<%argp.next> = getelementptr inbounds ir<%argp.next1315>, ir<8>
    REPLICATE store ir<%argp.next>, ir<%p>
    vp<%4> = vector-pointer ir<%argp.next1315>
    WIDEN ir<%1> = load vp<%4>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'gen_rtvec' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %argp.next1315 = phi ptr [ %p.promoted, %for.body.preheader ], [ %argp.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %argp.next = getelementptr inbounds i8, ptr %argp.next1315, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %argp.next, ptr %p, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1 = load ptr, ptr %argp.next1315, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %1, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'gen_rtvec' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %argp.next1315 = phi ptr [ %p.promoted, %for.body.preheader ], [ %argp.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %argp.next = getelementptr inbounds i8, ptr %argp.next1315, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %argp.next, ptr %p, align 8 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load ptr, ptr %argp.next1315, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %1, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 10737418235
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 10737418235
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'gen_rtvec' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %argp.next1315 = phi ptr [ %p.promoted, %for.body.preheader ], [ %argp.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %argp.next = getelementptr inbounds i8, ptr %argp.next1315, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3 for VF 4 For instruction:   store ptr %argp.next, ptr %p, align 8 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1 = load ptr, ptr %argp.next1315, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %1, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4831838214, RTCostB: 10737418235
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4831838214, RTCostB: 6442450943
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'gen_rtvec' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %argp.next1315 = phi ptr [ %p.promoted, %for.body.preheader ], [ %argp.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %argp.next = getelementptr inbounds i8, ptr %argp.next1315, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %argp.next, ptr %p, align 8 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %1 = load ptr, ptr %argp.next1315, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %1, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 10737418235
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 4831838214

-----------------Function that is being costed:'gen_rtvec' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %argp.next1315 = phi ptr [ %p.promoted, %for.body.preheader ], [ %argp.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %argp.next = getelementptr inbounds i8, ptr %argp.next1315, i64 8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr %argp.next, ptr %p, align 8 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %1 = load ptr, ptr %argp.next1315, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %1, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4831838214, RTCostB: 10737418235
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4831838214, RTCostB: 4831838214
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: gen_rtvec at line: emit-rtl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%argp.next1315> = WIDEN-POINTER-INDUCTION ir<%p.promoted>, 8
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    WIDEN-GEP Var[Inv] ir<%argp.next> = getelementptr inbounds ir<%argp.next1315>, ir<8>
    REPLICATE store ir<%argp.next>, ir<%p>
    vp<%5> = vector-pointer ir<%argp.next1315>
    WIDEN ir<%2> = load vp<%5>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%6>, ir<%2>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %0 = load ptr, ptr %argp.addr.09, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load ptr, ptr %argp.addr.09, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %0, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %0 = load ptr, ptr %argp.addr.09, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %0 = load ptr, ptr %argp.addr.09, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %0, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: gen_rtvec_v' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.addr.09> = WIDEN-POINTER-INDUCTION ir<%argp>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%argp.addr.09>, ir<8>
    CLONE ir<%0> = load ir<%argp.addr.09>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%0>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_rtvec_v' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.addr.09> = WIDEN-POINTER-INDUCTION ir<%argp>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%argp.addr.09>, ir<8>
    vp<%4> = vector-pointer ir<%argp.addr.09>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_rtvec_v' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    EMIT ir<%argp.addr.09> = WIDEN-POINTER-INDUCTION ir<%argp>, 8
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%argp.addr.09>, ir<8>
    vp<%4> = vector-pointer ir<%argp.addr.09>
    WIDEN ir<%0> = load vp<%4>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%0>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'gen_rtvec_v' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %argp.addr.09 = phi ptr [ %argp, %for.body.lr.ph ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %argp.addr.09, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %0 = load ptr, ptr %argp.addr.09, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %0, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'gen_rtvec_v' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %argp.addr.09 = phi ptr [ %argp, %for.body.lr.ph ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %argp.addr.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %0 = load ptr, ptr %argp.addr.09, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %0, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'gen_rtvec_v' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %argp.addr.09 = phi ptr [ %argp, %for.body.lr.ph ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %argp.addr.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %0 = load ptr, ptr %argp.addr.09, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %0, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 4294967296
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'gen_rtvec_v' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %argp.addr.09 = phi ptr [ %argp, %for.body.lr.ph ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %argp.addr.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %0 = load ptr, ptr %argp.addr.09, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %0, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 3221225478

-----------------Function that is being costed:'gen_rtvec_v' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %argp.addr.09 = phi ptr [ %argp, %for.body.lr.ph ], [ %incdec.ptr, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %argp.addr.09, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %0 = load ptr, ptr %argp.addr.09, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %0, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 3221225478
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: gen_rtvec_v at line: emit-rtl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    vp<%5>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%6> = SCALAR-STEPS vp<%5>, ir<8>
    EMIT vp<%7> = ptradd ir<%argp>, vp<%6>
    vp<%8> = vector-pointer vp<%7>
    WIDEN ir<%5> = load vp<%8>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%elem>, ir<0>, vp<%4>
    vp<%9> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%9>, ir<%5>
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 3
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr %4, ptr %arrayidx17, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %4, ptr %arrayidx17, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr %4, ptr %arrayidx17, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %4, ptr %arrayidx17, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: gen_const_vector_0' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%4>, ir<%arrayidx17>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_const_vector_0' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx17>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: gen_const_vector_0' from emit-rtl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx17>
    WIDEN store vp<%4>, ir<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'gen_const_vector_0' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx17 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %4, ptr %arrayidx17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'gen_const_vector_0' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx17 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %4, ptr %arrayidx17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 384, RTCostB: 765
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 384, RTCostB: 765
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'gen_const_vector_0' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx17 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %4, ptr %arrayidx17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 261, RTCostB: 765
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 261, RTCostB: 384
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'gen_const_vector_0' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx17 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %4, ptr %arrayidx17, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 384, RTCostB: 765
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 384, RTCostB: 261

-----------------Function that is being costed:'gen_const_vector_0' from emit-rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx17 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %4, ptr %arrayidx17, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 261, RTCostB: 765
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 261, RTCostB: 261
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: gen_const_vector_0 at line: emit-rtl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx17> = getelementptr inbounds ir<%elem>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx17>
    WIDEN store vp<%5>, ir<%4>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 82
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o except.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         except.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o explow.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         explow.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o expmed.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         expmed.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o expr.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         expr.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o final.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         final.c
@@ Instruction =>  store ptr %seq.0759, ptr %arrayidx181, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %seq.0759, ptr %arrayidx181, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %seq.0759, ptr %arrayidx181, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store ptr %seq.0759, ptr %arrayidx181, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: shorten_branches' from final.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body179.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %conv165, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx181> = getelementptr inbounds ir<%align_tab>, ir<0>, ir<%indvars.iv.next>
    CLONE store ir<%seq.0759>, ir<%arrayidx181>
    CLONE ir<%cmp177> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end185.loopexit>, scalar.ph

ir-bb<if.end185.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: shorten_branches' from final.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body179.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %conv165, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx181> = getelementptr inbounds ir<%align_tab>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx181>
    WIDEN store vp<%4>, ir<%seq.0759>
    CLONE ir<%cmp177> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end185.loopexit>, scalar.ph

ir-bb<if.end185.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: shorten_branches' from final.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body179.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %conv165, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx181> = getelementptr inbounds ir<%align_tab>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx181>
    WIDEN store vp<%4>, ir<%seq.0759>
    CLONE ir<%cmp177> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end185.loopexit>, scalar.ph

ir-bb<if.end185.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'shorten_branches' from final.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %conv165, %for.body179.preheader ], [ %indvars.iv.next, %for.body179 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx181 = getelementptr inbounds [16 x ptr], ptr %align_tab, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %seq.0759, ptr %arrayidx181, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp177 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp177, label %for.body179, label %if.end185.loopexit of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'shorten_branches' from final.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %conv165, %for.body179.preheader ], [ %indvars.iv.next, %for.body179 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx181 = getelementptr inbounds [16 x ptr], ptr %align_tab, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store ptr %seq.0759, ptr %arrayidx181, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp177 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp177, label %for.body179, label %if.end185.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 196605, RTCostB: 196605
A is not scalable.	B is not scalable.	
RTCostA: 196605, RTCostB: 196605

-----------------Function that is being costed:'shorten_branches' from final.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %conv165, %for.body179.preheader ], [ %indvars.iv.next, %for.body179 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx181 = getelementptr inbounds [16 x ptr], ptr %align_tab, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store ptr %seq.0759, ptr %arrayidx181, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp177 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp177, label %for.body179, label %if.end185.loopexit of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 196605, RTCostB: 196605
A is not scalable.	B is not scalable.	
RTCostA: 196605, RTCostB: 196605

-----------------Function that is being costed:'shorten_branches' from final.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %conv165, %for.body179.preheader ], [ %indvars.iv.next, %for.body179 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx181 = getelementptr inbounds [16 x ptr], ptr %align_tab, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %seq.0759, ptr %arrayidx181, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp177 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp177, label %for.body179, label %if.end185.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 131071, RTCostB: 196605
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 131071, RTCostB: 196605
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'shorten_branches' from final.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %conv165, %for.body179.preheader ], [ %indvars.iv.next, %for.body179 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx181 = getelementptr inbounds [16 x ptr], ptr %align_tab, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store ptr %seq.0759, ptr %arrayidx181, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp177 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp177, label %for.body179, label %if.end185.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 81924, RTCostB: 196605
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 81924, RTCostB: 131071
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: shorten_branches at line: final.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body179.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i16 %35 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%conv165> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx181> = getelementptr inbounds ir<%align_tab>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx181>
    WIDEN store vp<%6>, ir<%seq.0759>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end185.loopexit>, scalar.ph

ir-bb<if.end185.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 9
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o flow.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         flow.c
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 2 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 2 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 3 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx100, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(3)
========== Loop: mark_used_reg' from flow.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body98.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((trunc i64 ((zext i32 (1 + %0) to i64) umax (1 + (zext i32 %regno_last.02533 to i64))<nuw><nsw>) to i32) + (-1 * %0))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.211 = phi %inc102, %0, ir<1>
    CLONE ir<%idxprom99> = zext ir<%i.211>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%idxprom99>
    CLONE store ir<1>, ir<%arrayidx100>
    CLONE ir<%inc102> = add ir<%i.211>, ir<1>
    CLONE ir<%cmp96.not> = icmp ugt ir<%inc102>, ir<%regno_last.02533>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end157.loopexit>, scalar.ph

ir-bb<if.end157.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: mark_used_reg' from flow.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body98.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((trunc i64 ((zext i32 (1 + %0) to i64) umax (1 + (zext i32 %regno_last.02533 to i64))<nuw><nsw>) to i32) + (-1 * %0))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.211 = phi %inc102, %0, ir<1>
    CLONE ir<%idxprom99> = zext ir<%i.211>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%idxprom99>
    vp<%4> = vector-pointer ir<%arrayidx100>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%inc102> = add ir<%i.211>, ir<1>
    CLONE ir<%cmp96.not> = icmp ugt ir<%inc102>, ir<%regno_last.02533>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end157.loopexit>, scalar.ph

ir-bb<if.end157.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: mark_used_reg' from flow.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body98.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((trunc i64 ((zext i32 (1 + %0) to i64) umax (1 + (zext i32 %regno_last.02533 to i64))<nuw><nsw>) to i32) + (-1 * %0))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.211 = phi %inc102, %0, ir<1>
    CLONE ir<%idxprom99> = zext ir<%i.211>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%idxprom99>
    vp<%4> = vector-pointer ir<%arrayidx100>
    WIDEN store vp<%4>, ir<1>
    CLONE ir<%inc102> = add ir<%i.211>, ir<1>
    CLONE ir<%cmp96.not> = icmp ugt ir<%inc102>, ir<%regno_last.02533>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end157.loopexit>, scalar.ph

ir-bb<if.end157.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 16 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 64
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 32 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 128
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 96

-----------------Function that is being costed:'mark_used_reg' from flow.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.211 = phi i32 [ %inc102, %for.body98 ], [ %0, %for.body98.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %idxprom99 = zext i32 %i.211 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx100 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %idxprom99 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx100, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %inc102 = add i32 %i.211, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp96.not = icmp ugt i32 %inc102, %regno_last.02533 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp96.not, label %if.end157.loopexit, label %for.body98 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: mark_used_reg at line: flow.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body98.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((trunc i64 ((zext i32 (1 + %0) to i64) umax (1 + (zext i32 %regno_last.02533 to i64))<nuw><nsw>) to i32) + (-1 * %0))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4>    = DERIVED-IV ir<%0> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%idxprom99> = zext vp<%5>
    CLONE ir<%arrayidx100> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%idxprom99>
    vp<%6> = vector-pointer ir<%arrayidx100>
    WIDEN store vp<%6>, ir<1>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end157.loopexit>, scalar.ph

ir-bb<if.end157.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 69
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o fold-const.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         fold-const.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o function.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         function.c
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4 -> Cost: 4 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4 -> Cost: 4 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4 -> Cost: 10 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %9 = load i32, ptr %arrayidx22.us, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: contains' from function.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (trunc i64 %3 to i32)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv77 = phi %5, %indvars.iv.next78, ir<-1>
    WIDEN-REDUCTION-PHI ir<%count.168.us> = phi ir<%count.072.us>, ir<%spec.select.us>
    CLONE ir<%arrayidx22.us> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv77>
    CLONE ir<%9> = load ir<%arrayidx22.us>
    CLONE ir<%cmp23.us> = icmp eq ir<%8>, ir<%9>
    CLONE ir<%inc.us> = zext ir<%cmp23.us>
    CLONE ir<%spec.select.us> = add ir<%count.168.us>, ir<%inc.us>
    CLONE ir<%indvars.iv.next78> = add nsw ir<%indvars.iv77>, ir<-1>
    CLONE ir<%cmp11.us> = icmp sgt ir<%indvars.iv77>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%count.168.us>, ir<%spec.select.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.us.lcssa = vp<%6>
}

========== Loop: contains' from function.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (trunc i64 %3 to i32)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv77 = phi %5, %indvars.iv.next78, ir<-1>
    WIDEN-REDUCTION-PHI ir<%count.168.us> = phi ir<%count.072.us>, ir<%spec.select.us>
    CLONE ir<%arrayidx22.us> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv77>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx22.us>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%cmp23.us> = icmp eq ir<%8>, ir<%9>
    WIDEN-CAST ir<%inc.us> = zext  ir<%cmp23.us> to i32
    WIDEN ir<%spec.select.us> = add ir<%count.168.us>, ir<%inc.us>
    CLONE ir<%indvars.iv.next78> = add nsw ir<%indvars.iv77>, ir<-1>
    CLONE ir<%cmp11.us> = icmp sgt ir<%indvars.iv77>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count.168.us>, ir<%spec.select.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.us.lcssa = vp<%7>
}

========== Loop: contains' from function.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (trunc i64 %3 to i32)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv77 = phi %5, %indvars.iv.next78, ir<-1>
    WIDEN-REDUCTION-PHI ir<%count.168.us> = phi ir<%count.072.us>, ir<%spec.select.us>
    CLONE ir<%arrayidx22.us> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv77>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx22.us>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%cmp23.us> = icmp eq ir<%8>, ir<%9>
    WIDEN-CAST ir<%inc.us> = zext  ir<%cmp23.us> to i32
    WIDEN ir<%spec.select.us> = add ir<%count.168.us>, ir<%inc.us>
    CLONE ir<%indvars.iv.next78> = add nsw ir<%indvars.iv77>, ir<-1>
    CLONE ir<%cmp11.us> = icmp sgt ir<%indvars.iv77>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count.168.us>, ir<%spec.select.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.us.lcssa = vp<%7>
}


-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv77 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next78, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv77, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv77 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next78, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv77, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv77 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next78, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv77, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv77 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next78, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 8 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 4 for VF 8 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv77, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 20
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv77 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next78, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv77, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv77 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next78, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv77, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'contains' from function.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv77 = phi i64 [ %5, %for.body.us ], [ %indvars.iv.next78, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %count.168.us = phi i32 [ %count.072.us, %for.body.us ], [ %spec.select.us, %for.body13.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx22.us = getelementptr inbounds [1 x i32], ptr %data, i64 0, i64 %indvars.iv77 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   %9 = load i32, ptr %arrayidx22.us, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp23.us = icmp eq i32 %8, %9 of type:icmp
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %inc.us = zext i1 %cmp23.us to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %spec.select.us = add nsw i32 %count.168.us, %inc.us of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next78 = add nsw i64 %indvars.iv77, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp11.us = icmp sgt i64 %indvars.iv77, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp11.us, label %for.body13.us, label %for.cond10.for.cond.loopexit_crit_edge.us of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 13
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 52, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: contains at line: function.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (trunc i64 %3 to i32)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%count.168.us> = phi ir<%count.072.us>, ir<%spec.select.us>
    vp<%4>    = DERIVED-IV ir<%5> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx22.us> = getelementptr inbounds ir<%data>, ir<0>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx22.us>
    WIDEN ir<%9> = load vp<%6>
    WIDEN ir<%cmp23.us> = icmp eq ir<%8>, ir<%9>
    WIDEN-CAST ir<%inc.us> = zext  ir<%cmp23.us> to i32
    WIDEN ir<%spec.select.us> = add ir<%count.168.us>, ir<%inc.us>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%count.168.us>, ir<%spec.select.us>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>, scalar.ph

ir-bb<for.cond10.for.cond.loopexit_crit_edge.us>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.us.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 71
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o gcse.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         gcse.c
========== Loop: compute_hash_table' from gcse.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    CLONE store ir<-1>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3.preheader.loopexit>, scalar.ph

ir-bb<for.cond3.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: compute_hash_table' from gcse.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx>, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3.preheader.loopexit>, scalar.ph

ir-bb<for.cond3.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: compute_hash_table' from gcse.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx>, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3.preheader.loopexit>, scalar.ph

ir-bb<for.cond3.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934591, RTCostB: 12884901885
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934591, RTCostB: 12884901885
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192770, RTCostB: 12884901885
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192770, RTCostB: 8589934591
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 6979321864, RTCostB: 12884901885
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6979321864, RTCostB: 7516192770
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934591, RTCostB: 12884901885
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934591, RTCostB: 6979321864

-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192770, RTCostB: 12884901885
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192770, RTCostB: 6979321864

-----------------Function that is being costed:'compute_hash_table' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds %struct.reg_avail_info, ptr %call, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond3.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 6979321864, RTCostB: 12884901885
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6979321864, RTCostB: 6979321864
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: compute_hash_table at line: gcse.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx> = getelementptr inbounds ir<%call>, ir<%indvars.iv>
    WIDEN store ir<%arrayidx>, ir<-1>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3.preheader.loopexit>, scalar.ph

ir-bb<for.cond3.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 26
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %3 = load i64, ptr %arrayidx23, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i64, ptr %arrayidx23, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %3 = load i64, ptr %arrayidx23, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load i64, ptr %arrayidx23, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: hash_expr_1' from gcse.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %2 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv524 = phi 2, %indvars.iv.next525, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1451> = phi ir<%add12>, ir<%add25>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%fld22>, ir<0>, ir<%indvars.iv524>
    CLONE ir<%3> = load ir<%arrayidx23>
    CLONE ir<%conv24> = trunc ir<%3>
    CLONE ir<%add25> = add ir<%hash.1451>, ir<%conv24>
    CLONE ir<%indvars.iv.next525> = add nuw nsw ir<%indvars.iv524>, ir<1>
    CLONE ir<%exitcond527.not> = icmp eq ir<%indvars.iv.next525>, ir<%wide.trip.count526>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%hash.1451>, ir<%add25>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add25.lcssa = vp<%6>
}

========== Loop: hash_expr_1' from gcse.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %2 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv524 = phi 2, %indvars.iv.next525, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1451> = phi ir<%add12>, ir<%add25>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%fld22>, ir<0>, ir<%indvars.iv524>
    vp<%4> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%conv24> = trunc  ir<%3> to i32
    WIDEN ir<%add25> = add ir<%hash.1451>, ir<%conv24>
    CLONE ir<%indvars.iv.next525> = add nuw nsw ir<%indvars.iv524>, ir<1>
    CLONE ir<%exitcond527.not> = icmp eq ir<%indvars.iv.next525>, ir<%wide.trip.count526>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.1451>, ir<%add25>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add25.lcssa = vp<%7>
}

========== Loop: hash_expr_1' from gcse.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %2 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv524 = phi 2, %indvars.iv.next525, ir<1>
    WIDEN-REDUCTION-PHI ir<%hash.1451> = phi ir<%add12>, ir<%add25>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%fld22>, ir<0>, ir<%indvars.iv524>
    vp<%4> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-CAST ir<%conv24> = trunc  ir<%3> to i32
    WIDEN ir<%add25> = add ir<%hash.1451>, ir<%conv24>
    CLONE ir<%indvars.iv.next525> = add nuw nsw ir<%indvars.iv524>, ir<1>
    CLONE ir<%exitcond527.not> = icmp eq ir<%indvars.iv.next525>, ir<%wide.trip.count526>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%hash.1451>, ir<%add25>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add25.lcssa = vp<%7>
}


-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv524 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next525, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv524 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %3 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next525 = add nuw nsw i64 %indvars.iv524, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond527.not = icmp eq i64 %indvars.iv.next525, %wide.trip.count526 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond527.not, label %cleanup.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv524 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next525, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv524 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next525 = add nuw nsw i64 %indvars.iv524, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond527.not = icmp eq i64 %indvars.iv.next525, %wide.trip.count526 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond527.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 1012
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 1012
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv524 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next525, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv524 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %3 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next525 = add nuw nsw i64 %indvars.iv524, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond527.not = icmp eq i64 %indvars.iv.next525, %wide.trip.count526 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond527.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 1012
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 634
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv524 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next525, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv524 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %3 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next525 = add nuw nsw i64 %indvars.iv524, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond527.not = icmp eq i64 %indvars.iv.next525, %wide.trip.count526 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond527.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 1012
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 634, RTCostB: 382

-----------------Function that is being costed:'hash_expr_1' from gcse.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv524 = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next525, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hash.1451 = phi i32 [ %add12, %for.body.lr.ph ], [ %add25, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld22, i64 0, i64 %indvars.iv524 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %3 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv24 = trunc i64 %3 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add25 = add i32 %hash.1451, %conv24 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next525 = add nuw nsw i64 %indvars.iv524, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond527.not = icmp eq i64 %indvars.iv.next525, %wide.trip.count526 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond527.not, label %cleanup.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 1012
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 382, RTCostB: 382
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: hash_expr_1 at line: gcse.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (-2 + (zext i8 %2 to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%hash.1451> = phi ir<%add12>, ir<%add25>
    vp<%4>    = DERIVED-IV ir<2> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%fld22>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%3> = load vp<%6>
    WIDEN-CAST ir<%conv24> = trunc  ir<%3> to i32
    WIDEN ir<%add25> = add ir<%hash.1451>, ir<%conv24>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%hash.1451>, ir<%add25>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %add25.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 46
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o genrtl.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         genrtl.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o ggc-common.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         ggc-common.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o global.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         global.c
@@ Instruction =>  %80 = load i32, ptr %arrayidx339, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %81 = load i32, ptr %arrayidx345, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %82 = load i32, ptr %arrayidx351, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %80 = load i32, ptr %arrayidx339, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %81 = load i32, ptr %arrayidx345, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %82 = load i32, ptr %arrayidx351, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %80 = load i32, ptr %arrayidx339, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %81 = load i32, ptr %arrayidx345, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %82 = load i32, ptr %arrayidx351, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %80 = load i32, ptr %arrayidx339, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %81 = load i32, ptr %arrayidx345, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %82 = load i32, ptr %arrayidx351, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %80 = load i32, ptr %arrayidx339, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %81 = load i32, ptr %arrayidx345, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %82 = load i32, ptr %arrayidx351, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %80 = load i32, ptr %arrayidx339, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %add340, ptr %arrayidx339, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %81 = load i32, ptr %arrayidx345, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %add346, ptr %arrayidx345, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %82 = load i32, ptr %arrayidx351, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %add352, ptr %arrayidx351, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body334.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * (sext i16 %64 to i32))<nsw> + ((1 + (sext i16 %64 to i32))<nsw> smax ((sext i16 %64 to i32) + %cond329.ph.pn)<nuw><nsw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %79, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx339> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%80> = load ir<%arrayidx339>
    CLONE ir<%add340> = add nsw ir<%80>, ir<%76>
    CLONE store ir<%add340>, ir<%arrayidx339>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, ir<%indvars.iv>
    CLONE ir<%81> = load ir<%arrayidx345>
    CLONE ir<%add346> = add nsw ir<%81>, ir<%77>
    CLONE store ir<%add346>, ir<%arrayidx345>
    CLONE ir<%arrayidx351> = getelementptr inbounds ir<@local_reg_live_length>, ir<0>, ir<%indvars.iv>
    CLONE ir<%82> = load ir<%arrayidx351>
    CLONE ir<%add352> = add nsw ir<%82>, ir<%78>
    CLONE store ir<%add352>, ir<%arrayidx351>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%83> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp332> = icmp sgt ir<%add330695>, ir<%83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc357.loopexit>, scalar.ph

ir-bb<for.inc357.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body334.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * (sext i16 %64 to i32))<nsw> + ((1 + (sext i16 %64 to i32))<nsw> smax ((sext i16 %64 to i32) + %cond329.ph.pn)<nuw><nsw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi %79, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx339> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx339>
    WIDEN ir<%80> = load vp<%4>
    WIDEN ir<%add340> = add nsw ir<%80>, ir<%76>
    vp<%5> = vector-pointer ir<%arrayidx339>
    WIDEN store vp<%5>, ir<%add340>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx345>
    WIDEN ir<%81> = load vp<%6>
    WIDEN ir<%add346> = add nsw ir<%81>, ir<%77>
    vp<%7> = vector-pointer ir<%arrayidx345>
    WIDEN store vp<%7>, ir<%add346>
    CLONE ir<%arrayidx351> = getelementptr inbounds ir<@local_reg_live_length>, ir<0>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx351>
    WIDEN ir<%82> = load vp<%8>
    WIDEN ir<%add352> = add nsw ir<%82>, ir<%78>
    vp<%9> = vector-pointer ir<%arrayidx351>
    WIDEN store vp<%9>, ir<%add352>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%83> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp332> = icmp sgt ir<%add330695>, ir<%83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.inc357.loopexit>, scalar.ph

ir-bb<for.inc357.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body334.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * (sext i16 %64 to i32))<nsw> + ((1 + (sext i16 %64 to i32))<nsw> smax ((sext i16 %64 to i32) + %cond329.ph.pn)<nuw><nsw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi %79, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx339> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx339>
    WIDEN ir<%80> = load vp<%4>
    WIDEN ir<%add340> = add nsw ir<%80>, ir<%76>
    vp<%5> = vector-pointer ir<%arrayidx339>
    WIDEN store vp<%5>, ir<%add340>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx345>
    WIDEN ir<%81> = load vp<%6>
    WIDEN ir<%add346> = add nsw ir<%81>, ir<%77>
    vp<%7> = vector-pointer ir<%arrayidx345>
    WIDEN store vp<%7>, ir<%add346>
    CLONE ir<%arrayidx351> = getelementptr inbounds ir<@local_reg_live_length>, ir<0>, ir<%indvars.iv>
    vp<%8> = vector-pointer ir<%arrayidx351>
    WIDEN ir<%82> = load vp<%8>
    WIDEN ir<%add352> = add nsw ir<%82>, ir<%78>
    vp<%9> = vector-pointer ir<%arrayidx351>
    WIDEN store vp<%9>, ir<%add352>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%83> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp332> = icmp sgt ir<%add330695>, ir<%83>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.inc357.loopexit>, scalar.ph

ir-bb<for.inc357.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %79, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %80 = load i32, ptr %arrayidx339, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add340 = add nsw i32 %80, %76 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %add340, ptr %arrayidx339, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %81 = load i32, ptr %arrayidx345, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add346 = add nsw i32 %81, %77 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %add346, ptr %arrayidx345, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %82 = load i32, ptr %arrayidx351, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add352 = add nsw i32 %82, %78 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %add352, ptr %arrayidx351, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %83 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp332 = icmp sgt i32 %add330695, %83 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %79, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %80 = load i32, ptr %arrayidx339, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add340 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %add340, ptr %arrayidx339, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %81 = load i32, ptr %arrayidx345, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add346 = add nsw i32 %81, %77 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %add346, ptr %arrayidx345, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %82 = load i32, ptr %arrayidx351, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add352 = add nsw i32 %82, %78 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %add352, ptr %arrayidx351, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %83 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp332 = icmp sgt i32 %add330695, %83 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 5905940469, RTCostB: 11811880938
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5905940469, RTCostB: 11811880938
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %79, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %80 = load i32, ptr %arrayidx339, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add340 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %add340, ptr %arrayidx339, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %81 = load i32, ptr %arrayidx345, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add346 = add nsw i32 %81, %77 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %add346, ptr %arrayidx345, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %82 = load i32, ptr %arrayidx351, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add352 = add nsw i32 %82, %78 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %add352, ptr %arrayidx351, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %83 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp332 = icmp sgt i32 %add330695, %83 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2952970251, RTCostB: 11811880938
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2952970251, RTCostB: 5905940469
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %79, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %80 = load i32, ptr %arrayidx339, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %add340 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %add340, ptr %arrayidx339, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %81 = load i32, ptr %arrayidx345, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %add346 = add nsw i32 %81, %77 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %add346, ptr %arrayidx345, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %82 = load i32, ptr %arrayidx351, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %add352 = add nsw i32 %82, %78 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %add352, ptr %arrayidx351, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %83 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp332 = icmp sgt i32 %add330695, %83 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684518446, RTCostB: 11811880938
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684518446, RTCostB: 2952970251
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %79, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %80 = load i32, ptr %arrayidx339, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add340 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %add340, ptr %arrayidx339, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %81 = load i32, ptr %arrayidx345, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add346 = add nsw i32 %81, %77 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %add346, ptr %arrayidx345, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %82 = load i32, ptr %arrayidx351, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add352 = add nsw i32 %82, %78 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %add352, ptr %arrayidx351, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %83 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp332 = icmp sgt i32 %add330695, %83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 5
A is scalable.	B is not scalable.	
RTCostA: 5905940469, RTCostB: 11811880938
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5905940469, RTCostB: 2684518446

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %79, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %80 = load i32, ptr %arrayidx339, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add340 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %add340, ptr %arrayidx339, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %81 = load i32, ptr %arrayidx345, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add346 = add nsw i32 %81, %77 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %add346, ptr %arrayidx345, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %82 = load i32, ptr %arrayidx351, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add352 = add nsw i32 %82, %78 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %add352, ptr %arrayidx351, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %83 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp332 = icmp sgt i32 %add330695, %83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2952970251, RTCostB: 11811880938
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2952970251, RTCostB: 2684518446

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %79, %for.body334.lr.ph ], [ %indvars.iv.next, %for.body334 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx339 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %80 = load i32, ptr %arrayidx339, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %add340 = add nsw i32 %80, %76 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %add340, ptr %arrayidx339, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx345 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %81 = load i32, ptr %arrayidx345, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %add346 = add nsw i32 %81, %77 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %add346, ptr %arrayidx345, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx351 = getelementptr inbounds [53 x i32], ptr @local_reg_live_length, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %82 = load i32, ptr %arrayidx351, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %add352 = add nsw i32 %82, %78 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %add352, ptr %arrayidx351, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %83 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp332 = icmp sgt i32 %add330695, %83 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp332, label %for.body334, label %for.inc357.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684518446, RTCostB: 11811880938
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684518446, RTCostB: 2684518446
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: global_alloc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body334.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * (sext i16 %64 to i32))<nsw> + ((1 + (sext i16 %64 to i32))<nsw> smax ((sext i16 %64 to i32) + %cond329.ph.pn)<nuw><nsw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%79> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx339> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx339>
    WIDEN ir<%80> = load vp<%6>
    WIDEN ir<%add340> = add nsw ir<%80>, ir<%76>
    vp<%7> = vector-pointer ir<%arrayidx339>
    WIDEN store vp<%7>, ir<%add340>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx345>
    WIDEN ir<%81> = load vp<%8>
    WIDEN ir<%add346> = add nsw ir<%81>, ir<%77>
    vp<%9> = vector-pointer ir<%arrayidx345>
    WIDEN store vp<%9>, ir<%add346>
    CLONE ir<%arrayidx351> = getelementptr inbounds ir<@local_reg_live_length>, ir<0>, vp<%5>
    vp<%10> = vector-pointer ir<%arrayidx351>
    WIDEN ir<%82> = load vp<%10>
    WIDEN ir<%add352> = add nsw ir<%82>, ir<%78>
    vp<%11> = vector-pointer ir<%arrayidx351>
    WIDEN store vp<%11>, ir<%add352>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.inc357.loopexit>, scalar.ph

ir-bb<for.inc357.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %106 = load i8, ptr %arrayidx364, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %arrayidx364, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %arrayidx364, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  %106 = load i8, ptr %arrayidx364, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %arrayidx364, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %106 = load i8, ptr %arrayidx364, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 0, ptr %arrayidx367, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i32 0, ptr %arrayidx368, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.7661 = phi 0, %inc371, ir<1>
    CLONE ir<%arrayidx364> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%i.7661>
    CLONE ir<%106> = load ir<%arrayidx364>
    CLONE ir<%tobool365.not> = icmp eq ir<%106>, ir<0>
  Successor(s): if.then366

  if.then366:
    EMIT vp<%3> = not ir<%tobool365.not>
    CLONE ir<%arrayidx367> = getelementptr inbounds ir<@local_reg_n_refs>, ir<0>, ir<%i.7661>
    CLONE store ir<0>, ir<%arrayidx367>, vp<%3>
    CLONE ir<%arrayidx368> = getelementptr inbounds ir<@local_reg_freq>, ir<0>, ir<%i.7661>
    CLONE store ir<0>, ir<%arrayidx368>, vp<%3>
  Successor(s): for.inc370

  for.inc370:
    EMIT vp<%4> = or ir<%tobool365.not>, vp<%3>
    CLONE ir<%inc371> = add nuw nsw ir<%i.7661>, ir<1>
    CLONE ir<%exitcond676.not> = icmp eq ir<%inc371>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end372>, scalar.ph

ir-bb<for.end372>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %i.7661 = phi 0, %inc371, ir<1>
    CLONE ir<%arrayidx364> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%i.7661>
    vp<%3> = vector-pointer ir<%arrayidx364>
    WIDEN ir<%106> = load vp<%3>
    WIDEN ir<%tobool365.not> = icmp eq ir<%106>, ir<0>
  Successor(s): if.then366

  if.then366:
    EMIT vp<%4> = not ir<%tobool365.not>
    CLONE ir<%arrayidx367> = getelementptr ir<@local_reg_n_refs>, ir<0>, ir<%i.7661>
    vp<%5> = vector-pointer ir<%arrayidx367>
    WIDEN store vp<%5>, ir<0>, vp<%4>
    CLONE ir<%arrayidx368> = getelementptr ir<@local_reg_freq>, ir<0>, ir<%i.7661>
    vp<%6> = vector-pointer ir<%arrayidx368>
    WIDEN store vp<%6>, ir<0>, vp<%4>
  Successor(s): for.inc370

  for.inc370:
    EMIT vp<%7> = or ir<%tobool365.not>, vp<%4>
    CLONE ir<%inc371> = add nuw nsw ir<%i.7661>, ir<1>
    CLONE ir<%exitcond676.not> = icmp eq ir<%inc371>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end372>, scalar.ph

ir-bb<for.end372>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %i.7661 = phi 0, %inc371, ir<1>
    CLONE ir<%arrayidx364> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%i.7661>
    vp<%3> = vector-pointer ir<%arrayidx364>
    WIDEN ir<%106> = load vp<%3>
    WIDEN ir<%tobool365.not> = icmp eq ir<%106>, ir<0>
  Successor(s): if.then366

  if.then366:
    EMIT vp<%4> = not ir<%tobool365.not>
    CLONE ir<%arrayidx367> = getelementptr ir<@local_reg_n_refs>, ir<0>, ir<%i.7661>
    vp<%5> = vector-pointer ir<%arrayidx367>
    WIDEN store vp<%5>, ir<0>, vp<%4>
    CLONE ir<%arrayidx368> = getelementptr ir<@local_reg_freq>, ir<0>, ir<%i.7661>
    vp<%6> = vector-pointer ir<%arrayidx368>
    WIDEN store vp<%6>, ir<0>, vp<%4>
  Successor(s): for.inc370

  for.inc370:
    EMIT vp<%7> = or ir<%tobool365.not>, vp<%4>
    CLONE ir<%inc371> = add nuw nsw ir<%i.7661>, ir<1>
    CLONE ir<%exitcond676.not> = icmp eq ir<%inc371>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end372>, scalar.ph

ir-bb<for.end372>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.7661 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7661 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %106 = load i8, ptr %arrayidx364, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool365.not = icmp eq i8 %106, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7661 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 0, ptr %arrayidx367, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7661 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 0, ptr %arrayidx368, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc371 = add nuw nsw i64 %i.7661, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.7661 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %106 = load i8, ptr %arrayidx364, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool365.not = icmp eq i8 %106, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 0, ptr %arrayidx367, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 0, ptr %arrayidx368, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc371 = add nuw nsw i64 %i.7661, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 161, RTCostB: 265
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 161, RTCostB: 265
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.7661 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %106 = load i8, ptr %arrayidx364, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool365.not = icmp eq i8 %106, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 0, ptr %arrayidx367, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 0, ptr %arrayidx368, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc371 = add nuw nsw i64 %i.7661, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 83, RTCostB: 265
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 83, RTCostB: 161
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.7661 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %106 = load i8, ptr %arrayidx364, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool365.not = icmp eq i8 %106, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 0, ptr %arrayidx367, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 0, ptr %arrayidx368, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %inc371 = add nuw nsw i64 %i.7661, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 73, RTCostB: 265
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 73, RTCostB: 83
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.7661 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %106 = load i8, ptr %arrayidx364, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool365.not = icmp eq i8 %106, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx367, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx368, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc371 = add nuw nsw i64 %i.7661, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 161, RTCostB: 265
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 161, RTCostB: 73

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.7661 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %106 = load i8, ptr %arrayidx364, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool365.not = icmp eq i8 %106, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx367, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx368, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc371 = add nuw nsw i64 %i.7661, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 83, RTCostB: 265
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 83, RTCostB: 73

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.7661 = phi i64 [ 0, %for.cond360.preheader ], [ %inc371, %for.inc370 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx364 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %106 = load i8, ptr %arrayidx364, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool365.not = icmp eq i8 %106, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool365.not, label %for.inc370, label %if.then366 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx367 = getelementptr inbounds [53 x i32], ptr @local_reg_n_refs, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx367, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx368 = getelementptr inbounds [53 x i32], ptr @local_reg_freq, i64 0, i64 %i.7661 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx368, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc370 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc371 = add nuw nsw i64 %i.7661, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond676.not = icmp eq i64 %inc371, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond676.not, label %for.end372, label %for.body363 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 73, RTCostB: 265
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 73, RTCostB: 73
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: global_alloc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx364> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx364>
    WIDEN ir<%106> = load vp<%4>
    WIDEN ir<%tobool365.not> = icmp eq ir<%106>, ir<0>
    EMIT vp<%5> = not ir<%tobool365.not>
    CLONE ir<%arrayidx367> = getelementptr ir<@local_reg_n_refs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx367>
    WIDEN store vp<%6>, ir<0>, vp<%5>
    CLONE ir<%arrayidx368> = getelementptr ir<@local_reg_freq>, ir<0>, vp<%3>
    vp<%7> = vector-pointer ir<%arrayidx368>
    WIDEN store vp<%7>, ir<0>, vp<%5>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end372>, scalar.ph

ir-bb<for.end372>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body389.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %126 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.8663 = phi 0, %inc399, ir<1>
    CLONE ir<%hard_reg_conflicts> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<6>
    CLONE ir<%129> = load ir<%hard_reg_conflicts>
    CLONE ir<%and391> = and ir<%129>, ir<%not>
    CLONE store ir<%and391>, ir<%hard_reg_conflicts>
    CLONE ir<%hard_reg_copy_preferences> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<8>
    CLONE ir<%130> = load ir<%hard_reg_copy_preferences>
    CLONE ir<%and394> = and ir<%130>, ir<%not>
    CLONE store ir<%and394>, ir<%hard_reg_copy_preferences>
    CLONE ir<%hard_reg_preferences> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<7>
    CLONE ir<%131> = load ir<%hard_reg_preferences>
    CLONE ir<%and397> = and ir<%131>, ir<%not>
    CLONE store ir<%and397>, ir<%hard_reg_preferences>
    CLONE ir<%inc399> = add nuw ir<%i.8663>, ir<1>
    CLONE ir<%exitcond677.not> = icmp eq ir<%inc399>, ir<%conv386>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end400.loopexit>, scalar.ph

ir-bb<for.end400.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body389.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %126 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.8663 = phi 0, %inc399, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_conflicts> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<6>
    WIDEN ir<%129> = load ir<%hard_reg_conflicts>
    WIDEN ir<%and391> = and ir<%129>, ir<%not>
    WIDEN store ir<%hard_reg_conflicts>, ir<%and391>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_copy_preferences> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<8>
    WIDEN ir<%130> = load ir<%hard_reg_copy_preferences>
    WIDEN ir<%and394> = and ir<%130>, ir<%not>
    WIDEN store ir<%hard_reg_copy_preferences>, ir<%and394>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_preferences> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<7>
    WIDEN ir<%131> = load ir<%hard_reg_preferences>
    WIDEN ir<%and397> = and ir<%131>, ir<%not>
    WIDEN store ir<%hard_reg_preferences>, ir<%and397>
    WIDEN ir<%inc399> = add nuw ir<%i.8663>, ir<1>
    CLONE ir<%exitcond677.not> = icmp eq ir<%inc399>, ir<%conv386>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end400.loopexit>, scalar.ph

ir-bb<for.end400.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body389.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %126 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.8663 = phi 0, %inc399, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_conflicts> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<6>
    WIDEN ir<%129> = load ir<%hard_reg_conflicts>
    WIDEN ir<%and391> = and ir<%129>, ir<%not>
    WIDEN store ir<%hard_reg_conflicts>, ir<%and391>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_copy_preferences> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<8>
    WIDEN ir<%130> = load ir<%hard_reg_copy_preferences>
    WIDEN ir<%and394> = and ir<%130>, ir<%not>
    WIDEN store ir<%hard_reg_copy_preferences>, ir<%and394>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_preferences> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<7>
    WIDEN ir<%131> = load ir<%hard_reg_preferences>
    WIDEN ir<%and397> = and ir<%131>, ir<%not>
    WIDEN store ir<%hard_reg_preferences>, ir<%and397>
    WIDEN ir<%inc399> = add nuw ir<%i.8663>, ir<1>
    CLONE ir<%exitcond677.not> = icmp eq ir<%inc399>, ir<%conv386>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end400.loopexit>, scalar.ph

ir-bb<for.end400.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.8663 = phi i64 [ 0, %for.body389.lr.ph ], [ %inc399, %for.body389 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hard_reg_conflicts = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 6 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %129 = load i64, ptr %hard_reg_conflicts, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and391 = and i64 %129, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %and391, ptr %hard_reg_conflicts, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hard_reg_copy_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %130 = load i64, ptr %hard_reg_copy_preferences, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and394 = and i64 %130, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %and394, ptr %hard_reg_copy_preferences, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %hard_reg_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 7 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %131 = load i64, ptr %hard_reg_preferences, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and397 = and i64 %131, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %and397, ptr %hard_reg_preferences, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc399 = add nuw i64 %i.8663, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond677.not = icmp eq i64 %inc399, %conv386 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond677.not, label %for.end400.loopexit, label %for.body389 of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.8663 = phi i64 [ 0, %for.body389.lr.ph ], [ %inc399, %for.body389 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hard_reg_conflicts = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %129 = load i64, ptr %hard_reg_conflicts, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and391 = and i64 %129, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i64 %and391, ptr %hard_reg_conflicts, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hard_reg_copy_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %130 = load i64, ptr %hard_reg_copy_preferences, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and394 = and i64 %130, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i64 %and394, ptr %hard_reg_copy_preferences, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %hard_reg_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %131 = load i64, ptr %hard_reg_preferences, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and397 = and i64 %131, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i64 %and397, ptr %hard_reg_preferences, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc399 = add nuw i64 %i.8663, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond677.not = icmp eq i64 %inc399, %conv386 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond677.not, label %for.end400.loopexit, label %for.body389 of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 22
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 22
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.8663 = phi i64 [ 0, %for.body389.lr.ph ], [ %inc399, %for.body389 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hard_reg_conflicts = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %129 = load i64, ptr %hard_reg_conflicts, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and391 = and i64 %129, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i64 %and391, ptr %hard_reg_conflicts, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hard_reg_copy_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %130 = load i64, ptr %hard_reg_copy_preferences, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and394 = and i64 %130, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i64 %and394, ptr %hard_reg_copy_preferences, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %hard_reg_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %131 = load i64, ptr %hard_reg_preferences, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and397 = and i64 %131, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i64 %and397, ptr %hard_reg_preferences, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc399 = add nuw i64 %i.8663, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond677.not = icmp eq i64 %inc399, %conv386 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond677.not, label %for.end400.loopexit, label %for.body389 of type:br
LV: Vector loop of width 4 costs: 8
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 33
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 33, CostB * EstimatedWidthA: 44
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 33
B VF: 2, EstimatedWidthB: 2, CostB: 17
CostA * EstimatedWidthB: 66, CostB * EstimatedWidthA: 68
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.8663 = phi i64 [ 0, %for.body389.lr.ph ], [ %inc399, %for.body389 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hard_reg_conflicts = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %129 = load i64, ptr %hard_reg_conflicts, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and391 = and i64 %129, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i64 %and391, ptr %hard_reg_conflicts, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hard_reg_copy_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %130 = load i64, ptr %hard_reg_copy_preferences, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and394 = and i64 %130, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i64 %and394, ptr %hard_reg_copy_preferences, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %hard_reg_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %131 = load i64, ptr %hard_reg_preferences, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and397 = and i64 %131, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i64 %and397, ptr %hard_reg_preferences, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc399 = add nuw i64 %i.8663, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond677.not = icmp eq i64 %inc399, %conv386 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond677.not, label %for.end400.loopexit, label %for.body389 of type:br
LV: Vector loop of width vscale x 1 costs: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 17
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 17, CostB * EstimatedWidthA: 22
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 17
B VF: 4, EstimatedWidthB: 4, CostB: 33
CostA * EstimatedWidthB: 68, CostB * EstimatedWidthA: 66

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.8663 = phi i64 [ 0, %for.body389.lr.ph ], [ %inc399, %for.body389 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hard_reg_conflicts = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %129 = load i64, ptr %hard_reg_conflicts, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and391 = and i64 %129, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i64 %and391, ptr %hard_reg_conflicts, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hard_reg_copy_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %130 = load i64, ptr %hard_reg_copy_preferences, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and394 = and i64 %130, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i64 %and394, ptr %hard_reg_copy_preferences, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %hard_reg_preferences = getelementptr inbounds %struct.allocno, ptr %128, i64 %i.8663, i32 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %131 = load i64, ptr %hard_reg_preferences, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and397 = and i64 %131, %not of type:and
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i64 %and397, ptr %hard_reg_preferences, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc399 = add nuw i64 %i.8663, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond677.not = icmp eq i64 %inc399, %conv386 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond677.not, label %for.end400.loopexit, label %for.body389 of type:br
LV: Vector loop of width vscale x 2 costs: 8
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 33
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 33, CostB * EstimatedWidthA: 44
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 33
B VF: 4, EstimatedWidthB: 4, CostB: 33
CostA * EstimatedWidthB: 132, CostB * EstimatedWidthA: 132
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 8.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: global_alloc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body389.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %126 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.8663 = phi 0, %inc399, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_conflicts> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<6>
    WIDEN ir<%144> = load ir<%hard_reg_conflicts>
    WIDEN ir<%and391> = and ir<%144>, ir<%not>
    WIDEN store ir<%hard_reg_conflicts>, ir<%and391>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_copy_preferences> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<8>
    WIDEN ir<%145> = load ir<%hard_reg_copy_preferences>
    WIDEN ir<%and394> = and ir<%145>, ir<%not>
    WIDEN store ir<%hard_reg_copy_preferences>, ir<%and394>
    WIDEN-GEP Inv[Var][Inv] ir<%hard_reg_preferences> = getelementptr inbounds ir<%128>, ir<%i.8663>, ir<7>
    WIDEN ir<%146> = load ir<%hard_reg_preferences>
    WIDEN ir<%and397> = and ir<%146>, ir<%not>
    WIDEN store ir<%hard_reg_preferences>, ir<%and397>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end400.loopexit>, scalar.ph

ir-bb<for.end400.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %conv409, ptr %arrayidx410, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body408.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %168 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.9665 = phi %inc412, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.9665 = phi %inc412, 0\l" +
    "  ir<%conv409>, ir<1>
    CLONE ir<%arrayidx410> = getelementptr inbounds ir<%call403>, ir<%i.9665>
    CLONE store ir<%conv409>, ir<%arrayidx410>
    CLONE ir<%inc412> = add nuw ir<%i.9665>, ir<1>
    CLONE ir<%exitcond678.not> = icmp eq ir<%inc412>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond414.preheader>, scalar.ph

ir-bb<for.cond414.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body408.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %168 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.9665 = phi %inc412, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.9665 = phi %inc412, 0\l" +
    "  ir<%conv409>, ir<1>
    CLONE ir<%arrayidx410> = getelementptr inbounds ir<%call403>, ir<%i.9665>
    vp<%4> = vector-pointer ir<%arrayidx410>
    WIDEN store vp<%4>, ir<%conv409>
    WIDEN ir<%inc412> = add nuw ir<%i.9665>, ir<1>
    CLONE ir<%exitcond678.not> = icmp eq ir<%inc412>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond414.preheader>, scalar.ph

ir-bb<for.cond414.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body408.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %168 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %i.9665 = phi %inc412, 0, ir<1>
    WIDEN-INDUCTION\l" +
    "  %i.9665 = phi %inc412, 0\l" +
    "  ir<%conv409>, ir<1>
    CLONE ir<%arrayidx410> = getelementptr inbounds ir<%call403>, ir<%i.9665>
    vp<%4> = vector-pointer ir<%arrayidx410>
    WIDEN store vp<%4>, ir<%conv409>
    WIDEN ir<%inc412> = add nuw ir<%i.9665>, ir<1>
    CLONE ir<%exitcond678.not> = icmp eq ir<%inc412>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond414.preheader>, scalar.ph

ir-bb<for.cond414.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.9665 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv409 = trunc i64 %i.9665 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9665 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc412 = add nuw i64 %i.9665, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.9665 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv409 = trunc i64 %i.9665 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9665 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc412 = add nuw i64 %i.9665, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.9665 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %conv409 = trunc i64 %i.9665 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9665 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc412 = add nuw i64 %i.9665, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 3
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.9665 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %conv409 = trunc i64 %i.9665 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9665 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %inc412 = add nuw i64 %i.9665, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.9665 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv409 = trunc i64 %i.9665 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9665 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc412 = add nuw i64 %i.9665, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 3, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 3
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.9665 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv409 = trunc i64 %i.9665 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9665 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc412 = add nuw i64 %i.9665, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.9665 = phi i64 [ %inc412, %for.body408 ], [ 0, %for.body408.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv409 = trunc i64 %i.9665 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx410 = getelementptr inbounds i32, ptr %call403, i64 %i.9665 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %conv409, ptr %arrayidx410, align 4 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %inc412 = add nuw i64 %i.9665, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond678.not = icmp eq i64 %inc412, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond678.not, label %for.cond414.preheader, label %for.body408 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 7
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: global_alloc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body408.preheader>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %168 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %i.9665 = phi %inc412, 0\l" +
    "  ir<%conv409>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx410> = getelementptr inbounds ir<%call403>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx410>
    WIDEN store vp<%5>, ir<%conv409>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond414.preheader>, scalar.ph

ir-bb<for.cond414.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body418.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %168 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %i.10669 = phi 0, %inc436, ir<1>
    CLONE ir<%size420> = getelementptr inbounds ir<%185>, ir<%i.10669>, ir<1>
    CLONE ir<%186> = load ir<%size420>
    CLONE ir<%cmp421> = icmp eq ir<%186>, ir<0>
  Successor(s): if.then423

  if.then423:
    CLONE store ir<1>, ir<%size420>, ir<%cmp421>
  Successor(s): if.end426

  if.end426:
    EMIT vp<%4> = not ir<%cmp421>
    EMIT vp<%5> = or ir<%cmp421>, vp<%4>
    CLONE ir<%live_length428> = getelementptr inbounds ir<%185>, ir<%i.10669>, ir<5>
    CLONE ir<%187> = load ir<%live_length428>
    CLONE ir<%cmp429> = icmp eq ir<%187>, ir<0>
  Successor(s): if.then431

  if.then431:
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp429>
    CLONE store ir<-1>, ir<%live_length428>, vp<%6>
  Successor(s): for.inc435

  for.inc435:
    EMIT vp<%7> = not ir<%cmp429>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%6>
    CLONE ir<%inc436> = add nuw ir<%i.10669>, ir<1>
    CLONE ir<%exitcond679.not> = icmp eq ir<%inc436>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end437.loopexit>, scalar.ph

ir-bb<for.end437.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body418.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %168 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %i.10669 = phi 0, %inc436, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%size420> = getelementptr inbounds ir<%185>, ir<%i.10669>, ir<1>
    WIDEN ir<%186> = load ir<%size420>
    WIDEN ir<%cmp421> = icmp eq ir<%186>, ir<0>
  Successor(s): if.then423

  if.then423:
    WIDEN store ir<%size420>, ir<1>, ir<%cmp421>
  Successor(s): if.end426

  if.end426:
    EMIT vp<%4> = not ir<%cmp421>
    EMIT vp<%5> = or ir<%cmp421>, vp<%4>
    WIDEN-GEP Inv[Var][Inv] ir<%live_length428> = getelementptr inbounds ir<%185>, ir<%i.10669>, ir<5>
    WIDEN ir<%187> = load ir<%live_length428>
    WIDEN ir<%cmp429> = icmp eq ir<%187>, ir<0>
  Successor(s): if.then431

  if.then431:
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp429>
    WIDEN store ir<%live_length428>, ir<-1>, vp<%6>
  Successor(s): for.inc435

  for.inc435:
    EMIT vp<%7> = not ir<%cmp429>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%6>
    WIDEN ir<%inc436> = add nuw ir<%i.10669>, ir<1>
    CLONE ir<%exitcond679.not> = icmp eq ir<%inc436>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end437.loopexit>, scalar.ph

ir-bb<for.end437.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: global_alloc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body418.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %168 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %i.10669 = phi 0, %inc436, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%size420> = getelementptr inbounds ir<%185>, ir<%i.10669>, ir<1>
    WIDEN ir<%186> = load ir<%size420>
    WIDEN ir<%cmp421> = icmp eq ir<%186>, ir<0>
  Successor(s): if.then423

  if.then423:
    WIDEN store ir<%size420>, ir<1>, ir<%cmp421>
  Successor(s): if.end426

  if.end426:
    EMIT vp<%4> = not ir<%cmp421>
    EMIT vp<%5> = or ir<%cmp421>, vp<%4>
    WIDEN-GEP Inv[Var][Inv] ir<%live_length428> = getelementptr inbounds ir<%185>, ir<%i.10669>, ir<5>
    WIDEN ir<%187> = load ir<%live_length428>
    WIDEN ir<%cmp429> = icmp eq ir<%187>, ir<0>
  Successor(s): if.then431

  if.then431:
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp429>
    WIDEN store ir<%live_length428>, ir<-1>, vp<%6>
  Successor(s): for.inc435

  for.inc435:
    EMIT vp<%7> = not ir<%cmp429>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%6>
    WIDEN ir<%inc436> = add nuw ir<%i.10669>, ir<1>
    CLONE ir<%exitcond679.not> = icmp eq ir<%inc436>, ir<%conv405>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end437.loopexit>, scalar.ph

ir-bb<for.end437.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.10669 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %186 = load i32, ptr %size420, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp421 = icmp eq i32 %186, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1, ptr %size420, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 5 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %187 = load i32, ptr %live_length428, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp429 = icmp eq i32 %187, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -1, ptr %live_length428, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc436 = add nuw i64 %i.10669, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.10669 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %186 = load i32, ptr %size420, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp421 = icmp eq i32 %186, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1, ptr %size420, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %187 = load i32, ptr %live_length428, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp429 = icmp eq i32 %187, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -1, ptr %live_length428, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc436 = add nuw i64 %i.10669, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.10669 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %186 = load i32, ptr %size420, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp421 = icmp eq i32 %186, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 1, ptr %size420, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %187 = load i32, ptr %live_length428, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp429 = icmp eq i32 %187, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 -1, ptr %live_length428, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc436 = add nuw i64 %i.10669, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.10669 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %186 = load i32, ptr %size420, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp421 = icmp eq i32 %186, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 1, ptr %size420, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %187 = load i32, ptr %live_length428, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp429 = icmp eq i32 %187, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 -1, ptr %live_length428, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %inc436 = add nuw i64 %i.10669, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width 8 costs: 5
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 41
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 41, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 41
B VF: 4, EstimatedWidthB: 4, CostB: 21
CostA * EstimatedWidthB: 164, CostB * EstimatedWidthA: 168
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.10669 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %186 = load i32, ptr %size420, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp421 = icmp eq i32 %186, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1, ptr %size420, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %187 = load i32, ptr %live_length428, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp429 = icmp eq i32 %187, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 -1, ptr %live_length428, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc436 = add nuw i64 %i.10669, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width vscale x 1 costs: 6
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 12
B VF: 8, EstimatedWidthB: 8, CostB: 41
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 82

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.10669 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %186 = load i32, ptr %size420, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp421 = icmp eq i32 %186, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 1, ptr %size420, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %187 = load i32, ptr %live_length428, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp429 = icmp eq i32 %187, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 -1, ptr %live_length428, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc436 = add nuw i64 %i.10669, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width vscale x 2 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 21
B VF: 8, EstimatedWidthB: 8, CostB: 41
CostA * EstimatedWidthB: 168, CostB * EstimatedWidthA: 164

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.10669 = phi i64 [ 0, %for.body418.lr.ph ], [ %inc436, %for.inc435 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %size420 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %186 = load i32, ptr %size420, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp421 = icmp eq i32 %186, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp421, label %if.then423, label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 1, ptr %size420, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %if.end426 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %live_length428 = getelementptr inbounds %struct.allocno, ptr %185, i64 %i.10669, i32 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %187 = load i32, ptr %live_length428, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp429 = icmp eq i32 %187, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp429, label %if.then431, label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 -1, ptr %live_length428, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc435 of type:br

-----------------Function that is being costed:'global_alloc' from global.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %inc436 = add nuw i64 %i.10669, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond679.not = icmp eq i64 %inc436, %conv405 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond679.not, label %for.end437.loopexit, label %for.body418 of type:br
LV: Vector loop of width vscale x 4 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 41
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 41, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 41
B VF: 8, EstimatedWidthB: 8, CostB: 41
CostA * EstimatedWidthB: 328, CostB * EstimatedWidthA: 328
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 5.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: global_alloc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body418.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (sext i32 %168 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %i.10669 = phi 0, %inc436, ir<1>
    WIDEN-GEP Inv[Var][Inv] ir<%size420> = getelementptr inbounds ir<%185>, ir<%i.10669>, ir<1>
    WIDEN ir<%196> = load ir<%size420>
    WIDEN ir<%cmp421> = icmp eq ir<%196>, ir<0>
    WIDEN store ir<%size420>, ir<1>, ir<%cmp421>
    EMIT vp<%4> = not ir<%cmp421>
    EMIT vp<%5> = or ir<%cmp421>, vp<%4>
    WIDEN-GEP Inv[Var][Inv] ir<%live_length428> = getelementptr inbounds ir<%185>, ir<%i.10669>, ir<5>
    WIDEN ir<%197> = load ir<%live_length428>
    WIDEN ir<%cmp429> = icmp eq ir<%197>, ir<0>
    EMIT vp<%6> = logical-and vp<%5>, ir<%cmp429>
    WIDEN store ir<%live_length428>, ir<-1>, vp<%6>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end437.loopexit>, scalar.ph

ir-bb<for.end437.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 11
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: dump_conflicts' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nregs.0218> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx>
    CLONE ir<%idxprom1> = sext ir<%4>
    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%2>, ir<%idxprom1>
    CLONE ir<%5> = load ir<%arrayidx2>
    CLONE ir<%idxprom3> = sext ir<%5>
    CLONE ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    CLONE ir<%6> = load ir<%arrayidx4>
    CLONE ir<%.lobit> = lshr ir<%6>, ir<15>
    CLONE ir<%inc> = zext nneg ir<%.lobit>
    CLONE ir<%spec.select> = add ir<%nregs.0218>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%nregs.0218>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%6>
}

========== Loop: dump_conflicts' from global.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nregs.0218> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN-CAST ir<%idxprom1> = sext  ir<%4> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx2> = getelementptr inbounds ir<%2>, ir<%idxprom1>
    WIDEN ir<%5> = load ir<%arrayidx2>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%5> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    WIDEN ir<%6> = load ir<%arrayidx4>
    WIDEN ir<%.lobit> = lshr ir<%6>, ir<15>
    WIDEN-CAST ir<%inc> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select> = add ir<%nregs.0218>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nregs.0218>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}

========== Loop: dump_conflicts' from global.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%nregs.0218> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN-CAST ir<%idxprom1> = sext  ir<%4> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx2> = getelementptr inbounds ir<%2>, ir<%idxprom1>
    WIDEN ir<%5> = load ir<%arrayidx2>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%5> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    WIDEN ir<%6> = load ir<%arrayidx4>
    WIDEN ir<%.lobit> = lshr ir<%6>, ir<15>
    WIDEN-CAST ir<%inc> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select> = add ir<%nregs.0218>, ir<%inc>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%nregs.0218>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
}


-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = load i32, ptr %arrayidx, align 4 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = load i32, ptr %arrayidx2, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %6 = load i16, ptr %arrayidx4, align 2 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load i32, ptr %arrayidx, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %5 = load i32, ptr %arrayidx2, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %6 = load i16, ptr %arrayidx4, align 2 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 12884901884, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901884, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = load i32, ptr %arrayidx, align 4 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %5 = load i32, ptr %arrayidx2, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %6 = load i16, ptr %arrayidx4, align 2 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676422, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676422, RTCostB: 12884901884
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %4 = load i32, ptr %arrayidx, align 4 of type:load
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %5 = load i32, ptr %arrayidx2, align 8 of type:load
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %6 = load i16, ptr %arrayidx4, align 2 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 2 for VF 8 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 8858370071, RTCostB: 17179869176
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8858370071, RTCostB: 9663676422
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %4 = load i32, ptr %arrayidx, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %5 = load i32, ptr %arrayidx2, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %6 = load i16, ptr %arrayidx4, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 6
A is scalable.	B is not scalable.	
RTCostA: 12884901884, RTCostB: 17179869176
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901884, RTCostB: 8858370071

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load i32, ptr %arrayidx, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %5 = load i32, ptr %arrayidx2, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %6 = load i16, ptr %arrayidx4, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 9663676422, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 9663676422, RTCostB: 8858370071

-----------------Function that is being costed:'dump_conflicts' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %nregs.0218 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %3, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %4 = load i32, ptr %arrayidx, align 4 of type:load
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %idxprom1 = sext i32 %4 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2 = getelementptr inbounds %struct.allocno, ptr %2, i64 %idxprom1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %5 = load i32, ptr %arrayidx2, align 8 of type:load
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %idxprom3 = sext i32 %5 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx4 = getelementptr inbounds i16, ptr %1, i64 %idxprom3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %6 = load i16, ptr %arrayidx4, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %.lobit = lshr i16 %6, 15 of type:lshr
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %inc = zext nneg i16 %.lobit to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %spec.select = add nuw nsw i32 %nregs.0218, %inc of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 8858370071, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8858370071, RTCostB: 8858370071
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 4.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: dump_conflicts at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%nregs.0218> = phi ir<0>, ir<%spec.select>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%3>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%5>
    WIDEN-CAST ir<%idxprom1> = sext  ir<%4> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx2> = getelementptr inbounds ir<%2>, ir<%idxprom1>
    WIDEN ir<%5> = load ir<%arrayidx2>
    WIDEN-CAST ir<%idxprom3> = sext  ir<%5> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx4> = getelementptr inbounds ir<%1>, ir<%idxprom3>
    WIDEN ir<%6> = load ir<%arrayidx4>
    WIDEN ir<%.lobit> = lshr ir<%6>, ir<15>
    WIDEN-CAST ir<%inc> = zext  nneg ir<%.lobit> to i32
    WIDEN ir<%spec.select> = add ir<%nregs.0218>, ir<%inc>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%nregs.0218>, ir<%spec.select>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 27
Loops Epilogues Vectorized: 0
================================================
========== Loop: find_reg' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body850.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %best_reg.18) + ((1 + %best_reg.18) smax (%cond845.ph.pn + %best_reg.18)<nuw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1298 = phi %172, %indvars.iv.next1299, ir<1>
    WIDEN-REDUCTION-PHI ir<%this_reg.01256> = phi ir<0>, ir<%or853>
    WIDEN-REDUCTION-PHI ir<%or85612521254> = phi ir<%regs_used_so_far.promoted>, ir<%or856>
    CLONE ir<%shl852> = shl nuw ir<1>, ir<%indvars.iv1298>
    CLONE ir<%or853> = or ir<%shl852>, ir<%this_reg.01256>
    CLONE ir<%or856> = or ir<%or85612521254>, ir<%shl852>
    CLONE ir<%indvars.iv.next1299> = add nuw nsw ir<%indvars.iv1298>, ir<1>
    CLONE ir<%180> = trunc ir<%indvars.iv.next1299>
    CLONE ir<%cmp848> = icmp sgt ir<%add8461322>, ir<%180>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.01256>, ir<%or853>
  EMIT vp<%7> = compute-reduction-result ir<%or85612521254>, ir<%or856>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond847.for.end863_crit_edge>, scalar.ph

ir-bb<for.cond847.for.end863_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or853.lcssa = vp<%6>
Live-out i64 %or856.lcssa = vp<%7>
}

========== Loop: find_reg' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body850.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %best_reg.18) + ((1 + %best_reg.18) smax (%cond845.ph.pn + %best_reg.18)<nuw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1298 = phi %172, %indvars.iv.next1299, ir<1>
    WIDEN-REDUCTION-PHI ir<%this_reg.01256> = phi ir<0>, ir<%or853>
    WIDEN-REDUCTION-PHI ir<%or85612521254> = phi ir<%regs_used_so_far.promoted>, ir<%or856>
    WIDEN ir<%shl852> = shl nuw ir<1>, ir<%indvars.iv1298>
    WIDEN ir<%or853> = or ir<%shl852>, ir<%this_reg.01256>
    WIDEN ir<%or856> = or ir<%or85612521254>, ir<%shl852>
    WIDEN ir<%indvars.iv.next1299> = add nuw nsw ir<%indvars.iv1298>, ir<1>
    CLONE ir<%180> = trunc ir<%indvars.iv.next1299>
    CLONE ir<%cmp848> = icmp sgt ir<%add8461322>, ir<%180>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.01256>, ir<%or853>
  EMIT vp<%7> = compute-reduction-result ir<%or85612521254>, ir<%or856>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond847.for.end863_crit_edge>, scalar.ph

ir-bb<for.cond847.for.end863_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or853.lcssa = vp<%6>
Live-out i64 %or856.lcssa = vp<%7>
}

========== Loop: find_reg' from global.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body850.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %best_reg.18) + ((1 + %best_reg.18) smax (%cond845.ph.pn + %best_reg.18)<nuw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1298 = phi %172, %indvars.iv.next1299, ir<1>
    WIDEN-REDUCTION-PHI ir<%this_reg.01256> = phi ir<0>, ir<%or853>
    WIDEN-REDUCTION-PHI ir<%or85612521254> = phi ir<%regs_used_so_far.promoted>, ir<%or856>
    WIDEN ir<%shl852> = shl nuw ir<1>, ir<%indvars.iv1298>
    WIDEN ir<%or853> = or ir<%shl852>, ir<%this_reg.01256>
    WIDEN ir<%or856> = or ir<%or85612521254>, ir<%shl852>
    WIDEN ir<%indvars.iv.next1299> = add nuw nsw ir<%indvars.iv1298>, ir<1>
    CLONE ir<%180> = trunc ir<%indvars.iv.next1299>
    CLONE ir<%cmp848> = icmp sgt ir<%add8461322>, ir<%180>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.01256>, ir<%or853>
  EMIT vp<%7> = compute-reduction-result ir<%or85612521254>, ir<%or856>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond847.for.end863_crit_edge>, scalar.ph

ir-bb<for.cond847.for.end863_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or853.lcssa = vp<%6>
Live-out i64 %or856.lcssa = vp<%7>
}


-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1298 = phi i64 [ %172, %for.body850.preheader ], [ %indvars.iv.next1299, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %this_reg.01256 = phi i64 [ 0, %for.body850.preheader ], [ %or853, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or85612521254 = phi i64 [ %regs_used_so_far.promoted, %for.body850.preheader ], [ %or856, %for.body850 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl852 = shl nuw i64 1, %indvars.iv1298 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or853 = or i64 %shl852, %this_reg.01256 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or856 = or i64 %or85612521254, %shl852 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1299 = add nuw nsw i64 %indvars.iv1298, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %180 = trunc nuw i64 %indvars.iv.next1299 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp848 = icmp sgt i32 %add8461322, %180 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp848, label %for.body850, label %for.cond847.for.end863_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1298 = phi i64 [ %172, %for.body850.preheader ], [ %indvars.iv.next1299, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %this_reg.01256 = phi i64 [ 0, %for.body850.preheader ], [ %or853, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or85612521254 = phi i64 [ %regs_used_so_far.promoted, %for.body850.preheader ], [ %or856, %for.body850 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl852 = shl nuw i64 1, %indvars.iv1298 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or853 = or i64 %shl852, %this_reg.01256 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or856 = or i64 %or85612521254, %shl852 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1299 = add nuw nsw i64 %indvars.iv1298, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %180 = trunc nuw i64 %indvars.iv.next1299 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp848 = icmp sgt i32 %add8461322, %180 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp848, label %for.body850, label %for.cond847.for.end863_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1298 = phi i64 [ %172, %for.body850.preheader ], [ %indvars.iv.next1299, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %this_reg.01256 = phi i64 [ 0, %for.body850.preheader ], [ %or853, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or85612521254 = phi i64 [ %regs_used_so_far.promoted, %for.body850.preheader ], [ %or856, %for.body850 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl852 = shl nuw i64 1, %indvars.iv1298 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or853 = or i64 %shl852, %this_reg.01256 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or856 = or i64 %or85612521254, %shl852 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1299 = add nuw nsw i64 %indvars.iv1298, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %180 = trunc nuw i64 %indvars.iv.next1299 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp848 = icmp sgt i32 %add8461322, %180 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp848, label %for.body850, label %for.cond847.for.end863_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1298 = phi i64 [ %172, %for.body850.preheader ], [ %indvars.iv.next1299, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %this_reg.01256 = phi i64 [ 0, %for.body850.preheader ], [ %or853, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or85612521254 = phi i64 [ %regs_used_so_far.promoted, %for.body850.preheader ], [ %or856, %for.body850 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl852 = shl nuw i64 1, %indvars.iv1298 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or853 = or i64 %shl852, %this_reg.01256 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or856 = or i64 %or85612521254, %shl852 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1299 = add nuw nsw i64 %indvars.iv1298, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %180 = trunc nuw i64 %indvars.iv.next1299 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp848 = icmp sgt i32 %add8461322, %180 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp848, label %for.body850, label %for.cond847.for.end863_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'find_reg' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1298 = phi i64 [ %172, %for.body850.preheader ], [ %indvars.iv.next1299, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %this_reg.01256 = phi i64 [ 0, %for.body850.preheader ], [ %or853, %for.body850 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or85612521254 = phi i64 [ %regs_used_so_far.promoted, %for.body850.preheader ], [ %or856, %for.body850 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl852 = shl nuw i64 1, %indvars.iv1298 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or853 = or i64 %shl852, %this_reg.01256 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or856 = or i64 %or85612521254, %shl852 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1299 = add nuw nsw i64 %indvars.iv1298, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %180 = trunc nuw i64 %indvars.iv.next1299 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp848 = icmp sgt i32 %add8461322, %180 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp848, label %for.body850, label %for.cond847.for.end863_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: find_reg at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body850.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %best_reg.18) + ((1 + %best_reg.18) smax (%cond845.ph.pn + %best_reg.18)<nuw>)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1298 = phi %172, %indvars.iv.next1299, ir<1>
    WIDEN-REDUCTION-PHI ir<%this_reg.01256> = phi ir<0>, ir<%or853>
    WIDEN-REDUCTION-PHI ir<%or85612521254> = phi ir<%regs_used_so_far.promoted>, ir<%or856>
    WIDEN ir<%shl852> = shl nuw ir<1>, ir<%indvars.iv1298>
    WIDEN ir<%or853> = or ir<%shl852>, ir<%this_reg.01256>
    WIDEN ir<%or856> = or ir<%or85612521254>, ir<%shl852>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.01256>, ir<%or853>
  EMIT vp<%7> = compute-reduction-result ir<%or85612521254>, ir<%or856>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond847.for.end863_crit_edge>, scalar.ph

ir-bb<for.cond847.for.end863_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or853.lcssa = vp<%6>
Live-out i64 %or856.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 35
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_reg_live_nc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno) + ((1 + %regno) smax (%regno + %cond39.ph.pn)<nuw><nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.addr.068 = phi %inc, %regno, ir<1>
    WIDEN-REDUCTION-PHI ir<%or6567> = phi ir<%hard_regs_live.promoted>, ir<%or>
    CLONE ir<%sh_prom> = zext nneg ir<%regno.addr.068>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%or6567>, ir<%shl>
    CLONE ir<%inc> = add nsw ir<%regno.addr.068>, ir<1>
    CLONE ir<%cmp41> = icmp slt ir<%inc>, ir<%add4072>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or6567>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.while.end_crit_edge>, scalar.ph

ir-bb<while.cond.while.end_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_reg_live_nc' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno) + ((1 + %regno) smax (%regno + %cond39.ph.pn)<nuw><nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.addr.068 = phi %inc, %regno, ir<1>
    WIDEN-REDUCTION-PHI ir<%or6567> = phi ir<%hard_regs_live.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%regno.addr.068> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or6567>, ir<%shl>
    WIDEN ir<%inc> = add nsw ir<%regno.addr.068>, ir<1>
    CLONE ir<%cmp41> = icmp slt ir<%inc>, ir<%add4072>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or6567>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.while.end_crit_edge>, scalar.ph

ir-bb<while.cond.while.end_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_reg_live_nc' from global.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno) + ((1 + %regno) smax (%regno + %cond39.ph.pn)<nuw><nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.addr.068 = phi %inc, %regno, ir<1>
    WIDEN-REDUCTION-PHI ir<%or6567> = phi ir<%hard_regs_live.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%regno.addr.068> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or6567>, ir<%shl>
    WIDEN ir<%inc> = add nsw ir<%regno.addr.068>, ir<1>
    CLONE ir<%cmp41> = icmp slt ir<%inc>, ir<%add4072>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or6567>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.while.end_crit_edge>, scalar.ph

ir-bb<while.cond.while.end_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_reg_live_nc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %regno.addr.068 = phi i32 [ %inc, %while.body ], [ %regno, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or6567 = phi i64 [ %or, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom = zext nneg i32 %regno.addr.068 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or6567, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %regno.addr.068, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp41 = icmp slt i32 %inc, %add4072 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp41, label %while.body, label %while.cond.while.end_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'mark_reg_live_nc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %regno.addr.068 = phi i32 [ %inc, %while.body ], [ %regno, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or6567 = phi i64 [ %or, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom = zext nneg i32 %regno.addr.068 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or6567, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %regno.addr.068, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp41 = icmp slt i32 %inc, %add4072 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp41, label %while.body, label %while.cond.while.end_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_reg_live_nc' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %regno.addr.068 = phi i32 [ %inc, %while.body ], [ %regno, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or6567 = phi i64 [ %or, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom = zext nneg i32 %regno.addr.068 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or6567, %shl of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nsw i32 %regno.addr.068, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp41 = icmp slt i32 %inc, %add4072 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp41, label %while.body, label %while.cond.while.end_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_reg_live_nc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %regno.addr.068 = phi i32 [ %inc, %while.body ], [ %regno, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or6567 = phi i64 [ %or, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %regno.addr.068 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or6567, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nsw i32 %regno.addr.068, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp41 = icmp slt i32 %inc, %add4072 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp41, label %while.body, label %while.cond.while.end_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'mark_reg_live_nc' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %regno.addr.068 = phi i32 [ %inc, %while.body ], [ %regno, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or6567 = phi i64 [ %or, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %regno.addr.068 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or6567, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %regno.addr.068, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp41 = icmp slt i32 %inc, %add4072 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp41, label %while.body, label %while.cond.while.end_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_reg_live_nc at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %regno) + ((1 + %regno) smax (%regno + %cond39.ph.pn)<nuw><nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.addr.068 = phi %inc, %regno, ir<1>
    WIDEN-REDUCTION-PHI ir<%or6567> = phi ir<%hard_regs_live.promoted>, ir<%or>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%regno.addr.068> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or6567>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or6567>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.while.end_crit_edge>, scalar.ph

ir-bb<while.cond.while.end_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 46
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %15 = load i64, ptr %arrayidx19, align 8 -> Cost: 4 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i64, ptr %gep, align 8 -> Cost: 4 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i64 %or23, ptr %gep, align 8 -> Cost: 4 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %15 = load i64, ptr %arrayidx19, align 8 -> Cost: 10 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i64, ptr %gep, align 8 -> Cost: 10 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i64 %or23, ptr %gep, align 8 -> Cost: 10 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %15 = load i64, ptr %arrayidx19, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i64, ptr %gep, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i64 %or23, ptr %gep, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %15 = load i64, ptr %arrayidx19, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %16 = load i64, ptr %gep, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i64 %or23, ptr %gep, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: record_one_conflict' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next>
    CLONE ir<%15> = load ir<%arrayidx19>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv.next>
    CLONE ir<%16> = load ir<%gep>
    CLONE ir<%or23> = or ir<%16>, ir<%15>
    CLONE store ir<%or23>, ir<%gep>
    CLONE ir<%cmp16> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end27.loopexit58>, scalar.ph

ir-bb<if.end27.loopexit58>:
No successors

scalar.ph:
No successors
}

========== Loop: record_one_conflict' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx19>
    WIDEN ir<%15> = load vp<%4>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer (reverse) ir<%gep>
    WIDEN ir<%16> = load vp<%5>
    WIDEN ir<%or23> = or ir<%16>, ir<%15>
    vp<%6> = vector-pointer (reverse) ir<%gep>
    WIDEN store vp<%6>, ir<%or23>
    CLONE ir<%cmp16> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end27.loopexit58>, scalar.ph

ir-bb<if.end27.loopexit58>:
No successors

scalar.ph:
No successors
}

========== Loop: record_one_conflict' from global.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx19>
    WIDEN ir<%15> = load vp<%4>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer (reverse) ir<%gep>
    WIDEN ir<%16> = load vp<%5>
    WIDEN ir<%or23> = or ir<%16>, ir<%15>
    vp<%6> = vector-pointer (reverse) ir<%gep>
    WIDEN store vp<%6>, ir<%or23>
    CLONE ir<%cmp16> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end27.loopexit58>, scalar.ph

ir-bb<if.end27.loopexit58>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_one_conflict' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx19 = getelementptr inbounds i64, ptr %11, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %15 = load i64, ptr %arrayidx19, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep = getelementptr i64, ptr %invariant.gep, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %16 = load i64, ptr %gep, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or23 = or i64 %16, %15 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %or23, ptr %gep, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp16 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp16, label %for.body17, label %if.end27.loopexit58 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'record_one_conflict' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx19 = getelementptr inbounds i64, ptr %11, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %15 = load i64, ptr %arrayidx19, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep = getelementptr i64, ptr %invariant.gep, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %16 = load i64, ptr %gep, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or23 = or i64 %16, %15 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i64 %or23, ptr %gep, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp16 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp16, label %for.body17, label %if.end27.loopexit58 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 32212254711, RTCostB: 25769803770
A is not scalable.	B is not scalable.	
RTCostA: 32212254711, RTCostB: 25769803770

-----------------Function that is being costed:'record_one_conflict' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %13, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx19 = getelementptr inbounds i64, ptr %11, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   %15 = load i64, ptr %arrayidx19, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %gep = getelementptr i64, ptr %invariant.gep, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   %16 = load i64, ptr %gep, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or23 = or i64 %16, %15 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   store i64 %or23, ptr %gep, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp16 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp16, label %for.body17, label %if.end27.loopexit58 of type:br
LV: Vector loop of width 4 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 36507222000, RTCostB: 25769803770
A is not scalable.	B is not scalable.	
RTCostA: 36507222000, RTCostB: 25769803770

-----------------Function that is being costed:'record_one_conflict' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx19 = getelementptr inbounds i64, ptr %11, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %15 = load i64, ptr %arrayidx19, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %gep = getelementptr i64, ptr %invariant.gep, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %16 = load i64, ptr %gep, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or23 = or i64 %16, %15 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i64 %or23, ptr %gep, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp16 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp16, label %for.body17, label %if.end27.loopexit58 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 19327352829, RTCostB: 25769803770
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 19327352829, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: vscale x 1 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_one_conflict' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx19 = getelementptr inbounds i64, ptr %11, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %15 = load i64, ptr %arrayidx19, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %gep = getelementptr i64, ptr %invariant.gep, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %16 = load i64, ptr %gep, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or23 = or i64 %16, %15 of type:or
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store i64 %or23, ptr %gep, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp16 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp16, label %for.body17, label %if.end27.loopexit58 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 13958643717, RTCostB: 25769803770
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 13958643717, RTCostB: 19327352829
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: vscale x 1
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: record_one_conflict at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%13> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx19> = getelementptr inbounds ir<%11>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx19>
    WIDEN ir<%18> = load vp<%6>
    CLONE ir<%gep> = getelementptr ir<%invariant.gep>, ir<%indvars.iv.next>
    vp<%7> = vector-pointer (reverse) ir<%gep>
    WIDEN ir<%19> = load vp<%7>
    WIDEN ir<%or23> = or ir<%19>, ir<%18>
    vp<%8> = vector-pointer (reverse) ir<%gep>
    WIDEN store vp<%8>, ir<%or23>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end27.loopexit58>, scalar.ph

ir-bb<if.end27.loopexit58>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 9
Loops Analyzed: 49
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_reg_death' from global.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %spec.select) + ((1 + %spec.select) smax (%cond95.ph.pn + %spec.select)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.1142 = phi %inc, %spec.select, ir<1>
    WIDEN-REDUCTION-PHI ir<%and102139141> = phi ir<%hard_regs_live.promoted>, ir<%and102>
    CLONE ir<%sh_prom99> = zext nneg ir<%regno.1142>
    CLONE ir<%shl100> = shl nuw ir<1>, ir<%sh_prom99>
    CLONE ir<%not101> = xor ir<%shl100>, ir<-1>
    CLONE ir<%and102> = and ir<%and102139141>, ir<%not101>
    CLONE ir<%inc> = add nsw ir<%regno.1142>, ir<1>
    CLONE ir<%cmp97> = icmp slt ir<%inc>, ir<%add96146>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and102139141>, ir<%and102>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end103.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end103.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and102.lcssa = vp<%6>
}

========== Loop: mark_reg_death' from global.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %spec.select) + ((1 + %spec.select) smax (%cond95.ph.pn + %spec.select)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.1142 = phi %inc, %spec.select, ir<1>
    WIDEN-REDUCTION-PHI ir<%and102139141> = phi ir<%hard_regs_live.promoted>, ir<%and102>
    WIDEN-CAST ir<%sh_prom99> = zext  nneg ir<%regno.1142> to i64
    WIDEN ir<%shl100> = shl nuw ir<1>, ir<%sh_prom99>
    WIDEN ir<%not101> = xor ir<%shl100>, ir<-1>
    WIDEN ir<%and102> = and ir<%and102139141>, ir<%not101>
    WIDEN ir<%inc> = add nsw ir<%regno.1142>, ir<1>
    CLONE ir<%cmp97> = icmp slt ir<%inc>, ir<%add96146>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and102139141>, ir<%and102>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end103.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end103.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and102.lcssa = vp<%6>
}

========== Loop: mark_reg_death' from global.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %spec.select) + ((1 + %spec.select) smax (%cond95.ph.pn + %spec.select)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.1142 = phi %inc, %spec.select, ir<1>
    WIDEN-REDUCTION-PHI ir<%and102139141> = phi ir<%hard_regs_live.promoted>, ir<%and102>
    WIDEN-CAST ir<%sh_prom99> = zext  nneg ir<%regno.1142> to i64
    WIDEN ir<%shl100> = shl nuw ir<1>, ir<%sh_prom99>
    WIDEN ir<%not101> = xor ir<%shl100>, ir<-1>
    WIDEN ir<%and102> = and ir<%and102139141>, ir<%not101>
    WIDEN ir<%inc> = add nsw ir<%regno.1142>, ir<1>
    CLONE ir<%cmp97> = icmp slt ir<%inc>, ir<%add96146>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and102139141>, ir<%and102>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end103.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end103.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and102.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_reg_death' from global.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %regno.1142 = phi i32 [ %inc, %while.body ], [ %spec.select, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and102139141 = phi i64 [ %and102, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom99 = zext nneg i32 %regno.1142 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl100 = shl nuw i64 1, %sh_prom99 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not101 = xor i64 %shl100, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and102 = and i64 %and102139141, %not101 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %regno.1142, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp97 = icmp slt i32 %inc, %add96146 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp97, label %while.body, label %while.cond.if.end103.loopexit_crit_edge of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'mark_reg_death' from global.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %regno.1142 = phi i32 [ %inc, %while.body ], [ %spec.select, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and102139141 = phi i64 [ %and102, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom99 = zext nneg i32 %regno.1142 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl100 = shl nuw i64 1, %sh_prom99 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not101 = xor i64 %shl100, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and102 = and i64 %and102139141, %not101 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %regno.1142, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp97 = icmp slt i32 %inc, %add96146 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp97, label %while.body, label %while.cond.if.end103.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_reg_death' from global.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %regno.1142 = phi i32 [ %inc, %while.body ], [ %spec.select, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and102139141 = phi i64 [ %and102, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom99 = zext nneg i32 %regno.1142 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl100 = shl nuw i64 1, %sh_prom99 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not101 = xor i64 %shl100, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and102 = and i64 %and102139141, %not101 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nsw i32 %regno.1142, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp97 = icmp slt i32 %inc, %add96146 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp97, label %while.body, label %while.cond.if.end103.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_reg_death' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %regno.1142 = phi i32 [ %inc, %while.body ], [ %spec.select, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and102139141 = phi i64 [ %and102, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom99 = zext nneg i32 %regno.1142 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl100 = shl nuw i64 1, %sh_prom99 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not101 = xor i64 %shl100, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and102 = and i64 %and102139141, %not101 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nsw i32 %regno.1142, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp97 = icmp slt i32 %inc, %add96146 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp97, label %while.body, label %while.cond.if.end103.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'mark_reg_death' from global.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %regno.1142 = phi i32 [ %inc, %while.body ], [ %spec.select, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and102139141 = phi i64 [ %and102, %while.body ], [ %hard_regs_live.promoted, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom99 = zext nneg i32 %regno.1142 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl100 = shl nuw i64 1, %sh_prom99 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not101 = xor i64 %shl100, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and102 = and i64 %and102139141, %not101 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %regno.1142, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp97 = icmp slt i32 %inc, %add96146 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp97, label %while.body, label %while.cond.if.end103.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 10
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_reg_death at line: global.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %spec.select) + ((1 + %spec.select) smax (%cond95.ph.pn + %spec.select)<nsw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %regno.1142 = phi %inc, %spec.select, ir<1>
    WIDEN-REDUCTION-PHI ir<%and102139141> = phi ir<%hard_regs_live.promoted>, ir<%and102>
    WIDEN-CAST ir<%sh_prom99> = zext  nneg ir<%regno.1142> to i64
    WIDEN ir<%shl100> = shl nuw ir<1>, ir<%sh_prom99>
    WIDEN ir<%not101> = xor ir<%shl100>, ir<-1>
    WIDEN ir<%and102> = and ir<%and102139141>, ir<%not101>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and102139141>, ir<%and102>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end103.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end103.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and102.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 10
Loops Analyzed: 50
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o graph.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         graph.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o haifa-sched.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         haifa-sched.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o hash.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         hash.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o hashtable.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         hashtable.c
@@ Instruction =>  %2 = load ptr, ptr %p.0, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load ptr, ptr %p.0, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %2 = load ptr, ptr %p.0, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load ptr, ptr %p.0, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: ht_dump_statistics' from hashtable.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<entry>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %0 to i64)) + ((8 + (ptrtoint ptr %0 to i64)) umax ((8 * (zext i32 %1 to i64))<nuw><nsw> + (ptrtoint ptr %0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%sum_of_squares.0> = phi ir<0>, ir<%sum_of_squares.1>
    WIDEN-REDUCTION-PHI ir<%longest.0> = phi ir<0>, ir<%longest.2>
    EMIT ir<%p.0> = WIDEN-POINTER-INDUCTION ir<%0>, 8
    WIDEN-REDUCTION-PHI ir<%total_bytes.0> = phi ir<0>, ir<%total_bytes.1>
    WIDEN-REDUCTION-PHI ir<%nids.0> = phi ir<0>, ir<%nids.1>
    CLONE ir<%2> = load ir<%p.0>
    CLONE ir<%tobool.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%4> = not ir<%tobool.not>
    CLONE ir<%3> = load ir<%2>, vp<%4>
    CLONE ir<%conv> = zext ir<%3>
    CLONE ir<%add> = add ir<%total_bytes.0>, ir<%conv>
    CLONE ir<%mul> = mul nuw ir<%conv>, ir<%conv>
    CLONE ir<%add1> = add ir<%mul>, ir<%sum_of_squares.0>
    CLONE ir<%spec.select> = call @llvm.umax.i64(ir<%longest.0>, ir<%conv>)
    CLONE ir<%inc> = add ir<%nids.0>, ir<1>
  Successor(s): do.cond

  do.cond:
    EMIT vp<%5> = or ir<%tobool.not>, vp<%4>
    BLEND ir<%sum_of_squares.1> = ir<%add1> ir<%sum_of_squares.0>/ir<%tobool.not>
    BLEND ir<%longest.2> = ir<%spec.select> ir<%longest.0>/ir<%tobool.not>
    BLEND ir<%total_bytes.1> = ir<%add> ir<%total_bytes.0>/ir<%tobool.not>
    BLEND ir<%nids.1> = ir<%inc> ir<%nids.0>/ir<%tobool.not>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%p.0>, ir<8>
    CLONE ir<%cmp5> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%sum_of_squares.0>, ir<%sum_of_squares.1>
  EMIT vp<%9> = compute-reduction-result ir<%longest.0>, ir<%longest.2>
  EMIT vp<%10> = compute-reduction-result ir<%total_bytes.0>, ir<%total_bytes.1>
  EMIT vp<%11> = compute-reduction-result ir<%nids.0>, ir<%nids.1>
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out i64 %sum_of_squares.1.lcssa = vp<%8>
Live-out i64 %longest.2.lcssa = vp<%9>
Live-out i64 %total_bytes.1.lcssa = vp<%10>
Live-out i64 %nids.1.lcssa = vp<%11>
}

========== Loop: ht_dump_statistics' from hashtable.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<entry>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %0 to i64)) + ((8 + (ptrtoint ptr %0 to i64)) umax ((8 * (zext i32 %1 to i64))<nuw><nsw> + (ptrtoint ptr %0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%sum_of_squares.0> = phi ir<0>, ir<%sum_of_squares.1>
    WIDEN-REDUCTION-PHI ir<%longest.0> = phi ir<0>, ir<%longest.2>
    EMIT ir<%p.0> = WIDEN-POINTER-INDUCTION ir<%0>, 8
    WIDEN-REDUCTION-PHI ir<%total_bytes.0> = phi ir<0>, ir<%total_bytes.1>
    WIDEN-REDUCTION-PHI ir<%nids.0> = phi ir<0>, ir<%nids.1>
    vp<%4> = vector-pointer ir<%p.0>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%5> = not ir<%tobool.not>
    WIDEN ir<%3> = load ir<%2>, vp<%5>
    WIDEN-CAST ir<%conv> = zext  ir<%3> to i64
    WIDEN ir<%add> = add ir<%total_bytes.0>, ir<%conv>
    WIDEN ir<%mul> = mul nuw ir<%conv>, ir<%conv>
    WIDEN ir<%add1> = add ir<%mul>, ir<%sum_of_squares.0>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i64(ir<%longest.0>, ir<%conv>) (using vector intrinsic)
    WIDEN ir<%inc> = add ir<%nids.0>, ir<1>
  Successor(s): do.cond

  do.cond:
    EMIT vp<%6> = or ir<%tobool.not>, vp<%5>
    BLEND ir<%sum_of_squares.1> = ir<%add1> ir<%sum_of_squares.0>/ir<%tobool.not>
    BLEND ir<%longest.2> = ir<%spec.select> ir<%longest.0>/ir<%tobool.not>
    BLEND ir<%total_bytes.1> = ir<%add> ir<%total_bytes.0>/ir<%tobool.not>
    BLEND ir<%nids.1> = ir<%inc> ir<%nids.0>/ir<%tobool.not>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%p.0>, ir<8>
    CLONE ir<%cmp5> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sum_of_squares.0>, ir<%sum_of_squares.1>
  EMIT vp<%10> = compute-reduction-result ir<%longest.0>, ir<%longest.2>
  EMIT vp<%11> = compute-reduction-result ir<%total_bytes.0>, ir<%total_bytes.1>
  EMIT vp<%12> = compute-reduction-result ir<%nids.0>, ir<%nids.1>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out i64 %sum_of_squares.1.lcssa = vp<%9>
Live-out i64 %longest.2.lcssa = vp<%10>
Live-out i64 %total_bytes.1.lcssa = vp<%11>
Live-out i64 %nids.1.lcssa = vp<%12>
}

========== Loop: ht_dump_statistics' from hashtable.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<entry>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((-1 + (-1 * (ptrtoint ptr %0 to i64)) + ((8 + (ptrtoint ptr %0 to i64)) umax ((8 * (zext i32 %1 to i64))<nuw><nsw> + (ptrtoint ptr %0 to i64)))) /u 8))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%sum_of_squares.0> = phi ir<0>, ir<%sum_of_squares.1>
    WIDEN-REDUCTION-PHI ir<%longest.0> = phi ir<0>, ir<%longest.2>
    EMIT ir<%p.0> = WIDEN-POINTER-INDUCTION ir<%0>, 8
    WIDEN-REDUCTION-PHI ir<%total_bytes.0> = phi ir<0>, ir<%total_bytes.1>
    WIDEN-REDUCTION-PHI ir<%nids.0> = phi ir<0>, ir<%nids.1>
    vp<%4> = vector-pointer ir<%p.0>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%tobool.not> = icmp eq ir<%2>, ir<null>
  Successor(s): if.then

  if.then:
    EMIT vp<%5> = not ir<%tobool.not>
    WIDEN ir<%3> = load ir<%2>, vp<%5>
    WIDEN-CAST ir<%conv> = zext  ir<%3> to i64
    WIDEN ir<%add> = add ir<%total_bytes.0>, ir<%conv>
    WIDEN ir<%mul> = mul nuw ir<%conv>, ir<%conv>
    WIDEN ir<%add1> = add ir<%mul>, ir<%sum_of_squares.0>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i64(ir<%longest.0>, ir<%conv>) (using vector intrinsic)
    WIDEN ir<%inc> = add ir<%nids.0>, ir<1>
  Successor(s): do.cond

  do.cond:
    EMIT vp<%6> = or ir<%tobool.not>, vp<%5>
    BLEND ir<%sum_of_squares.1> = ir<%add1> ir<%sum_of_squares.0>/ir<%tobool.not>
    BLEND ir<%longest.2> = ir<%spec.select> ir<%longest.0>/ir<%tobool.not>
    BLEND ir<%total_bytes.1> = ir<%add> ir<%total_bytes.0>/ir<%tobool.not>
    BLEND ir<%nids.1> = ir<%inc> ir<%nids.0>/ir<%tobool.not>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%p.0>, ir<8>
    CLONE ir<%cmp5> = icmp ult ir<%incdec.ptr>, ir<%add.ptr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%sum_of_squares.0>, ir<%sum_of_squares.1>
  EMIT vp<%10> = compute-reduction-result ir<%longest.0>, ir<%longest.2>
  EMIT vp<%11> = compute-reduction-result ir<%total_bytes.0>, ir<%total_bytes.1>
  EMIT vp<%12> = compute-reduction-result ir<%nids.0>, ir<%nids.1>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<do.end>, scalar.ph

ir-bb<do.end>:
No successors

scalar.ph:
No successors

Live-out i64 %sum_of_squares.1.lcssa = vp<%9>
Live-out i64 %longest.2.lcssa = vp<%10>
Live-out i64 %total_bytes.1.lcssa = vp<%11>
Live-out i64 %nids.1.lcssa = vp<%12>
}


-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = load ptr, ptr %p.0, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %3 = load i32, ptr %2, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load ptr, ptr %p.0, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %3 = load i32, ptr %2, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %2 = load ptr, ptr %p.0, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %3 = load i32, ptr %2, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Vector loop of width 4 costs: 7
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 24
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %2 = load ptr, ptr %p.0, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %3 = load i32, ptr %2, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Vector loop of width vscale x 1 costs: 7
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 12
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %sum_of_squares.0 = phi i64 [ 0, %entry ], [ %sum_of_squares.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %longest.0 = phi i64 [ 0, %entry ], [ %longest.2, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.0 = phi ptr [ %0, %entry ], [ %incdec.ptr, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %total_bytes.0 = phi i64 [ 0, %entry ], [ %total_bytes.1, %do.cond ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %nids.0 = phi i64 [ 0, %entry ], [ %nids.1, %do.cond ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %2 = load ptr, ptr %p.0, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool.not = icmp eq ptr %2, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %do.cond, label %if.then of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %3 = load i32, ptr %2, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %conv = zext i32 %3 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %add = add i64 %total_bytes.0, %conv of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %mul = mul nuw i64 %conv, %conv of type:mul
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %add1 = add i64 %mul, %sum_of_squares.0 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %spec.select = tail call i64 @llvm.umax.i64(i64 %longest.0, i64 %conv) of type:call
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc = add i64 %nids.0, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %do.cond of type:br

-----------------Function that is being costed:'ht_dump_statistics' from hashtable.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sum_of_squares.1 = phi i64 [ %add1, %if.then ], [ %sum_of_squares.0, %do.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %longest.2 = phi i64 [ %spec.select, %if.then ], [ %longest.0, %do.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %total_bytes.1 = phi i64 [ %add, %if.then ], [ %total_bytes.0, %do.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %nids.1 = phi i64 [ %inc, %if.then ], [ %nids.0, %do.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp5 = icmp ult ptr %incdec.ptr, %add.ptr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5, label %do.body, label %do.end of type:br
LV: Vector loop of width vscale x 2 costs: 7
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 24
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 29
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 29, CostB * EstimatedWidthA: 24
LV: Selecting VF: 1 With Cost: 6.
maxbefore: 1
maxafter: 1
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o hooks.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         hooks.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o ifcvt.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         ifcvt.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o insn-attrtab.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         insn-attrtab.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o insn-emit.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         insn-emit.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o insn-extract.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         insn-extract.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o insn-opinit.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         insn-opinit.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o insn-output.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         insn-output.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o insn-peep.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         insn-peep.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o insn-recog.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         insn-recog.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o integrate.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         integrate.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o intl.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         intl.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o jump.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         jump.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o langhooks.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         langhooks.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o lcm.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         lcm.c
========== Loop: reg_becomes_live' from lcm.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond64105 to i64) + (-1 * (1 umin (zext i32 %cond64105 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or100> = phi ir<%live.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%15> = add nsw ir<%indvars.iv.next>, ir<%14>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%15>
    CLONE ir<%or> = or ir<%or100>, ir<%shl>
    CLONE ir<%cmp66> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or100>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: reg_becomes_live' from lcm.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond64105 to i64) + (-1 * (1 umin (zext i32 %cond64105 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or100> = phi ir<%live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%14>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or100>, ir<%shl>
    CLONE ir<%cmp66> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or100>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: reg_becomes_live' from lcm.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond64105 to i64) + (-1 * (1 umin (zext i32 %cond64105 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or100> = phi ir<%live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%14>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or100>, ir<%shl>
    CLONE ir<%cmp66> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or100>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'reg_becomes_live' from lcm.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or100 = phi i64 [ %live.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %15 = add nsw i64 %indvars.iv.next, %14 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or100, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp66 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'reg_becomes_live' from lcm.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or100 = phi i64 [ %live.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %15 = add nsw i64 %indvars.iv.next, %14 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or100, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp66 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reg_becomes_live' from lcm.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or100 = phi i64 [ %live.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %15 = add nsw i64 %indvars.iv.next, %14 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or100, %shl of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp66 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reg_becomes_live' from lcm.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or100 = phi i64 [ %live.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %15 = add nsw i64 %indvars.iv.next, %14 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or100, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp66 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'reg_becomes_live' from lcm.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %13, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or100 = phi i64 [ %live.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %15 = add nsw i64 %indvars.iv.next, %14 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or100, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp66 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp66, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: reg_becomes_live at line: lcm.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond64105 to i64) + (-1 * (1 umin (zext i32 %cond64105 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %13, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or100> = phi ir<%live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%14>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or100>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or100>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 33
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o lists.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         lists.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o local-alloc.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         local-alloc.c
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %78, ptr %arrayidx505, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body503.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1108 = phi 0, %indvars.iv.next1109, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1108 = phi 0, %indvars.iv.next1109\l" +
    "  ir<%78>, ir<1>
    CLONE ir<%arrayidx505> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1108>
    CLONE store ir<%78>, ir<%arrayidx505>
    CLONE ir<%indvars.iv.next1109> = add nuw nsw ir<%indvars.iv1108>, ir<1>
    CLONE ir<%exitcond1111.not> = icmp eq ir<%indvars.iv.next1109>, ir<%wide.trip.count1110>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end508.loopexit>, scalar.ph

ir-bb<for.end508.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body503.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1108 = phi 0, %indvars.iv.next1109, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1108 = phi 0, %indvars.iv.next1109\l" +
    "  ir<%78>, ir<1>
    CLONE ir<%arrayidx505> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1108>
    vp<%4> = vector-pointer ir<%arrayidx505>
    WIDEN store vp<%4>, ir<%78>
    WIDEN ir<%indvars.iv.next1109> = add nuw nsw ir<%indvars.iv1108>, ir<1>
    CLONE ir<%exitcond1111.not> = icmp eq ir<%indvars.iv.next1109>, ir<%wide.trip.count1110>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end508.loopexit>, scalar.ph

ir-bb<for.end508.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body503.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1108 = phi 0, %indvars.iv.next1109, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1108 = phi 0, %indvars.iv.next1109\l" +
    "  ir<%78>, ir<1>
    CLONE ir<%arrayidx505> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1108>
    vp<%4> = vector-pointer ir<%arrayidx505>
    WIDEN store vp<%4>, ir<%78>
    WIDEN ir<%indvars.iv.next1109> = add nuw nsw ir<%indvars.iv1108>, ir<1>
    CLONE ir<%exitcond1111.not> = icmp eq ir<%indvars.iv.next1109>, ir<%wide.trip.count1110>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end508.loopexit>, scalar.ph

ir-bb<for.end508.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1108 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1109, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1108 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1108 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %78, ptr %arrayidx505, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1109 = add nuw nsw i64 %indvars.iv1108, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1111.not = icmp eq i64 %indvars.iv.next1109, %wide.trip.count1110 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1111.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1108 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1109, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1108 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1108 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %78, ptr %arrayidx505, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1109 = add nuw nsw i64 %indvars.iv1108, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1111.not = icmp eq i64 %indvars.iv.next1109, %wide.trip.count1110 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1111.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450941
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450941
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1108 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1109, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1108 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1108 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %78, ptr %arrayidx505, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1109 = add nuw nsw i64 %indvars.iv1108, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1111.not = icmp eq i64 %indvars.iv.next1109, %wide.trip.count1110 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1111.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 6442450941
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 3221225472
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1108 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1109, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1108 of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1108 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %78, ptr %arrayidx505, align 4 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next1109 = add nuw nsw i64 %indvars.iv1108, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1111.not = icmp eq i64 %indvars.iv.next1109, %wide.trip.count1110 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1111.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1879048206, RTCostB: 6442450941
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1879048206, RTCostB: 2147483653
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1108 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1109, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1108 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1108 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %78, ptr %arrayidx505, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1109 = add nuw nsw i64 %indvars.iv1108, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1111.not = icmp eq i64 %indvars.iv.next1109, %wide.trip.count1110 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1111.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450941
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 1879048206

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1108 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1109, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1108 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1108 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %78, ptr %arrayidx505, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1109 = add nuw nsw i64 %indvars.iv1108, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1111.not = icmp eq i64 %indvars.iv.next1109, %wide.trip.count1110 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1111.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 6442450941
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 1879048206

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1108 = phi i64 [ 0, %for.body503.preheader ], [ %indvars.iv.next1109, %for.body503 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx505 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1108 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %78 = trunc nuw nsw i64 %indvars.iv1108 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %78, ptr %arrayidx505, align 4 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next1109 = add nuw nsw i64 %indvars.iv1108, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1111.not = icmp eq i64 %indvars.iv.next1109, %wide.trip.count1110 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1111.not, label %for.end508.loopexit, label %for.body503 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1879048206, RTCostB: 6442450941
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1879048206, RTCostB: 1879048206
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: block_alloc at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body503.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %77 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1108 = phi 0, %indvars.iv.next1109\l" +
    "  ir<%78>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx505> = getelementptr inbounds ir<%call499>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx505>
    WIDEN store vp<%5>, ir<%78>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end508.loopexit>, scalar.ph

ir-bb<for.end508.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %117, ptr %arrayidx581, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %117, ptr %arrayidx581, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %117, ptr %arrayidx581, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %117, ptr %arrayidx581, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %117, ptr %arrayidx581, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %117, ptr %arrayidx581, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body579.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %114 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1114 = phi 0, %indvars.iv.next1115, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1114 = phi 0, %indvars.iv.next1115\l" +
    "  ir<%117>, ir<1>
    CLONE ir<%arrayidx581> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1114>
    CLONE store ir<%117>, ir<%arrayidx581>
    CLONE ir<%indvars.iv.next1115> = add nuw nsw ir<%indvars.iv1114>, ir<1>
    CLONE ir<%exitcond1117.not> = icmp eq ir<%indvars.iv.next1115>, ir<%wide.trip.count1116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end584.loopexit>, scalar.ph

ir-bb<for.end584.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body579.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %114 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1114 = phi 0, %indvars.iv.next1115, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1114 = phi 0, %indvars.iv.next1115\l" +
    "  ir<%117>, ir<1>
    CLONE ir<%arrayidx581> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1114>
    vp<%4> = vector-pointer ir<%arrayidx581>
    WIDEN store vp<%4>, ir<%117>
    WIDEN ir<%indvars.iv.next1115> = add nuw nsw ir<%indvars.iv1114>, ir<1>
    CLONE ir<%exitcond1117.not> = icmp eq ir<%indvars.iv.next1115>, ir<%wide.trip.count1116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end584.loopexit>, scalar.ph

ir-bb<for.end584.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: block_alloc' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body579.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %114 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1114 = phi 0, %indvars.iv.next1115, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1114 = phi 0, %indvars.iv.next1115\l" +
    "  ir<%117>, ir<1>
    CLONE ir<%arrayidx581> = getelementptr inbounds ir<%call499>, ir<%indvars.iv1114>
    vp<%4> = vector-pointer ir<%arrayidx581>
    WIDEN store vp<%4>, ir<%117>
    WIDEN ir<%indvars.iv.next1115> = add nuw nsw ir<%indvars.iv1114>, ir<1>
    CLONE ir<%exitcond1117.not> = icmp eq ir<%indvars.iv.next1115>, ir<%wide.trip.count1116>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end584.loopexit>, scalar.ph

ir-bb<for.end584.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1114 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1115, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1114 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %117 = trunc nuw nsw i64 %indvars.iv1114 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %117, ptr %arrayidx581, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1115 = add nuw nsw i64 %indvars.iv1114, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1117.not = icmp eq i64 %indvars.iv.next1115, %wide.trip.count1116 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1117.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1114 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1115, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1114 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %117 = trunc nuw nsw i64 %indvars.iv1114 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %117, ptr %arrayidx581, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1115 = add nuw nsw i64 %indvars.iv1114, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1117.not = icmp eq i64 %indvars.iv.next1115, %wide.trip.count1116 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1117.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450941
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450941
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1114 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1115, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1114 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %117 = trunc nuw nsw i64 %indvars.iv1114 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %117, ptr %arrayidx581, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1115 = add nuw nsw i64 %indvars.iv1114, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1117.not = icmp eq i64 %indvars.iv.next1115, %wide.trip.count1116 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1117.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 6442450941
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 3221225472
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1114 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1115, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1114 of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %117 = trunc nuw nsw i64 %indvars.iv1114 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %117, ptr %arrayidx581, align 4 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next1115 = add nuw nsw i64 %indvars.iv1114, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1117.not = icmp eq i64 %indvars.iv.next1115, %wide.trip.count1116 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1117.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1879048206, RTCostB: 6442450941
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1879048206, RTCostB: 2147483653
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1114 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1115, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1114 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %117 = trunc nuw nsw i64 %indvars.iv1114 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %117, ptr %arrayidx581, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1115 = add nuw nsw i64 %indvars.iv1114, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1117.not = icmp eq i64 %indvars.iv.next1115, %wide.trip.count1116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1117.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width vscale x 1 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450941
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 1879048206

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1114 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1115, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1114 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %117 = trunc nuw nsw i64 %indvars.iv1114 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %117, ptr %arrayidx581, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1115 = add nuw nsw i64 %indvars.iv1114, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1117.not = icmp eq i64 %indvars.iv.next1115, %wide.trip.count1116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1117.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 6442450941
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 1879048206

-----------------Function that is being costed:'block_alloc' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1114 = phi i64 [ 0, %for.body579.preheader ], [ %indvars.iv.next1115, %for.body579 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx581 = getelementptr inbounds i32, ptr %call499, i64 %indvars.iv1114 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %117 = trunc nuw nsw i64 %indvars.iv1114 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %117, ptr %arrayidx581, align 4 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next1115 = add nuw nsw i64 %indvars.iv1114, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1117.not = icmp eq i64 %indvars.iv.next1115, %wide.trip.count1116 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1117.not, label %for.end584.loopexit, label %for.body579 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1879048206, RTCostB: 6442450941
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1879048206, RTCostB: 1879048206
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: block_alloc at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body579.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %114 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1114 = phi 0, %indvars.iv.next1115\l" +
    "  ir<%117>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx581> = getelementptr inbounds ir<%call499>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx581>
    WIDEN store vp<%5>, ir<%117>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end584.loopexit>, scalar.ph

ir-bb<for.end584.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 20
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load i64, ptr %arrayidx20, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %arrayidx20, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i64, ptr %arrayidx20, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %arrayidx20, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: find_free_reg' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %born_index) + %dead_index) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used.2310> = phi ir<%used.1>, ir<%or21>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    CLONE ir<%9> = load ir<%arrayidx20>
    CLONE ir<%or21> = or ir<%9>, ir<%used.2310>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%10> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp18> = icmp slt ir<%10>, ir<%dead_index>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used.2310>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}

========== Loop: find_free_reg' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %born_index) + %dead_index) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used.2310> = phi ir<%used.1>, ir<%or21>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%or21> = or ir<%9>, ir<%used.2310>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%10> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp18> = icmp slt ir<%10>, ir<%dead_index>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%used.2310>, ir<%or21>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%7>
}

========== Loop: find_free_reg' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %born_index) + %dead_index) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used.2310> = phi ir<%used.1>, ir<%or21>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%8>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%or21> = or ir<%9>, ir<%used.2310>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%10> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp18> = icmp slt ir<%10>, ir<%dead_index>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%used.2310>, ir<%or21>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%7>
}


-----------------Function that is being costed:'find_free_reg' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %used.2310 = phi i64 [ %used.1, %for.body.lr.ph ], [ %or21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx20 = getelementptr inbounds i64, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load i64, ptr %arrayidx20, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or21 = or i64 %9, %used.2310 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %10 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp18 = icmp slt i32 %10, %dead_index of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp18, label %for.body, label %for.end.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'find_free_reg' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %used.2310 = phi i64 [ %used.1, %for.body.lr.ph ], [ %or21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx20 = getelementptr inbounds i64, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %arrayidx20, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or21 = or i64 %9, %used.2310 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %10 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp18 = icmp slt i32 %10, %dead_index of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp18, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_free_reg' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %used.2310 = phi i64 [ %used.1, %for.body.lr.ph ], [ %or21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx20 = getelementptr inbounds i64, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %9 = load i64, ptr %arrayidx20, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or21 = or i64 %9, %used.2310 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %10 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp18 = icmp slt i32 %10, %dead_index of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp18, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_free_reg' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %used.2310 = phi i64 [ %used.1, %for.body.lr.ph ], [ %or21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx20 = getelementptr inbounds i64, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %9 = load i64, ptr %arrayidx20, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or21 = or i64 %9, %used.2310 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %10 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp18 = icmp slt i32 %10, %dead_index of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp18, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'find_free_reg' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %used.2310 = phi i64 [ %used.1, %for.body.lr.ph ], [ %or21, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx20 = getelementptr inbounds i64, ptr %8, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %9 = load i64, ptr %arrayidx20, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or21 = or i64 %9, %used.2310 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %10 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp18 = icmp slt i32 %10, %dead_index of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp18, label %for.body, label %for.end.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: find_free_reg at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + (-1 * %born_index) + %dead_index) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%used.2310> = phi ir<%used.1>, ir<%or21>
    vp<%4>    = DERIVED-IV ir<%0> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%8>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%9> = load vp<%6>
    WIDEN ir<%or21> = or ir<%9>, ir<%used.2310>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%used.2310>, ir<%or21>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 41
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %11, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or7880> = phi ir<%regs_live.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%15> = add nsw ir<%indvars.iv.next>, ir<%12>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%15>
    CLONE ir<%or> = or ir<%or7880>, ir<%shl>
    CLONE ir<%cmp41> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or7880>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit91>, scalar.ph

ir-bb<if.end.sink.split.loopexit91>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %11, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or7880> = phi ir<%regs_live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%12>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or7880>, ir<%shl>
    CLONE ir<%cmp41> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or7880>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit91>, scalar.ph

ir-bb<if.end.sink.split.loopexit91>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %11, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or7880> = phi ir<%regs_live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%12>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or7880>, ir<%shl>
    CLONE ir<%cmp41> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or7880>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit91>, scalar.ph

ir-bb<if.end.sink.split.loopexit91>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %11, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or7880 = phi i64 [ %regs_live.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %15 = add nsw i64 %indvars.iv.next, %12 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or7880, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp41 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp41, label %while.body, label %if.end.sink.split.loopexit91 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %11, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or7880 = phi i64 [ %regs_live.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %15 = add nsw i64 %indvars.iv.next, %12 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or7880, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp41 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp41, label %while.body, label %if.end.sink.split.loopexit91 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %11, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or7880 = phi i64 [ %regs_live.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %15 = add nsw i64 %indvars.iv.next, %12 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or7880, %shl of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp41 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp41, label %while.body, label %if.end.sink.split.loopexit91 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %11, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or7880 = phi i64 [ %regs_live.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %15 = add nsw i64 %indvars.iv.next, %12 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or7880, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp41 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp41, label %while.body, label %if.end.sink.split.loopexit91 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %11, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or7880 = phi i64 [ %regs_live.promoted, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %15 = add nsw i64 %indvars.iv.next, %12 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %15 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or7880, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp41 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp41, label %while.body, label %if.end.sink.split.loopexit91 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_life at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %11, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or7880> = phi ir<%regs_live.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%15> = add nsw ir<%indvars.iv.next>, ir<%12>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%15>
    WIDEN ir<%or> = or ir<%or7880>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or7880>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit91>, scalar.ph

ir-bb<if.end.sink.split.loopexit91>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body48.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv88 = phi %32, %indvars.iv.next89, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and528385> = phi ir<%regs_live.promoted82>, ir<%and52>
    CLONE ir<%indvars.iv.next89> = add nsw ir<%indvars.iv88>, ir<-1>
    CLONE ir<%35> = add nsw ir<%indvars.iv.next89>, ir<%33>
    CLONE ir<%shl51> = shl nuw ir<1>, ir<%35>
    CLONE ir<%not> = xor ir<%shl51>, ir<-1>
    CLONE ir<%and52> = and ir<%and528385>, ir<%not>
    CLONE ir<%cmp46> = icmp ugt ir<%indvars.iv88>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and528385>, ir<%and52>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit>, scalar.ph

ir-bb<if.end.sink.split.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %and52.lcssa = vp<%6>
}

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body48.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv88 = phi %32, %indvars.iv.next89, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and528385> = phi ir<%regs_live.promoted82>, ir<%and52>
    WIDEN ir<%indvars.iv.next89> = add nsw ir<%indvars.iv88>, ir<-1>
    WIDEN ir<%35> = add nsw ir<%indvars.iv.next89>, ir<%33>
    WIDEN ir<%shl51> = shl nuw ir<1>, ir<%35>
    WIDEN ir<%not> = xor ir<%shl51>, ir<-1>
    WIDEN ir<%and52> = and ir<%and528385>, ir<%not>
    CLONE ir<%cmp46> = icmp ugt ir<%indvars.iv88>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and528385>, ir<%and52>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit>, scalar.ph

ir-bb<if.end.sink.split.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %and52.lcssa = vp<%6>
}

========== Loop: mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body48.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv88 = phi %32, %indvars.iv.next89, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and528385> = phi ir<%regs_live.promoted82>, ir<%and52>
    WIDEN ir<%indvars.iv.next89> = add nsw ir<%indvars.iv88>, ir<-1>
    WIDEN ir<%35> = add nsw ir<%indvars.iv.next89>, ir<%33>
    WIDEN ir<%shl51> = shl nuw ir<1>, ir<%35>
    WIDEN ir<%not> = xor ir<%shl51>, ir<-1>
    WIDEN ir<%and52> = and ir<%and528385>, ir<%not>
    CLONE ir<%cmp46> = icmp ugt ir<%indvars.iv88>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and528385>, ir<%and52>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit>, scalar.ph

ir-bb<if.end.sink.split.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %and52.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv88 = phi i64 [ %32, %while.body48.preheader ], [ %indvars.iv.next89, %while.body48 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and528385 = phi i64 [ %regs_live.promoted82, %while.body48.preheader ], [ %and52, %while.body48 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next89 = add nsw i64 %indvars.iv88, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %35 = add nsw i64 %indvars.iv.next89, %33 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl51 = shl nuw i64 1, %35 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl51, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and52 = and i64 %and528385, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp46 = icmp ugt i64 %indvars.iv88, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp46, label %while.body48, label %if.end.sink.split.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv88 = phi i64 [ %32, %while.body48.preheader ], [ %indvars.iv.next89, %while.body48 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and528385 = phi i64 [ %regs_live.promoted82, %while.body48.preheader ], [ %and52, %while.body48 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next89 = add nsw i64 %indvars.iv88, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %35 = add nsw i64 %indvars.iv.next89, %33 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl51 = shl nuw i64 1, %35 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl51, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and52 = and i64 %and528385, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp46 = icmp ugt i64 %indvars.iv88, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp46, label %while.body48, label %if.end.sink.split.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450938
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450938
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv88 = phi i64 [ %32, %while.body48.preheader ], [ %indvars.iv.next89, %while.body48 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and528385 = phi i64 [ %regs_live.promoted82, %while.body48.preheader ], [ %and52, %while.body48 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next89 = add nsw i64 %indvars.iv88, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %35 = add nsw i64 %indvars.iv.next89, %33 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl51 = shl nuw i64 1, %35 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not = xor i64 %shl51, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and52 = and i64 %and528385, %not of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp46 = icmp ugt i64 %indvars.iv88, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp46, label %while.body48, label %if.end.sink.split.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2952790023, RTCostB: 6442450938
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2952790023, RTCostB: 3221225472
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv88 = phi i64 [ %32, %while.body48.preheader ], [ %indvars.iv.next89, %while.body48 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and528385 = phi i64 [ %regs_live.promoted82, %while.body48.preheader ], [ %and52, %while.body48 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next89 = add nsw i64 %indvars.iv88, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %35 = add nsw i64 %indvars.iv.next89, %33 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl51 = shl nuw i64 1, %35 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not = xor i64 %shl51, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and52 = and i64 %and528385, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp46 = icmp ugt i64 %indvars.iv88, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp46, label %while.body48, label %if.end.sink.split.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 6442450938
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225472, RTCostB: 2952790023

-----------------Function that is being costed:'mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv88 = phi i64 [ %32, %while.body48.preheader ], [ %indvars.iv.next89, %while.body48 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and528385 = phi i64 [ %regs_live.promoted82, %while.body48.preheader ], [ %and52, %while.body48 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next89 = add nsw i64 %indvars.iv88, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %35 = add nsw i64 %indvars.iv.next89, %33 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl51 = shl nuw i64 1, %35 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not = xor i64 %shl51, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and52 = and i64 %and528385, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp46 = icmp ugt i64 %indvars.iv88, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp46, label %while.body48, label %if.end.sink.split.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2952790023, RTCostB: 6442450938
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2952790023, RTCostB: 2952790023
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_life at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body48.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond39 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv88 = phi %32, %indvars.iv.next89, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and528385> = phi ir<%regs_live.promoted82>, ir<%and52>
    WIDEN ir<%indvars.iv.next89> = add nsw ir<%indvars.iv88>, ir<-1>
    WIDEN ir<%35> = add nsw ir<%indvars.iv.next89>, ir<%33>
    WIDEN ir<%shl51> = shl nuw ir<1>, ir<%35>
    WIDEN ir<%not> = xor ir<%shl51>, ir<-1>
    WIDEN ir<%and52> = and ir<%and528385>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and528385>, ir<%and52>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.sink.split.loopexit>, scalar.ph

ir-bb<if.end.sink.split.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %and52.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 43
Loops Epilogues Vectorized: 0
================================================
========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond3999 to i64) + (-1 * (1 umin (zext i32 %cond3999 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%this_reg.091> = phi ir<0>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%13> = add nsw ir<%indvars.iv.next>, ir<%10>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%13>
    CLONE ir<%or> = or ir<%shl>, ir<%this_reg.091>
    CLONE ir<%cmp40> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.091>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond44.preheader.loopexit>, scalar.ph

ir-bb<while.cond44.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond3999 to i64) + (-1 * (1 umin (zext i32 %cond3999 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%this_reg.091> = phi ir<0>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%13> = add nsw ir<%indvars.iv.next>, ir<%10>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%13>
    WIDEN ir<%or> = or ir<%shl>, ir<%this_reg.091>
    CLONE ir<%cmp40> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.091>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond44.preheader.loopexit>, scalar.ph

ir-bb<while.cond44.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond3999 to i64) + (-1 * (1 umin (zext i32 %cond3999 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%this_reg.091> = phi ir<0>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%13> = add nsw ir<%indvars.iv.next>, ir<%10>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%13>
    WIDEN ir<%or> = or ir<%shl>, ir<%this_reg.091>
    CLONE ir<%cmp40> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.091>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond44.preheader.loopexit>, scalar.ph

ir-bb<while.cond44.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %this_reg.091 = phi i64 [ 0, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %13 = add nsw i64 %indvars.iv.next, %10 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %13 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %shl, %this_reg.091 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp40 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp40, label %while.body, label %while.cond44.preheader.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %this_reg.091 = phi i64 [ 0, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %13 = add nsw i64 %indvars.iv.next, %10 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %13 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %shl, %this_reg.091 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp40 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp40, label %while.body, label %while.cond44.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %this_reg.091 = phi i64 [ 0, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %13 = add nsw i64 %indvars.iv.next, %10 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %13 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %shl, %this_reg.091 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp40 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp40, label %while.body, label %while.cond44.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %this_reg.091 = phi i64 [ 0, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %13 = add nsw i64 %indvars.iv.next, %10 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %13 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %shl, %this_reg.091 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp40 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp40, label %while.body, label %while.cond44.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %9, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %this_reg.091 = phi i64 [ 0, %while.body.preheader ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %13 = add nsw i64 %indvars.iv.next, %10 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %13 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %shl, %this_reg.091 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp40 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp40, label %while.body, label %while.cond44.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: post_mark_life at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond3999 to i64) + (-1 * (1 umin (zext i32 %cond3999 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %9, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%this_reg.091> = phi ir<0>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%13> = add nsw ir<%indvars.iv.next>, ir<%10>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%13>
    WIDEN ir<%or> = or ir<%shl>, ir<%this_reg.091>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%this_reg.091>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond44.preheader.loopexit>, scalar.ph

ir-bb<while.cond44.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

@@ Instruction =>  %34 = load i64, ptr %arrayidx49, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or50, ptr %arrayidx49, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load i64, ptr %arrayidx49, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %or50, ptr %arrayidx49, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %34 = load i64, ptr %arrayidx49, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or50, ptr %arrayidx49, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load i64, ptr %arrayidx49, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %or50, ptr %arrayidx49, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body47.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %death to i64) + (-1 * (sext i32 %birth to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv95 = phi %32, %indvars.iv.next96, ir<1>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%31>, ir<%indvars.iv95>
    CLONE ir<%34> = load ir<%arrayidx49>
    CLONE ir<%or50> = or ir<%34>, ir<%this_reg.0.lcssa>
    CLONE store ir<%or50>, ir<%arrayidx49>
    CLONE ir<%indvars.iv.next96> = add nsw ir<%indvars.iv95>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next96>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body47.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %death to i64) + (-1 * (sext i32 %birth to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv95 = phi %32, %indvars.iv.next96, ir<1>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%31>, ir<%indvars.iv95>
    vp<%4> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%34> = load vp<%4>
    WIDEN ir<%or50> = or ir<%34>, ir<%this_reg.0.lcssa>
    vp<%5> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%5>, ir<%or50>
    CLONE ir<%indvars.iv.next96> = add nsw ir<%indvars.iv95>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next96>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: post_mark_life' from local-alloc.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body47.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %death to i64) + (-1 * (sext i32 %birth to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv95 = phi %32, %indvars.iv.next96, ir<1>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%31>, ir<%indvars.iv95>
    vp<%4> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%34> = load vp<%4>
    WIDEN ir<%or50> = or ir<%34>, ir<%this_reg.0.lcssa>
    vp<%5> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%5>, ir<%or50>
    CLONE ir<%indvars.iv.next96> = add nsw ir<%indvars.iv95>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next96>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv95 = phi i64 [ %32, %while.body47.lr.ph ], [ %indvars.iv.next96, %while.body47 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx49 = getelementptr inbounds i64, ptr %31, i64 %indvars.iv95 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %34 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or50 = or i64 %34, %this_reg.0.lcssa of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %or50, ptr %arrayidx49, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next96, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %while.body47 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv95 = phi i64 [ %32, %while.body47.lr.ph ], [ %indvars.iv.next96, %while.body47 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx49 = getelementptr inbounds i64, ptr %31, i64 %indvars.iv95 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %34 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or50 = or i64 %34, %this_reg.0.lcssa of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %or50, ptr %arrayidx49, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next96, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %while.body47 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv95 = phi i64 [ %32, %while.body47.lr.ph ], [ %indvars.iv.next96, %while.body47 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx49 = getelementptr inbounds i64, ptr %31, i64 %indvars.iv95 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %34 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or50 = or i64 %34, %this_reg.0.lcssa of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i64 %or50, ptr %arrayidx49, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next96, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %while.body47 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv95 = phi i64 [ %32, %while.body47.lr.ph ], [ %indvars.iv.next96, %while.body47 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx49 = getelementptr inbounds i64, ptr %31, i64 %indvars.iv95 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %34 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or50 = or i64 %34, %this_reg.0.lcssa of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i64 %or50, ptr %arrayidx49, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next96, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %while.body47 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'post_mark_life' from local-alloc.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv95 = phi i64 [ %32, %while.body47.lr.ph ], [ %indvars.iv.next96, %while.body47 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx49 = getelementptr inbounds i64, ptr %31, i64 %indvars.iv95 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %34 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or50 = or i64 %34, %this_reg.0.lcssa of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i64 %or50, ptr %arrayidx49, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next96 = add nsw i64 %indvars.iv95, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next96, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %while.body47 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: post_mark_life at line: local-alloc.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body47.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %death to i64) + (-1 * (sext i32 %birth to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%32> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%31>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%34> = load vp<%6>
    WIDEN ir<%or50> = or ir<%34>, ir<%this_reg.0.lcssa>
    vp<%7> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%7>, ir<%or50>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 45
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o loop.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         loop.c
========== Loop: loop_optimize' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body22.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %inc124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%add.ptr> = getelementptr inbounds ir<%call17>, ir<%indvars.iv>
    CLONE ir<%aux> = getelementptr inbounds ir<%call14>, ir<%indvars.iv>, ir<22>
    CLONE store ir<%add.ptr>, ir<%aux>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end27.loopexit>, scalar.ph

ir-bb<for.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: loop_optimize' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body22.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %inc124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call17>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var][Inv] ir<%aux> = getelementptr inbounds ir<%call14>, ir<%indvars.iv>, ir<22>
    WIDEN store ir<%aux>, ir<%add.ptr>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end27.loopexit>, scalar.ph

ir-bb<for.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: loop_optimize' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body22.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %inc124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call17>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var][Inv] ir<%aux> = getelementptr inbounds ir<%call14>, ir<%indvars.iv>, ir<22>
    WIDEN store ir<%aux>, ir<%add.ptr>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end27.loopexit>, scalar.ph

ir-bb<for.end27.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'loop_optimize' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body22.preheader ], [ %indvars.iv.next, %for.body22 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add.ptr = getelementptr inbounds %struct.loop_info, ptr %call17, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %aux = getelementptr inbounds %struct.loop, ptr %call14, i64 %indvars.iv, i32 22 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %add.ptr, ptr %aux, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end27.loopexit, label %for.body22 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'loop_optimize' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body22.preheader ], [ %indvars.iv.next, %for.body22 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %add.ptr = getelementptr inbounds %struct.loop_info, ptr %call17, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %aux = getelementptr inbounds %struct.loop, ptr %call14, i64 %indvars.iv, i32 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %add.ptr, ptr %aux, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end27.loopexit, label %for.body22 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 6442450941
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 6442450941
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'loop_optimize' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body22.preheader ], [ %indvars.iv.next, %for.body22 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %add.ptr = getelementptr inbounds %struct.loop_info, ptr %call17, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %aux = getelementptr inbounds %struct.loop, ptr %call14, i64 %indvars.iv, i32 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %add.ptr, ptr %aux, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end27.loopexit, label %for.body22 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096386, RTCostB: 6442450941
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096386, RTCostB: 4294967295
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'loop_optimize' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body22.preheader ], [ %indvars.iv.next, %for.body22 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %add.ptr = getelementptr inbounds %struct.loop_info, ptr %call17, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %aux = getelementptr inbounds %struct.loop, ptr %call14, i64 %indvars.iv, i32 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %add.ptr, ptr %aux, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end27.loopexit, label %for.body22 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 6442450941
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 3758096386

-----------------Function that is being costed:'loop_optimize' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body22.preheader ], [ %indvars.iv.next, %for.body22 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %add.ptr = getelementptr inbounds %struct.loop_info, ptr %call17, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %aux = getelementptr inbounds %struct.loop, ptr %call14, i64 %indvars.iv, i32 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %add.ptr, ptr %aux, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end27.loopexit, label %for.body22 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096386, RTCostB: 6442450941
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096386, RTCostB: 3758096386
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: loop_optimize at line: loop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body22.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %inc124 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Var] ir<%add.ptr> = getelementptr inbounds ir<%call17>, ir<%indvars.iv>
    WIDEN-GEP Inv[Var][Inv] ir<%aux> = getelementptr inbounds ir<%call14>, ir<%indvars.iv>, ir<22>
    WIDEN store ir<%aux>, ir<%add.ptr>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end27.loopexit>, scalar.ph

ir-bb<for.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv457> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv444 = phi 0, %indvars.iv.next445, ir<1>
    CLONE ir<%arrayidx232.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv444>
    CLONE ir<%22> = load ir<%arrayidx232.us>
    CLONE ir<%mul234.us> = mul nsw ir<%22>, ir<%giv_count.0.lcssa.fr456>
    CLONE ir<%add235.us> = add nsw ir<%mul234.us>, ir<%.lcssa>
    CLONE ir<%idxprom236.us> = sext ir<%add235.us>
    CLONE ir<%arrayidx237.us> = getelementptr inbounds ir<%call22>, ir<%idxprom236.us>
    CLONE ir<%23> = load ir<%arrayidx237.us>
    CLONE ir<%tobool238.not.us> = icmp eq ir<%23>, ir<null>
  Successor(s): if.then239.us

  if.then239.us:
    EMIT vp<%3> = not ir<%tobool238.not.us>
    CLONE ir<%24> = load ir<%benefit215.us.lcssa>, vp<%3>
    CLONE ir<%total_benefit244.us> = getelementptr inbounds ir<%arrayidx232.us>, ir<4>
    CLONE ir<%25> = load ir<%total_benefit244.us>, vp<%3>
    CLONE ir<%reass.sub416> = sub ir<%25>, ir<%24>
    CLONE ir<%sub245.us> = add ir<%reass.sub416>, ir<-3>
    CLONE store ir<%sub245.us>, ir<%total_benefit244.us>, vp<%3>
  Successor(s): if.end246.us

  if.end246.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool238.not.us>
    CLONE ir<%indvars.iv.next445> = add nuw nsw ir<%indvars.iv444>, ir<1>
    CLONE ir<%exitcond447.not> = icmp eq ir<%indvars.iv.next445>, ir<%conv457>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%conv457>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup253.us>, scalar.ph

ir-bb<cleanup253.us>:
No successors

scalar.ph:
No successors
}

========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv457> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv444 = phi 0, %indvars.iv.next445, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx232.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv444>
    INTERLEAVE-GROUP with factor 2 at %22, ir<%arrayidx232.us>
      ir<%22> = load from index 0
    WIDEN ir<%mul234.us> = mul nsw ir<%22>, ir<%giv_count.0.lcssa.fr456>
    WIDEN ir<%add235.us> = add nsw ir<%mul234.us>, ir<%.lcssa>
    WIDEN-CAST ir<%idxprom236.us> = sext  ir<%add235.us> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx237.us> = getelementptr inbounds ir<%call22>, ir<%idxprom236.us>
    WIDEN ir<%23> = load ir<%arrayidx237.us>
    WIDEN ir<%tobool238.not.us> = icmp eq ir<%23>, ir<null>
  Successor(s): if.then239.us

  if.then239.us:
    EMIT vp<%3> = not ir<%tobool238.not.us>
    WIDEN ir<%24> = load ir<%benefit215.us.lcssa>, vp<%3>
    WIDEN-GEP Var[Inv] ir<%total_benefit244.us> = getelementptr inbounds ir<%arrayidx232.us>, ir<4>
    WIDEN ir<%25> = load ir<%total_benefit244.us>, vp<%3>
    WIDEN ir<%reass.sub416> = sub ir<%25>, ir<%24>
    WIDEN ir<%sub245.us> = add ir<%reass.sub416>, ir<-3>
    WIDEN store ir<%total_benefit244.us>, ir<%sub245.us>, vp<%3>
  Successor(s): if.end246.us

  if.end246.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool238.not.us>
    WIDEN ir<%indvars.iv.next445> = add nuw nsw ir<%indvars.iv444>, ir<1>
    CLONE ir<%exitcond447.not> = icmp eq ir<%indvars.iv.next445>, ir<%conv457>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: combine_givs' from loop.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv457> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv444 = phi 0, %indvars.iv.next445, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx232.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv444>
    INTERLEAVE-GROUP with factor 2 at %22, ir<%arrayidx232.us>
      ir<%22> = load from index 0
    WIDEN ir<%mul234.us> = mul nsw ir<%22>, ir<%giv_count.0.lcssa.fr456>
    WIDEN ir<%add235.us> = add nsw ir<%mul234.us>, ir<%.lcssa>
    WIDEN-CAST ir<%idxprom236.us> = sext  ir<%add235.us> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx237.us> = getelementptr inbounds ir<%call22>, ir<%idxprom236.us>
    WIDEN ir<%23> = load ir<%arrayidx237.us>
    WIDEN ir<%tobool238.not.us> = icmp eq ir<%23>, ir<null>
  Successor(s): if.then239.us

  if.then239.us:
    EMIT vp<%3> = not ir<%tobool238.not.us>
    WIDEN ir<%24> = load ir<%benefit215.us.lcssa>, vp<%3>
    WIDEN-GEP Var[Inv] ir<%total_benefit244.us> = getelementptr inbounds ir<%arrayidx232.us>, ir<4>
    WIDEN ir<%25> = load ir<%total_benefit244.us>, vp<%3>
    WIDEN ir<%reass.sub416> = sub ir<%25>, ir<%24>
    WIDEN ir<%sub245.us> = add ir<%reass.sub416>, ir<-3>
    WIDEN store ir<%total_benefit244.us>, ir<%sub245.us>, vp<%3>
  Successor(s): if.end246.us

  if.end246.us:
    EMIT vp<%4> = or vp<%3>, ir<%tobool238.not.us>
    WIDEN ir<%indvars.iv.next445> = add nuw nsw ir<%indvars.iv444>, ir<1>
    CLONE ir<%exitcond447.not> = icmp eq ir<%indvars.iv.next445>, ir<%conv457>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv444 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next445, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv444 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr456 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next445 = add nuw nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond447.not = icmp eq i64 %indvars.iv.next445, %conv457 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond447.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv444 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next445, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv444 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr456 of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next445 = add nuw nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond447.not = icmp eq i64 %indvars.iv.next445, %conv457 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond447.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv444 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next445, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv444 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 4 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr456 of type:mul
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next445 = add nuw nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond447.not = icmp eq i64 %indvars.iv.next445, %conv457 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond447.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Vector loop of width 4 costs: 7
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 30
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 30, CostB * EstimatedWidthA: 40
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 30
B VF: 2, EstimatedWidthB: 2, CostB: 18
CostA * EstimatedWidthB: 60, CostB * EstimatedWidthA: 72
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv444 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next445, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv444 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr456 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next445 = add nuw nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond447.not = icmp eq i64 %indvars.iv.next445, %conv457 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond447.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Vector loop of width vscale x 1 costs: 9
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 18
B VF: 4, EstimatedWidthB: 4, CostB: 30
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 60

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv444 = phi i64 [ 0, %for.cond226.preheader.us ], [ %indvars.iv.next445, %if.end246.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx232.us = getelementptr inbounds %struct.combine_givs_stats, ptr %call, i64 %indvars.iv444 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %22 = load i32, ptr %arrayidx232.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul234.us = mul nsw i32 %22, %giv_count.0.lcssa.fr456 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add235.us = add nsw i32 %mul234.us, %.lcssa of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %idxprom236.us = sext i32 %add235.us to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx237.us = getelementptr inbounds ptr, ptr %call22, i64 %idxprom236.us of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %23 = load ptr, ptr %arrayidx237.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool238.not.us = icmp eq ptr %23, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool238.not.us, label %if.end246.us, label %if.then239.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %24 = load i32, ptr %benefit215.us.lcssa, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %total_benefit244.us = getelementptr inbounds i8, ptr %arrayidx232.us, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %25 = load i32, ptr %total_benefit244.us, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %reass.sub416 = sub i32 %25, %24 of type:sub
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub245.us = add i32 %reass.sub416, -3 of type:add
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %sub245.us, ptr %total_benefit244.us, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end246.us of type:br

-----------------Function that is being costed:'combine_givs' from loop.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next445 = add nuw nsw i64 %indvars.iv444, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond447.not = icmp eq i64 %indvars.iv.next445, %conv457 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond447.not, label %cleanup253.us, label %for.body229.us of type:br
LV: Vector loop of width vscale x 2 costs: 7
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 30
B VF: 1, EstimatedWidthB: 1, CostB: 10
CostA * EstimatedWidthB: 30, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 30
B VF: 4, EstimatedWidthB: 4, CostB: 30
CostA * EstimatedWidthB: 120, CostB * EstimatedWidthA: 120
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 7.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: combine_givs at line: loop.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%conv457> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv444 = phi 0, %indvars.iv.next445, ir<1>
    WIDEN-GEP Inv[Var] ir<%arrayidx232.us> = getelementptr inbounds ir<%call>, ir<%indvars.iv444>
    INTERLEAVE-GROUP with factor 2 at %23, ir<%arrayidx232.us>
      ir<%23> = load from index 0
    WIDEN ir<%mul234.us> = mul nsw ir<%23>, ir<%giv_count.0.lcssa.fr456>
    WIDEN ir<%add235.us> = add nsw ir<%mul234.us>, ir<%.lcssa>
    WIDEN-CAST ir<%idxprom236.us> = sext  ir<%add235.us> to i64
    WIDEN-GEP Inv[Var] ir<%arrayidx237.us> = getelementptr inbounds ir<%call22>, ir<%idxprom236.us>
    WIDEN ir<%24> = load ir<%arrayidx237.us>
    WIDEN ir<%tobool238.not.us> = icmp eq ir<%24>, ir<null>
    EMIT vp<%3> = not ir<%tobool238.not.us>
    WIDEN ir<%25> = load ir<%benefit215.us.lcssa>, vp<%3>
    WIDEN-GEP Var[Inv] ir<%total_benefit244.us> = getelementptr inbounds ir<%arrayidx232.us>, ir<4>
    WIDEN ir<%26> = load ir<%total_benefit244.us>, vp<%3>
    WIDEN ir<%reass.sub416> = sub ir<%26>, ir<%25>
    WIDEN ir<%sub245.us> = add ir<%reass.sub416>, ir<-3>
    WIDEN store ir<%total_benefit244.us>, ir<%sub245.us>, vp<%3>
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 127
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o obstack.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         obstack.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o optabs.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         optabs.c
========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv365>, ir<%indvars.iv>, ir<0>
    CLONE store ir<1317>, ir<%arrayidx15>
    CLONE ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv365>, ir<%indvars.iv>, ir<1>
    CLONE store ir<1317>, ir<%arrayidx15.1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv365>, ir<%indvars.iv>, ir<0>
    CLONE ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv365>, ir<%indvars.iv>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx15.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx15> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv365>, ir<%indvars.iv>, ir<0>
    CLONE ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv365>, ir<%indvars.iv>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx15.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx15 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv365, i64 %indvars.iv, i64 0 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv365, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i32 1317, ptr %arrayidx15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv365, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i32 1317, ptr %arrayidx15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv365, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 236
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 120
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i32 1317, ptr %arrayidx15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv365, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 8 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 236
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 82
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx15, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv365, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 61

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx15, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv365, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 236
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 61

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.cond2.preheader ], [ %indvars.iv.next, %for.cond7.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx15, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx15.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtab, i64 0, i64 %indvars.iv365, i64 %indvars.iv, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx15.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.inc19, label %for.cond7.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 236
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 61
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx15.1> = getelementptr inbounds ir<@fixtab>, ir<0>, ir<%indvars.iv365>, vp<%3>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx15.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc19>, scalar.ph

ir-bb<for.inc19>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv370 = phi 0, %indvars.iv.next371, ir<1>
    CLONE ir<%arrayidx42> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv373>, ir<%indvars.iv370>, ir<0>
    CLONE store ir<1317>, ir<%arrayidx42>
    CLONE ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv373>, ir<%indvars.iv370>, ir<1>
    CLONE store ir<1317>, ir<%arrayidx42.1>
    CLONE ir<%indvars.iv.next371> = add nuw nsw ir<%indvars.iv370>, ir<1>
    CLONE ir<%exitcond372.not> = icmp eq ir<%indvars.iv.next371>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv370 = phi 0, %indvars.iv.next371, ir<1>
    CLONE ir<%arrayidx42> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv373>, ir<%indvars.iv370>, ir<0>
    CLONE ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv373>, ir<%indvars.iv370>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx42.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next371> = add nuw nsw ir<%indvars.iv370>, ir<1>
    CLONE ir<%exitcond372.not> = icmp eq ir<%indvars.iv.next371>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv370 = phi 0, %indvars.iv.next371, ir<1>
    CLONE ir<%arrayidx42> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv373>, ir<%indvars.iv370>, ir<0>
    CLONE ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv373>, ir<%indvars.iv370>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx42.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next371> = add nuw nsw ir<%indvars.iv370>, ir<1>
    CLONE ir<%exitcond372.not> = icmp eq ir<%indvars.iv.next371>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv370 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next371, %for.cond32.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx42 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv373, i64 %indvars.iv370, i64 0 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx42, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv373, i64 %indvars.iv370, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next371 = add nuw nsw i64 %indvars.iv370, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond372.not = icmp eq i64 %indvars.iv.next371, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond372.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv370 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next371, %for.cond32.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i32 1317, ptr %arrayidx42, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv373, i64 %indvars.iv370, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next371 = add nuw nsw i64 %indvars.iv370, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond372.not = icmp eq i64 %indvars.iv.next371, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond372.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv370 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next371, %for.cond32.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i32 1317, ptr %arrayidx42, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv373, i64 %indvars.iv370, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next371 = add nuw nsw i64 %indvars.iv370, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond372.not = icmp eq i64 %indvars.iv.next371, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond372.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 236
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 120
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv370 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next371, %for.cond32.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i32 1317, ptr %arrayidx42, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv373, i64 %indvars.iv370, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 8 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next371 = add nuw nsw i64 %indvars.iv370, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond372.not = icmp eq i64 %indvars.iv.next371, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond372.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 236
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 82
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv370 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next371, %for.cond32.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx42, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv373, i64 %indvars.iv370, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next371 = add nuw nsw i64 %indvars.iv370, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond372.not = icmp eq i64 %indvars.iv.next371, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond372.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 61

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv370 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next371, %for.cond32.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx42, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv373, i64 %indvars.iv370, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next371 = add nuw nsw i64 %indvars.iv370, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond372.not = icmp eq i64 %indvars.iv.next371, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond372.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 236
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 61

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv370 = phi i64 [ 0, %for.cond27.preheader ], [ %indvars.iv.next371, %for.cond32.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx42, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx42.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @fixtrunctab, i64 0, i64 %indvars.iv373, i64 %indvars.iv370, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx42.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next371 = add nuw nsw i64 %indvars.iv370, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond372.not = icmp eq i64 %indvars.iv.next371, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond372.not, label %for.inc49, label %for.cond32.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 236
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 61
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx42.1> = getelementptr inbounds ir<@fixtrunctab>, ir<0>, ir<%indvars.iv373>, vp<%3>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx42.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc49>, scalar.ph

ir-bb<for.inc49>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv378 = phi 0, %indvars.iv.next379, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv381>, ir<%indvars.iv378>, ir<0>
    CLONE store ir<1317>, ir<%arrayidx72>
    CLONE ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv381>, ir<%indvars.iv378>, ir<1>
    CLONE store ir<1317>, ir<%arrayidx72.1>
    CLONE ir<%indvars.iv.next379> = add nuw nsw ir<%indvars.iv378>, ir<1>
    CLONE ir<%exitcond380.not> = icmp eq ir<%indvars.iv.next379>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv378 = phi 0, %indvars.iv.next379, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv381>, ir<%indvars.iv378>, ir<0>
    CLONE ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv381>, ir<%indvars.iv378>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx72.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next379> = add nuw nsw ir<%indvars.iv378>, ir<1>
    CLONE ir<%exitcond380.not> = icmp eq ir<%indvars.iv.next379>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv378 = phi 0, %indvars.iv.next379, ir<1>
    CLONE ir<%arrayidx72> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv381>, ir<%indvars.iv378>, ir<0>
    CLONE ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv381>, ir<%indvars.iv378>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx72.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next379> = add nuw nsw ir<%indvars.iv378>, ir<1>
    CLONE ir<%exitcond380.not> = icmp eq ir<%indvars.iv.next379>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv378 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next379, %for.cond62.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx72 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv381, i64 %indvars.iv378, i64 0 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx72, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv381, i64 %indvars.iv378, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond380.not = icmp eq i64 %indvars.iv.next379, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond380.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv378 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next379, %for.cond62.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i32 1317, ptr %arrayidx72, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv381, i64 %indvars.iv378, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond380.not = icmp eq i64 %indvars.iv.next379, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond380.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv378 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next379, %for.cond62.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i32 1317, ptr %arrayidx72, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv381, i64 %indvars.iv378, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond380.not = icmp eq i64 %indvars.iv.next379, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond380.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 236
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 120
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv378 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next379, %for.cond62.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i32 1317, ptr %arrayidx72, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv381, i64 %indvars.iv378, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 8 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond380.not = icmp eq i64 %indvars.iv.next379, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond380.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 236
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 82
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv378 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next379, %for.cond62.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx72, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv381, i64 %indvars.iv378, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond380.not = icmp eq i64 %indvars.iv.next379, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond380.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 61

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv378 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next379, %for.cond62.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx72, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv381, i64 %indvars.iv378, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond380.not = icmp eq i64 %indvars.iv.next379, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond380.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 236
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 61

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv378 = phi i64 [ 0, %for.cond57.preheader ], [ %indvars.iv.next379, %for.cond62.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx72, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx72.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @floattab, i64 0, i64 %indvars.iv381, i64 %indvars.iv378, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx72.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next379 = add nuw nsw i64 %indvars.iv378, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond380.not = icmp eq i64 %indvars.iv.next379, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond380.not, label %for.inc79, label %for.cond62.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 236
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 61
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx72.1> = getelementptr inbounds ir<@floattab>, ir<0>, ir<%indvars.iv381>, vp<%3>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx72.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc79>, scalar.ph

ir-bb<for.inc79>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv386 = phi 0, %indvars.iv.next387, ir<1>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv386>, ir<0>
    CLONE store ir<1317>, ir<%arrayidx102>
    CLONE ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv386>, ir<1>
    CLONE store ir<1317>, ir<%arrayidx102.1>
    CLONE ir<%indvars.iv.next387> = add nuw nsw ir<%indvars.iv386>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next387>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv386 = phi 0, %indvars.iv.next387, ir<1>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv386>, ir<0>
    CLONE ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv386>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx102.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next387> = add nuw nsw ir<%indvars.iv386>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next387>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv386 = phi 0, %indvars.iv.next387, ir<1>
    CLONE ir<%arrayidx102> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv386>, ir<0>
    CLONE ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv389>, ir<%indvars.iv386>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx102.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    CLONE ir<%indvars.iv.next387> = add nuw nsw ir<%indvars.iv386>, ir<1>
    CLONE ir<%exitcond388.not> = icmp eq ir<%indvars.iv.next387>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next387, %for.cond92.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx102 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv389, i64 %indvars.iv386, i64 0 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx102, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv389, i64 %indvars.iv386, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next387, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond388.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next387, %for.cond92.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 2 For instruction:   store i32 1317, ptr %arrayidx102, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv389, i64 %indvars.iv386, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next387, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond388.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next387, %for.cond92.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 4 For instruction:   store i32 1317, ptr %arrayidx102, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv389, i64 %indvars.iv386, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next387, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond388.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 236
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 120
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next387, %for.cond92.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF 8 For instruction:   store i32 1317, ptr %arrayidx102, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv389, i64 %indvars.iv386, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF 8 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next387, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond388.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 236
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 82
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next387, %for.cond92.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx102, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv389, i64 %indvars.iv386, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next387, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond388.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 236
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 120, RTCostB: 61

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next387, %for.cond92.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx102, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv389, i64 %indvars.iv386, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next387, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond388.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 236
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 82, RTCostB: 61

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv386 = phi i64 [ 0, %for.cond87.preheader ], [ %indvars.iv.next387, %for.cond92.preheader ] of type:phi
LV: Decision: Interleave
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx102, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx102.1 = getelementptr inbounds [59 x [59 x [2 x i32]]], ptr @extendtab, i64 0, i64 %indvars.iv389, i64 %indvars.iv386, i64 1 of type:getelementptr
LV: Decision: Interleave
LV: Found an estimated cost of 5 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx102.1, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next387 = add nuw nsw i64 %indvars.iv386, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond388.not = icmp eq i64 %indvars.iv.next387, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond388.not, label %for.inc109, label %for.cond92.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 236
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 61, RTCostB: 61
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx102.1> = getelementptr inbounds ir<@extendtab>, ir<0>, ir<%indvars.iv389>, vp<%3>, ir<1>
    INTERLEAVE-GROUP with factor 2 at <badref>, ir<%arrayidx102.1>
      store ir<1317> to index 0
      store ir<1317> to index 1
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.inc109>, scalar.ph

ir-bb<for.inc109>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4 -> Cost: 2 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4 -> Cost: 3 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx117, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)
========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<153> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv392 = phi %indvars.iv.next393, 0, ir<1>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<@setcc_gen_code>, ir<0>, ir<%indvars.iv392>
    CLONE store ir<1317>, ir<%arrayidx117>
    CLONE ir<%indvars.iv.next393> = add nuw nsw ir<%indvars.iv392>, ir<1>
    CLONE ir<%exitcond394.not> = icmp eq ir<%indvars.iv.next393>, ir<153>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<153>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body124.preheader>, scalar.ph

ir-bb<for.body124.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<153> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv392 = phi %indvars.iv.next393, 0, ir<1>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<@setcc_gen_code>, ir<0>, ir<%indvars.iv392>
    vp<%3> = vector-pointer ir<%arrayidx117>
    WIDEN store vp<%3>, ir<1317>
    CLONE ir<%indvars.iv.next393> = add nuw nsw ir<%indvars.iv392>, ir<1>
    CLONE ir<%exitcond394.not> = icmp eq ir<%indvars.iv.next393>, ir<153>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<153>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body124.preheader>, scalar.ph

ir-bb<for.body124.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<153> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv392 = phi %indvars.iv.next393, 0, ir<1>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<@setcc_gen_code>, ir<0>, ir<%indvars.iv392>
    vp<%3> = vector-pointer ir<%arrayidx117>
    WIDEN store vp<%3>, ir<1317>
    CLONE ir<%indvars.iv.next393> = add nuw nsw ir<%indvars.iv392>, ir<1>
    CLONE ir<%exitcond394.not> = icmp eq ir<%indvars.iv.next393>, ir<153>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<153>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body124.preheader>, scalar.ph

ir-bb<for.body124.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv392 = phi i64 [ %indvars.iv.next393, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv392 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx117, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next393 = add nuw nsw i64 %indvars.iv392, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond394.not = icmp eq i64 %indvars.iv.next393, 153 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond394.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv392 = phi i64 [ %indvars.iv.next393, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv392 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx117, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next393 = add nuw nsw i64 %indvars.iv392, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond394.not = icmp eq i64 %indvars.iv.next393, 153 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond394.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 307, RTCostB: 459
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 307, RTCostB: 459
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv392 = phi i64 [ %indvars.iv.next393, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv392 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 1317, ptr %arrayidx117, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next393 = add nuw nsw i64 %indvars.iv392, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond394.not = icmp eq i64 %indvars.iv.next393, 153 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond394.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 155, RTCostB: 459
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 155, RTCostB: 307
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv392 = phi i64 [ %indvars.iv.next393, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv392 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 8 For instruction:   store i32 1317, ptr %arrayidx117, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next393 = add nuw nsw i64 %indvars.iv392, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond394.not = icmp eq i64 %indvars.iv.next393, 153 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond394.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 98, RTCostB: 459
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 98, RTCostB: 155
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv392 = phi i64 [ %indvars.iv.next393, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv392 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx117, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next393 = add nuw nsw i64 %indvars.iv392, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond394.not = icmp eq i64 %indvars.iv.next393, 153 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond394.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 307, RTCostB: 459
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 307, RTCostB: 98

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv392 = phi i64 [ %indvars.iv.next393, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv392 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx117, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next393 = add nuw nsw i64 %indvars.iv392, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond394.not = icmp eq i64 %indvars.iv.next393, 153 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond394.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 155, RTCostB: 459
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 155, RTCostB: 98

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv392 = phi i64 [ %indvars.iv.next393, %for.body115 ], [ 0, %for.body115.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx117 = getelementptr inbounds [153 x i32], ptr @setcc_gen_code, i64 0, i64 %indvars.iv392 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx117, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next393 = add nuw nsw i64 %indvars.iv392, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond394.not = icmp eq i64 %indvars.iv.next393, 153 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond394.not, label %for.body124.preheader, label %for.body115 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 98, RTCostB: 459
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 98, RTCostB: 98
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<153> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx117> = getelementptr inbounds ir<@setcc_gen_code>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx117>
    WIDEN store vp<%4>, ir<1317>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<153>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body124.preheader>, scalar.ph

ir-bb<for.body124.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4 -> Cost: 2 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4 -> Cost: 2 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4 -> Cost: 2 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4 -> Cost: 2 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4 -> Cost: 3 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4 -> Cost: 3 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4 -> Cost: 3 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4 -> Cost: 3 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 1317, ptr %arrayidx183, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 1317, ptr %arrayidx185, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 1317, ptr %arrayidx187, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 1317, ptr %arrayidx189, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)
========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv398 = phi 0, %indvars.iv.next399, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<@movstr_optab>, ir<0>, ir<%indvars.iv398>
    CLONE store ir<1317>, ir<%arrayidx183>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<@clrstr_optab>, ir<0>, ir<%indvars.iv398>
    CLONE store ir<1317>, ir<%arrayidx185>
    CLONE ir<%arrayidx187> = getelementptr inbounds ir<@reload_out_optab>, ir<0>, ir<%indvars.iv398>
    CLONE store ir<1317>, ir<%arrayidx187>
    CLONE ir<%arrayidx189> = getelementptr inbounds ir<@reload_in_optab>, ir<0>, ir<%indvars.iv398>
    CLONE store ir<1317>, ir<%arrayidx189>
    CLONE ir<%indvars.iv.next399> = add nuw nsw ir<%indvars.iv398>, ir<1>
    CLONE ir<%exitcond400.not> = icmp eq ir<%indvars.iv.next399>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end192>, scalar.ph

ir-bb<for.end192>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv398 = phi 0, %indvars.iv.next399, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<@movstr_optab>, ir<0>, ir<%indvars.iv398>
    vp<%3> = vector-pointer ir<%arrayidx183>
    WIDEN store vp<%3>, ir<1317>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<@clrstr_optab>, ir<0>, ir<%indvars.iv398>
    vp<%4> = vector-pointer ir<%arrayidx185>
    WIDEN store vp<%4>, ir<1317>
    CLONE ir<%arrayidx187> = getelementptr inbounds ir<@reload_out_optab>, ir<0>, ir<%indvars.iv398>
    vp<%5> = vector-pointer ir<%arrayidx187>
    WIDEN store vp<%5>, ir<1317>
    CLONE ir<%arrayidx189> = getelementptr inbounds ir<@reload_in_optab>, ir<0>, ir<%indvars.iv398>
    vp<%6> = vector-pointer ir<%arrayidx189>
    WIDEN store vp<%6>, ir<1317>
    CLONE ir<%indvars.iv.next399> = add nuw nsw ir<%indvars.iv398>, ir<1>
    CLONE ir<%exitcond400.not> = icmp eq ir<%indvars.iv.next399>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end192>, scalar.ph

ir-bb<for.end192>:
No successors

scalar.ph:
No successors
}

========== Loop: init_optabs' from optabs.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv398 = phi 0, %indvars.iv.next399, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<@movstr_optab>, ir<0>, ir<%indvars.iv398>
    vp<%3> = vector-pointer ir<%arrayidx183>
    WIDEN store vp<%3>, ir<1317>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<@clrstr_optab>, ir<0>, ir<%indvars.iv398>
    vp<%4> = vector-pointer ir<%arrayidx185>
    WIDEN store vp<%4>, ir<1317>
    CLONE ir<%arrayidx187> = getelementptr inbounds ir<@reload_out_optab>, ir<0>, ir<%indvars.iv398>
    vp<%5> = vector-pointer ir<%arrayidx187>
    WIDEN store vp<%5>, ir<1317>
    CLONE ir<%arrayidx189> = getelementptr inbounds ir<@reload_in_optab>, ir<0>, ir<%indvars.iv398>
    vp<%6> = vector-pointer ir<%arrayidx189>
    WIDEN store vp<%6>, ir<1317>
    CLONE ir<%indvars.iv.next399> = add nuw nsw ir<%indvars.iv398>, ir<1>
    CLONE ir<%exitcond400.not> = icmp eq ir<%indvars.iv.next399>, ir<59>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end192>, scalar.ph

ir-bb<for.end192>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv398 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next399, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx183, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx185, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx187, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 1317, ptr %arrayidx189, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next399 = add nuw nsw i64 %indvars.iv398, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond400.not = icmp eq i64 %indvars.iv.next399, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond400.not, label %for.end192, label %for.body181 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv398 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next399, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx183, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx185, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx187, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 1317, ptr %arrayidx189, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next399 = add nuw nsw i64 %indvars.iv398, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond400.not = icmp eq i64 %indvars.iv.next399, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond400.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 296, RTCostB: 354
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 296, RTCostB: 354
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv398 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next399, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 1317, ptr %arrayidx183, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 1317, ptr %arrayidx185, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 1317, ptr %arrayidx187, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 1317, ptr %arrayidx189, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next399 = add nuw nsw i64 %indvars.iv398, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond400.not = icmp eq i64 %indvars.iv.next399, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond400.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 158, RTCostB: 354
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 158, RTCostB: 296
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv398 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next399, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 8 For instruction:   store i32 1317, ptr %arrayidx183, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 8 For instruction:   store i32 1317, ptr %arrayidx185, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 8 For instruction:   store i32 1317, ptr %arrayidx187, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 8 For instruction:   store i32 1317, ptr %arrayidx189, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next399 = add nuw nsw i64 %indvars.iv398, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond400.not = icmp eq i64 %indvars.iv.next399, 59 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond400.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 116, RTCostB: 354
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 116, RTCostB: 158
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv398 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next399, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx183, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx185, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx187, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 1317, ptr %arrayidx189, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next399 = add nuw nsw i64 %indvars.iv398, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond400.not = icmp eq i64 %indvars.iv.next399, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond400.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width vscale x 1 costs: 5
A is scalable.	B is not scalable.	
RTCostA: 296, RTCostB: 354
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 296, RTCostB: 116

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv398 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next399, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx183, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx185, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx187, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 1317, ptr %arrayidx189, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next399 = add nuw nsw i64 %indvars.iv398, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond400.not = icmp eq i64 %indvars.iv.next399, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond400.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 158, RTCostB: 354
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 158, RTCostB: 116

-----------------Function that is being costed:'init_optabs' from optabs.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv398 = phi i64 [ 0, %for.body124.preheader ], [ %indvars.iv.next399, %for.body181 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx183 = getelementptr inbounds [59 x i32], ptr @movstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx183, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx185 = getelementptr inbounds [59 x i32], ptr @clrstr_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx185, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx187 = getelementptr inbounds [59 x i32], ptr @reload_out_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx187, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx189 = getelementptr inbounds [59 x i32], ptr @reload_in_optab, i64 0, i64 %indvars.iv398 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 1317, ptr %arrayidx189, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next399 = add nuw nsw i64 %indvars.iv398, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond400.not = icmp eq i64 %indvars.iv.next399, 59 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond400.not, label %for.end192, label %for.body181 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 116, RTCostB: 354
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 116, RTCostB: 116
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: init_optabs at line: optabs.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<59> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx183> = getelementptr inbounds ir<@movstr_optab>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx183>
    WIDEN store vp<%4>, ir<1317>
    CLONE ir<%arrayidx185> = getelementptr inbounds ir<@clrstr_optab>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx185>
    WIDEN store vp<%5>, ir<1317>
    CLONE ir<%arrayidx187> = getelementptr inbounds ir<@reload_out_optab>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx187>
    WIDEN store vp<%6>, ir<1317>
    CLONE ir<%arrayidx189> = getelementptr inbounds ir<@reload_in_optab>, ir<0>, vp<%3>
    vp<%7> = vector-pointer ir<%arrayidx189>
    WIDEN store vp<%7>, ir<1317>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<59>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end192>, scalar.ph

ir-bb<for.end192>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 44
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o params.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         params.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o predict.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         predict.c
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %3 = load ptr, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: counts_to_freqs' from predict.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%count_max.036> = phi ir<1>, ir<%.count_max.0>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv>
    CLONE ir<%3> = load ir<%arrayidx>
    CLONE ir<%count> = getelementptr inbounds ir<%3>, ir<96>
    CLONE ir<%4> = load ir<%count>
    CLONE ir<%.count_max.0> = call @llvm.smax.i64(ir<%4>, ir<%count_max.036>)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%count_max.036>, ir<%.count_max.0>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond6.preheader.loopexit>, scalar.ph

ir-bb<for.cond6.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %.count_max.0.lcssa = vp<%6>
}

========== Loop: counts_to_freqs' from predict.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%count_max.036> = phi ir<1>, ir<%.count_max.0>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%count> = getelementptr inbounds ir<%3>, ir<96>
    WIDEN ir<%4> = load ir<%count>
    WIDEN-CALL ir<%.count_max.0> = call @llvm.smax.i64(ir<%4>, ir<%count_max.036>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count_max.036>, ir<%.count_max.0>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond6.preheader.loopexit>, scalar.ph

ir-bb<for.cond6.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %.count_max.0.lcssa = vp<%7>
}

========== Loop: counts_to_freqs' from predict.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%count_max.036> = phi ir<1>, ir<%.count_max.0>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%4>
    WIDEN-GEP Var[Inv] ir<%count> = getelementptr inbounds ir<%3>, ir<96>
    WIDEN ir<%4> = load ir<%count>
    WIDEN-CALL ir<%.count_max.0> = call @llvm.smax.i64(ir<%4>, ir<%count_max.036>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%count_max.036>, ir<%.count_max.0>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond6.preheader.loopexit>, scalar.ph

ir-bb<for.cond6.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %.count_max.0.lcssa = vp<%7>
}


-----------------Function that is being costed:'counts_to_freqs' from predict.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %count_max.036 = phi i64 [ 1, %for.body.lr.ph ], [ %.count_max.0, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %data, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %3 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %count = getelementptr inbounds i8, ptr %3, i64 96 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = load i64, ptr %count, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %.count_max.0 = tail call i64 @llvm.smax.i64(i64 %4, i64 %count_max.036) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond6.preheader.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'counts_to_freqs' from predict.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %count_max.036 = phi i64 [ 1, %for.body.lr.ph ], [ %.count_max.0, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %data, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %3 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %count = getelementptr inbounds i8, ptr %3, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %4 = load i64, ptr %count, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %.count_max.0 = tail call i64 @llvm.smax.i64(i64 %4, i64 %count_max.036) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond6.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 10737418235
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 10737418235
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'counts_to_freqs' from predict.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %count_max.036 = phi i64 [ 1, %for.body.lr.ph ], [ %.count_max.0, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %data, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %3 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %count = getelementptr inbounds i8, ptr %3, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %4 = load i64, ptr %count, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %.count_max.0 = tail call i64 @llvm.smax.i64(i64 %4, i64 %count_max.036) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond6.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709125, RTCostB: 10737418235
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709125, RTCostB: 6442450943
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'counts_to_freqs' from predict.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %count_max.036 = phi i64 [ 1, %for.body.lr.ph ], [ %.count_max.0, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %data, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %3 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %count = getelementptr inbounds i8, ptr %3, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %4 = load i64, ptr %count, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %.count_max.0 = tail call i64 @llvm.smax.i64(i64 %4, i64 %count_max.036) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond6.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 10737418235
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450943, RTCostB: 5368709125

-----------------Function that is being costed:'counts_to_freqs' from predict.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %count_max.036 = phi i64 [ 1, %for.body.lr.ph ], [ %.count_max.0, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [1 x ptr], ptr %data, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %3 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %count = getelementptr inbounds i8, ptr %3, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %4 = load i64, ptr %count, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %.count_max.0 = tail call i64 @llvm.smax.i64(i64 %4, i64 %count_max.036) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond6.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709125, RTCostB: 10737418235
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709125, RTCostB: 5368709125
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: counts_to_freqs at line: predict.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%count_max.036> = phi ir<1>, ir<%.count_max.0>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%data>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%3> = load vp<%5>
    WIDEN-GEP Var[Inv] ir<%count> = getelementptr inbounds ir<%3>, ir<96>
    WIDEN ir<%4> = load ir<%count>
    WIDEN-CALL ir<%.count_max.0> = call @llvm.smax.i64(ir<%4>, ir<%count_max.036>) (using vector intrinsic)
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%count_max.036>, ir<%.count_max.0>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond6.preheader.loopexit>, scalar.ph

ir-bb<for.cond6.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %.count_max.0.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o print-rtl.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         print-rtl.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o print-tree.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         print-tree.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o profile.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         profile.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o real.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         real.c
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2 -> Cost: 1 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2 -> Cost: 2 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2 -> Cost: 2 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2 -> Cost: 1 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2 -> Cost: 2 -> VectorType: <8 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2 -> Cost: 2 -> VectorType: <16 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2 -> Cost: 3 -> VectorType: <16 x i16> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2 -> Cost: 1 -> VectorType: <vscale x 1 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2 -> Cost: 2 -> VectorType: <vscale x 1 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2 -> Cost: 2 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2 -> Cost: 2 -> VectorType: <vscale x 4 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i16, ptr %arrayidx56, align 2 -> Cost: 2 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i16 0, ptr %arrayidx56, align 2 -> Cost: 3 -> VectorType: <vscale x 8 x i16> -> ttilog -> MemoryOpCost(3)
========== Loop: emdnorm' from real.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (7 + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom44, ir<1>
    WIDEN-REDUCTION-PHI ir<%r.0200> = phi ir<%and48194>, ir<%spec.select197>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, %idxprom44\l" +
    "  ir<%11>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%s>, ir<%indvars.iv.next>
    CLONE ir<%9> = load ir<%arrayidx56>
    CLONE ir<%tobool57.not> = icmp ne ir<%9>, ir<0>
    CLONE ir<%10> = zext ir<%tobool57.not>
    CLONE ir<%spec.select197> = or ir<%r.0200>, ir<%10>
    CLONE store ir<0>, ir<%arrayidx56>
    CLONE ir<%cmp53> = icmp slt ir<%11>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%r.0200>, ir<%spec.select197>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end65.loopexit>, scalar.ph

ir-bb<if.end65.loopexit>:
No successors

scalar.ph:
No successors

Live-out i16 %spec.select197.lcssa = vp<%6>
}

========== Loop: emdnorm' from real.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (7 + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom44, ir<1>
    WIDEN-REDUCTION-PHI ir<%r.0200> = phi ir<%and48194>, ir<%spec.select197>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, %idxprom44\l" +
    "  ir<%11>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%s>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%tobool57.not> = icmp ne ir<%9>, ir<0>
    WIDEN-CAST ir<%10> = zext  ir<%tobool57.not> to i16
    WIDEN ir<%spec.select197> = or ir<%r.0200>, ir<%10>
    vp<%5> = vector-pointer ir<%arrayidx56>
    WIDEN store vp<%5>, ir<0>
    CLONE ir<%cmp53> = icmp slt ir<%11>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%r.0200>, ir<%spec.select197>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end65.loopexit>, scalar.ph

ir-bb<if.end65.loopexit>:
No successors

scalar.ph:
No successors

Live-out i16 %spec.select197.lcssa = vp<%8>
}

========== Loop: emdnorm' from real.c==========
========== VPlan for Vector Factor Range: 1 to 16==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (7 + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom44, ir<1>
    WIDEN-REDUCTION-PHI ir<%r.0200> = phi ir<%and48194>, ir<%spec.select197>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %indvars.iv.next, %idxprom44\l" +
    "  ir<%11>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%s>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%9> = load vp<%4>
    WIDEN ir<%tobool57.not> = icmp ne ir<%9>, ir<0>
    WIDEN-CAST ir<%10> = zext  ir<%tobool57.not> to i16
    WIDEN ir<%spec.select197> = or ir<%r.0200>, ir<%10>
    vp<%5> = vector-pointer ir<%arrayidx56>
    WIDEN store vp<%5>, ir<0>
    CLONE ir<%cmp53> = icmp slt ir<%11>, ir<7>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%r.0200>, ir<%spec.select197>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end65.loopexit>, scalar.ph

ir-bb<if.end65.loopexit>:
No successors

scalar.ph:
No successors

Live-out i16 %spec.select197.lcssa = vp<%8>
}


-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load i16, ptr %arrayidx56, align 2 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i16 0, ptr %arrayidx56, align 2 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i16, ptr %arrayidx56, align 2 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i16 0, ptr %arrayidx56, align 2 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676452, RTCostB: 15032385592
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676452, RTCostB: 15032385592
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %9 = load i16, ptr %arrayidx56, align 2 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i16 0, ptr %arrayidx56, align 2 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4831838226, RTCostB: 15032385592
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4831838226, RTCostB: 9663676452
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %9 = load i16, ptr %arrayidx56, align 2 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 8 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i16 0, ptr %arrayidx56, align 2 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919113, RTCostB: 15032385592
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919113, RTCostB: 4831838226
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 16 For instruction:   %9 = load i16, ptr %arrayidx56, align 2 of type:load
LV: Found an estimated cost of 2 for VF 16 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 16 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 2 for VF 16 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i16 0, ptr %arrayidx56, align 2 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 2013265976, RTCostB: 15032385592
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2013265976, RTCostB: 2415919113
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %9 = load i16, ptr %arrayidx56, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i16 0, ptr %arrayidx56, align 2 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 9663676452, RTCostB: 15032385592
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 9663676452, RTCostB: 2013265976

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = load i16, ptr %arrayidx56, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i16 0, ptr %arrayidx56, align 2 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4831838226, RTCostB: 15032385592
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4831838226, RTCostB: 2013265976

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %9 = load i16, ptr %arrayidx56, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i16 0, ptr %arrayidx56, align 2 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919113, RTCostB: 15032385592
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919113, RTCostB: 2013265976

-----------------Function that is being costed:'emdnorm' from real.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ %idxprom44, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %r.0200 = phi i16 [ %spec.select197, %while.body ], [ %and48194, %while.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx56 = getelementptr inbounds i16, ptr %s, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %9 = load i16, ptr %arrayidx56, align 2 of type:load
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %tobool57.not = icmp ne i16 %9, 0 of type:icmp
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %10 = zext i1 %tobool57.not to i16 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %spec.select197 = or i16 %r.0200, %10 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 8 For instruction:   store i16 0, ptr %arrayidx56, align 2 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %11 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp53 = icmp slt i32 %11, 7 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp53, label %while.body, label %if.end65.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 2013265976, RTCostB: 15032385592
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2013265976, RTCostB: 2013265976
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 8, UF=1 at function: emdnorm at line: real.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (7 + (-1 * %6)) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%r.0200> = phi ir<%and48194>, ir<%spec.select197>
    vp<%4>    = DERIVED-IV ir<%idxprom44> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx56> = getelementptr inbounds ir<%s>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer ir<%arrayidx56>
    WIDEN ir<%9> = load vp<%6>
    WIDEN ir<%tobool57.not> = icmp ne ir<%9>, ir<0>
    WIDEN-CAST ir<%10> = zext  ir<%tobool57.not> to i16
    WIDEN ir<%spec.select197> = or ir<%r.0200>, ir<%10>
    vp<%7> = vector-pointer ir<%arrayidx56>
    WIDEN store vp<%7>, ir<0>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%r.0200>, ir<%spec.select197>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end65.loopexit>, scalar.ph

ir-bb<if.end65.loopexit>:
No successors

scalar.ph:
No successors

Live-out i16 %spec.select197.lcssa = vp<%10>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o recog.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         recog.c
========== Loop: peep2_find_free_register' from recog.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body401.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond396557 to i64) + (-1 * (1 umin (zext i32 %cond396557 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv551 = phi %45, %indvars.iv.next552, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or405545> = phi ir<%reg_set.promoted>, ir<%or405>
    CLONE ir<%indvars.iv.next552> = add nsw ir<%indvars.iv551>, ir<-1>
    CLONE ir<%46> = add nsw ir<%indvars.iv.next552>, ir<%idxprom209.lcssa>
    CLONE ir<%shl404> = shl nuw ir<1>, ir<%46>
    CLONE ir<%or405> = or ir<%or405545>, ir<%shl404>
    CLONE ir<%cmp399> = icmp ugt ir<%indvars.iv551>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or405545>, ir<%or405>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond398.cleanup_crit_edge>, scalar.ph

ir-bb<for.cond398.cleanup_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or405.lcssa = vp<%6>
}

========== Loop: peep2_find_free_register' from recog.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body401.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond396557 to i64) + (-1 * (1 umin (zext i32 %cond396557 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv551 = phi %45, %indvars.iv.next552, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or405545> = phi ir<%reg_set.promoted>, ir<%or405>
    WIDEN ir<%indvars.iv.next552> = add nsw ir<%indvars.iv551>, ir<-1>
    WIDEN ir<%46> = add nsw ir<%indvars.iv.next552>, ir<%idxprom209.lcssa>
    WIDEN ir<%shl404> = shl nuw ir<1>, ir<%46>
    WIDEN ir<%or405> = or ir<%or405545>, ir<%shl404>
    CLONE ir<%cmp399> = icmp ugt ir<%indvars.iv551>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or405545>, ir<%or405>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond398.cleanup_crit_edge>, scalar.ph

ir-bb<for.cond398.cleanup_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or405.lcssa = vp<%6>
}

========== Loop: peep2_find_free_register' from recog.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body401.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond396557 to i64) + (-1 * (1 umin (zext i32 %cond396557 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv551 = phi %45, %indvars.iv.next552, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or405545> = phi ir<%reg_set.promoted>, ir<%or405>
    WIDEN ir<%indvars.iv.next552> = add nsw ir<%indvars.iv551>, ir<-1>
    WIDEN ir<%46> = add nsw ir<%indvars.iv.next552>, ir<%idxprom209.lcssa>
    WIDEN ir<%shl404> = shl nuw ir<1>, ir<%46>
    WIDEN ir<%or405> = or ir<%or405545>, ir<%shl404>
    CLONE ir<%cmp399> = icmp ugt ir<%indvars.iv551>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or405545>, ir<%or405>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond398.cleanup_crit_edge>, scalar.ph

ir-bb<for.cond398.cleanup_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or405.lcssa = vp<%6>
}


-----------------Function that is being costed:'peep2_find_free_register' from recog.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv551 = phi i64 [ %45, %for.body401.lr.ph ], [ %indvars.iv.next552, %for.body401 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or405545 = phi i64 [ %reg_set.promoted, %for.body401.lr.ph ], [ %or405, %for.body401 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next552 = add nsw i64 %indvars.iv551, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %46 = add nsw i64 %indvars.iv.next552, %idxprom209.lcssa of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl404 = shl nuw i64 1, %46 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or405 = or i64 %or405545, %shl404 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp399 = icmp ugt i64 %indvars.iv551, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp399, label %for.body401, label %for.cond398.cleanup_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'peep2_find_free_register' from recog.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv551 = phi i64 [ %45, %for.body401.lr.ph ], [ %indvars.iv.next552, %for.body401 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or405545 = phi i64 [ %reg_set.promoted, %for.body401.lr.ph ], [ %or405, %for.body401 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next552 = add nsw i64 %indvars.iv551, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %46 = add nsw i64 %indvars.iv.next552, %idxprom209.lcssa of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl404 = shl nuw i64 1, %46 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or405 = or i64 %or405545, %shl404 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp399 = icmp ugt i64 %indvars.iv551, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp399, label %for.body401, label %for.cond398.cleanup_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'peep2_find_free_register' from recog.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv551 = phi i64 [ %45, %for.body401.lr.ph ], [ %indvars.iv.next552, %for.body401 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or405545 = phi i64 [ %reg_set.promoted, %for.body401.lr.ph ], [ %or405, %for.body401 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next552 = add nsw i64 %indvars.iv551, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %46 = add nsw i64 %indvars.iv.next552, %idxprom209.lcssa of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl404 = shl nuw i64 1, %46 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or405 = or i64 %or405545, %shl404 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp399 = icmp ugt i64 %indvars.iv551, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp399, label %for.body401, label %for.cond398.cleanup_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'peep2_find_free_register' from recog.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv551 = phi i64 [ %45, %for.body401.lr.ph ], [ %indvars.iv.next552, %for.body401 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or405545 = phi i64 [ %reg_set.promoted, %for.body401.lr.ph ], [ %or405, %for.body401 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next552 = add nsw i64 %indvars.iv551, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %46 = add nsw i64 %indvars.iv.next552, %idxprom209.lcssa of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl404 = shl nuw i64 1, %46 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or405 = or i64 %or405545, %shl404 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp399 = icmp ugt i64 %indvars.iv551, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp399, label %for.body401, label %for.cond398.cleanup_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'peep2_find_free_register' from recog.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv551 = phi i64 [ %45, %for.body401.lr.ph ], [ %indvars.iv.next552, %for.body401 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or405545 = phi i64 [ %reg_set.promoted, %for.body401.lr.ph ], [ %or405, %for.body401 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next552 = add nsw i64 %indvars.iv551, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %46 = add nsw i64 %indvars.iv.next552, %idxprom209.lcssa of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl404 = shl nuw i64 1, %46 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or405 = or i64 %or405545, %shl404 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp399 = icmp ugt i64 %indvars.iv551, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp399, label %for.body401, label %for.cond398.cleanup_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: peep2_find_free_register at line: recog.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body401.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond396557 to i64) + (-1 * (1 umin (zext i32 %cond396557 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv551 = phi %45, %indvars.iv.next552, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or405545> = phi ir<%reg_set.promoted>, ir<%or405>
    WIDEN ir<%indvars.iv.next552> = add nsw ir<%indvars.iv551>, ir<-1>
    WIDEN ir<%46> = add nsw ir<%indvars.iv.next552>, ir<%idxprom209.lcssa>
    WIDEN ir<%shl404> = shl nuw ir<1>, ir<%46>
    WIDEN ir<%or405> = or ir<%or405545>, ir<%shl404>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or405545>, ir<%or405>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond398.cleanup_crit_edge>, scalar.ph

ir-bb<for.cond398.cleanup_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or405.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 31
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o reg-stack.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         reg-stack.c
========== Loop: subst_stack_regs' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %.pr to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%3> = phi ir<%reg_set.promoted>, ir<%and>
    CLONE ir<%shl> = shl nuw ir<256>, ir<%indvars.iv>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and> = and ir<%3>, ir<%not>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%3>, ir<%and>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end8.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end8.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and.lcssa = vp<%6>
}

========== Loop: subst_stack_regs' from reg-stack.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %.pr to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%3> = phi ir<%reg_set.promoted>, ir<%and>
    WIDEN ir<%shl> = shl nuw ir<256>, ir<%indvars.iv>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and> = and ir<%3>, ir<%not>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%3>, ir<%and>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end8.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end8.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and.lcssa = vp<%6>
}

========== Loop: subst_stack_regs' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %.pr to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%3> = phi ir<%reg_set.promoted>, ir<%and>
    WIDEN ir<%shl> = shl nuw ir<256>, ir<%indvars.iv>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and> = and ir<%3>, ir<%not>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%3>, ir<%and>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end8.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end8.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and.lcssa = vp<%6>
}


-----------------Function that is being costed:'subst_stack_regs' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %2, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %3 = phi i64 [ %reg_set.promoted, %while.body.lr.ph ], [ %and, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 256, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and = and i64 %3, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5.not, label %while.cond.if.end8.loopexit_crit_edge, label %while.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'subst_stack_regs' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %2, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %3 = phi i64 [ %reg_set.promoted, %while.body.lr.ph ], [ %and, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 256, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and = and i64 %3, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5.not, label %while.cond.if.end8.loopexit_crit_edge, label %while.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 10737418240
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 10737418240
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'subst_stack_regs' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %2, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %3 = phi i64 [ %reg_set.promoted, %while.body.lr.ph ], [ %and, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 256, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and = and i64 %3, %not of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp5.not, label %while.cond.if.end8.loopexit_crit_edge, label %while.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4831838208, RTCostB: 10737418240
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4831838208, RTCostB: 5368709120
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'subst_stack_regs' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %2, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %3 = phi i64 [ %reg_set.promoted, %while.body.lr.ph ], [ %and, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 256, %indvars.iv of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and = and i64 %3, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5.not, label %while.cond.if.end8.loopexit_crit_edge, label %while.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 10737418240
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 4831838208

-----------------Function that is being costed:'subst_stack_regs' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %2, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %3 = phi i64 [ %reg_set.promoted, %while.body.lr.ph ], [ %and, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 256, %indvars.iv of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and = and i64 %3, %not of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5.not, label %while.cond.if.end8.loopexit_crit_edge, label %while.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4831838208, RTCostB: 10737418240
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4831838208, RTCostB: 4831838208
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: subst_stack_regs at line: reg-stack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %.pr to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%3> = phi ir<%reg_set.promoted>, ir<%and>
    WIDEN ir<%shl> = shl nuw ir<256>, ir<%indvars.iv>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and> = and ir<%3>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%3>, ir<%and>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.if.end8.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.if.end8.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 50
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 4 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 11 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i8 %conv, ptr %arrayidx, align 1 -> Cost: 3 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: straighten_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %0 to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %2, %indvars.iv.next\l" +
    "  ir<%3>, ir<-1>
    CLONE ir<%sub> = sub ir<%add>, ir<%3>
    CLONE ir<%conv> = trunc ir<%sub>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%conv>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: straighten_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %0 to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %2, %indvars.iv.next\l" +
    "  ir<%3>, ir<-1>
    WIDEN ir<%sub> = sub ir<%add>, ir<%3>
    WIDEN-CAST ir<%conv> = trunc  ir<%sub> to i8
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: straighten_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %0 to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %2, %indvars.iv.next, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %2, %indvars.iv.next\l" +
    "  ir<%3>, ir<-1>
    WIDEN ir<%sub> = sub ir<%add>, ir<%3>
    WIDEN-CAST ir<%conv> = trunc  ir<%sub> to i8
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp5.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676416, RTCostB: 8589934592
A is not scalable.	B is not scalable.	
RTCostA: 9663676416, RTCostB: 8589934592

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 2 for VF 4 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 8589934592
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709120, RTCostB: 8589934592
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 8 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 2 for VF 8 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3489660928, RTCostB: 8589934592
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3489660928, RTCostB: 5368709120
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 4 for VF 16 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 3 for VF 16 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 16 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 16 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 8589934592
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 3489660928
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 8 for VF 32 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 6 for VF 32 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 32 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 16 for VF 32 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 32 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2818572288, RTCostB: 8589934592
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2818572288, RTCostB: 2684354560

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7516192768, RTCostB: 8589934592
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192768, RTCostB: 2684354560

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 8589934592
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967296, RTCostB: 2684354560

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2952790016, RTCostB: 8589934592
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2952790016, RTCostB: 2684354560

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 3 for VF vscale x 8 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919104, RTCostB: 8589934592
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919104, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'straighten_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %2, %if.end ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %3 = trunc nuw nsw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %sub = sub i32 %add, %3 of type:sub
LV: Found an estimated cost of 6 for VF vscale x 16 For instruction:   %conv = trunc i32 %sub to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 16 For instruction:   store i8 %conv, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp5.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp5.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2281701376, RTCostB: 8589934592
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2281701376, RTCostB: 2415919104
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: straighten_stack at line: reg-stack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %0 to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi %2, %indvars.iv.next\l" +
    "  ir<%3>, ir<-1>
    vp<%4>    = DERIVED-IV ir<%2> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    WIDEN ir<%sub> = sub ir<%add>, ir<%3>
    WIDEN-CAST ir<%conv> = trunc  ir<%sub> to i8
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%reg>, ir<0>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%6>, ir<%conv>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 58
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %arrayidx20, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %4, ptr %arrayidx23, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: pop_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom8.lcssa, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv.next>
    CLONE ir<%4> = load ir<%arrayidx20>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%4>, ir<%arrayidx23>
    CLONE ir<%5> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp15> = icmp sgt ir<%0>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: pop_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom8.lcssa, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%4> = load vp<%4>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%5>, ir<%4>
    CLONE ir<%5> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp15> = icmp sgt ir<%0>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: pop_stack' from reg-stack.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom8.lcssa, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%4> = load vp<%4>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%5>, ir<%4>
    CLONE ir<%5> = trunc ir<%indvars.iv.next>
    CLONE ir<%cmp15> = icmp sgt ir<%0>, ir<%5>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 4
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 4
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 64
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 32 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 128
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 48

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 96

-----------------Function that is being costed:'pop_stack' from reg-stack.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body17 ], [ %idxprom8.lcssa, %for.body17.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx20 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %4 = load i8, ptr %arrayidx20, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx23 = getelementptr inbounds [8 x i8], ptr %reg, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %4, ptr %arrayidx23, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %5 = trunc nuw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp15 = icmp sgt i32 %0, %5 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp15, label %for.body17, label %if.end27.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 6
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: pop_stack at line: reg-stack.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.preheader>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%for.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%idxprom8.lcssa> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx20> = getelementptr inbounds ir<%reg>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer ir<%arrayidx20>
    WIDEN ir<%4> = load vp<%6>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<%reg>, ir<0>, vp<%5>
    vp<%7> = vector-pointer ir<%arrayidx23>
    WIDEN store vp<%7>, ir<%4>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 91
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o regclass.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         regclass.c
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i8, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv5, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %2 = load i8, ptr %arrayidx9, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv17, ptr %arrayidx9, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx>
    CLONE ir<%conv> = zext ir<%1>
    CLONE ir<%and2> = and ir<%cond>, ir<%conv>
    CLONE ir<%cmp3> = icmp ne ir<%and2>, ir<0>
    CLONE ir<%conv5> = zext ir<%cmp3>
    CLONE store ir<%conv5>, ir<%arrayidx>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%2> = load ir<%arrayidx9>
    CLONE ir<%conv10> = zext ir<%2>
    CLONE ir<%and14> = and ir<%cond>, ir<%conv10>
    CLONE ir<%cmp15> = icmp ne ir<%and14>, ir<0>
    CLONE ir<%conv17> = zext ir<%cmp15>
    CLONE store ir<%conv17>, ir<%arrayidx9>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%3>
    WIDEN-CAST ir<%conv> = zext  ir<%1> to i32
    WIDEN ir<%and2> = and ir<%cond>, ir<%conv>
    WIDEN ir<%cmp3> = icmp ne ir<%and2>, ir<0>
    WIDEN-CAST ir<%conv5> = zext  ir<%cmp3> to i8
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv5>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%5>
    WIDEN-CAST ir<%conv10> = zext  ir<%2> to i32
    WIDEN ir<%and14> = and ir<%cond>, ir<%conv10>
    WIDEN ir<%cmp15> = icmp ne ir<%and14>, ir<0>
    WIDEN-CAST ir<%conv17> = zext  ir<%cmp15> to i8
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%6>, ir<%conv17>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%3>
    WIDEN-CAST ir<%conv> = zext  ir<%1> to i32
    WIDEN ir<%and2> = and ir<%cond>, ir<%conv>
    WIDEN ir<%cmp3> = icmp ne ir<%and2>, ir<0>
    WIDEN-CAST ir<%conv5> = zext  ir<%cmp3> to i8
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<%conv5>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%5>
    WIDEN-CAST ir<%conv10> = zext  ir<%2> to i32
    WIDEN ir<%and14> = and ir<%cond>, ir<%conv10>
    WIDEN ir<%cmp15> = icmp ne ir<%and14>, ir<0>
    WIDEN-CAST ir<%conv17> = zext  ir<%cmp15> to i8
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%6>, ir<%conv17>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 428, RTCostB: 636
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 428, RTCostB: 636
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 220, RTCostB: 636
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 220, RTCostB: 428
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 8 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 8 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 192, RTCostB: 636
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 192, RTCostB: 220
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 4 for VF 16 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 4 for VF 16 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 16 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 4 for VF 16 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 4 for VF 16 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 16 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 16 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 162, RTCostB: 636
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 162, RTCostB: 192
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 8 for VF 32 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 8 for VF 32 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 8 for VF 32 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 32 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 8 for VF 32 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 8 for VF 32 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 8 for VF 32 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 32 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 32 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 318, RTCostB: 636
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 318, RTCostB: 162

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 8
A is scalable.	B is not scalable.	
RTCostA: 428, RTCostB: 636
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 428, RTCostB: 162

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 220, RTCostB: 636
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 220, RTCostB: 162

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 192, RTCostB: 636
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 192, RTCostB: 162

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 162, RTCostB: 636
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 162, RTCostB: 162
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %1 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %conv = zext i8 %1 to i32 of type:zext
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %and2 = and i32 %cond, %conv of type:and
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %cmp3 = icmp ne i32 %and2, 0 of type:icmp
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %conv5 = zext i1 %cmp3 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %conv5, ptr %arrayidx, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx9 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %2 = load i8, ptr %arrayidx9, align 1 of type:load
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %conv10 = zext i8 %2 to i32 of type:zext
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %and14 = and i32 %cond, %conv10 of type:and
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %cmp15 = icmp ne i32 %and14, 0 of type:icmp
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %conv17 = zext i1 %cmp15 to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %conv17, ptr %arrayidx9, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 318, RTCostB: 636
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 318, RTCostB: 162
LV: Selecting VF: vscale x 8 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 8, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    WIDEN-CAST ir<%conv> = zext  ir<%1> to i32
    WIDEN ir<%and2> = and ir<%cond>, ir<%conv>
    WIDEN ir<%cmp3> = icmp ne ir<%and2>, ir<0>
    WIDEN-CAST ir<%conv5> = zext  ir<%cmp3> to i8
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<%conv5>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN ir<%2> = load vp<%6>
    WIDEN-CAST ir<%conv10> = zext  ir<%2> to i32
    WIDEN ir<%and14> = and ir<%cond>, ir<%conv10>
    WIDEN ir<%cmp15> = icmp ne ir<%and14>, ir<0>
    WIDEN-CAST ir<%conv17> = zext  ir<%cmp15> to i8
    vp<%7> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%7>, ir<%conv17>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx57, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx59, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv968 = phi 0, %indvars.iv.next969, ir<1>
    CLONE ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv968>
    CLONE ir<%and53> = and ir<%25>, ir<%shl>
    CLONE ir<%tobool54.not> = icmp eq ir<%and53>, ir<0>
  Successor(s): if.then55

  if.then55:
    EMIT vp<%3> = not ir<%tobool54.not>
    CLONE ir<%arrayidx57> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv968>
    CLONE store ir<1>, ir<%arrayidx57>, vp<%3>
    CLONE ir<%arrayidx59> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv968>
    CLONE store ir<1>, ir<%arrayidx59>, vp<%3>
  Successor(s): for.inc61

  for.inc61:
    EMIT vp<%4> = or ir<%tobool54.not>, vp<%3>
    CLONE ir<%indvars.iv.next969> = add nuw nsw ir<%indvars.iv968>, ir<1>
    CLONE ir<%exitcond970.not> = icmp eq ir<%indvars.iv.next969>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end64.loopexit>, scalar.ph

ir-bb<if.end64.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv968 = phi 0, %indvars.iv.next969, ir<1>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv968>
    WIDEN ir<%and53> = and ir<%25>, ir<%shl>
    WIDEN ir<%tobool54.not> = icmp eq ir<%and53>, ir<0>
  Successor(s): if.then55

  if.then55:
    EMIT vp<%3> = not ir<%tobool54.not>
    CLONE ir<%arrayidx57> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv968>
    vp<%4> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx59> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv968>
    vp<%5> = vector-pointer ir<%arrayidx59>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc61

  for.inc61:
    EMIT vp<%6> = or ir<%tobool54.not>, vp<%3>
    WIDEN ir<%indvars.iv.next969> = add nuw nsw ir<%indvars.iv968>, ir<1>
    CLONE ir<%exitcond970.not> = icmp eq ir<%indvars.iv.next969>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end64.loopexit>, scalar.ph

ir-bb<if.end64.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv968 = phi 0, %indvars.iv.next969, ir<1>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv968>
    WIDEN ir<%and53> = and ir<%25>, ir<%shl>
    WIDEN ir<%tobool54.not> = icmp eq ir<%and53>, ir<0>
  Successor(s): if.then55

  if.then55:
    EMIT vp<%3> = not ir<%tobool54.not>
    CLONE ir<%arrayidx57> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv968>
    vp<%4> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx59> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv968>
    vp<%5> = vector-pointer ir<%arrayidx59>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc61

  for.inc61:
    EMIT vp<%6> = or ir<%tobool54.not>, vp<%3>
    WIDEN ir<%indvars.iv.next969> = add nuw nsw ir<%indvars.iv968>, ir<1>
    CLONE ir<%exitcond970.not> = icmp eq ir<%indvars.iv.next969>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end64.loopexit>, scalar.ph

ir-bb<if.end64.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 318
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 318
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 318
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 188
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 318
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 149
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 8 for VF 16 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 8 for VF 16 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width 16 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 318
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 144
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 16 for VF 32 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 16 for VF 32 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 16 for VF 32 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 16 for VF 32 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width 32 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 195, RTCostB: 318
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 195, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 318
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 318
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 318
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 8 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 318
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 135
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv968 = phi i64 [ 0, %for.cond49.preheader ], [ %indvars.iv.next969, %for.inc61 ] of type:phi
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv968 of type:shl
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %and53 = and i64 %25, %shl of type:and
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %tobool54.not = icmp eq i64 %and53, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool54.not, label %for.inc61, label %if.then55 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx57 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx57, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx59 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv968 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx59, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc61 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %indvars.iv.next969 = add nuw nsw i64 %indvars.iv968, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond970.not = icmp eq i64 %indvars.iv.next969, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond970.not, label %if.end64.loopexit, label %for.body52 of type:br
LV: Vector loop of width vscale x 16 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 195, RTCostB: 318
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 195, RTCostB: 135
LV: Selecting VF: vscale x 8 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 8, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv968 = phi 0, %indvars.iv.next969, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv968>
    WIDEN ir<%and53> = and ir<%25>, ir<%shl>
    WIDEN ir<%tobool54.not> = icmp eq ir<%and53>, ir<0>
    EMIT vp<%4> = not ir<%tobool54.not>
    CLONE ir<%arrayidx57> = getelementptr ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx57>
    WIDEN store vp<%5>, ir<1>, vp<%4>
    CLONE ir<%arrayidx59> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx59>
    WIDEN store vp<%6>, ir<1>, vp<%4>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end64.loopexit>, scalar.ph

ir-bb<if.end64.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx80, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx82, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv971 = phi 0, %indvars.iv.next972, ir<1>
    CLONE ir<%shl75> = shl nuw nsw ir<1>, ir<%indvars.iv971>
    CLONE ir<%and76> = and ir<%48>, ir<%shl75>
    CLONE ir<%tobool77.not> = icmp eq ir<%and76>, ir<0>
  Successor(s): if.then78

  if.then78:
    EMIT vp<%3> = not ir<%tobool77.not>
    CLONE ir<%arrayidx80> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv971>
    CLONE store ir<1>, ir<%arrayidx80>, vp<%3>
    CLONE ir<%arrayidx82> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv971>
    CLONE store ir<1>, ir<%arrayidx82>, vp<%3>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%4> = or ir<%tobool77.not>, vp<%3>
    CLONE ir<%indvars.iv.next972> = add nuw nsw ir<%indvars.iv971>, ir<1>
    CLONE ir<%exitcond973.not> = icmp eq ir<%indvars.iv.next972>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end87.loopexit>, scalar.ph

ir-bb<if.end87.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv971 = phi 0, %indvars.iv.next972, ir<1>
    WIDEN ir<%shl75> = shl nuw nsw ir<1>, ir<%indvars.iv971>
    WIDEN ir<%and76> = and ir<%48>, ir<%shl75>
    WIDEN ir<%tobool77.not> = icmp eq ir<%and76>, ir<0>
  Successor(s): if.then78

  if.then78:
    EMIT vp<%3> = not ir<%tobool77.not>
    CLONE ir<%arrayidx80> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv971>
    vp<%4> = vector-pointer ir<%arrayidx80>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx82> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv971>
    vp<%5> = vector-pointer ir<%arrayidx82>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%6> = or ir<%tobool77.not>, vp<%3>
    WIDEN ir<%indvars.iv.next972> = add nuw nsw ir<%indvars.iv971>, ir<1>
    CLONE ir<%exitcond973.not> = icmp eq ir<%indvars.iv.next972>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end87.loopexit>, scalar.ph

ir-bb<if.end87.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv971 = phi 0, %indvars.iv.next972, ir<1>
    WIDEN ir<%shl75> = shl nuw nsw ir<1>, ir<%indvars.iv971>
    WIDEN ir<%and76> = and ir<%48>, ir<%shl75>
    WIDEN ir<%tobool77.not> = icmp eq ir<%and76>, ir<0>
  Successor(s): if.then78

  if.then78:
    EMIT vp<%3> = not ir<%tobool77.not>
    CLONE ir<%arrayidx80> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv971>
    vp<%4> = vector-pointer ir<%arrayidx80>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx82> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv971>
    vp<%5> = vector-pointer ir<%arrayidx82>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%6> = or ir<%tobool77.not>, vp<%3>
    WIDEN ir<%indvars.iv.next972> = add nuw nsw ir<%indvars.iv971>, ir<1>
    CLONE ir<%exitcond973.not> = icmp eq ir<%indvars.iv.next972>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end87.loopexit>, scalar.ph

ir-bb<if.end87.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 318
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 318
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 318
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 188
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 318
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 149
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 8 for VF 16 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 8 for VF 16 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width 16 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 318
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 144
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 16 for VF 32 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 16 for VF 32 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 16 for VF 32 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 16 for VF 32 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width 32 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 195, RTCostB: 318
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 195, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 318
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 318
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 318
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 8 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 318
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 135
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv971 = phi i64 [ 0, %for.cond70.preheader ], [ %indvars.iv.next972, %for.inc84 ] of type:phi
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %shl75 = shl nuw nsw i64 1, %indvars.iv971 of type:shl
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %and76 = and i64 %48, %shl75 of type:and
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %tobool77.not = icmp eq i64 %and76, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool77.not, label %for.inc84, label %if.then78 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx80 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx80, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx82 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv971 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx82, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %indvars.iv.next972 = add nuw nsw i64 %indvars.iv971, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond973.not = icmp eq i64 %indvars.iv.next972, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond973.not, label %if.end87.loopexit, label %for.body73 of type:br
LV: Vector loop of width vscale x 16 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 195, RTCostB: 318
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 195, RTCostB: 135
LV: Selecting VF: vscale x 8 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 8, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv971 = phi 0, %indvars.iv.next972, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl75> = shl nuw nsw ir<1>, ir<%indvars.iv971>
    WIDEN ir<%and76> = and ir<%48>, ir<%shl75>
    WIDEN ir<%tobool77.not> = icmp eq ir<%and76>, ir<0>
    EMIT vp<%4> = not ir<%tobool77.not>
    CLONE ir<%arrayidx80> = getelementptr ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx80>
    WIDEN store vp<%5>, ir<1>, vp<%4>
    CLONE ir<%arrayidx82> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx82>
    WIDEN store vp<%6>, ir<1>, vp<%4>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end87.loopexit>, scalar.ph

ir-bb<if.end87.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx104, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx106, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv974 = phi 0, %indvars.iv.next975, ir<1>
    CLONE ir<%shl99> = shl nuw nsw ir<1>, ir<%indvars.iv974>
    CLONE ir<%and100> = and ir<%shl99>, ir<%72>
    CLONE ir<%tobool101.not> = icmp eq ir<%and100>, ir<0>
  Successor(s): if.then102

  if.then102:
    EMIT vp<%3> = not ir<%tobool101.not>
    CLONE ir<%arrayidx104> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv974>
    CLONE store ir<1>, ir<%arrayidx104>, vp<%3>
    CLONE ir<%arrayidx106> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv974>
    CLONE store ir<1>, ir<%arrayidx106>, vp<%3>
  Successor(s): for.inc108

  for.inc108:
    EMIT vp<%4> = or ir<%tobool101.not>, vp<%3>
    CLONE ir<%indvars.iv.next975> = add nuw nsw ir<%indvars.iv974>, ir<1>
    CLONE ir<%exitcond976.not> = icmp eq ir<%indvars.iv.next975>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end111.loopexit>, scalar.ph

ir-bb<if.end111.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv974 = phi 0, %indvars.iv.next975, ir<1>
    WIDEN ir<%shl99> = shl nuw nsw ir<1>, ir<%indvars.iv974>
    WIDEN ir<%and100> = and ir<%shl99>, ir<%72>
    WIDEN ir<%tobool101.not> = icmp eq ir<%and100>, ir<0>
  Successor(s): if.then102

  if.then102:
    EMIT vp<%3> = not ir<%tobool101.not>
    CLONE ir<%arrayidx104> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv974>
    vp<%4> = vector-pointer ir<%arrayidx104>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx106> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv974>
    vp<%5> = vector-pointer ir<%arrayidx106>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc108

  for.inc108:
    EMIT vp<%6> = or ir<%tobool101.not>, vp<%3>
    WIDEN ir<%indvars.iv.next975> = add nuw nsw ir<%indvars.iv974>, ir<1>
    CLONE ir<%exitcond976.not> = icmp eq ir<%indvars.iv.next975>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end111.loopexit>, scalar.ph

ir-bb<if.end111.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv974 = phi 0, %indvars.iv.next975, ir<1>
    WIDEN ir<%shl99> = shl nuw nsw ir<1>, ir<%indvars.iv974>
    WIDEN ir<%and100> = and ir<%shl99>, ir<%72>
    WIDEN ir<%tobool101.not> = icmp eq ir<%and100>, ir<0>
  Successor(s): if.then102

  if.then102:
    EMIT vp<%3> = not ir<%tobool101.not>
    CLONE ir<%arrayidx104> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv974>
    vp<%4> = vector-pointer ir<%arrayidx104>
    WIDEN store vp<%4>, ir<1>, vp<%3>
    CLONE ir<%arrayidx106> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv974>
    vp<%5> = vector-pointer ir<%arrayidx106>
    WIDEN store vp<%5>, ir<1>, vp<%3>
  Successor(s): for.inc108

  for.inc108:
    EMIT vp<%6> = or ir<%tobool101.not>, vp<%3>
    WIDEN ir<%indvars.iv.next975> = add nuw nsw ir<%indvars.iv974>, ir<1>
    CLONE ir<%exitcond976.not> = icmp eq ir<%indvars.iv.next975>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end111.loopexit>, scalar.ph

ir-bb<if.end111.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 318
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 318
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 318
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 188
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 318
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 149
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 8 for VF 16 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 8 for VF 16 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width 16 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 318
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 144
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 16 for VF 32 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 16 for VF 32 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 16 for VF 32 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 16 for VF 32 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width 32 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 195, RTCostB: 318
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 195, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 318
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 188, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 318
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 149, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 318
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 144, RTCostB: 135

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 8 for VF vscale x 8 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 8 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 318
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 135, RTCostB: 135
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv974 = phi i64 [ 0, %if.then92 ], [ %indvars.iv.next975, %for.inc108 ] of type:phi
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %shl99 = shl nuw nsw i64 1, %indvars.iv974 of type:shl
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %and100 = and i64 %shl99, %72 of type:and
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %tobool101.not = icmp eq i64 %and100, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool101.not, label %for.inc108, label %if.then102 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx104 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx104, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx106 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv974 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx106, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc108 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 16 for VF vscale x 16 For instruction:   %indvars.iv.next975 = add nuw nsw i64 %indvars.iv974, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond976.not = icmp eq i64 %indvars.iv.next975, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond976.not, label %if.end111.loopexit, label %for.body97 of type:br
LV: Vector loop of width vscale x 16 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 195, RTCostB: 318
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 195, RTCostB: 135
LV: Selecting VF: vscale x 8 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 8, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv974 = phi 0, %indvars.iv.next975, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%shl99> = shl nuw nsw ir<1>, ir<%indvars.iv974>
    WIDEN ir<%and100> = and ir<%shl99>, ir<%72>
    WIDEN ir<%tobool101.not> = icmp eq ir<%and100>, ir<0>
    EMIT vp<%4> = not ir<%tobool101.not>
    CLONE ir<%arrayidx104> = getelementptr ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx104>
    WIDEN store vp<%5>, ir<1>, vp<%4>
    CLONE ir<%arrayidx106> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx106>
    WIDEN store vp<%6>, ir<1>, vp<%4>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end111.loopexit>, scalar.ph

ir-bb<if.end111.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %128 = load i64, ptr %arrayidx200, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %k196.0.lcssa, ptr %arrayidx220, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %128 = load i64, ptr %arrayidx200, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %k196.0.lcssa, ptr %arrayidx220, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %128 = load i64, ptr %arrayidx200, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %k196.0.lcssa, ptr %arrayidx220, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %128 = load i64, ptr %arrayidx200, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %k196.0.lcssa, ptr %arrayidx220, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%97>
    WIDEN-INDUCTION %indvars.iv995 = phi 0, %indvars.iv.next996, ir<1>
    CLONE ir<%arrayidx200> = getelementptr inbounds ir<@reg_class_contents>, ir<0>, ir<%indvars.iv995>
    CLONE ir<%128> = load ir<%arrayidx200>
    CLONE ir<%or201> = or ir<%128>, ir<%127>
    CLONE ir<%and209> = and ir<%or201>, ir<%not208>
    CLONE ir<%cmp210> = icmp eq ir<%and209>, ir<0>
  Successor(s): for.inc214

  for.inc214:
    EMIT vp<%3> = not ir<%cmp210>
    CLONE ir<%and209.1> = and ir<%or201>, ir<%not208.1>
    CLONE ir<%cmp210.1> = icmp eq ir<%and209.1>, ir<0>
  Successor(s): for.inc214.1

  for.inc214.1:
    EMIT vp<%4> = not ir<%cmp210.1>
    EMIT vp<%5> = logical-and vp<%3>, vp<%4>
    CLONE ir<%and209.2> = and ir<%or201>, ir<%not208.2>
    CLONE ir<%cmp210.2> = icmp eq ir<%and209.2>, ir<0>
  Successor(s): for.inc214.2

  for.inc214.2:
    EMIT vp<%6> = not ir<%cmp210.2>
    EMIT vp<%7> = logical-and vp<%5>, vp<%6>
    CLONE ir<%and209.3> = and ir<%or201>, ir<%not208.3>
    CLONE ir<%cmp210.3> = icmp eq ir<%and209.3>, ir<0>
  Successor(s): for.inc214.3

  for.inc214.3:
    EMIT vp<%8> = not ir<%cmp210.3>
    EMIT vp<%9> = logical-and vp<%7>, vp<%8>
    CLONE ir<%and209.4> = and ir<%or201>, ir<%not208.4>
    CLONE ir<%cmp210.4> = icmp eq ir<%and209.4>, ir<0>
  Successor(s): for.inc214.4

  for.inc214.4:
    EMIT vp<%10> = not ir<%cmp210.4>
    EMIT vp<%11> = logical-and vp<%9>, vp<%10>
    CLONE ir<%and209.5> = and ir<%or201>, ir<%not208.5>
    CLONE ir<%cmp210.5> = icmp eq ir<%and209.5>, ir<0>
  Successor(s): for.inc214.5

  for.inc214.5:
    EMIT vp<%12> = not ir<%cmp210.5>
    EMIT vp<%13> = logical-and vp<%11>, vp<%12>
    CLONE ir<%and209.6> = and ir<%or201>, ir<%not208.6>
    CLONE ir<%cmp210.6> = icmp eq ir<%and209.6>, ir<0>
  Successor(s): for.inc214.6

  for.inc214.6:
    EMIT vp<%14> = not ir<%cmp210.6>
    EMIT vp<%15> = logical-and vp<%13>, vp<%14>
    CLONE ir<%and209.7> = and ir<%or201>, ir<%not208.7>
    CLONE ir<%cmp210.7> = icmp eq ir<%and209.7>, ir<0>
  Successor(s): for.inc214.7

  for.inc214.7:
    EMIT vp<%16> = not ir<%cmp210.7>
    EMIT vp<%17> = logical-and vp<%15>, vp<%16>
    CLONE ir<%and209.8> = and ir<%or201>, ir<%not208.8>
    CLONE ir<%cmp210.8> = icmp eq ir<%and209.8>, ir<0>
  Successor(s): for.inc214.8

  for.inc214.8:
    EMIT vp<%18> = not ir<%cmp210.8>
    EMIT vp<%19> = logical-and vp<%17>, vp<%18>
    CLONE ir<%and209.9> = and ir<%or201>, ir<%not208.9>
    CLONE ir<%cmp210.9> = icmp eq ir<%and209.9>, ir<0>
  Successor(s): for.inc214.9

  for.inc214.9:
    EMIT vp<%20> = not ir<%cmp210.9>
    EMIT vp<%21> = logical-and vp<%19>, vp<%20>
    CLONE ir<%and209.10> = and ir<%or201>, ir<%not208.10>
    CLONE ir<%cmp210.10> = icmp eq ir<%and209.10>, ir<0>
  Successor(s): for.inc214.10

  for.inc214.10:
    EMIT vp<%22> = not ir<%cmp210.10>
    EMIT vp<%23> = logical-and vp<%21>, vp<%22>
    CLONE ir<%and209.11> = and ir<%or201>, ir<%not208.11>
    CLONE ir<%cmp210.11> = icmp eq ir<%and209.11>, ir<0>
  Successor(s): for.inc214.11

  for.inc214.11:
    EMIT vp<%24> = not ir<%cmp210.11>
    EMIT vp<%25> = logical-and vp<%23>, vp<%24>
    CLONE ir<%and209.12> = and ir<%or201>, ir<%not208.12>
    CLONE ir<%cmp210.12> = icmp eq ir<%and209.12>, ir<0>
  Successor(s): for.inc214.12

  for.inc214.12:
    EMIT vp<%26> = not ir<%cmp210.12>
    EMIT vp<%27> = logical-and vp<%25>, vp<%26>
    CLONE ir<%and209.13> = and ir<%or201>, ir<%not208.13>
    CLONE ir<%cmp210.13> = icmp eq ir<%and209.13>, ir<0>
  Successor(s): for.inc214.13

  for.inc214.13:
    EMIT vp<%28> = not ir<%cmp210.13>
    EMIT vp<%29> = logical-and vp<%27>, vp<%28>
    CLONE ir<%and209.14> = and ir<%or201>, ir<%not208.14>
    CLONE ir<%cmp210.14> = icmp eq ir<%and209.14>, ir<0>
  Successor(s): for.inc214.14

  for.inc214.14:
    EMIT vp<%30> = not ir<%cmp210.14>
    EMIT vp<%31> = logical-and vp<%29>, vp<%30>
    CLONE ir<%and209.15> = and ir<%or201>, ir<%not208.15>
    CLONE ir<%cmp210.15> = icmp eq ir<%and209.15>, ir<0>
  Successor(s): for.inc214.15

  for.inc214.15:
    EMIT vp<%32> = not ir<%cmp210.15>
    EMIT vp<%33> = logical-and vp<%31>, vp<%32>
    CLONE ir<%and209.16> = and ir<%or201>, ir<%not208.16>
    CLONE ir<%cmp210.16> = icmp eq ir<%and209.16>, ir<0>
  Successor(s): for.inc214.16

  for.inc214.16:
    EMIT vp<%34> = not ir<%cmp210.16>
    EMIT vp<%35> = logical-and vp<%33>, vp<%34>
    CLONE ir<%and209.17> = and ir<%or201>, ir<%not208.17>
    CLONE ir<%cmp210.17> = icmp eq ir<%and209.17>, ir<0>
  Successor(s): for.inc214.17

  for.inc214.17:
    EMIT vp<%36> = not ir<%cmp210.17>
    EMIT vp<%37> = logical-and vp<%35>, vp<%36>
    CLONE ir<%and209.18> = and ir<%or201>, ir<%not208.18>
    CLONE ir<%cmp210.18> = icmp eq ir<%and209.18>, ir<0>
  Successor(s): for.inc214.18

  for.inc214.18:
    EMIT vp<%38> = not ir<%cmp210.18>
    EMIT vp<%39> = logical-and vp<%37>, vp<%38>
    CLONE ir<%and209.19> = and ir<%or201>, ir<%not208.19>
    CLONE ir<%cmp210.19> = icmp eq ir<%and209.19>, ir<0>
  Successor(s): for.inc214.19

  for.inc214.19:
    EMIT vp<%40> = not ir<%cmp210.19>
    EMIT vp<%41> = logical-and vp<%39>, vp<%40>
    CLONE ir<%and209.20> = and ir<%or201>, ir<%not208.20>
    CLONE ir<%cmp210.20> = icmp eq ir<%and209.20>, ir<0>
  Successor(s): for.inc214.20

  for.inc214.20:
    EMIT vp<%42> = not ir<%cmp210.20>
    EMIT vp<%43> = logical-and vp<%41>, vp<%42>
    CLONE ir<%and209.21> = and ir<%or201>, ir<%not208.21>
    CLONE ir<%cmp210.21> = icmp eq ir<%and209.21>, ir<0>
  Successor(s): for.inc214.21

  for.inc214.21:
    EMIT vp<%44> = not ir<%cmp210.21>
    EMIT vp<%45> = logical-and vp<%43>, vp<%44>
    CLONE ir<%and209.22> = and ir<%or201>, ir<%not208.22>
    CLONE ir<%cmp210.22> = icmp eq ir<%and209.22>, ir<0>
  Successor(s): for.inc214.22

  for.inc214.22:
    EMIT vp<%46> = not ir<%cmp210.22>
    EMIT vp<%47> = logical-and vp<%45>, vp<%46>
    CLONE ir<%and209.23> = and ir<%or201>, ir<%not208.23>
    CLONE ir<%cmp210.23> = icmp eq ir<%and209.23>, ir<0>
  Successor(s): for.inc214.23

  for.inc214.23:
    EMIT vp<%48> = not ir<%cmp210.23>
    EMIT vp<%49> = logical-and vp<%47>, vp<%48>
    CLONE ir<%and209.24> = and ir<%or201>, ir<%not208.24>
    CLONE ir<%cmp210.24> = icmp eq ir<%and209.24>, ir<0>
    CLONE ir<%spec.select1200> = select ir<%cmp210.24>, ir<24>, ir<25>
  Successor(s): superclass

  superclass:
    EMIT vp<%50> = logical-and vp<%47>, ir<%cmp210.23>
    EMIT vp<%51> = or vp<%49>, vp<%50>
    EMIT vp<%52> = logical-and vp<%45>, ir<%cmp210.22>
    EMIT vp<%53> = or vp<%51>, vp<%52>
    EMIT vp<%54> = logical-and vp<%43>, ir<%cmp210.21>
    EMIT vp<%55> = or vp<%53>, vp<%54>
    EMIT vp<%56> = logical-and vp<%41>, ir<%cmp210.20>
    EMIT vp<%57> = or vp<%55>, vp<%56>
    EMIT vp<%58> = logical-and vp<%39>, ir<%cmp210.19>
    EMIT vp<%59> = or vp<%57>, vp<%58>
    EMIT vp<%60> = logical-and vp<%37>, ir<%cmp210.18>
    EMIT vp<%61> = or vp<%59>, vp<%60>
    EMIT vp<%62> = logical-and vp<%35>, ir<%cmp210.17>
    EMIT vp<%63> = or vp<%61>, vp<%62>
    EMIT vp<%64> = logical-and vp<%33>, ir<%cmp210.16>
    EMIT vp<%65> = or vp<%63>, vp<%64>
    EMIT vp<%66> = logical-and vp<%31>, ir<%cmp210.15>
    EMIT vp<%67> = or vp<%65>, vp<%66>
    EMIT vp<%68> = logical-and vp<%29>, ir<%cmp210.14>
    EMIT vp<%69> = or vp<%67>, vp<%68>
    EMIT vp<%70> = logical-and vp<%27>, ir<%cmp210.13>
    EMIT vp<%71> = or vp<%69>, vp<%70>
    EMIT vp<%72> = logical-and vp<%25>, ir<%cmp210.12>
    EMIT vp<%73> = or vp<%71>, vp<%72>
    EMIT vp<%74> = logical-and vp<%23>, ir<%cmp210.11>
    EMIT vp<%75> = or vp<%73>, vp<%74>
    EMIT vp<%76> = logical-and vp<%21>, ir<%cmp210.10>
    EMIT vp<%77> = or vp<%75>, vp<%76>
    EMIT vp<%78> = logical-and vp<%19>, ir<%cmp210.9>
    EMIT vp<%79> = or vp<%77>, vp<%78>
    EMIT vp<%80> = logical-and vp<%17>, ir<%cmp210.8>
    EMIT vp<%81> = or vp<%79>, vp<%80>
    EMIT vp<%82> = logical-and vp<%15>, ir<%cmp210.7>
    EMIT vp<%83> = or vp<%81>, vp<%82>
    EMIT vp<%84> = logical-and vp<%13>, ir<%cmp210.6>
    EMIT vp<%85> = or vp<%83>, vp<%84>
    EMIT vp<%86> = logical-and vp<%11>, ir<%cmp210.5>
    EMIT vp<%87> = or vp<%85>, vp<%86>
    EMIT vp<%88> = logical-and vp<%9>, ir<%cmp210.4>
    EMIT vp<%89> = or vp<%87>, vp<%88>
    EMIT vp<%90> = logical-and vp<%7>, ir<%cmp210.3>
    EMIT vp<%91> = or vp<%89>, vp<%90>
    EMIT vp<%92> = logical-and vp<%5>, ir<%cmp210.2>
    EMIT vp<%93> = or vp<%91>, vp<%92>
    EMIT vp<%94> = logical-and vp<%3>, ir<%cmp210.1>
    EMIT vp<%95> = or vp<%93>, vp<%94>
    EMIT vp<%96> = or vp<%95>, ir<%cmp210>
    BLEND ir<%k196.0.lcssa> = ir<0> ir<1>/vp<%94> ir<2>/vp<%92> ir<3>/vp<%90> ir<4>/vp<%88> ir<5>/vp<%86> ir<6>/vp<%84> ir<7>/vp<%82> ir<8>/vp<%80> ir<9>/vp<%78> ir<10>/vp<%76> ir<11>/vp<%74> ir<12>/vp<%72> ir<13>/vp<%70> ir<14>/vp<%68> ir<15>/vp<%66> ir<16>/vp<%64> ir<17>/vp<%62> ir<18>/vp<%60> ir<19>/vp<%58> ir<20>/vp<%56> ir<21>/vp<%54> ir<22>/vp<%52> ir<23>/vp<%50> ir<%spec.select1200>/vp<%49>
    CLONE ir<%arrayidx220> = getelementptr inbounds ir<@reg_class_superunion>, ir<0>, ir<%indvars.iv998>, ir<%indvars.iv995>
    CLONE store ir<%k196.0.lcssa>, ir<%arrayidx220>
    CLONE ir<%indvars.iv.next996> = add nuw nsw ir<%indvars.iv995>, ir<1>
    CLONE ir<%exitcond997.not> = icmp eq ir<%indvars.iv.next996>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%97> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%97>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%99> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%99>
Successor(s): ir-bb<for.inc224>, scalar.ph

ir-bb<for.inc224>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%99>
    WIDEN-INDUCTION %indvars.iv995 = phi 0, %indvars.iv.next996, ir<1>
    CLONE ir<%arrayidx200> = getelementptr inbounds ir<@reg_class_contents>, ir<0>, ir<%indvars.iv995>
    vp<%3> = vector-pointer ir<%arrayidx200>
    WIDEN ir<%128> = load vp<%3>
    WIDEN ir<%or201> = or ir<%128>, ir<%127>
    WIDEN ir<%and209> = and ir<%or201>, ir<%not208>
    WIDEN ir<%cmp210> = icmp eq ir<%and209>, ir<0>
  Successor(s): for.inc214

  for.inc214:
    EMIT vp<%4> = not ir<%cmp210>
    WIDEN ir<%and209.1> = and ir<%or201>, ir<%not208.1>
    WIDEN ir<%cmp210.1> = icmp eq ir<%and209.1>, ir<0>
  Successor(s): for.inc214.1

  for.inc214.1:
    EMIT vp<%5> = not ir<%cmp210.1>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%and209.2> = and ir<%or201>, ir<%not208.2>
    WIDEN ir<%cmp210.2> = icmp eq ir<%and209.2>, ir<0>
  Successor(s): for.inc214.2

  for.inc214.2:
    EMIT vp<%7> = not ir<%cmp210.2>
    EMIT vp<%8> = logical-and vp<%6>, vp<%7>
    WIDEN ir<%and209.3> = and ir<%or201>, ir<%not208.3>
    WIDEN ir<%cmp210.3> = icmp eq ir<%and209.3>, ir<0>
  Successor(s): for.inc214.3

  for.inc214.3:
    EMIT vp<%9> = not ir<%cmp210.3>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    WIDEN ir<%and209.4> = and ir<%or201>, ir<%not208.4>
    WIDEN ir<%cmp210.4> = icmp eq ir<%and209.4>, ir<0>
  Successor(s): for.inc214.4

  for.inc214.4:
    EMIT vp<%11> = not ir<%cmp210.4>
    EMIT vp<%12> = logical-and vp<%10>, vp<%11>
    WIDEN ir<%and209.5> = and ir<%or201>, ir<%not208.5>
    WIDEN ir<%cmp210.5> = icmp eq ir<%and209.5>, ir<0>
  Successor(s): for.inc214.5

  for.inc214.5:
    EMIT vp<%13> = not ir<%cmp210.5>
    EMIT vp<%14> = logical-and vp<%12>, vp<%13>
    WIDEN ir<%and209.6> = and ir<%or201>, ir<%not208.6>
    WIDEN ir<%cmp210.6> = icmp eq ir<%and209.6>, ir<0>
  Successor(s): for.inc214.6

  for.inc214.6:
    EMIT vp<%15> = not ir<%cmp210.6>
    EMIT vp<%16> = logical-and vp<%14>, vp<%15>
    WIDEN ir<%and209.7> = and ir<%or201>, ir<%not208.7>
    WIDEN ir<%cmp210.7> = icmp eq ir<%and209.7>, ir<0>
  Successor(s): for.inc214.7

  for.inc214.7:
    EMIT vp<%17> = not ir<%cmp210.7>
    EMIT vp<%18> = logical-and vp<%16>, vp<%17>
    WIDEN ir<%and209.8> = and ir<%or201>, ir<%not208.8>
    WIDEN ir<%cmp210.8> = icmp eq ir<%and209.8>, ir<0>
  Successor(s): for.inc214.8

  for.inc214.8:
    EMIT vp<%19> = not ir<%cmp210.8>
    EMIT vp<%20> = logical-and vp<%18>, vp<%19>
    WIDEN ir<%and209.9> = and ir<%or201>, ir<%not208.9>
    WIDEN ir<%cmp210.9> = icmp eq ir<%and209.9>, ir<0>
  Successor(s): for.inc214.9

  for.inc214.9:
    EMIT vp<%21> = not ir<%cmp210.9>
    EMIT vp<%22> = logical-and vp<%20>, vp<%21>
    WIDEN ir<%and209.10> = and ir<%or201>, ir<%not208.10>
    WIDEN ir<%cmp210.10> = icmp eq ir<%and209.10>, ir<0>
  Successor(s): for.inc214.10

  for.inc214.10:
    EMIT vp<%23> = not ir<%cmp210.10>
    EMIT vp<%24> = logical-and vp<%22>, vp<%23>
    WIDEN ir<%and209.11> = and ir<%or201>, ir<%not208.11>
    WIDEN ir<%cmp210.11> = icmp eq ir<%and209.11>, ir<0>
  Successor(s): for.inc214.11

  for.inc214.11:
    EMIT vp<%25> = not ir<%cmp210.11>
    EMIT vp<%26> = logical-and vp<%24>, vp<%25>
    WIDEN ir<%and209.12> = and ir<%or201>, ir<%not208.12>
    WIDEN ir<%cmp210.12> = icmp eq ir<%and209.12>, ir<0>
  Successor(s): for.inc214.12

  for.inc214.12:
    EMIT vp<%27> = not ir<%cmp210.12>
    EMIT vp<%28> = logical-and vp<%26>, vp<%27>
    WIDEN ir<%and209.13> = and ir<%or201>, ir<%not208.13>
    WIDEN ir<%cmp210.13> = icmp eq ir<%and209.13>, ir<0>
  Successor(s): for.inc214.13

  for.inc214.13:
    EMIT vp<%29> = not ir<%cmp210.13>
    EMIT vp<%30> = logical-and vp<%28>, vp<%29>
    WIDEN ir<%and209.14> = and ir<%or201>, ir<%not208.14>
    WIDEN ir<%cmp210.14> = icmp eq ir<%and209.14>, ir<0>
  Successor(s): for.inc214.14

  for.inc214.14:
    EMIT vp<%31> = not ir<%cmp210.14>
    EMIT vp<%32> = logical-and vp<%30>, vp<%31>
    WIDEN ir<%and209.15> = and ir<%or201>, ir<%not208.15>
    WIDEN ir<%cmp210.15> = icmp eq ir<%and209.15>, ir<0>
  Successor(s): for.inc214.15

  for.inc214.15:
    EMIT vp<%33> = not ir<%cmp210.15>
    EMIT vp<%34> = logical-and vp<%32>, vp<%33>
    WIDEN ir<%and209.16> = and ir<%or201>, ir<%not208.16>
    WIDEN ir<%cmp210.16> = icmp eq ir<%and209.16>, ir<0>
  Successor(s): for.inc214.16

  for.inc214.16:
    EMIT vp<%35> = not ir<%cmp210.16>
    EMIT vp<%36> = logical-and vp<%34>, vp<%35>
    WIDEN ir<%and209.17> = and ir<%or201>, ir<%not208.17>
    WIDEN ir<%cmp210.17> = icmp eq ir<%and209.17>, ir<0>
  Successor(s): for.inc214.17

  for.inc214.17:
    EMIT vp<%37> = not ir<%cmp210.17>
    EMIT vp<%38> = logical-and vp<%36>, vp<%37>
    WIDEN ir<%and209.18> = and ir<%or201>, ir<%not208.18>
    WIDEN ir<%cmp210.18> = icmp eq ir<%and209.18>, ir<0>
  Successor(s): for.inc214.18

  for.inc214.18:
    EMIT vp<%39> = not ir<%cmp210.18>
    EMIT vp<%40> = logical-and vp<%38>, vp<%39>
    WIDEN ir<%and209.19> = and ir<%or201>, ir<%not208.19>
    WIDEN ir<%cmp210.19> = icmp eq ir<%and209.19>, ir<0>
  Successor(s): for.inc214.19

  for.inc214.19:
    EMIT vp<%41> = not ir<%cmp210.19>
    EMIT vp<%42> = logical-and vp<%40>, vp<%41>
    WIDEN ir<%and209.20> = and ir<%or201>, ir<%not208.20>
    WIDEN ir<%cmp210.20> = icmp eq ir<%and209.20>, ir<0>
  Successor(s): for.inc214.20

  for.inc214.20:
    EMIT vp<%43> = not ir<%cmp210.20>
    EMIT vp<%44> = logical-and vp<%42>, vp<%43>
    WIDEN ir<%and209.21> = and ir<%or201>, ir<%not208.21>
    WIDEN ir<%cmp210.21> = icmp eq ir<%and209.21>, ir<0>
  Successor(s): for.inc214.21

  for.inc214.21:
    EMIT vp<%45> = not ir<%cmp210.21>
    EMIT vp<%46> = logical-and vp<%44>, vp<%45>
    WIDEN ir<%and209.22> = and ir<%or201>, ir<%not208.22>
    WIDEN ir<%cmp210.22> = icmp eq ir<%and209.22>, ir<0>
  Successor(s): for.inc214.22

  for.inc214.22:
    EMIT vp<%47> = not ir<%cmp210.22>
    EMIT vp<%48> = logical-and vp<%46>, vp<%47>
    WIDEN ir<%and209.23> = and ir<%or201>, ir<%not208.23>
    WIDEN ir<%cmp210.23> = icmp eq ir<%and209.23>, ir<0>
  Successor(s): for.inc214.23

  for.inc214.23:
    EMIT vp<%49> = not ir<%cmp210.23>
    EMIT vp<%50> = logical-and vp<%48>, vp<%49>
    WIDEN ir<%and209.24> = and ir<%or201>, ir<%not208.24>
    WIDEN ir<%cmp210.24> = icmp eq ir<%and209.24>, ir<0>
    WIDEN-SELECT ir<%spec.select1200> = select ir<%cmp210.24>, ir<24>, ir<25>
  Successor(s): superclass

  superclass:
    EMIT vp<%51> = logical-and vp<%48>, ir<%cmp210.23>
    EMIT vp<%52> = or vp<%50>, vp<%51>
    EMIT vp<%53> = logical-and vp<%46>, ir<%cmp210.22>
    EMIT vp<%54> = or vp<%52>, vp<%53>
    EMIT vp<%55> = logical-and vp<%44>, ir<%cmp210.21>
    EMIT vp<%56> = or vp<%54>, vp<%55>
    EMIT vp<%57> = logical-and vp<%42>, ir<%cmp210.20>
    EMIT vp<%58> = or vp<%56>, vp<%57>
    EMIT vp<%59> = logical-and vp<%40>, ir<%cmp210.19>
    EMIT vp<%60> = or vp<%58>, vp<%59>
    EMIT vp<%61> = logical-and vp<%38>, ir<%cmp210.18>
    EMIT vp<%62> = or vp<%60>, vp<%61>
    EMIT vp<%63> = logical-and vp<%36>, ir<%cmp210.17>
    EMIT vp<%64> = or vp<%62>, vp<%63>
    EMIT vp<%65> = logical-and vp<%34>, ir<%cmp210.16>
    EMIT vp<%66> = or vp<%64>, vp<%65>
    EMIT vp<%67> = logical-and vp<%32>, ir<%cmp210.15>
    EMIT vp<%68> = or vp<%66>, vp<%67>
    EMIT vp<%69> = logical-and vp<%30>, ir<%cmp210.14>
    EMIT vp<%70> = or vp<%68>, vp<%69>
    EMIT vp<%71> = logical-and vp<%28>, ir<%cmp210.13>
    EMIT vp<%72> = or vp<%70>, vp<%71>
    EMIT vp<%73> = logical-and vp<%26>, ir<%cmp210.12>
    EMIT vp<%74> = or vp<%72>, vp<%73>
    EMIT vp<%75> = logical-and vp<%24>, ir<%cmp210.11>
    EMIT vp<%76> = or vp<%74>, vp<%75>
    EMIT vp<%77> = logical-and vp<%22>, ir<%cmp210.10>
    EMIT vp<%78> = or vp<%76>, vp<%77>
    EMIT vp<%79> = logical-and vp<%20>, ir<%cmp210.9>
    EMIT vp<%80> = or vp<%78>, vp<%79>
    EMIT vp<%81> = logical-and vp<%18>, ir<%cmp210.8>
    EMIT vp<%82> = or vp<%80>, vp<%81>
    EMIT vp<%83> = logical-and vp<%16>, ir<%cmp210.7>
    EMIT vp<%84> = or vp<%82>, vp<%83>
    EMIT vp<%85> = logical-and vp<%14>, ir<%cmp210.6>
    EMIT vp<%86> = or vp<%84>, vp<%85>
    EMIT vp<%87> = logical-and vp<%12>, ir<%cmp210.5>
    EMIT vp<%88> = or vp<%86>, vp<%87>
    EMIT vp<%89> = logical-and vp<%10>, ir<%cmp210.4>
    EMIT vp<%90> = or vp<%88>, vp<%89>
    EMIT vp<%91> = logical-and vp<%8>, ir<%cmp210.3>
    EMIT vp<%92> = or vp<%90>, vp<%91>
    EMIT vp<%93> = logical-and vp<%6>, ir<%cmp210.2>
    EMIT vp<%94> = or vp<%92>, vp<%93>
    EMIT vp<%95> = logical-and vp<%4>, ir<%cmp210.1>
    EMIT vp<%96> = or vp<%94>, vp<%95>
    EMIT vp<%97> = or vp<%96>, ir<%cmp210>
    BLEND ir<%k196.0.lcssa> = ir<0> ir<1>/vp<%95> ir<2>/vp<%93> ir<3>/vp<%91> ir<4>/vp<%89> ir<5>/vp<%87> ir<6>/vp<%85> ir<7>/vp<%83> ir<8>/vp<%81> ir<9>/vp<%79> ir<10>/vp<%77> ir<11>/vp<%75> ir<12>/vp<%73> ir<13>/vp<%71> ir<14>/vp<%69> ir<15>/vp<%67> ir<16>/vp<%65> ir<17>/vp<%63> ir<18>/vp<%61> ir<19>/vp<%59> ir<20>/vp<%57> ir<21>/vp<%55> ir<22>/vp<%53> ir<23>/vp<%51> ir<%spec.select1200>/vp<%50>
    CLONE ir<%arrayidx220> = getelementptr inbounds ir<@reg_class_superunion>, ir<0>, ir<%indvars.iv998>, ir<%indvars.iv995>
    vp<%98> = vector-pointer ir<%arrayidx220>
    WIDEN store vp<%98>, ir<%k196.0.lcssa>
    CLONE ir<%indvars.iv.next996> = add nuw nsw ir<%indvars.iv995>, ir<1>
    CLONE ir<%exitcond997.not> = icmp eq ir<%indvars.iv.next996>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%99> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%99>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%101> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%101>
Successor(s): ir-bb<for.inc224>, scalar.ph

ir-bb<for.inc224>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%99>
    WIDEN-INDUCTION %indvars.iv995 = phi 0, %indvars.iv.next996, ir<1>
    CLONE ir<%arrayidx200> = getelementptr inbounds ir<@reg_class_contents>, ir<0>, ir<%indvars.iv995>
    vp<%3> = vector-pointer ir<%arrayidx200>
    WIDEN ir<%128> = load vp<%3>
    WIDEN ir<%or201> = or ir<%128>, ir<%127>
    WIDEN ir<%and209> = and ir<%or201>, ir<%not208>
    WIDEN ir<%cmp210> = icmp eq ir<%and209>, ir<0>
  Successor(s): for.inc214

  for.inc214:
    EMIT vp<%4> = not ir<%cmp210>
    WIDEN ir<%and209.1> = and ir<%or201>, ir<%not208.1>
    WIDEN ir<%cmp210.1> = icmp eq ir<%and209.1>, ir<0>
  Successor(s): for.inc214.1

  for.inc214.1:
    EMIT vp<%5> = not ir<%cmp210.1>
    EMIT vp<%6> = logical-and vp<%4>, vp<%5>
    WIDEN ir<%and209.2> = and ir<%or201>, ir<%not208.2>
    WIDEN ir<%cmp210.2> = icmp eq ir<%and209.2>, ir<0>
  Successor(s): for.inc214.2

  for.inc214.2:
    EMIT vp<%7> = not ir<%cmp210.2>
    EMIT vp<%8> = logical-and vp<%6>, vp<%7>
    WIDEN ir<%and209.3> = and ir<%or201>, ir<%not208.3>
    WIDEN ir<%cmp210.3> = icmp eq ir<%and209.3>, ir<0>
  Successor(s): for.inc214.3

  for.inc214.3:
    EMIT vp<%9> = not ir<%cmp210.3>
    EMIT vp<%10> = logical-and vp<%8>, vp<%9>
    WIDEN ir<%and209.4> = and ir<%or201>, ir<%not208.4>
    WIDEN ir<%cmp210.4> = icmp eq ir<%and209.4>, ir<0>
  Successor(s): for.inc214.4

  for.inc214.4:
    EMIT vp<%11> = not ir<%cmp210.4>
    EMIT vp<%12> = logical-and vp<%10>, vp<%11>
    WIDEN ir<%and209.5> = and ir<%or201>, ir<%not208.5>
    WIDEN ir<%cmp210.5> = icmp eq ir<%and209.5>, ir<0>
  Successor(s): for.inc214.5

  for.inc214.5:
    EMIT vp<%13> = not ir<%cmp210.5>
    EMIT vp<%14> = logical-and vp<%12>, vp<%13>
    WIDEN ir<%and209.6> = and ir<%or201>, ir<%not208.6>
    WIDEN ir<%cmp210.6> = icmp eq ir<%and209.6>, ir<0>
  Successor(s): for.inc214.6

  for.inc214.6:
    EMIT vp<%15> = not ir<%cmp210.6>
    EMIT vp<%16> = logical-and vp<%14>, vp<%15>
    WIDEN ir<%and209.7> = and ir<%or201>, ir<%not208.7>
    WIDEN ir<%cmp210.7> = icmp eq ir<%and209.7>, ir<0>
  Successor(s): for.inc214.7

  for.inc214.7:
    EMIT vp<%17> = not ir<%cmp210.7>
    EMIT vp<%18> = logical-and vp<%16>, vp<%17>
    WIDEN ir<%and209.8> = and ir<%or201>, ir<%not208.8>
    WIDEN ir<%cmp210.8> = icmp eq ir<%and209.8>, ir<0>
  Successor(s): for.inc214.8

  for.inc214.8:
    EMIT vp<%19> = not ir<%cmp210.8>
    EMIT vp<%20> = logical-and vp<%18>, vp<%19>
    WIDEN ir<%and209.9> = and ir<%or201>, ir<%not208.9>
    WIDEN ir<%cmp210.9> = icmp eq ir<%and209.9>, ir<0>
  Successor(s): for.inc214.9

  for.inc214.9:
    EMIT vp<%21> = not ir<%cmp210.9>
    EMIT vp<%22> = logical-and vp<%20>, vp<%21>
    WIDEN ir<%and209.10> = and ir<%or201>, ir<%not208.10>
    WIDEN ir<%cmp210.10> = icmp eq ir<%and209.10>, ir<0>
  Successor(s): for.inc214.10

  for.inc214.10:
    EMIT vp<%23> = not ir<%cmp210.10>
    EMIT vp<%24> = logical-and vp<%22>, vp<%23>
    WIDEN ir<%and209.11> = and ir<%or201>, ir<%not208.11>
    WIDEN ir<%cmp210.11> = icmp eq ir<%and209.11>, ir<0>
  Successor(s): for.inc214.11

  for.inc214.11:
    EMIT vp<%25> = not ir<%cmp210.11>
    EMIT vp<%26> = logical-and vp<%24>, vp<%25>
    WIDEN ir<%and209.12> = and ir<%or201>, ir<%not208.12>
    WIDEN ir<%cmp210.12> = icmp eq ir<%and209.12>, ir<0>
  Successor(s): for.inc214.12

  for.inc214.12:
    EMIT vp<%27> = not ir<%cmp210.12>
    EMIT vp<%28> = logical-and vp<%26>, vp<%27>
    WIDEN ir<%and209.13> = and ir<%or201>, ir<%not208.13>
    WIDEN ir<%cmp210.13> = icmp eq ir<%and209.13>, ir<0>
  Successor(s): for.inc214.13

  for.inc214.13:
    EMIT vp<%29> = not ir<%cmp210.13>
    EMIT vp<%30> = logical-and vp<%28>, vp<%29>
    WIDEN ir<%and209.14> = and ir<%or201>, ir<%not208.14>
    WIDEN ir<%cmp210.14> = icmp eq ir<%and209.14>, ir<0>
  Successor(s): for.inc214.14

  for.inc214.14:
    EMIT vp<%31> = not ir<%cmp210.14>
    EMIT vp<%32> = logical-and vp<%30>, vp<%31>
    WIDEN ir<%and209.15> = and ir<%or201>, ir<%not208.15>
    WIDEN ir<%cmp210.15> = icmp eq ir<%and209.15>, ir<0>
  Successor(s): for.inc214.15

  for.inc214.15:
    EMIT vp<%33> = not ir<%cmp210.15>
    EMIT vp<%34> = logical-and vp<%32>, vp<%33>
    WIDEN ir<%and209.16> = and ir<%or201>, ir<%not208.16>
    WIDEN ir<%cmp210.16> = icmp eq ir<%and209.16>, ir<0>
  Successor(s): for.inc214.16

  for.inc214.16:
    EMIT vp<%35> = not ir<%cmp210.16>
    EMIT vp<%36> = logical-and vp<%34>, vp<%35>
    WIDEN ir<%and209.17> = and ir<%or201>, ir<%not208.17>
    WIDEN ir<%cmp210.17> = icmp eq ir<%and209.17>, ir<0>
  Successor(s): for.inc214.17

  for.inc214.17:
    EMIT vp<%37> = not ir<%cmp210.17>
    EMIT vp<%38> = logical-and vp<%36>, vp<%37>
    WIDEN ir<%and209.18> = and ir<%or201>, ir<%not208.18>
    WIDEN ir<%cmp210.18> = icmp eq ir<%and209.18>, ir<0>
  Successor(s): for.inc214.18

  for.inc214.18:
    EMIT vp<%39> = not ir<%cmp210.18>
    EMIT vp<%40> = logical-and vp<%38>, vp<%39>
    WIDEN ir<%and209.19> = and ir<%or201>, ir<%not208.19>
    WIDEN ir<%cmp210.19> = icmp eq ir<%and209.19>, ir<0>
  Successor(s): for.inc214.19

  for.inc214.19:
    EMIT vp<%41> = not ir<%cmp210.19>
    EMIT vp<%42> = logical-and vp<%40>, vp<%41>
    WIDEN ir<%and209.20> = and ir<%or201>, ir<%not208.20>
    WIDEN ir<%cmp210.20> = icmp eq ir<%and209.20>, ir<0>
  Successor(s): for.inc214.20

  for.inc214.20:
    EMIT vp<%43> = not ir<%cmp210.20>
    EMIT vp<%44> = logical-and vp<%42>, vp<%43>
    WIDEN ir<%and209.21> = and ir<%or201>, ir<%not208.21>
    WIDEN ir<%cmp210.21> = icmp eq ir<%and209.21>, ir<0>
  Successor(s): for.inc214.21

  for.inc214.21:
    EMIT vp<%45> = not ir<%cmp210.21>
    EMIT vp<%46> = logical-and vp<%44>, vp<%45>
    WIDEN ir<%and209.22> = and ir<%or201>, ir<%not208.22>
    WIDEN ir<%cmp210.22> = icmp eq ir<%and209.22>, ir<0>
  Successor(s): for.inc214.22

  for.inc214.22:
    EMIT vp<%47> = not ir<%cmp210.22>
    EMIT vp<%48> = logical-and vp<%46>, vp<%47>
    WIDEN ir<%and209.23> = and ir<%or201>, ir<%not208.23>
    WIDEN ir<%cmp210.23> = icmp eq ir<%and209.23>, ir<0>
  Successor(s): for.inc214.23

  for.inc214.23:
    EMIT vp<%49> = not ir<%cmp210.23>
    EMIT vp<%50> = logical-and vp<%48>, vp<%49>
    WIDEN ir<%and209.24> = and ir<%or201>, ir<%not208.24>
    WIDEN ir<%cmp210.24> = icmp eq ir<%and209.24>, ir<0>
    WIDEN-SELECT ir<%spec.select1200> = select ir<%cmp210.24>, ir<24>, ir<25>
  Successor(s): superclass

  superclass:
    EMIT vp<%51> = logical-and vp<%48>, ir<%cmp210.23>
    EMIT vp<%52> = or vp<%50>, vp<%51>
    EMIT vp<%53> = logical-and vp<%46>, ir<%cmp210.22>
    EMIT vp<%54> = or vp<%52>, vp<%53>
    EMIT vp<%55> = logical-and vp<%44>, ir<%cmp210.21>
    EMIT vp<%56> = or vp<%54>, vp<%55>
    EMIT vp<%57> = logical-and vp<%42>, ir<%cmp210.20>
    EMIT vp<%58> = or vp<%56>, vp<%57>
    EMIT vp<%59> = logical-and vp<%40>, ir<%cmp210.19>
    EMIT vp<%60> = or vp<%58>, vp<%59>
    EMIT vp<%61> = logical-and vp<%38>, ir<%cmp210.18>
    EMIT vp<%62> = or vp<%60>, vp<%61>
    EMIT vp<%63> = logical-and vp<%36>, ir<%cmp210.17>
    EMIT vp<%64> = or vp<%62>, vp<%63>
    EMIT vp<%65> = logical-and vp<%34>, ir<%cmp210.16>
    EMIT vp<%66> = or vp<%64>, vp<%65>
    EMIT vp<%67> = logical-and vp<%32>, ir<%cmp210.15>
    EMIT vp<%68> = or vp<%66>, vp<%67>
    EMIT vp<%69> = logical-and vp<%30>, ir<%cmp210.14>
    EMIT vp<%70> = or vp<%68>, vp<%69>
    EMIT vp<%71> = logical-and vp<%28>, ir<%cmp210.13>
    EMIT vp<%72> = or vp<%70>, vp<%71>
    EMIT vp<%73> = logical-and vp<%26>, ir<%cmp210.12>
    EMIT vp<%74> = or vp<%72>, vp<%73>
    EMIT vp<%75> = logical-and vp<%24>, ir<%cmp210.11>
    EMIT vp<%76> = or vp<%74>, vp<%75>
    EMIT vp<%77> = logical-and vp<%22>, ir<%cmp210.10>
    EMIT vp<%78> = or vp<%76>, vp<%77>
    EMIT vp<%79> = logical-and vp<%20>, ir<%cmp210.9>
    EMIT vp<%80> = or vp<%78>, vp<%79>
    EMIT vp<%81> = logical-and vp<%18>, ir<%cmp210.8>
    EMIT vp<%82> = or vp<%80>, vp<%81>
    EMIT vp<%83> = logical-and vp<%16>, ir<%cmp210.7>
    EMIT vp<%84> = or vp<%82>, vp<%83>
    EMIT vp<%85> = logical-and vp<%14>, ir<%cmp210.6>
    EMIT vp<%86> = or vp<%84>, vp<%85>
    EMIT vp<%87> = logical-and vp<%12>, ir<%cmp210.5>
    EMIT vp<%88> = or vp<%86>, vp<%87>
    EMIT vp<%89> = logical-and vp<%10>, ir<%cmp210.4>
    EMIT vp<%90> = or vp<%88>, vp<%89>
    EMIT vp<%91> = logical-and vp<%8>, ir<%cmp210.3>
    EMIT vp<%92> = or vp<%90>, vp<%91>
    EMIT vp<%93> = logical-and vp<%6>, ir<%cmp210.2>
    EMIT vp<%94> = or vp<%92>, vp<%93>
    EMIT vp<%95> = logical-and vp<%4>, ir<%cmp210.1>
    EMIT vp<%96> = or vp<%94>, vp<%95>
    EMIT vp<%97> = or vp<%96>, ir<%cmp210>
    BLEND ir<%k196.0.lcssa> = ir<0> ir<1>/vp<%95> ir<2>/vp<%93> ir<3>/vp<%91> ir<4>/vp<%89> ir<5>/vp<%87> ir<6>/vp<%85> ir<7>/vp<%83> ir<8>/vp<%81> ir<9>/vp<%79> ir<10>/vp<%77> ir<11>/vp<%75> ir<12>/vp<%73> ir<13>/vp<%71> ir<14>/vp<%69> ir<15>/vp<%67> ir<16>/vp<%65> ir<17>/vp<%63> ir<18>/vp<%61> ir<19>/vp<%59> ir<20>/vp<%57> ir<21>/vp<%55> ir<22>/vp<%53> ir<23>/vp<%51> ir<%spec.select1200>/vp<%50>
    CLONE ir<%arrayidx220> = getelementptr inbounds ir<@reg_class_superunion>, ir<0>, ir<%indvars.iv998>, ir<%indvars.iv995>
    vp<%98> = vector-pointer ir<%arrayidx220>
    WIDEN store vp<%98>, ir<%k196.0.lcssa>
    CLONE ir<%indvars.iv.next996> = add nuw nsw ir<%indvars.iv995>, ir<1>
    CLONE ir<%exitcond997.not> = icmp eq ir<%indvars.iv.next996>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%99> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%99>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%101> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%101>
Successor(s): ir-bb<for.inc224>, scalar.ph

ir-bb<for.inc224>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv995 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next996, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv995 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %128 = load i64, ptr %arrayidx200, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or201 = or i64 %128, %127 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select1200 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1200, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv998, i64 %indvars.iv995 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next996 = add nuw nsw i64 %indvars.iv995, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond997.not = icmp eq i64 %indvars.iv.next996, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond997.not, label %for.inc224, label %for.body194 of type:br
LV: Scalar loop costs: 31.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv995 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next996, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv995 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %128 = load i64, ptr %arrayidx200, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or201 = or i64 %128, %127 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1200 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 24 for VF 2 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1200, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv998, i64 %indvars.iv995 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next996 = add nuw nsw i64 %indvars.iv995, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond997.not = icmp eq i64 %indvars.iv.next996, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond997.not, label %for.inc224, label %for.body194 of type:br
LV: Vector loop of width 2 costs: 40
A is not scalable.	B is not scalable.	
RTCostA: 991, RTCostB: 775
A is not scalable.	B is not scalable.	
RTCostA: 991, RTCostB: 775

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv995 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next996, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv995 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %128 = load i64, ptr %arrayidx200, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or201 = or i64 %128, %127 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select1200 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 24 for VF 4 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1200, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv998, i64 %indvars.iv995 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next996 = add nuw nsw i64 %indvars.iv995, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond997.not = icmp eq i64 %indvars.iv.next996, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond997.not, label %for.inc224, label %for.body194 of type:br
LV: Vector loop of width 4 costs: 33
A is not scalable.	B is not scalable.	
RTCostA: 823, RTCostB: 775
A is not scalable.	B is not scalable.	
RTCostA: 823, RTCostB: 775

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv995 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next996, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv995 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %128 = load i64, ptr %arrayidx200, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or201 = or i64 %128, %127 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select1200 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 24 for VF vscale x 1 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1200, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv998, i64 %indvars.iv995 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next996 = add nuw nsw i64 %indvars.iv995, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond997.not = icmp eq i64 %indvars.iv.next996, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond997.not, label %for.inc224, label %for.body194 of type:br
LV: Vector loop of width vscale x 1 costs: 40
A is scalable.	B is not scalable.	
RTCostA: 991, RTCostB: 775
A is scalable.	B is not scalable.	
RTCostA: 991, RTCostB: 775

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv995 = phi i64 [ 0, %for.cond191.preheader ], [ %indvars.iv.next996, %superclass ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx200 = getelementptr inbounds [25 x i64], ptr @reg_class_contents, i64 0, i64 %indvars.iv995 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %128 = load i64, ptr %arrayidx200, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or201 = or i64 %128, %127 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209 = and i64 %or201, %not208 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210 = icmp eq i64 %and209, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210, label %superclass, label %for.inc214 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.1 = and i64 %or201, %not208.1 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.1 = icmp eq i64 %and209.1, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.1, label %superclass, label %for.inc214.1 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.2 = and i64 %or201, %not208.2 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.2 = icmp eq i64 %and209.2, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.2, label %superclass, label %for.inc214.2 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.3 = and i64 %or201, %not208.3 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.3 = icmp eq i64 %and209.3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.3, label %superclass, label %for.inc214.3 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.4 = and i64 %or201, %not208.4 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.4 = icmp eq i64 %and209.4, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.4, label %superclass, label %for.inc214.4 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.5 = and i64 %or201, %not208.5 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.5 = icmp eq i64 %and209.5, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.5, label %superclass, label %for.inc214.5 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.6 = and i64 %or201, %not208.6 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.6 = icmp eq i64 %and209.6, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.6, label %superclass, label %for.inc214.6 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.7 = and i64 %or201, %not208.7 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.7 = icmp eq i64 %and209.7, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.7, label %superclass, label %for.inc214.7 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.8 = and i64 %or201, %not208.8 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.8 = icmp eq i64 %and209.8, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.8, label %superclass, label %for.inc214.8 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.9 = and i64 %or201, %not208.9 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.9 = icmp eq i64 %and209.9, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.9, label %superclass, label %for.inc214.9 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.10 = and i64 %or201, %not208.10 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.10 = icmp eq i64 %and209.10, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.10, label %superclass, label %for.inc214.10 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.11 = and i64 %or201, %not208.11 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.11 = icmp eq i64 %and209.11, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.11, label %superclass, label %for.inc214.11 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.12 = and i64 %or201, %not208.12 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.12 = icmp eq i64 %and209.12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.12, label %superclass, label %for.inc214.12 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.13 = and i64 %or201, %not208.13 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.13 = icmp eq i64 %and209.13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.13, label %superclass, label %for.inc214.13 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.14 = and i64 %or201, %not208.14 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.14 = icmp eq i64 %and209.14, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.14, label %superclass, label %for.inc214.14 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.15 = and i64 %or201, %not208.15 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.15 = icmp eq i64 %and209.15, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.15, label %superclass, label %for.inc214.15 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.16 = and i64 %or201, %not208.16 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.16 = icmp eq i64 %and209.16, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.16, label %superclass, label %for.inc214.16 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.17 = and i64 %or201, %not208.17 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.17 = icmp eq i64 %and209.17, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.17, label %superclass, label %for.inc214.17 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.18 = and i64 %or201, %not208.18 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.18 = icmp eq i64 %and209.18, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.18, label %superclass, label %for.inc214.18 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.19 = and i64 %or201, %not208.19 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.19 = icmp eq i64 %and209.19, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.19, label %superclass, label %for.inc214.19 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.20 = and i64 %or201, %not208.20 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.20 = icmp eq i64 %and209.20, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.20, label %superclass, label %for.inc214.20 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.21 = and i64 %or201, %not208.21 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.21 = icmp eq i64 %and209.21, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.21, label %superclass, label %for.inc214.21 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.22 = and i64 %or201, %not208.22 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.22 = icmp eq i64 %and209.22, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.22, label %superclass, label %for.inc214.22 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.23 = and i64 %or201, %not208.23 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.23 = icmp eq i64 %and209.23, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp210.23, label %superclass, label %for.inc214.23 of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and209.24 = and i64 %or201, %not208.24 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp210.24 = icmp eq i64 %and209.24, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select1200 = select i1 %cmp210.24, i32 24, i32 25 of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %superclass of type:br

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 24 for VF vscale x 2 For instruction:   %k196.0.lcssa = phi i32 [ 0, %for.body194 ], [ 1, %for.inc214 ], [ 2, %for.inc214.1 ], [ 3, %for.inc214.2 ], [ 4, %for.inc214.3 ], [ 5, %for.inc214.4 ], [ 6, %for.inc214.5 ], [ 7, %for.inc214.6 ], [ 8, %for.inc214.7 ], [ 9, %for.inc214.8 ], [ 10, %for.inc214.9 ], [ 11, %for.inc214.10 ], [ 12, %for.inc214.11 ], [ 13, %for.inc214.12 ], [ 14, %for.inc214.13 ], [ 15, %for.inc214.14 ], [ 16, %for.inc214.15 ], [ 17, %for.inc214.16 ], [ 18, %for.inc214.17 ], [ 19, %for.inc214.18 ], [ 20, %for.inc214.19 ], [ 21, %for.inc214.20 ], [ 22, %for.inc214.21 ], [ 23, %for.inc214.22 ], [ %spec.select1200, %for.inc214.23 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx220 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superunion, i64 0, i64 %indvars.iv998, i64 %indvars.iv995 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %k196.0.lcssa, ptr %arrayidx220, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next996 = add nuw nsw i64 %indvars.iv995, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond997.not = icmp eq i64 %indvars.iv.next996, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond997.not, label %for.inc224, label %for.body194 of type:br
LV: Vector loop of width vscale x 2 costs: 33
A is scalable.	B is not scalable.	
RTCostA: 823, RTCostB: 775
A is scalable.	B is not scalable.	
RTCostA: 823, RTCostB: 775
LV: Selecting VF: 1 With Cost: 31.
maxbefore: 1
maxafter: 1
========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1004 = phi %indvars.iv.next1005, 0, ir<1>
    CLONE ir<%arrayidx238> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<0>
    CLONE store ir<25>, ir<%arrayidx238>
    CLONE ir<%arrayidx242> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<0>
    CLONE store ir<25>, ir<%arrayidx242>
    CLONE ir<%arrayidx238.1> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<1>
    CLONE store ir<25>, ir<%arrayidx238.1>
    CLONE ir<%arrayidx242.1> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<1>
    CLONE store ir<25>, ir<%arrayidx242.1>
    CLONE ir<%arrayidx238.2> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<2>
    CLONE store ir<25>, ir<%arrayidx238.2>
    CLONE ir<%arrayidx242.2> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<2>
    CLONE store ir<25>, ir<%arrayidx242.2>
    CLONE ir<%arrayidx238.3> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<3>
    CLONE store ir<25>, ir<%arrayidx238.3>
    CLONE ir<%arrayidx242.3> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<3>
    CLONE store ir<25>, ir<%arrayidx242.3>
    CLONE ir<%arrayidx238.4> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<4>
    CLONE store ir<25>, ir<%arrayidx238.4>
    CLONE ir<%arrayidx242.4> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<4>
    CLONE store ir<25>, ir<%arrayidx242.4>
    CLONE ir<%arrayidx238.5> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<5>
    CLONE store ir<25>, ir<%arrayidx238.5>
    CLONE ir<%arrayidx242.5> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<5>
    CLONE store ir<25>, ir<%arrayidx242.5>
    CLONE ir<%arrayidx238.6> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<6>
    CLONE store ir<25>, ir<%arrayidx238.6>
    CLONE ir<%arrayidx242.6> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<6>
    CLONE store ir<25>, ir<%arrayidx242.6>
    CLONE ir<%arrayidx238.7> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<7>
    CLONE store ir<25>, ir<%arrayidx238.7>
    CLONE ir<%arrayidx242.7> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<7>
    CLONE store ir<25>, ir<%arrayidx242.7>
    CLONE ir<%arrayidx238.8> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<8>
    CLONE store ir<25>, ir<%arrayidx238.8>
    CLONE ir<%arrayidx242.8> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<8>
    CLONE store ir<25>, ir<%arrayidx242.8>
    CLONE ir<%arrayidx238.9> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<9>
    CLONE store ir<25>, ir<%arrayidx238.9>
    CLONE ir<%arrayidx242.9> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<9>
    CLONE store ir<25>, ir<%arrayidx242.9>
    CLONE ir<%arrayidx238.10> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<10>
    CLONE store ir<25>, ir<%arrayidx238.10>
    CLONE ir<%arrayidx242.10> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<10>
    CLONE store ir<25>, ir<%arrayidx242.10>
    CLONE ir<%arrayidx238.11> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<11>
    CLONE store ir<25>, ir<%arrayidx238.11>
    CLONE ir<%arrayidx242.11> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<11>
    CLONE store ir<25>, ir<%arrayidx242.11>
    CLONE ir<%arrayidx238.12> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<12>
    CLONE store ir<25>, ir<%arrayidx238.12>
    CLONE ir<%arrayidx242.12> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<12>
    CLONE store ir<25>, ir<%arrayidx242.12>
    CLONE ir<%arrayidx238.13> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<13>
    CLONE store ir<25>, ir<%arrayidx238.13>
    CLONE ir<%arrayidx242.13> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<13>
    CLONE store ir<25>, ir<%arrayidx242.13>
    CLONE ir<%arrayidx238.14> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<14>
    CLONE store ir<25>, ir<%arrayidx238.14>
    CLONE ir<%arrayidx242.14> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<14>
    CLONE store ir<25>, ir<%arrayidx242.14>
    CLONE ir<%arrayidx238.15> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<15>
    CLONE store ir<25>, ir<%arrayidx238.15>
    CLONE ir<%arrayidx242.15> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<15>
    CLONE store ir<25>, ir<%arrayidx242.15>
    CLONE ir<%arrayidx238.16> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<16>
    CLONE store ir<25>, ir<%arrayidx238.16>
    CLONE ir<%arrayidx242.16> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<16>
    CLONE store ir<25>, ir<%arrayidx242.16>
    CLONE ir<%arrayidx238.17> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<17>
    CLONE store ir<25>, ir<%arrayidx238.17>
    CLONE ir<%arrayidx242.17> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<17>
    CLONE store ir<25>, ir<%arrayidx242.17>
    CLONE ir<%arrayidx238.18> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<18>
    CLONE store ir<25>, ir<%arrayidx238.18>
    CLONE ir<%arrayidx242.18> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<18>
    CLONE store ir<25>, ir<%arrayidx242.18>
    CLONE ir<%arrayidx238.19> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<19>
    CLONE store ir<25>, ir<%arrayidx238.19>
    CLONE ir<%arrayidx242.19> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<19>
    CLONE store ir<25>, ir<%arrayidx242.19>
    CLONE ir<%arrayidx238.20> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<20>
    CLONE store ir<25>, ir<%arrayidx238.20>
    CLONE ir<%arrayidx242.20> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<20>
    CLONE store ir<25>, ir<%arrayidx242.20>
    CLONE ir<%arrayidx238.21> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<21>
    CLONE store ir<25>, ir<%arrayidx238.21>
    CLONE ir<%arrayidx242.21> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<21>
    CLONE store ir<25>, ir<%arrayidx242.21>
    CLONE ir<%arrayidx238.22> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<22>
    CLONE store ir<25>, ir<%arrayidx238.22>
    CLONE ir<%arrayidx242.22> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<22>
    CLONE store ir<25>, ir<%arrayidx242.22>
    CLONE ir<%arrayidx238.23> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<23>
    CLONE store ir<25>, ir<%arrayidx238.23>
    CLONE ir<%arrayidx242.23> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<23>
    CLONE store ir<25>, ir<%arrayidx242.23>
    CLONE ir<%arrayidx238.24> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<24>
    CLONE store ir<25>, ir<%arrayidx238.24>
    CLONE ir<%arrayidx242.24> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<24>
    CLONE store ir<25>, ir<%arrayidx242.24>
    CLONE ir<%indvars.iv.next1005> = add nuw nsw ir<%indvars.iv1004>, ir<1>
    CLONE ir<%exitcond1006.not> = icmp eq ir<%indvars.iv.next1005>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body252.preheader>, scalar.ph

ir-bb<for.body252.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1004 = phi %indvars.iv.next1005, 0, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<0>
    WIDEN store ir<%arrayidx238>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<0>
    WIDEN store ir<%arrayidx242>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.1> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<1>
    WIDEN store ir<%arrayidx238.1>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.1> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<1>
    WIDEN store ir<%arrayidx242.1>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.2> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<2>
    WIDEN store ir<%arrayidx238.2>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.2> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<2>
    WIDEN store ir<%arrayidx242.2>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.3> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<3>
    WIDEN store ir<%arrayidx238.3>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.3> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<3>
    WIDEN store ir<%arrayidx242.3>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.4> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<4>
    WIDEN store ir<%arrayidx238.4>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.4> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<4>
    WIDEN store ir<%arrayidx242.4>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.5> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<5>
    WIDEN store ir<%arrayidx238.5>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.5> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<5>
    WIDEN store ir<%arrayidx242.5>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.6> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<6>
    WIDEN store ir<%arrayidx238.6>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.6> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<6>
    WIDEN store ir<%arrayidx242.6>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.7> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<7>
    WIDEN store ir<%arrayidx238.7>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.7> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<7>
    WIDEN store ir<%arrayidx242.7>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.8> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<8>
    WIDEN store ir<%arrayidx238.8>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.8> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<8>
    WIDEN store ir<%arrayidx242.8>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.9> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<9>
    WIDEN store ir<%arrayidx238.9>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.9> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<9>
    WIDEN store ir<%arrayidx242.9>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.10> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<10>
    WIDEN store ir<%arrayidx238.10>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.10> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<10>
    WIDEN store ir<%arrayidx242.10>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.11> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<11>
    WIDEN store ir<%arrayidx238.11>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.11> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<11>
    WIDEN store ir<%arrayidx242.11>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.12> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<12>
    WIDEN store ir<%arrayidx238.12>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.12> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<12>
    WIDEN store ir<%arrayidx242.12>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.13> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<13>
    WIDEN store ir<%arrayidx238.13>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.13> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<13>
    WIDEN store ir<%arrayidx242.13>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.14> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<14>
    WIDEN store ir<%arrayidx238.14>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.14> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<14>
    WIDEN store ir<%arrayidx242.14>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.15> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<15>
    WIDEN store ir<%arrayidx238.15>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.15> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<15>
    WIDEN store ir<%arrayidx242.15>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.16> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<16>
    WIDEN store ir<%arrayidx238.16>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.16> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<16>
    WIDEN store ir<%arrayidx242.16>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.17> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<17>
    WIDEN store ir<%arrayidx238.17>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.17> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<17>
    WIDEN store ir<%arrayidx242.17>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.18> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<18>
    WIDEN store ir<%arrayidx238.18>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.18> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<18>
    WIDEN store ir<%arrayidx242.18>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.19> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<19>
    WIDEN store ir<%arrayidx238.19>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.19> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<19>
    WIDEN store ir<%arrayidx242.19>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.20> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<20>
    WIDEN store ir<%arrayidx238.20>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.20> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<20>
    WIDEN store ir<%arrayidx242.20>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.21> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<21>
    WIDEN store ir<%arrayidx238.21>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.21> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<21>
    WIDEN store ir<%arrayidx242.21>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.22> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<22>
    WIDEN store ir<%arrayidx238.22>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.22> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<22>
    WIDEN store ir<%arrayidx242.22>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.23> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<23>
    WIDEN store ir<%arrayidx238.23>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.23> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<23>
    WIDEN store ir<%arrayidx242.23>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.24> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<24>
    WIDEN store ir<%arrayidx238.24>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.24> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<24>
    WIDEN store ir<%arrayidx242.24>, ir<25>
    WIDEN ir<%indvars.iv.next1005> = add nuw nsw ir<%indvars.iv1004>, ir<1>
    CLONE ir<%exitcond1006.not> = icmp eq ir<%indvars.iv.next1005>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body252.preheader>, scalar.ph

ir-bb<for.body252.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: init_reg_sets_1' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1004 = phi %indvars.iv.next1005, 0, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<0>
    WIDEN store ir<%arrayidx238>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<0>
    WIDEN store ir<%arrayidx242>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.1> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<1>
    WIDEN store ir<%arrayidx238.1>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.1> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<1>
    WIDEN store ir<%arrayidx242.1>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.2> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<2>
    WIDEN store ir<%arrayidx238.2>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.2> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<2>
    WIDEN store ir<%arrayidx242.2>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.3> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<3>
    WIDEN store ir<%arrayidx238.3>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.3> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<3>
    WIDEN store ir<%arrayidx242.3>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.4> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<4>
    WIDEN store ir<%arrayidx238.4>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.4> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<4>
    WIDEN store ir<%arrayidx242.4>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.5> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<5>
    WIDEN store ir<%arrayidx238.5>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.5> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<5>
    WIDEN store ir<%arrayidx242.5>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.6> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<6>
    WIDEN store ir<%arrayidx238.6>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.6> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<6>
    WIDEN store ir<%arrayidx242.6>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.7> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<7>
    WIDEN store ir<%arrayidx238.7>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.7> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<7>
    WIDEN store ir<%arrayidx242.7>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.8> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<8>
    WIDEN store ir<%arrayidx238.8>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.8> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<8>
    WIDEN store ir<%arrayidx242.8>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.9> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<9>
    WIDEN store ir<%arrayidx238.9>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.9> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<9>
    WIDEN store ir<%arrayidx242.9>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.10> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<10>
    WIDEN store ir<%arrayidx238.10>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.10> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<10>
    WIDEN store ir<%arrayidx242.10>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.11> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<11>
    WIDEN store ir<%arrayidx238.11>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.11> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<11>
    WIDEN store ir<%arrayidx242.11>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.12> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<12>
    WIDEN store ir<%arrayidx238.12>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.12> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<12>
    WIDEN store ir<%arrayidx242.12>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.13> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<13>
    WIDEN store ir<%arrayidx238.13>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.13> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<13>
    WIDEN store ir<%arrayidx242.13>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.14> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<14>
    WIDEN store ir<%arrayidx238.14>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.14> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<14>
    WIDEN store ir<%arrayidx242.14>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.15> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<15>
    WIDEN store ir<%arrayidx238.15>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.15> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<15>
    WIDEN store ir<%arrayidx242.15>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.16> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<16>
    WIDEN store ir<%arrayidx238.16>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.16> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<16>
    WIDEN store ir<%arrayidx242.16>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.17> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<17>
    WIDEN store ir<%arrayidx238.17>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.17> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<17>
    WIDEN store ir<%arrayidx242.17>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.18> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<18>
    WIDEN store ir<%arrayidx238.18>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.18> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<18>
    WIDEN store ir<%arrayidx242.18>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.19> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<19>
    WIDEN store ir<%arrayidx238.19>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.19> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<19>
    WIDEN store ir<%arrayidx242.19>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.20> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<20>
    WIDEN store ir<%arrayidx238.20>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.20> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<20>
    WIDEN store ir<%arrayidx242.20>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.21> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<21>
    WIDEN store ir<%arrayidx238.21>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.21> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<21>
    WIDEN store ir<%arrayidx242.21>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.22> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<22>
    WIDEN store ir<%arrayidx238.22>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.22> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<22>
    WIDEN store ir<%arrayidx242.22>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.23> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<23>
    WIDEN store ir<%arrayidx238.23>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.23> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<23>
    WIDEN store ir<%arrayidx242.23>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.24> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<24>
    WIDEN store ir<%arrayidx238.24>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.24> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<24>
    WIDEN store ir<%arrayidx242.24>, ir<25>
    WIDEN ir<%indvars.iv.next1005> = add nuw nsw ir<%indvars.iv1004>, ir<1>
    CLONE ir<%exitcond1006.not> = icmp eq ir<%indvars.iv.next1005>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body252.preheader>, scalar.ph

ir-bb<for.body252.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1004 = phi i64 [ %indvars.iv.next1005, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx238.24, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 25, ptr %arrayidx242.24, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1005 = add nuw nsw i64 %indvars.iv1004, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1006.not = icmp eq i64 %indvars.iv.next1005, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1006.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Scalar loop costs: 52.
-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1004 = phi i64 [ %indvars.iv.next1005, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx238.24, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 25, ptr %arrayidx242.24, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1005 = add nuw nsw i64 %indvars.iv1004, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1006.not = icmp eq i64 %indvars.iv.next1005, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1006.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width 2 costs: 51
A is not scalable.	B is not scalable.	
RTCostA: 1276, RTCostB: 1300
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1276, RTCostB: 1300
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1004 = phi i64 [ %indvars.iv.next1005, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx238.24, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 25, ptr %arrayidx242.24, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1005 = add nuw nsw i64 %indvars.iv1004, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1006.not = icmp eq i64 %indvars.iv.next1005, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1006.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width 4 costs: 50
A is not scalable.	B is not scalable.	
RTCostA: 1270, RTCostB: 1300
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1270, RTCostB: 1276
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1004 = phi i64 [ %indvars.iv.next1005, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx238.24, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 25, ptr %arrayidx242.24, align 4 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next1005 = add nuw nsw i64 %indvars.iv1004, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1006.not = icmp eq i64 %indvars.iv.next1005, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1006.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width 8 costs: 50
A is not scalable.	B is not scalable.	
RTCostA: 1267, RTCostB: 1300
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1267, RTCostB: 1270
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1004 = phi i64 [ %indvars.iv.next1005, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx238.24, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 25, ptr %arrayidx242.24, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1005 = add nuw nsw i64 %indvars.iv1004, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1006.not = icmp eq i64 %indvars.iv.next1005, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1006.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width vscale x 1 costs: 51
A is scalable.	B is not scalable.	
RTCostA: 1276, RTCostB: 1300
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1276, RTCostB: 1267

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1004 = phi i64 [ %indvars.iv.next1005, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx238.24, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 25, ptr %arrayidx242.24, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1005 = add nuw nsw i64 %indvars.iv1004, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1006.not = icmp eq i64 %indvars.iv.next1005, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1006.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 50
A is scalable.	B is not scalable.	
RTCostA: 1270, RTCostB: 1300
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1270, RTCostB: 1267

-----------------Function that is being costed:'init_reg_sets_1' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1004 = phi i64 [ %indvars.iv.next1005, %for.cond231.preheader ], [ 0, %for.cond231.preheader.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 0 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.1 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.1, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.2 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.2, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.3 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.3, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.4 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.4, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.5 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.5, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.6 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.6, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.7 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.7, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.8 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.8, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.9 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.9, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.10 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.10, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.11 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.11, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.12 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.12, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.13 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.13, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.14 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.14, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.15 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 15 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.15, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.16 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 16 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.16, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.17 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 17 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.17, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.18 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 18 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.18, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.19 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 19 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.19, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.20 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 20 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.20, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.21 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 21 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.21, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.22 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 22 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.22, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.23 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 23 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.23, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx238.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_superclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx238.24, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242.24 = getelementptr inbounds [25 x [25 x i32]], ptr @reg_class_subclasses, i64 0, i64 %indvars.iv1004, i64 24 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 25, ptr %arrayidx242.24, align 4 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next1005 = add nuw nsw i64 %indvars.iv1004, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1006.not = icmp eq i64 %indvars.iv.next1005, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1006.not, label %for.body252.preheader, label %for.cond231.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 50
A is scalable.	B is not scalable.	
RTCostA: 1267, RTCostB: 1300
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1267, RTCostB: 1267
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 50.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: init_reg_sets_1 at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1004 = phi %indvars.iv.next1005, 0, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<0>
    WIDEN store ir<%arrayidx238>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<0>
    WIDEN store ir<%arrayidx242>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.1> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<1>
    WIDEN store ir<%arrayidx238.1>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.1> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<1>
    WIDEN store ir<%arrayidx242.1>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.2> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<2>
    WIDEN store ir<%arrayidx238.2>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.2> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<2>
    WIDEN store ir<%arrayidx242.2>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.3> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<3>
    WIDEN store ir<%arrayidx238.3>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.3> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<3>
    WIDEN store ir<%arrayidx242.3>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.4> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<4>
    WIDEN store ir<%arrayidx238.4>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.4> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<4>
    WIDEN store ir<%arrayidx242.4>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.5> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<5>
    WIDEN store ir<%arrayidx238.5>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.5> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<5>
    WIDEN store ir<%arrayidx242.5>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.6> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<6>
    WIDEN store ir<%arrayidx238.6>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.6> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<6>
    WIDEN store ir<%arrayidx242.6>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.7> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<7>
    WIDEN store ir<%arrayidx238.7>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.7> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<7>
    WIDEN store ir<%arrayidx242.7>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.8> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<8>
    WIDEN store ir<%arrayidx238.8>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.8> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<8>
    WIDEN store ir<%arrayidx242.8>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.9> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<9>
    WIDEN store ir<%arrayidx238.9>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.9> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<9>
    WIDEN store ir<%arrayidx242.9>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.10> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<10>
    WIDEN store ir<%arrayidx238.10>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.10> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<10>
    WIDEN store ir<%arrayidx242.10>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.11> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<11>
    WIDEN store ir<%arrayidx238.11>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.11> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<11>
    WIDEN store ir<%arrayidx242.11>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.12> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<12>
    WIDEN store ir<%arrayidx238.12>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.12> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<12>
    WIDEN store ir<%arrayidx242.12>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.13> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<13>
    WIDEN store ir<%arrayidx238.13>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.13> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<13>
    WIDEN store ir<%arrayidx242.13>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.14> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<14>
    WIDEN store ir<%arrayidx238.14>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.14> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<14>
    WIDEN store ir<%arrayidx242.14>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.15> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<15>
    WIDEN store ir<%arrayidx238.15>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.15> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<15>
    WIDEN store ir<%arrayidx242.15>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.16> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<16>
    WIDEN store ir<%arrayidx238.16>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.16> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<16>
    WIDEN store ir<%arrayidx242.16>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.17> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<17>
    WIDEN store ir<%arrayidx238.17>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.17> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<17>
    WIDEN store ir<%arrayidx242.17>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.18> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<18>
    WIDEN store ir<%arrayidx238.18>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.18> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<18>
    WIDEN store ir<%arrayidx242.18>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.19> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<19>
    WIDEN store ir<%arrayidx238.19>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.19> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<19>
    WIDEN store ir<%arrayidx242.19>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.20> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<20>
    WIDEN store ir<%arrayidx238.20>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.20> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<20>
    WIDEN store ir<%arrayidx242.20>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.21> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<21>
    WIDEN store ir<%arrayidx238.21>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.21> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<21>
    WIDEN store ir<%arrayidx242.21>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.22> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<22>
    WIDEN store ir<%arrayidx238.22>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.22> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<22>
    WIDEN store ir<%arrayidx242.22>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.23> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<23>
    WIDEN store ir<%arrayidx238.23>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.23> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<23>
    WIDEN store ir<%arrayidx242.23>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx238.24> = getelementptr inbounds ir<@reg_class_superclasses>, ir<0>, ir<%indvars.iv1004>, ir<24>
    WIDEN store ir<%arrayidx238.24>, ir<25>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx242.24> = getelementptr inbounds ir<@reg_class_subclasses>, ir<0>, ir<%indvars.iv1004>, ir<24>
    WIDEN store ir<%arrayidx242.24>, ir<25>
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body252.preheader>, scalar.ph

ir-bb<for.body252.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 16
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %19 = load i32, ptr %arrayidx240, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %add241, ptr %arrayidx240, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: record_address_regs' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%17> = load ir<@target_flags>
    CLONE ir<%and228> = and ir<%17>, ir<33554432>
    CLONE ir<%tobool229.not> = icmp eq ir<%and228>, ir<0>
    CLONE ir<%cond230> = select ir<%tobool229.not>, ir<4>, ir<5>
    CLONE ir<%arrayidx236> = getelementptr inbounds ir<@may_move_in_cost>, ir<0>, ir<%cond230>, ir<%indvars.iv>, ir<%idxprom235>
    CLONE ir<%18> = load ir<%arrayidx236>
    CLONE ir<%mul237> = mul nsw ir<%18>, ir<%scale.tr.lcssa444>
    CLONE ir<%div238> = sdiv ir<%mul237>, ir<2>
    CLONE ir<%arrayidx240> = getelementptr inbounds ir<%arrayidx222>, ir<0>, ir<%indvars.iv>
    CLONE ir<%19> = load ir<%arrayidx240>
    CLONE ir<%add241> = add nsw ir<%div238>, ir<%19>
    CLONE store ir<%add241>, ir<%arrayidx240>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<cleanup.loopexit439>, scalar.ph

ir-bb<cleanup.loopexit439>:
No successors

scalar.ph:
No successors
}

========== Loop: record_address_regs' from regclass.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%17> = load ir<@target_flags>
    WIDEN ir<%and228> = and ir<%17>, ir<33554432>
    WIDEN ir<%tobool229.not> = icmp eq ir<%and228>, ir<0>
    WIDEN-SELECT ir<%cond230> = select ir<%tobool229.not>, ir<4>, ir<5>
    WIDEN-GEP Inv[Inv][Var][Var][Inv] ir<%arrayidx236> = getelementptr inbounds ir<@may_move_in_cost>, ir<0>, ir<%cond230>, ir<%indvars.iv>, ir<%idxprom235>
    WIDEN ir<%18> = load ir<%arrayidx236>
    WIDEN ir<%mul237> = mul nsw ir<%18>, ir<%scale.tr.lcssa444>
    WIDEN ir<%div238> = sdiv ir<%mul237>, ir<2>
    CLONE ir<%arrayidx240> = getelementptr inbounds ir<%arrayidx222>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx240>
    WIDEN ir<%19> = load vp<%3>
    WIDEN ir<%add241> = add nsw ir<%div238>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx240>
    WIDEN store vp<%4>, ir<%add241>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit439>, scalar.ph

ir-bb<cleanup.loopexit439>:
No successors

scalar.ph:
No successors
}

========== Loop: record_address_regs' from regclass.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%17> = load ir<@target_flags>
    WIDEN ir<%and228> = and ir<%17>, ir<33554432>
    WIDEN ir<%tobool229.not> = icmp eq ir<%and228>, ir<0>
    WIDEN-SELECT ir<%cond230> = select ir<%tobool229.not>, ir<4>, ir<5>
    WIDEN-GEP Inv[Inv][Var][Var][Inv] ir<%arrayidx236> = getelementptr inbounds ir<@may_move_in_cost>, ir<0>, ir<%cond230>, ir<%indvars.iv>, ir<%idxprom235>
    WIDEN ir<%18> = load ir<%arrayidx236>
    WIDEN ir<%mul237> = mul nsw ir<%18>, ir<%scale.tr.lcssa444>
    WIDEN ir<%div238> = sdiv ir<%mul237>, ir<2>
    CLONE ir<%arrayidx240> = getelementptr inbounds ir<%arrayidx222>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx240>
    WIDEN ir<%19> = load vp<%3>
    WIDEN ir<%add241> = add nsw ir<%div238>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx240>
    WIDEN store vp<%4>, ir<%add241>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<25>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup.loopexit439>, scalar.ph

ir-bb<cleanup.loopexit439>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %17 = load i32, ptr @target_flags, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %18 = load i32, ptr %arrayidx236, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa444 of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %19 = load i32, ptr %arrayidx240, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %add241, ptr %arrayidx240, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit439, label %for.body of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %17 = load i32, ptr @target_flags, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %18 = load i32, ptr %arrayidx236, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa444 of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %19 = load i32, ptr %arrayidx240, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %add241, ptr %arrayidx240, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit439, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 168, RTCostB: 300
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 168, RTCostB: 300
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %17 = load i32, ptr @target_flags, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %18 = load i32, ptr %arrayidx236, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa444 of type:mul
LV: Found an estimated cost of 1 for VF 4 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %19 = load i32, ptr %arrayidx240, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %add241, ptr %arrayidx240, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit439, label %for.body of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 114, RTCostB: 300
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 114, RTCostB: 168
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %17 = load i32, ptr @target_flags, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 2 for VF 8 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 8 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %18 = load i32, ptr %arrayidx236, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa444 of type:mul
LV: Found an estimated cost of 2 for VF 8 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %19 = load i32, ptr %arrayidx240, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %add241, ptr %arrayidx240, align 4 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit439, label %for.body of type:br
LV: Vector loop of width 8 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 108, RTCostB: 300
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 108, RTCostB: 114
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %17 = load i32, ptr @target_flags, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %18 = load i32, ptr %arrayidx236, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa444 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %19 = load i32, ptr %arrayidx240, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %add241, ptr %arrayidx240, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit439, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 6
A is scalable.	B is not scalable.	
RTCostA: 168, RTCostB: 300
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 168, RTCostB: 108

-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %17 = load i32, ptr @target_flags, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %18 = load i32, ptr %arrayidx236, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa444 of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %19 = load i32, ptr %arrayidx240, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %add241, ptr %arrayidx240, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit439, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 114, RTCostB: 300
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 114, RTCostB: 108

-----------------Function that is being costed:'record_address_regs' from regclass.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %sw.bb219 ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %17 = load i32, ptr @target_flags, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and228 = and i32 %17, 33554432 of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %tobool229.not = icmp eq i32 %and228, 0 of type:icmp
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %cond230 = select i1 %tobool229.not, i64 4, i64 5 of type:select
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx236 = getelementptr inbounds [59 x [25 x [25 x i32]]], ptr @may_move_in_cost, i64 0, i64 %cond230, i64 %indvars.iv, i64 %idxprom235 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %18 = load i32, ptr %arrayidx236, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %mul237 = mul nsw i32 %18, %scale.tr.lcssa444 of type:mul
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %div238 = sdiv i32 %mul237, 2 of type:sdiv
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx240 = getelementptr inbounds [25 x i32], ptr %arrayidx222, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %19 = load i32, ptr %arrayidx240, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %add241 = add nsw i32 %div238, %19 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %add241, ptr %arrayidx240, align 4 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 25 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %cleanup.loopexit439, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 108, RTCostB: 300
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 108, RTCostB: 108
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 4.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: record_address_regs at line: regclass.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<25> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%19> = load ir<@target_flags>
    WIDEN ir<%and228> = and ir<%19>, ir<33554432>
    WIDEN ir<%tobool229.not> = icmp eq ir<%and228>, ir<0>
    WIDEN-SELECT ir<%cond230> = select ir<%tobool229.not>, ir<4>, ir<5>
    WIDEN-GEP Inv[Inv][Var][Var][Inv] ir<%arrayidx236> = getelementptr inbounds ir<@may_move_in_cost>, ir<0>, ir<%cond230>, ir<%indvars.iv>, ir<%idxprom235>
    WIDEN ir<%20> = load ir<%arrayidx236>
    WIDEN ir<%mul237> = mul nsw ir<%20>, ir<%scale.tr.lcssa444>
    WIDEN ir<%div238> = sdiv ir<%mul237>, ir<2>
    CLONE ir<%arrayidx240> = getelementptr inbounds ir<%arrayidx222>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx240>
    WIDEN ir<%21> = load vp<%4>
    WIDEN ir<%add241> = add nsw ir<%div238>, ir<%21>
    vp<%5> = vector-pointer ir<%arrayidx240>
    WIDEN store vp<%5>, ir<%add241>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<25>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit439>, scalar.ph

ir-bb<cleanup.loopexit439>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 43
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o regmove.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         regmove.c
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4 -> Cost: 5 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4 -> Cost: 5 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4 -> Cost: 5 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4 -> Cost: 5 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4 -> Cost: 11 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4 -> Cost: 11 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4 -> Cost: 3 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4 -> Cost: 3 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4 -> Cost: 3 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4 -> Cost: 3 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx, align 4 -> Cost: 4 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 -1, ptr %arrayidx3, align 4 -> Cost: 4 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: find_matches' from regmove.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %1, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%commutative>, ir<0>, ir<%indvars.iv.next>
    CLONE store ir<-1>, ir<%arrayidx>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%matchp>, ir<0>, ir<%indvars.iv.next>
    CLONE store ir<-1>, ir<%arrayidx3>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond4.preheader>, scalar.ph

ir-bb<for.cond4.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_matches' from regmove.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %1, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%commutative>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<-1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%matchp>, ir<0>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx3>
    WIDEN store vp<%5>, ir<-1>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond4.preheader>, scalar.ph

ir-bb<for.cond4.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_matches' from regmove.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %1, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%commutative>, ir<0>, ir<%indvars.iv.next>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%4>, ir<-1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%matchp>, ir<0>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx3>
    WIDEN store vp<%5>, ir<-1>
    CLONE ir<%cmp> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond4.preheader>, scalar.ph

ir-bb<for.cond4.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -1, ptr %arrayidx3, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i32 -1, ptr %arrayidx3, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 1528, RTCostB: 1020
A is not scalable.	B is not scalable.	
RTCostA: 1528, RTCostB: 1020

-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 4 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 4 For instruction:   store i32 -1, ptr %arrayidx3, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 768, RTCostB: 1020
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 768, RTCostB: 1020
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 8 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 11 for VF 8 For instruction:   store i32 -1, ptr %arrayidx3, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 772, RTCostB: 1020
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 772, RTCostB: 768

-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   store i32 -1, ptr %arrayidx3, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 1020, RTCostB: 1020
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1020, RTCostB: 768

-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   store i32 -1, ptr %arrayidx3, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 516, RTCostB: 1020
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 516, RTCostB: 768
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_matches' from regmove.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %1, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [30 x i32], ptr %commutative, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   store i32 -1, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3 = getelementptr inbounds [30 x i32], ptr %matchp, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   store i32 -1, ptr %arrayidx3, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp, label %for.body, label %for.cond4.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 338, RTCostB: 1020
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 338, RTCostB: 516
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: find_matches at line: regmove.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%1> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%commutative>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx>
    WIDEN store vp<%6>, ir<-1>
    CLONE ir<%arrayidx3> = getelementptr inbounds ir<%matchp>, ir<0>, ir<%indvars.iv.next>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx3>
    WIDEN store vp<%7>, ir<-1>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond4.preheader>, scalar.ph

ir-bb<for.cond4.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 17
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o regrename.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         regrename.c
========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv575 = phi %19, %indvars.iv.next576, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.1552> = phi ir<%or.lcssa>, ir<%or126>
    WIDEN-INDUCTION %i.1551 = phi %div538, %dec120, ir<-1>
    CLONE ir<%dec120> = add nsw ir<%i.1551>, ir<-1>
    CLONE ir<%add123> = add ir<%indvars.iv575>, ir<5>
    CLONE ir<%sh_prom124> = and ir<%add123>, ir<4294967295>
    CLONE ir<%shl125> = shl nuw ir<1>, ir<%sh_prom124>
    CLONE ir<%or126> = or ir<%shl125>, ir<%unavailable.1552>
    CLONE ir<%tobool121.not> = icmp eq ir<%dec120>, ir<0>
    CLONE ir<%indvars.iv.next576> = add nsw ir<%indvars.iv575>, ir<-1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.1552>, ir<%or126>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end128.loopexit>, scalar.ph

ir-bb<if.end128.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or126.lcssa = vp<%6>
}

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv575 = phi %19, %indvars.iv.next576, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.1552> = phi ir<%or.lcssa>, ir<%or126>
    WIDEN-INDUCTION %i.1551 = phi %div538, %dec120, ir<-1>
    CLONE ir<%dec120> = add nsw ir<%i.1551>, ir<-1>
    WIDEN ir<%add123> = add ir<%indvars.iv575>, ir<5>
    WIDEN ir<%sh_prom124> = and ir<%add123>, ir<4294967295>
    WIDEN ir<%shl125> = shl nuw ir<1>, ir<%sh_prom124>
    WIDEN ir<%or126> = or ir<%shl125>, ir<%unavailable.1552>
    CLONE ir<%tobool121.not> = icmp eq ir<%dec120>, ir<0>
    WIDEN ir<%indvars.iv.next576> = add nsw ir<%indvars.iv575>, ir<-1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.1552>, ir<%or126>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end128.loopexit>, scalar.ph

ir-bb<if.end128.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or126.lcssa = vp<%6>
}

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv575 = phi %19, %indvars.iv.next576, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.1552> = phi ir<%or.lcssa>, ir<%or126>
    WIDEN-INDUCTION %i.1551 = phi %div538, %dec120, ir<-1>
    CLONE ir<%dec120> = add nsw ir<%i.1551>, ir<-1>
    WIDEN ir<%add123> = add ir<%indvars.iv575>, ir<5>
    WIDEN ir<%sh_prom124> = and ir<%add123>, ir<4294967295>
    WIDEN ir<%shl125> = shl nuw ir<1>, ir<%sh_prom124>
    WIDEN ir<%or126> = or ir<%shl125>, ir<%unavailable.1552>
    CLONE ir<%tobool121.not> = icmp eq ir<%dec120>, ir<0>
    WIDEN ir<%indvars.iv.next576> = add nsw ir<%indvars.iv575>, ir<-1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.1552>, ir<%or126>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end128.loopexit>, scalar.ph

ir-bb<if.end128.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or126.lcssa = vp<%6>
}


-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv575 = phi i64 [ %19, %for.body122.preheader ], [ %indvars.iv.next576, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %unavailable.1552 = phi i64 [ %or.lcssa, %for.body122.preheader ], [ %or126, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.1551 = phi i32 [ %div538, %for.body122.preheader ], [ %dec120, %for.body122 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec120 = add nsw i32 %i.1551, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add123 = add i64 %indvars.iv575, 5 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom124 = and i64 %add123, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl125 = shl nuw i64 1, %sh_prom124 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or126 = or i64 %shl125, %unavailable.1552 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool121.not = icmp eq i32 %dec120, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next576 = add nsw i64 %indvars.iv575, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool121.not, label %if.end128.loopexit, label %for.body122 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv575 = phi i64 [ %19, %for.body122.preheader ], [ %indvars.iv.next576, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %unavailable.1552 = phi i64 [ %or.lcssa, %for.body122.preheader ], [ %or126, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.1551 = phi i32 [ %div538, %for.body122.preheader ], [ %dec120, %for.body122 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec120 = add nsw i32 %i.1551, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add123 = add i64 %indvars.iv575, 5 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom124 = and i64 %add123, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl125 = shl nuw i64 1, %sh_prom124 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or126 = or i64 %shl125, %unavailable.1552 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool121.not = icmp eq i32 %dec120, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next576 = add nsw i64 %indvars.iv575, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool121.not, label %if.end128.loopexit, label %for.body122 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3758096384, RTCostB: 7516192761
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096384, RTCostB: 7516192761
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv575 = phi i64 [ %19, %for.body122.preheader ], [ %indvars.iv.next576, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %unavailable.1552 = phi i64 [ %or.lcssa, %for.body122.preheader ], [ %or126, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.1551 = phi i32 [ %div538, %for.body122.preheader ], [ %dec120, %for.body122 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec120 = add nsw i32 %i.1551, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add123 = add i64 %indvars.iv575, 5 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom124 = and i64 %add123, 4294967295 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl125 = shl nuw i64 1, %sh_prom124 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or126 = or i64 %shl125, %unavailable.1552 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool121.not = icmp eq i32 %dec120, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next576 = add nsw i64 %indvars.iv575, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool121.not, label %if.end128.loopexit, label %for.body122 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 7516192761
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 3758096384
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv575 = phi i64 [ %19, %for.body122.preheader ], [ %indvars.iv.next576, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %unavailable.1552 = phi i64 [ %or.lcssa, %for.body122.preheader ], [ %or126, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.1551 = phi i32 [ %div538, %for.body122.preheader ], [ %dec120, %for.body122 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec120 = add nsw i32 %i.1551, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add123 = add i64 %indvars.iv575, 5 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom124 = and i64 %add123, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl125 = shl nuw i64 1, %sh_prom124 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or126 = or i64 %shl125, %unavailable.1552 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool121.not = icmp eq i32 %dec120, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next576 = add nsw i64 %indvars.iv575, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool121.not, label %if.end128.loopexit, label %for.body122 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 3758096384, RTCostB: 7516192761
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096384, RTCostB: 3221225481

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv575 = phi i64 [ %19, %for.body122.preheader ], [ %indvars.iv.next576, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %unavailable.1552 = phi i64 [ %or.lcssa, %for.body122.preheader ], [ %or126, %for.body122 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.1551 = phi i32 [ %div538, %for.body122.preheader ], [ %dec120, %for.body122 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec120 = add nsw i32 %i.1551, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %add123 = add i64 %indvars.iv575, 5 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom124 = and i64 %add123, 4294967295 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl125 = shl nuw i64 1, %sh_prom124 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or126 = or i64 %shl125, %unavailable.1552 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool121.not = icmp eq i32 %dec120, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next576 = add nsw i64 %indvars.iv575, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool121.not, label %if.end128.loopexit, label %for.body122 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 7516192761
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 3221225481
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: regrename_optimize at line: regrename.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body122.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv575 = phi %19, %indvars.iv.next576, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.1552> = phi ir<%or.lcssa>, ir<%or126>
    WIDEN ir<%add123> = add ir<%indvars.iv575>, ir<5>
    WIDEN ir<%sh_prom124> = and ir<%add123>, ir<4294967295>
    WIDEN ir<%shl125> = shl nuw ir<1>, ir<%sh_prom124>
    WIDEN ir<%or126> = or ir<%shl125>, ir<%unavailable.1552>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.1552>, ir<%or126>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end128.loopexit>, scalar.ph

ir-bb<if.end128.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or126.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %18, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.0549> = phi ir<0>, ir<%or>
    WIDEN-INDUCTION %i.0548 = phi %div538, %dec, ir<-1>
    CLONE ir<%dec> = add nsw ir<%i.0548>, ir<-1>
    CLONE ir<%add79> = add ir<%indvars.iv>, ir<19>
    CLONE ir<%sh_prom> = and ir<%add79>, ir<4294967295>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%shl>, ir<%unavailable.0549>
    CLONE ir<%tobool77.not> = icmp eq ir<%dec>, ir<0>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.0549>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond119.preheader>, scalar.ph

ir-bb<for.cond119.preheader>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %18, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.0549> = phi ir<0>, ir<%or>
    WIDEN-INDUCTION %i.0548 = phi %div538, %dec, ir<-1>
    CLONE ir<%dec> = add nsw ir<%i.0548>, ir<-1>
    WIDEN ir<%add79> = add ir<%indvars.iv>, ir<19>
    WIDEN ir<%sh_prom> = and ir<%add79>, ir<4294967295>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%unavailable.0549>
    CLONE ir<%tobool77.not> = icmp eq ir<%dec>, ir<0>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.0549>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond119.preheader>, scalar.ph

ir-bb<for.cond119.preheader>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: regrename_optimize' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %18, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.0549> = phi ir<0>, ir<%or>
    WIDEN-INDUCTION %i.0548 = phi %div538, %dec, ir<-1>
    CLONE ir<%dec> = add nsw ir<%i.0548>, ir<-1>
    WIDEN ir<%add79> = add ir<%indvars.iv>, ir<19>
    WIDEN ir<%sh_prom> = and ir<%add79>, ir<4294967295>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%unavailable.0549>
    CLONE ir<%tobool77.not> = icmp eq ir<%dec>, ir<0>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.0549>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond119.preheader>, scalar.ph

ir-bb<for.cond119.preheader>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %18, %for.body78.preheader ], [ %indvars.iv.next, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %unavailable.0549 = phi i64 [ 0, %for.body78.preheader ], [ %or, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0548 = phi i32 [ %div538, %for.body78.preheader ], [ %dec, %for.body78 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %i.0548, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add79 = add i64 %indvars.iv, 19 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom = and i64 %add79, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %shl, %unavailable.0549 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool77.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool77.not, label %for.cond119.preheader, label %for.body78 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %18, %for.body78.preheader ], [ %indvars.iv.next, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %unavailable.0549 = phi i64 [ 0, %for.body78.preheader ], [ %or, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0548 = phi i32 [ %div538, %for.body78.preheader ], [ %dec, %for.body78 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %i.0548, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add79 = add i64 %indvars.iv, 19 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom = and i64 %add79, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %shl, %unavailable.0549 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool77.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool77.not, label %for.cond119.preheader, label %for.body78 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3758096384, RTCostB: 7516192761
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096384, RTCostB: 7516192761
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %18, %for.body78.preheader ], [ %indvars.iv.next, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %unavailable.0549 = phi i64 [ 0, %for.body78.preheader ], [ %or, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0548 = phi i32 [ %div538, %for.body78.preheader ], [ %dec, %for.body78 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %i.0548, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add79 = add i64 %indvars.iv, 19 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom = and i64 %add79, 4294967295 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %shl, %unavailable.0549 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool77.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool77.not, label %for.cond119.preheader, label %for.body78 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 7516192761
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 3758096384
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %18, %for.body78.preheader ], [ %indvars.iv.next, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %unavailable.0549 = phi i64 [ 0, %for.body78.preheader ], [ %or, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0548 = phi i32 [ %div538, %for.body78.preheader ], [ %dec, %for.body78 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %i.0548, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add79 = add i64 %indvars.iv, 19 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom = and i64 %add79, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %shl, %unavailable.0549 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool77.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool77.not, label %for.cond119.preheader, label %for.body78 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 3758096384, RTCostB: 7516192761
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096384, RTCostB: 3221225481

-----------------Function that is being costed:'regrename_optimize' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %18, %for.body78.preheader ], [ %indvars.iv.next, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %unavailable.0549 = phi i64 [ 0, %for.body78.preheader ], [ %or, %for.body78 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0548 = phi i32 [ %div538, %for.body78.preheader ], [ %dec, %for.body78 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %i.0548, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %add79 = add i64 %indvars.iv, 19 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom = and i64 %add79, 4294967295 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %shl, %unavailable.0549 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool77.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool77.not, label %for.cond119.preheader, label %for.body78 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 7516192761
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225481, RTCostB: 3221225481
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: regrename_optimize at line: regrename.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body78.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div538 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %18, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%unavailable.0549> = phi ir<0>, ir<%or>
    WIDEN ir<%add79> = add ir<%indvars.iv>, ir<19>
    WIDEN ir<%sh_prom> = and ir<%add79>, ir<4294967295>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%unavailable.0549>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%unavailable.0549>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond119.preheader>, scalar.ph

ir-bb<for.cond119.preheader>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 5
Loops Epilogues Vectorized: 0
================================================
========== Loop: clear_dead_regs' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond65 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and73106> = phi ir<%pset.promoted>, ir<%and73>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%11> = trunc ir<%indvars.iv.next>
    CLONE ir<%add72> = add ir<%.fr109>, ir<%11>
    CLONE ir<%sh_prom> = zext nneg ir<%add72>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and73> = and ir<%and73106>, ir<%not>
    CLONE ir<%cmp70> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and73106>, ir<%and73>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.for.inc.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.for.inc.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and73.lcssa = vp<%6>
}

========== Loop: clear_dead_regs' from regrename.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond65 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and73106> = phi ir<%pset.promoted>, ir<%and73>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%11> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add72> = add ir<%.fr109>, ir<%11>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add72> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and73> = and ir<%and73106>, ir<%not>
    CLONE ir<%cmp70> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and73106>, ir<%and73>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.for.inc.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.for.inc.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and73.lcssa = vp<%6>
}

========== Loop: clear_dead_regs' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond65 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and73106> = phi ir<%pset.promoted>, ir<%and73>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%11> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add72> = add ir<%.fr109>, ir<%11>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add72> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and73> = and ir<%and73106>, ir<%not>
    CLONE ir<%cmp70> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and73106>, ir<%and73>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.for.inc.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.for.inc.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and73.lcssa = vp<%6>
}


-----------------Function that is being costed:'clear_dead_regs' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and73106 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and73, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add72 = add i32 %.fr109, %11 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom = zext nneg i32 %add72 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and73 = and i64 %and73106, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp70 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp70, label %while.body, label %while.cond.for.inc.loopexit_crit_edge of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'clear_dead_regs' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and73106 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and73, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add72 = add i32 %.fr109, %11 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom = zext nneg i32 %add72 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and73 = and i64 %and73106, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp70 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp70, label %while.body, label %while.cond.for.inc.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 7516192761
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 7516192761
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'clear_dead_regs' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and73106 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and73, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add72 = add i32 %.fr109, %11 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom = zext nneg i32 %add72 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and73 = and i64 %and73106, %not of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp70 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp70, label %while.body, label %while.cond.for.inc.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3489660936, RTCostB: 7516192761
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3489660936, RTCostB: 4294967295
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'clear_dead_regs' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and73106 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and73, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add72 = add i32 %.fr109, %11 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %add72 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and73 = and i64 %and73106, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp70 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp70, label %while.body, label %while.cond.for.inc.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 7516192761
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 3489660936

-----------------Function that is being costed:'clear_dead_regs' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and73106 = phi i64 [ %pset.promoted, %while.body.lr.ph ], [ %and73, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add72 = add i32 %.fr109, %11 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %add72 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and73 = and i64 %and73106, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp70 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp70, label %while.body, label %while.cond.for.inc.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 3489660936, RTCostB: 7516192761
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3489660936, RTCostB: 3489660936
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: clear_dead_regs at line: regrename.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond65 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%and73106> = phi ir<%pset.promoted>, ir<%and73>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%11> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add72> = add ir<%.fr109>, ir<%11>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add72> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and73> = and ir<%and73106>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and73106>, ir<%and73>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.for.inc.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.for.inc.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and73.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 36
Loops Epilogues Vectorized: 0
================================================
========== Loop: note_sets' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond55 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or92> = phi ir<%data.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%11> = trunc ir<%indvars.iv.next>
    CLONE ir<%add63> = add ir<%.fr93>, ir<%11>
    CLONE ir<%sh_prom> = zext nneg ir<%add63>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%or92>, ir<%shl>
    CLONE ir<%cmp61> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or92>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: note_sets' from regrename.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond55 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or92> = phi ir<%data.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%11> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add63> = add ir<%.fr93>, ir<%11>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add63> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or92>, ir<%shl>
    CLONE ir<%cmp61> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or92>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: note_sets' from regrename.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond55 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or92> = phi ir<%data.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%11> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add63> = add ir<%.fr93>, ir<%11>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add63> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or92>, ir<%shl>
    CLONE ir<%cmp61> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or92>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'note_sets' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or92 = phi i64 [ %data.promoted, %while.body.lr.ph ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add63 = add i32 %.fr93, %11 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom = zext nneg i32 %add63 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or92, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp61 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp61, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'note_sets' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or92 = phi i64 [ %data.promoted, %while.body.lr.ph ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add63 = add i32 %.fr93, %11 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom = zext nneg i32 %add63 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or92, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp61 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp61, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3758096383, RTCostB: 6442450938
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096383, RTCostB: 6442450938
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'note_sets' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or92 = phi i64 [ %data.promoted, %while.body.lr.ph ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add63 = add i32 %.fr93, %11 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom = zext nneg i32 %add63 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or92, %shl of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp61 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp61, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2952790023, RTCostB: 6442450938
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2952790023, RTCostB: 3758096383
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'note_sets' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or92 = phi i64 [ %data.promoted, %while.body.lr.ph ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add63 = add i32 %.fr93, %11 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %add63 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or92, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp61 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp61, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 3758096383, RTCostB: 6442450938
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096383, RTCostB: 2952790023

-----------------Function that is being costed:'note_sets' from regrename.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %10, %while.body.lr.ph ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or92 = phi i64 [ %data.promoted, %while.body.lr.ph ], [ %or, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %11 = trunc nuw nsw i64 %indvars.iv.next to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add63 = add i32 %.fr93, %11 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %add63 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or92, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp61 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp61, label %while.body, label %while.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2952790023, RTCostB: 6442450938
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2952790023, RTCostB: 2952790023
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: note_sets at line: regrename.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond55 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %10, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or92> = phi ir<%data.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN-CAST ir<%11> = trunc  ir<%indvars.iv.next> to i32
    WIDEN ir<%add63> = add ir<%.fr93>, ir<%11>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add63> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%or92>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or92>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 37
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o reload.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         reload.c
========== Loop: transfer_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>, ir<2>
    CLONE ir<%1> = load ir<%what>
    CLONE ir<%cmp1> = icmp eq ir<%1>, ir<%from>
  Successor(s): if.then

  if.then:
    CLONE store ir<%to>, ir<%what>, ir<%cmp1>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp1>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: transfer_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>, ir<2>
    WIDEN ir<%1> = load ir<%what>
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%from>
  Successor(s): if.then

  if.then:
    WIDEN store ir<%what>, ir<%to>, ir<%cmp1>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp1>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: transfer_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>, ir<2>
    WIDEN ir<%1> = load ir<%what>
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%from>
  Successor(s): if.then

  if.then:
    WIDEN store ir<%what>, ir<%to>, ir<%cmp1>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%4> = not ir<%cmp1>
    EMIT vp<%5> = or vp<%4>, ir<%cmp1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %to, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %1 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %to, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192765, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192765, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %1 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %to, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 7516192765
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %1 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %to, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 6174015493, RTCostB: 8589934588
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6174015493, RTCostB: 6442450944
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %1 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %to, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7516192765, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192765, RTCostB: 6174015493

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %1 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %to, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 6174015493

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %1 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp1 = icmp eq i32 %1, %from of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp1, label %if.then, label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 %to, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'transfer_replacements' from reload.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 6174015493, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6174015493, RTCostB: 6174015493
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: transfer_replacements at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>, ir<2>
    WIDEN ir<%1> = load ir<%what>
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%from>
    WIDEN store ir<%what>, ir<%to>, ir<%cmp1>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 26
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %218 = load i32, ptr %arrayidx2270, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %220 = load i8, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2280, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx2275, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then2259>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6138 = phi 0, %indvars.iv.next6139, ir<1>
    WIDEN-REDUCTION-PHI ir<%losers.115984> = phi ir<%inc2260>, ir<%losers.12>
    CLONE ir<%arrayidx2270> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6138>
    CLONE ir<%218> = load ir<%arrayidx2270>
    CLONE ir<%219> = zext ir<%218>
    CLONE ir<%cmp2271> = icmp eq ir<%indvars.iv6142>, ir<%219>
  Successor(s): land.lhs.true2273

  land.lhs.true2273:
    CLONE ir<%arrayidx2275> = getelementptr inbounds ir<%this_alternative_match_win>, ir<0>, ir<%indvars.iv6138>
    CLONE ir<%220> = load ir<%arrayidx2275>, ir<%cmp2271>
    CLONE ir<%tobool2277.not> = icmp eq ir<%220>, ir<0>
  Successor(s): if.then2278

  if.then2278:
    EMIT vp<%4> = not ir<%tobool2277.not>
    EMIT vp<%5> = logical-and ir<%cmp2271>, vp<%4>
    CLONE ir<%arrayidx2280> = getelementptr inbounds ir<%this_alternative_win>, ir<0>, ir<%indvars.iv6138>
    CLONE store ir<0>, ir<%arrayidx2280>, vp<%5>
    CLONE store ir<0>, ir<%arrayidx2275>, vp<%5>
    CLONE ir<%inc2283> = add ir<%losers.115984>, ir<1>
  Successor(s): for.inc2285

  for.inc2285:
    EMIT vp<%6> = not ir<%cmp2271>
    EMIT vp<%7> = logical-and ir<%cmp2271>, ir<%tobool2277.not>
    EMIT vp<%8> = or vp<%6>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%5>
    BLEND ir<%losers.12> = ir<%inc2283> ir<%losers.115984>/vp<%7> ir<%losers.115984>/vp<%6>
    CLONE ir<%indvars.iv.next6139> = add nuw nsw ir<%indvars.iv6138>, ir<1>
    CLONE ir<%exitcond6141.not> = icmp eq ir<%indvars.iv.next6139>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = compute-reduction-result ir<%losers.115984>, ir<%losers.12>
  EMIT vp<%13> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%13>
Successor(s): ir-bb<if.end2288.loopexit>, scalar.ph

ir-bb<if.end2288.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %losers.12.lcssa = vp<%12>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then2259>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    WIDEN-INDUCTION %indvars.iv6138 = phi 0, %indvars.iv.next6139, ir<1>
    WIDEN-REDUCTION-PHI ir<%losers.115984> = phi ir<%inc2260>, ir<%losers.12>
    CLONE ir<%arrayidx2270> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6138>
    vp<%4> = vector-pointer ir<%arrayidx2270>
    WIDEN ir<%218> = load vp<%4>
    WIDEN-CAST ir<%219> = zext  ir<%218> to i64
    WIDEN ir<%cmp2271> = icmp eq ir<%indvars.iv6142>, ir<%219>
  Successor(s): land.lhs.true2273

  land.lhs.true2273:
    CLONE ir<%arrayidx2275> = getelementptr ir<%this_alternative_match_win>, ir<0>, ir<%indvars.iv6138>
    vp<%5> = vector-pointer ir<%arrayidx2275>
    WIDEN ir<%220> = load vp<%5>, ir<%cmp2271>
    WIDEN ir<%tobool2277.not> = icmp eq ir<%220>, ir<0>
  Successor(s): if.then2278

  if.then2278:
    EMIT vp<%6> = not ir<%tobool2277.not>
    EMIT vp<%7> = logical-and ir<%cmp2271>, vp<%6>
    CLONE ir<%arrayidx2280> = getelementptr ir<%this_alternative_win>, ir<0>, ir<%indvars.iv6138>
    vp<%8> = vector-pointer ir<%arrayidx2280>
    WIDEN store vp<%8>, ir<0>, vp<%7>
    vp<%9> = vector-pointer ir<%arrayidx2275>
    WIDEN store vp<%9>, ir<0>, vp<%7>
    WIDEN ir<%inc2283> = add ir<%losers.115984>, ir<1>
  Successor(s): for.inc2285

  for.inc2285:
    EMIT vp<%10> = not ir<%cmp2271>
    EMIT vp<%11> = logical-and ir<%cmp2271>, ir<%tobool2277.not>
    EMIT vp<%12> = or vp<%10>, vp<%11>
    EMIT vp<%13> = or vp<%12>, vp<%7>
    BLEND ir<%losers.12> = ir<%inc2283> ir<%losers.115984>/vp<%11> ir<%losers.115984>/vp<%10>
    CLONE ir<%indvars.iv.next6139> = add nuw nsw ir<%indvars.iv6138>, ir<1>
    CLONE ir<%exitcond6141.not> = icmp eq ir<%indvars.iv.next6139>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = compute-reduction-result ir<%losers.115984>, ir<%losers.12>
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<if.end2288.loopexit>, scalar.ph

ir-bb<if.end2288.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %losers.12.lcssa = vp<%16>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then2259>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    WIDEN-INDUCTION %indvars.iv6138 = phi 0, %indvars.iv.next6139, ir<1>
    WIDEN-REDUCTION-PHI ir<%losers.115984> = phi ir<%inc2260>, ir<%losers.12>
    CLONE ir<%arrayidx2270> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6138>
    vp<%4> = vector-pointer ir<%arrayidx2270>
    WIDEN ir<%218> = load vp<%4>
    WIDEN-CAST ir<%219> = zext  ir<%218> to i64
    WIDEN ir<%cmp2271> = icmp eq ir<%indvars.iv6142>, ir<%219>
  Successor(s): land.lhs.true2273

  land.lhs.true2273:
    CLONE ir<%arrayidx2275> = getelementptr ir<%this_alternative_match_win>, ir<0>, ir<%indvars.iv6138>
    vp<%5> = vector-pointer ir<%arrayidx2275>
    WIDEN ir<%220> = load vp<%5>, ir<%cmp2271>
    WIDEN ir<%tobool2277.not> = icmp eq ir<%220>, ir<0>
  Successor(s): if.then2278

  if.then2278:
    EMIT vp<%6> = not ir<%tobool2277.not>
    EMIT vp<%7> = logical-and ir<%cmp2271>, vp<%6>
    CLONE ir<%arrayidx2280> = getelementptr ir<%this_alternative_win>, ir<0>, ir<%indvars.iv6138>
    vp<%8> = vector-pointer ir<%arrayidx2280>
    WIDEN store vp<%8>, ir<0>, vp<%7>
    vp<%9> = vector-pointer ir<%arrayidx2275>
    WIDEN store vp<%9>, ir<0>, vp<%7>
    WIDEN ir<%inc2283> = add ir<%losers.115984>, ir<1>
  Successor(s): for.inc2285

  for.inc2285:
    EMIT vp<%10> = not ir<%cmp2271>
    EMIT vp<%11> = logical-and ir<%cmp2271>, ir<%tobool2277.not>
    EMIT vp<%12> = or vp<%10>, vp<%11>
    EMIT vp<%13> = or vp<%12>, vp<%7>
    BLEND ir<%losers.12> = ir<%inc2283> ir<%losers.115984>/vp<%11> ir<%losers.115984>/vp<%10>
    CLONE ir<%indvars.iv.next6139> = add nuw nsw ir<%indvars.iv6138>, ir<1>
    CLONE ir<%exitcond6141.not> = icmp eq ir<%indvars.iv.next6139>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = compute-reduction-result ir<%losers.115984>, ir<%losers.12>
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<if.end2288.loopexit>, scalar.ph

ir-bb<if.end2288.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %losers.12.lcssa = vp<%16>
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6138 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6139, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6142, %219 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 0, ptr %arrayidx2280, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 0, ptr %arrayidx2275, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6139 = add nuw nsw i64 %indvars.iv6138, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6141.not = icmp eq i64 %indvars.iv.next6139, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6141.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6138 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6139, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6142, %219 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 0, ptr %arrayidx2280, align 1 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 0, ptr %arrayidx2275, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6139 = add nuw nsw i64 %indvars.iv6138, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6141.not = icmp eq i64 %indvars.iv.next6139, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6141.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6138 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6139, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6142, %219 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 0, ptr %arrayidx2280, align 1 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 0, ptr %arrayidx2275, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6139 = add nuw nsw i64 %indvars.iv6138, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6141.not = icmp eq i64 %indvars.iv.next6139, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6141.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 14
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 14
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6138 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6139, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4 of type:load
LV: Found an estimated cost of 4 for VF 8 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 4 for VF 8 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6142, %219 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 0, ptr %arrayidx2280, align 1 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 0, ptr %arrayidx2275, align 1 of type:store
LV: Found an estimated cost of 2 for VF 8 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next6139 = add nuw nsw i64 %indvars.iv6138, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6141.not = icmp eq i64 %indvars.iv.next6139, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6141.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 22
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 22
B VF: 4, EstimatedWidthB: 4, CostB: 14
CostA * EstimatedWidthB: 88, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6138 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6139, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6142, %219 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 0, ptr %arrayidx2280, align 1 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 0, ptr %arrayidx2275, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6139 = add nuw nsw i64 %indvars.iv6138, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6141.not = icmp eq i64 %indvars.iv.next6139, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6141.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width vscale x 1 costs: 6
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 12
B VF: 8, EstimatedWidthB: 8, CostB: 22
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 44

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6138 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6139, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6142, %219 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 0, ptr %arrayidx2280, align 1 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 0, ptr %arrayidx2275, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6139 = add nuw nsw i64 %indvars.iv6138, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6141.not = icmp eq i64 %indvars.iv.next6139, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6141.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 14
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 14
B VF: 8, EstimatedWidthB: 8, CostB: 22
CostA * EstimatedWidthB: 112, CostB * EstimatedWidthA: 88

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6138 = phi i64 [ 0, %if.then2259 ], [ %indvars.iv.next6139, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %losers.115984 = phi i32 [ %inc2260, %if.then2259 ], [ %losers.12, %for.inc2285 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2270 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %218 = load i32, ptr %arrayidx2270, align 4 of type:load
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %219 = zext i32 %218 to i64 of type:zext
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %cmp2271 = icmp eq i64 %indvars.iv6142, %219 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2271, label %land.lhs.true2273, label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2275 = getelementptr inbounds [30 x i8], ptr %this_alternative_match_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %220 = load i8, ptr %arrayidx2275, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool2277.not = icmp eq i8 %220, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool2277.not, label %for.inc2285, label %if.then2278 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2280 = getelementptr inbounds [30 x i8], ptr %this_alternative_win, i64 0, i64 %indvars.iv6138 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 0, ptr %arrayidx2280, align 1 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 0, ptr %arrayidx2275, align 1 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %inc2283 = add nsw i32 %losers.115984, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc2285 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %losers.12 = phi i32 [ %inc2283, %if.then2278 ], [ %losers.115984, %land.lhs.true2273 ], [ %losers.115984, %for.body2268 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next6139 = add nuw nsw i64 %indvars.iv6138, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6141.not = icmp eq i64 %indvars.iv.next6139, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6141.not, label %if.end2288.loopexit, label %for.body2268 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 22
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 22
B VF: 8, EstimatedWidthB: 8, CostB: 22
CostA * EstimatedWidthB: 176, CostB * EstimatedWidthA: 176
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.then2259>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    WIDEN-REDUCTION-PHI ir<%losers.115984> = phi ir<%inc2260>, ir<%losers.12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx2270> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx2270>
    WIDEN ir<%218> = load vp<%5>
    WIDEN-CAST ir<%219> = zext  ir<%218> to i64
    WIDEN ir<%cmp2271> = icmp eq ir<%indvars.iv6142>, ir<%219>
    CLONE ir<%arrayidx2275> = getelementptr ir<%this_alternative_match_win>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2275>
    WIDEN ir<%220> = load vp<%6>, ir<%cmp2271>
    WIDEN ir<%tobool2277.not> = icmp eq ir<%220>, ir<0>
    EMIT vp<%7> = not ir<%tobool2277.not>
    EMIT vp<%8> = logical-and ir<%cmp2271>, vp<%7>
    CLONE ir<%arrayidx2280> = getelementptr ir<%this_alternative_win>, ir<0>, vp<%4>
    vp<%9> = vector-pointer ir<%arrayidx2280>
    WIDEN store vp<%9>, ir<0>, vp<%8>
    vp<%10> = vector-pointer ir<%arrayidx2275>
    WIDEN store vp<%10>, ir<0>, vp<%8>
    WIDEN ir<%inc2283> = add ir<%losers.115984>, ir<1>
    EMIT vp<%11> = not ir<%cmp2271>
    EMIT vp<%12> = logical-and ir<%cmp2271>, ir<%tobool2277.not>
    BLEND ir<%losers.12> = ir<%inc2283> ir<%losers.115984>/vp<%12> ir<%losers.115984>/vp<%11>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = compute-reduction-result ir<%losers.115984>, ir<%losers.12>
  EMIT vp<%16> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%16>
Successor(s): ir-bb<if.end2288.loopexit>, scalar.ph

ir-bb<if.end2288.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %losers.12.lcssa = vp<%15>
}
================ Final VPlan ================

@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %121 = load i32, ptr %arrayidx921, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body919.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body584>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv6126 = phi %indvars.iv.next6127, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%badop.25918> = phi ir<false>, vp<%4>
    CLONE ir<%arrayidx921> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6126>
    CLONE ir<%121> = load ir<%arrayidx921>
    CLONE ir<%cmp924> = icmp eq ir<%121>, ir<%conv793>
    EMIT vp<%4> = or ir<%badop.25918>, ir<%cmp924>
    CLONE ir<%spec.select5547> = select ir<%cmp924>, ir<1>, ir<%badop.25918>
    CLONE ir<%indvars.iv.next6127> = add nuw nsw ir<%indvars.iv6126>, ir<1>
    CLONE ir<%exitcond6129.not> = icmp eq ir<%indvars.iv.next6127>, ir<%indvars.iv6130>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%badop.25918>, vp<%4>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<sw.epilog.loopexit6375>, scalar.ph

ir-bb<sw.epilog.loopexit6375>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select5547.lcssa = vp<%7>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body919.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body584>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6126 = phi %indvars.iv.next6127, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%badop.25918> = phi ir<false>, vp<%5>
    CLONE ir<%arrayidx921> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6126>
    vp<%4> = vector-pointer ir<%arrayidx921>
    WIDEN ir<%121> = load vp<%4>
    WIDEN ir<%cmp924> = icmp eq ir<%121>, ir<%conv793>
    EMIT vp<%5> = or ir<%badop.25918>, ir<%cmp924>
    WIDEN-SELECT ir<%spec.select5547> = select ir<%cmp924>, ir<1>, ir<%badop.25918>
    CLONE ir<%indvars.iv.next6127> = add nuw nsw ir<%indvars.iv6126>, ir<1>
    CLONE ir<%exitcond6129.not> = icmp eq ir<%indvars.iv.next6127>, ir<%indvars.iv6130>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%badop.25918>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit6375>, scalar.ph

ir-bb<sw.epilog.loopexit6375>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select5547.lcssa = vp<%8>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body919.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body584>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6126 = phi %indvars.iv.next6127, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%badop.25918> = phi ir<false>, vp<%5>
    CLONE ir<%arrayidx921> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, ir<%indvars.iv6126>
    vp<%4> = vector-pointer ir<%arrayidx921>
    WIDEN ir<%121> = load vp<%4>
    WIDEN ir<%cmp924> = icmp eq ir<%121>, ir<%conv793>
    EMIT vp<%5> = or ir<%badop.25918>, ir<%cmp924>
    WIDEN-SELECT ir<%spec.select5547> = select ir<%cmp924>, ir<1>, ir<%badop.25918>
    CLONE ir<%indvars.iv.next6127> = add nuw nsw ir<%indvars.iv6126>, ir<1>
    CLONE ir<%exitcond6129.not> = icmp eq ir<%indvars.iv.next6127>, ir<%indvars.iv6130>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%badop.25918>, vp<%5>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<sw.epilog.loopexit6375>, scalar.ph

ir-bb<sw.epilog.loopexit6375>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select5547.lcssa = vp<%8>
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %121 = load i32, ptr %arrayidx921, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6129.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6130 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6129.not, label %sw.epilog.loopexit6375, label %for.body919 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %121 = load i32, ptr %arrayidx921, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6129.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6130 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6129.not, label %sw.epilog.loopexit6375, label %for.body919 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %121 = load i32, ptr %arrayidx921, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6129.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6130 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6129.not, label %sw.epilog.loopexit6375, label %for.body919 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %121 = load i32, ptr %arrayidx921, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6129.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6130 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6129.not, label %sw.epilog.loopexit6375, label %for.body919 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %121 = load i32, ptr %arrayidx921, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6129.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6130 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6129.not, label %sw.epilog.loopexit6375, label %for.body919 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %121 = load i32, ptr %arrayidx921, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6129.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6130 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6129.not, label %sw.epilog.loopexit6375, label %for.body919 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6126 = phi i64 [ %indvars.iv.next6127, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %badop.25918 = phi i32 [ %spec.select5547, %for.body919 ], [ 0, %for.body919.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx921 = getelementptr inbounds [30 x i32], ptr %this_alternative_matches, i64 0, i64 %indvars.iv6126 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %121 = load i32, ptr %arrayidx921, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp924 = icmp eq i32 %121, %conv793 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %spec.select5547 = select i1 %cmp924, i32 1, i32 %badop.25918 of type:select
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next6127 = add nuw nsw i64 %indvars.iv6126, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6129.not = icmp eq i64 %indvars.iv.next6127, %indvars.iv6130 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6129.not, label %sw.epilog.loopexit6375, label %for.body919 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body919.preheader>:
  EMIT vp<%2> = EXPAND SCEV {0,+,1}<nuw><nsw><%for.body584>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%badop.25918> = phi ir<false>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx921> = getelementptr inbounds ir<%this_alternative_matches>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx921>
    WIDEN ir<%121> = load vp<%5>
    WIDEN ir<%cmp924> = icmp eq ir<%121>, ir<%conv793>
    EMIT vp<%6> = or ir<%badop.25918>, ir<%cmp924>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%badop.25918>, vp<%6>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<sw.epilog.loopexit6375>, scalar.ph

ir-bb<sw.epilog.loopexit6375>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select5547.lcssa = vp<%9>
}
================ Final VPlan ================

@@ Instruction =>  %284 = load i8, ptr %arrayidx2528, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %285 = load i32, ptr %arrayidx2532, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %284 = load i8, ptr %arrayidx2528, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %285 = load i32, ptr %arrayidx2532, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %284 = load i8, ptr %arrayidx2528, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %285 = load i32, ptr %arrayidx2532, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  %284 = load i8, ptr %arrayidx2528, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %285 = load i32, ptr %arrayidx2532, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %284 = load i8, ptr %arrayidx2528, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %285 = load i32, ptr %arrayidx2532, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %284 = load i8, ptr %arrayidx2528, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %285 = load i32, ptr %arrayidx2532, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2526.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6157 = phi 0, %indvars.iv.next6158, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv6157 = phi 0, %indvars.iv.next6158\l" +
    "  ir<%286>, ir<1>
    CLONE ir<%arrayidx2528> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6157>
    CLONE ir<%284> = load ir<%arrayidx2528>
    CLONE ir<%tobool2529.not> = icmp eq ir<%284>, ir<0>
  Successor(s): land.lhs.true2530

  land.lhs.true2530:
    CLONE ir<%arrayidx2532> = getelementptr inbounds ir<%goal_alternative_matches>, ir<0>, ir<%indvars.iv6157>
    CLONE ir<%285> = load ir<%arrayidx2532>, ir<%tobool2529.not>
    CLONE ir<%cmp2533> = icmp sgt ir<%285>, ir<-1>
  Successor(s): if.then2535

  if.then2535:
    EMIT vp<%4> = logical-and ir<%tobool2529.not>, ir<%cmp2533>
    CLONE ir<%idxprom2538> = zext nneg ir<%285>
    CLONE ir<%arrayidx2539> = getelementptr inbounds ir<%goal_alternative_matched>, ir<0>, ir<%idxprom2538>
    CLONE store ir<%286>, ir<%arrayidx2539>, vp<%4>
  Successor(s): for.inc2541

  for.inc2541:
    EMIT vp<%5> = not ir<%tobool2529.not>
    EMIT vp<%6> = not ir<%cmp2533>
    EMIT vp<%7> = logical-and ir<%tobool2529.not>, vp<%6>
    EMIT vp<%8> = or vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%8>, vp<%4>
    CLONE ir<%indvars.iv.next6158> = add nuw nsw ir<%indvars.iv6157>, ir<1>
    CLONE ir<%exitcond6160.not> = icmp eq ir<%indvars.iv.next6158>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.body2547.preheader>, scalar.ph

ir-bb<for.body2547.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2526.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv6157 = phi 0, %indvars.iv.next6158, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv6157 = phi 0, %indvars.iv.next6158\l" +
    "  ir<%286>, ir<1>
    CLONE ir<%arrayidx2528> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6157>
    vp<%4> = vector-pointer ir<%arrayidx2528>
    WIDEN ir<%284> = load vp<%4>
    WIDEN ir<%tobool2529.not> = icmp eq ir<%284>, ir<0>
  Successor(s): land.lhs.true2530

  land.lhs.true2530:
    CLONE ir<%arrayidx2532> = getelementptr ir<%goal_alternative_matches>, ir<0>, ir<%indvars.iv6157>
    vp<%5> = vector-pointer ir<%arrayidx2532>
    WIDEN ir<%285> = load vp<%5>, ir<%tobool2529.not>
    WIDEN ir<%cmp2533> = icmp sgt ir<%285>, ir<-1>
  Successor(s): if.then2535

  if.then2535:
    EMIT vp<%6> = logical-and ir<%tobool2529.not>, ir<%cmp2533>
    WIDEN-CAST ir<%idxprom2538> = zext  nneg ir<%285> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2539> = getelementptr inbounds ir<%goal_alternative_matched>, ir<0>, ir<%idxprom2538>
    WIDEN store ir<%arrayidx2539>, ir<%286>, vp<%6>
  Successor(s): for.inc2541

  for.inc2541:
    EMIT vp<%7> = not ir<%tobool2529.not>
    EMIT vp<%8> = not ir<%cmp2533>
    EMIT vp<%9> = logical-and ir<%tobool2529.not>, vp<%8>
    EMIT vp<%10> = or vp<%7>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    WIDEN ir<%indvars.iv.next6158> = add nuw nsw ir<%indvars.iv6157>, ir<1>
    CLONE ir<%exitcond6160.not> = icmp eq ir<%indvars.iv.next6158>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.body2547.preheader>, scalar.ph

ir-bb<for.body2547.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2526.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv6157 = phi 0, %indvars.iv.next6158, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv6157 = phi 0, %indvars.iv.next6158\l" +
    "  ir<%286>, ir<1>
    CLONE ir<%arrayidx2528> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6157>
    vp<%4> = vector-pointer ir<%arrayidx2528>
    WIDEN ir<%284> = load vp<%4>
    WIDEN ir<%tobool2529.not> = icmp eq ir<%284>, ir<0>
  Successor(s): land.lhs.true2530

  land.lhs.true2530:
    CLONE ir<%arrayidx2532> = getelementptr ir<%goal_alternative_matches>, ir<0>, ir<%indvars.iv6157>
    vp<%5> = vector-pointer ir<%arrayidx2532>
    WIDEN ir<%285> = load vp<%5>, ir<%tobool2529.not>
    WIDEN ir<%cmp2533> = icmp sgt ir<%285>, ir<-1>
  Successor(s): if.then2535

  if.then2535:
    EMIT vp<%6> = logical-and ir<%tobool2529.not>, ir<%cmp2533>
    WIDEN-CAST ir<%idxprom2538> = zext  nneg ir<%285> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2539> = getelementptr inbounds ir<%goal_alternative_matched>, ir<0>, ir<%idxprom2538>
    WIDEN store ir<%arrayidx2539>, ir<%286>, vp<%6>
  Successor(s): for.inc2541

  for.inc2541:
    EMIT vp<%7> = not ir<%tobool2529.not>
    EMIT vp<%8> = not ir<%cmp2533>
    EMIT vp<%9> = logical-and ir<%tobool2529.not>, vp<%8>
    EMIT vp<%10> = or vp<%7>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%6>
    WIDEN ir<%indvars.iv.next6158> = add nuw nsw ir<%indvars.iv6157>, ir<1>
    CLONE ir<%exitcond6160.not> = icmp eq ir<%indvars.iv.next6158>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.body2547.preheader>, scalar.ph

ir-bb<for.body2547.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6157 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6158, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %284 = load i8, ptr %arrayidx2528, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool2529.not = icmp eq i8 %284, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %285 = load i32, ptr %arrayidx2532, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2533 = icmp sgt i32 %285, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom2538 = zext nneg i32 %285 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %286 = trunc nuw nsw i64 %indvars.iv6157 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %286, ptr %arrayidx2539, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6158 = add nuw nsw i64 %indvars.iv6157, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6160.not = icmp eq i64 %indvars.iv.next6158, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6160.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6157 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6158, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %284 = load i8, ptr %arrayidx2528, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool2529.not = icmp eq i8 %284, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %285 = load i32, ptr %arrayidx2532, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2533 = icmp sgt i32 %285, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom2538 = zext nneg i32 %285 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %286 = trunc nuw nsw i64 %indvars.iv6157 to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %286, ptr %arrayidx2539, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6158 = add nuw nsw i64 %indvars.iv6157, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6160.not = icmp eq i64 %indvars.iv.next6158, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6160.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6157 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6158, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %284 = load i8, ptr %arrayidx2528, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool2529.not = icmp eq i8 %284, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %285 = load i32, ptr %arrayidx2532, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2533 = icmp sgt i32 %285, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom2538 = zext nneg i32 %285 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %286 = trunc nuw nsw i64 %indvars.iv6157 to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %286, ptr %arrayidx2539, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next6158 = add nuw nsw i64 %indvars.iv6157, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6160.not = icmp eq i64 %indvars.iv.next6158, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6160.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 13
B VF: 2, EstimatedWidthB: 2, CostB: 9
CostA * EstimatedWidthB: 26, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6157 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6158, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %284 = load i8, ptr %arrayidx2528, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool2529.not = icmp eq i8 %284, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %285 = load i32, ptr %arrayidx2532, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp2533 = icmp sgt i32 %285, -1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom2538 = zext nneg i32 %285 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %286 = trunc nuw nsw i64 %indvars.iv6157 to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %286, ptr %arrayidx2539, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next6158 = add nuw nsw i64 %indvars.iv6157, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6160.not = icmp eq i64 %indvars.iv.next6158, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6160.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 23
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 23, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 23
B VF: 4, EstimatedWidthB: 4, CostB: 13
CostA * EstimatedWidthB: 92, CostB * EstimatedWidthA: 104
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6157 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6158, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %284 = load i8, ptr %arrayidx2528, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool2529.not = icmp eq i8 %284, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %285 = load i32, ptr %arrayidx2532, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2533 = icmp sgt i32 %285, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom2538 = zext nneg i32 %285 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %286 = trunc nuw nsw i64 %indvars.iv6157 to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %286, ptr %arrayidx2539, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6158 = add nuw nsw i64 %indvars.iv6157, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6160.not = icmp eq i64 %indvars.iv.next6158, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6160.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 9
B VF: 8, EstimatedWidthB: 8, CostB: 23
CostA * EstimatedWidthB: 72, CostB * EstimatedWidthA: 46

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6157 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6158, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %284 = load i8, ptr %arrayidx2528, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool2529.not = icmp eq i8 %284, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %285 = load i32, ptr %arrayidx2532, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2533 = icmp sgt i32 %285, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %idxprom2538 = zext nneg i32 %285 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %286 = trunc nuw nsw i64 %indvars.iv6157 to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %286, ptr %arrayidx2539, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next6158 = add nuw nsw i64 %indvars.iv6157, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6160.not = icmp eq i64 %indvars.iv.next6158, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6160.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 13
B VF: 8, EstimatedWidthB: 8, CostB: 23
CostA * EstimatedWidthB: 104, CostB * EstimatedWidthA: 92

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6157 = phi i64 [ 0, %for.body2526.preheader ], [ %indvars.iv.next6158, %for.inc2541 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2528 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %284 = load i8, ptr %arrayidx2528, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool2529.not = icmp eq i8 %284, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool2529.not, label %land.lhs.true2530, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2532 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matches, i64 0, i64 %indvars.iv6157 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %285 = load i32, ptr %arrayidx2532, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp2533 = icmp sgt i32 %285, -1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2533, label %if.then2535, label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %idxprom2538 = zext nneg i32 %285 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2539 = getelementptr inbounds [30 x i32], ptr %goal_alternative_matched, i64 0, i64 %idxprom2538 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %286 = trunc nuw nsw i64 %indvars.iv6157 to i32 of type:trunc
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 %286, ptr %arrayidx2539, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc2541 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next6158 = add nuw nsw i64 %indvars.iv6157, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6160.not = icmp eq i64 %indvars.iv.next6158, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6160.not, label %for.body2547.preheader, label %for.body2526 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 23
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 23, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 23
B VF: 8, EstimatedWidthB: 8, CostB: 23
CostA * EstimatedWidthB: 184, CostB * EstimatedWidthA: 184
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2526.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv6157 = phi 0, %indvars.iv.next6158\l" +
    "  ir<%286>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx2528> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx2528>
    WIDEN ir<%284> = load vp<%5>
    WIDEN ir<%tobool2529.not> = icmp eq ir<%284>, ir<0>
    CLONE ir<%arrayidx2532> = getelementptr ir<%goal_alternative_matches>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2532>
    WIDEN ir<%285> = load vp<%6>, ir<%tobool2529.not>
    WIDEN ir<%cmp2533> = icmp sgt ir<%285>, ir<-1>
    EMIT vp<%7> = logical-and ir<%tobool2529.not>, ir<%cmp2533>
    WIDEN-CAST ir<%idxprom2538> = zext  nneg ir<%285> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2539> = getelementptr inbounds ir<%goal_alternative_matched>, ir<0>, ir<%idxprom2538>
    WIDEN store ir<%arrayidx2539>, ir<%286>, vp<%7>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.body2547.preheader>, scalar.ph

ir-bb<for.body2547.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %310 = load i8, ptr %arrayidx2549, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %311 = load i8, ptr %arrayidx2552, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %or25545529, ptr %arrayidx2552, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2547.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv6161 = phi %indvars.iv.next6162, 0, ir<1>
    CLONE ir<%arrayidx2549> = getelementptr inbounds ir<%goal_alternative_match_win>, ir<0>, ir<%indvars.iv6161>
    CLONE ir<%310> = load ir<%arrayidx2549>
    CLONE ir<%arrayidx2552> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6161>
    CLONE ir<%311> = load ir<%arrayidx2552>
    CLONE ir<%or25545529> = or ir<%311>, ir<%310>
    CLONE store ir<%or25545529>, ir<%arrayidx2552>
    CLONE ir<%indvars.iv.next6162> = add nuw nsw ir<%indvars.iv6161>, ir<1>
    CLONE ir<%exitcond6164.not> = icmp eq ir<%indvars.iv.next6162>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end2558>, scalar.ph

ir-bb<for.end2558>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2547.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv6161 = phi %indvars.iv.next6162, 0, ir<1>
    CLONE ir<%arrayidx2549> = getelementptr inbounds ir<%goal_alternative_match_win>, ir<0>, ir<%indvars.iv6161>
    vp<%4> = vector-pointer ir<%arrayidx2549>
    WIDEN ir<%310> = load vp<%4>
    CLONE ir<%arrayidx2552> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6161>
    vp<%5> = vector-pointer ir<%arrayidx2552>
    WIDEN ir<%311> = load vp<%5>
    WIDEN ir<%or25545529> = or ir<%311>, ir<%310>
    vp<%6> = vector-pointer ir<%arrayidx2552>
    WIDEN store vp<%6>, ir<%or25545529>
    CLONE ir<%indvars.iv.next6162> = add nuw nsw ir<%indvars.iv6161>, ir<1>
    CLONE ir<%exitcond6164.not> = icmp eq ir<%indvars.iv.next6162>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end2558>, scalar.ph

ir-bb<for.end2558>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2547.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv6161 = phi %indvars.iv.next6162, 0, ir<1>
    CLONE ir<%arrayidx2549> = getelementptr inbounds ir<%goal_alternative_match_win>, ir<0>, ir<%indvars.iv6161>
    vp<%4> = vector-pointer ir<%arrayidx2549>
    WIDEN ir<%310> = load vp<%4>
    CLONE ir<%arrayidx2552> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, ir<%indvars.iv6161>
    vp<%5> = vector-pointer ir<%arrayidx2552>
    WIDEN ir<%311> = load vp<%5>
    WIDEN ir<%or25545529> = or ir<%311>, ir<%310>
    vp<%6> = vector-pointer ir<%arrayidx2552>
    WIDEN store vp<%6>, ir<%or25545529>
    CLONE ir<%indvars.iv.next6162> = add nuw nsw ir<%indvars.iv6161>, ir<1>
    CLONE ir<%exitcond6164.not> = icmp eq ir<%indvars.iv.next6162>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end2558>, scalar.ph

ir-bb<for.end2558>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 192
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 160

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv6161 = phi i64 [ %indvars.iv.next6162, %for.body2547 ], [ 0, %for.body2547.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2549 = getelementptr inbounds [30 x i8], ptr %goal_alternative_match_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %310 = load i8, ptr %arrayidx2549, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2552 = getelementptr inbounds [30 x i8], ptr %goal_alternative_win, i64 0, i64 %indvars.iv6161 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %311 = load i8, ptr %arrayidx2552, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %or25545529 = or i8 %311, %310 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %or25545529, ptr %arrayidx2552, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next6162 = add nuw nsw i64 %indvars.iv6161, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond6164.not = icmp eq i64 %indvars.iv.next6162, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond6164.not, label %for.end2558, label %for.body2547 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 320, CostB * EstimatedWidthA: 320
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2547.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx2549> = getelementptr inbounds ir<%goal_alternative_match_win>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx2549>
    WIDEN ir<%310> = load vp<%5>
    CLONE ir<%arrayidx2552> = getelementptr inbounds ir<%goal_alternative_win>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2552>
    WIDEN ir<%311> = load vp<%6>
    WIDEN ir<%or25545529> = or ir<%311>, ir<%310>
    vp<%7> = vector-pointer ir<%arrayidx2552>
    WIDEN store vp<%7>, ir<%or25545529>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end2558>, scalar.ph

ir-bb<for.end2558>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2594.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %334 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6165 = phi 0, %indvars.iv.next6166, ir<1>
    CLONE ir<%opnum> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv6165>, ir<12>
    CLONE ir<%335> = load ir<%opnum>
    CLONE ir<%cmp2597> = icmp eq ir<%335>, ir<%commutative.6.lcssa6289.lcssa6401>
  Successor(s): if.else2604

  if.else2604:
    EMIT vp<%4> = not ir<%cmp2597>
    CLONE ir<%cmp2609> = icmp eq ir<%335>, ir<%add2563>
  Successor(s): for.inc2617.sink.split

  for.inc2617.sink.split:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp2609>
    EMIT vp<%6> = or vp<%5>, ir<%cmp2597>
    BLEND ir<%add2563.sink> = ir<%add2563> ir<%commutative.6.lcssa6289.lcssa6401>/vp<%5>
    CLONE store ir<%add2563.sink>, ir<%opnum>, vp<%6>
  Successor(s): for.inc2617

  for.inc2617:
    EMIT vp<%7> = not ir<%cmp2609>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    CLONE ir<%indvars.iv.next6166> = add nuw nsw ir<%indvars.iv6165>, ir<1>
    CLONE ir<%exitcond6168.not> = icmp eq ir<%indvars.iv.next6166>, ir<%wide.trip.count6167>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.body2624.preheader.loopexit>, scalar.ph

ir-bb<for.body2624.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2594.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %334 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6165 = phi 0, %indvars.iv.next6166, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%opnum> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv6165>, ir<12>
    WIDEN ir<%335> = load ir<%opnum>
    WIDEN ir<%cmp2597> = icmp eq ir<%335>, ir<%commutative.6.lcssa6289.lcssa6401>
  Successor(s): if.else2604

  if.else2604:
    EMIT vp<%4> = not ir<%cmp2597>
    WIDEN ir<%cmp2609> = icmp eq ir<%335>, ir<%add2563>
  Successor(s): for.inc2617.sink.split

  for.inc2617.sink.split:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp2609>
    EMIT vp<%6> = or vp<%5>, ir<%cmp2597>
    BLEND ir<%add2563.sink> = ir<%add2563> ir<%commutative.6.lcssa6289.lcssa6401>/vp<%5>
    WIDEN store ir<%opnum>, ir<%add2563.sink>, vp<%6>
  Successor(s): for.inc2617

  for.inc2617:
    EMIT vp<%7> = not ir<%cmp2609>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    WIDEN ir<%indvars.iv.next6166> = add nuw nsw ir<%indvars.iv6165>, ir<1>
    CLONE ir<%exitcond6168.not> = icmp eq ir<%indvars.iv.next6166>, ir<%wide.trip.count6167>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.body2624.preheader.loopexit>, scalar.ph

ir-bb<for.body2624.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2594.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %334 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv6165 = phi 0, %indvars.iv.next6166, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%opnum> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv6165>, ir<12>
    WIDEN ir<%335> = load ir<%opnum>
    WIDEN ir<%cmp2597> = icmp eq ir<%335>, ir<%commutative.6.lcssa6289.lcssa6401>
  Successor(s): if.else2604

  if.else2604:
    EMIT vp<%4> = not ir<%cmp2597>
    WIDEN ir<%cmp2609> = icmp eq ir<%335>, ir<%add2563>
  Successor(s): for.inc2617.sink.split

  for.inc2617.sink.split:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp2609>
    EMIT vp<%6> = or vp<%5>, ir<%cmp2597>
    BLEND ir<%add2563.sink> = ir<%add2563> ir<%commutative.6.lcssa6289.lcssa6401>/vp<%5>
    WIDEN store ir<%opnum>, ir<%add2563.sink>, vp<%6>
  Successor(s): for.inc2617

  for.inc2617:
    EMIT vp<%7> = not ir<%cmp2609>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    WIDEN ir<%indvars.iv.next6166> = add nuw nsw ir<%indvars.iv6165>, ir<1>
    CLONE ir<%exitcond6168.not> = icmp eq ir<%indvars.iv.next6166>, ir<%wide.trip.count6167>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.body2624.preheader.loopexit>, scalar.ph

ir-bb<for.body2624.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6165 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6166, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6165, i32 12 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %335 = load i32, ptr %opnum, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2597 = icmp eq i32 %335, %commutative.6.lcssa6289.lcssa6401 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2609 = icmp eq i32 %335, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6289.lcssa6401, %if.else2604 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6166 = add nuw nsw i64 %indvars.iv6165, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6168.not = icmp eq i64 %indvars.iv.next6166, %wide.trip.count6167 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6168.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6165 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6166, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6165, i32 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %335 = load i32, ptr %opnum, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2597 = icmp eq i32 %335, %commutative.6.lcssa6289.lcssa6401 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2609 = icmp eq i32 %335, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6289.lcssa6401, %if.else2604 ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6166 = add nuw nsw i64 %indvars.iv6165, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6168.not = icmp eq i64 %indvars.iv.next6166, %wide.trip.count6167 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6168.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676411, RTCostB: 8589934588
A is not scalable.	B is not scalable.	
RTCostA: 9663676411, RTCostB: 8589934588

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6165 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6166, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6165, i32 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %335 = load i32, ptr %opnum, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2597 = icmp eq i32 %335, %commutative.6.lcssa6289.lcssa6401 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2609 = icmp eq i32 %335, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6289.lcssa6401, %if.else2604 ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next6166 = add nuw nsw i64 %indvars.iv6165, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6168.not = icmp eq i64 %indvars.iv.next6166, %wide.trip.count6167 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6168.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192766, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192766, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6165 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6166, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6165, i32 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %335 = load i32, ptr %opnum, align 8 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp2597 = icmp eq i32 %335, %commutative.6.lcssa6289.lcssa6401 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp2609 = icmp eq i32 %335, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 8 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6289.lcssa6401, %if.else2604 ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next6166 = add nuw nsw i64 %indvars.iv6165, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6168.not = icmp eq i64 %indvars.iv.next6166, %wide.trip.count6167 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6168.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7247757313, RTCostB: 8589934588
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7247757313, RTCostB: 7516192766
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6165 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6166, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6165, i32 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %335 = load i32, ptr %opnum, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2597 = icmp eq i32 %335, %commutative.6.lcssa6289.lcssa6401 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2609 = icmp eq i32 %335, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6289.lcssa6401, %if.else2604 ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6166 = add nuw nsw i64 %indvars.iv6165, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6168.not = icmp eq i64 %indvars.iv.next6166, %wide.trip.count6167 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6168.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 9663676411, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: 9663676411, RTCostB: 7247757313

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6165 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6166, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6165, i32 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %335 = load i32, ptr %opnum, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2597 = icmp eq i32 %335, %commutative.6.lcssa6289.lcssa6401 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2609 = icmp eq i32 %335, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6289.lcssa6401, %if.else2604 ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next6166 = add nuw nsw i64 %indvars.iv6165, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6168.not = icmp eq i64 %indvars.iv.next6166, %wide.trip.count6167 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6168.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7516192766, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192766, RTCostB: 7247757313

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6165 = phi i64 [ 0, %for.body2594.preheader ], [ %indvars.iv.next6166, %for.inc2617 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %opnum = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv6165, i32 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %335 = load i32, ptr %opnum, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp2597 = icmp eq i32 %335, %commutative.6.lcssa6289.lcssa6401 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2597, label %for.inc2617.sink.split, label %if.else2604 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp2609 = icmp eq i32 %335, %add2563 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2609, label %for.inc2617.sink.split, label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %add2563.sink = phi i32 [ %add2563, %for.body2594 ], [ %commutative.6.lcssa6289.lcssa6401, %if.else2604 ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 %add2563.sink, ptr %opnum, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc2617 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next6166 = add nuw nsw i64 %indvars.iv6165, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6168.not = icmp eq i64 %indvars.iv.next6166, %wide.trip.count6167 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6168.not, label %for.body2624.preheader.loopexit, label %for.body2594 of type:br
LV: Vector loop of width vscale x 4 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7247757313, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7247757313, RTCostB: 7247757313
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body2594.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %334 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv6165 = phi 0, %indvars.iv.next6166, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%opnum> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv6165>, ir<12>
    WIDEN ir<%335> = load ir<%opnum>
    WIDEN ir<%cmp2597> = icmp eq ir<%335>, ir<%commutative.6.lcssa6289.lcssa6401>
    EMIT vp<%4> = not ir<%cmp2597>
    WIDEN ir<%cmp2609> = icmp eq ir<%335>, ir<%add2563>
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp2609>
    EMIT vp<%6> = or vp<%5>, ir<%cmp2597>
    BLEND ir<%add2563.sink> = ir<%add2563> ir<%commutative.6.lcssa6289.lcssa6401>/vp<%5>
    WIDEN store ir<%opnum>, ir<%add2563.sink>, vp<%6>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.body2624.preheader.loopexit>, scalar.ph

ir-bb<for.body2624.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %368 = load ptr, ptr %arrayidx3400.us, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %369 = load ptr, ptr %arrayidx3402.us, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %368 = load ptr, ptr %arrayidx3400.us, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %369 = load ptr, ptr %arrayidx3402.us, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %368 = load ptr, ptr %arrayidx3400.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %369 = load ptr, ptr %arrayidx3402.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %368 = load ptr, ptr %arrayidx3400.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %369 = load ptr, ptr %arrayidx3402.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3368.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv6193 = phi 0, %indvars.iv.next6194, ir<1>
    WIDEN-REDUCTION-PHI ir<%retval17.26036.us> = phi ir<0>, ir<%or3405.us>
    CLONE ir<%arrayidx3400.us> = getelementptr inbounds ir<%substed_operand>, ir<0>, ir<%indvars.iv6193>
    CLONE ir<%368> = load ir<%arrayidx3400.us>
    CLONE ir<%arrayidx3402.us> = getelementptr inbounds ir<getelementptr inbounds (i8, ptr @recog_data, i64 240)>, ir<0>, ir<%indvars.iv6193>
    CLONE ir<%369> = load ir<%arrayidx3402.us>
    CLONE ir<%370> = load ir<%369>
    CLONE ir<%cmp3403.us> = icmp ne ir<%368>, ir<%370>
    CLONE ir<%conv3404.us> = zext ir<%cmp3403.us>
    CLONE ir<%or3405.us> = or ir<%retval17.26036.us>, ir<%conv3404.us>
    CLONE ir<%indvars.iv.next6194> = add nuw nsw ir<%indvars.iv6193>, ir<1>
    CLONE ir<%exitcond6196.not> = icmp eq ir<%indvars.iv.next6194>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%retval17.26036.us>, ir<%or3405.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end3409.loopexit>, scalar.ph

ir-bb<for.end3409.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or3405.us.lcssa = vp<%6>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3368.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6193 = phi 0, %indvars.iv.next6194, ir<1>
    WIDEN-REDUCTION-PHI ir<%retval17.26036.us> = phi ir<0>, ir<%or3405.us>
    CLONE ir<%arrayidx3400.us> = getelementptr inbounds ir<%substed_operand>, ir<0>, ir<%indvars.iv6193>
    vp<%4> = vector-pointer ir<%arrayidx3400.us>
    WIDEN ir<%368> = load vp<%4>
    CLONE ir<%arrayidx3402.us> = getelementptr inbounds ir<getelementptr inbounds (i8, ptr @recog_data, i64 240)>, ir<0>, ir<%indvars.iv6193>
    vp<%5> = vector-pointer ir<%arrayidx3402.us>
    WIDEN ir<%369> = load vp<%5>
    WIDEN ir<%370> = load ir<%369>
    WIDEN ir<%cmp3403.us> = icmp ne ir<%368>, ir<%370>
    WIDEN-CAST ir<%conv3404.us> = zext  ir<%cmp3403.us> to i32
    WIDEN ir<%or3405.us> = or ir<%retval17.26036.us>, ir<%conv3404.us>
    CLONE ir<%indvars.iv.next6194> = add nuw nsw ir<%indvars.iv6193>, ir<1>
    CLONE ir<%exitcond6196.not> = icmp eq ir<%indvars.iv.next6194>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%retval17.26036.us>, ir<%or3405.us>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end3409.loopexit>, scalar.ph

ir-bb<for.end3409.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or3405.us.lcssa = vp<%8>
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3368.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6193 = phi 0, %indvars.iv.next6194, ir<1>
    WIDEN-REDUCTION-PHI ir<%retval17.26036.us> = phi ir<0>, ir<%or3405.us>
    CLONE ir<%arrayidx3400.us> = getelementptr inbounds ir<%substed_operand>, ir<0>, ir<%indvars.iv6193>
    vp<%4> = vector-pointer ir<%arrayidx3400.us>
    WIDEN ir<%368> = load vp<%4>
    CLONE ir<%arrayidx3402.us> = getelementptr inbounds ir<getelementptr inbounds (i8, ptr @recog_data, i64 240)>, ir<0>, ir<%indvars.iv6193>
    vp<%5> = vector-pointer ir<%arrayidx3402.us>
    WIDEN ir<%369> = load vp<%5>
    WIDEN ir<%370> = load ir<%369>
    WIDEN ir<%cmp3403.us> = icmp ne ir<%368>, ir<%370>
    WIDEN-CAST ir<%conv3404.us> = zext  ir<%cmp3403.us> to i32
    WIDEN ir<%or3405.us> = or ir<%retval17.26036.us>, ir<%conv3404.us>
    CLONE ir<%indvars.iv.next6194> = add nuw nsw ir<%indvars.iv6193>, ir<1>
    CLONE ir<%exitcond6196.not> = icmp eq ir<%indvars.iv.next6194>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%retval17.26036.us>, ir<%or3405.us>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end3409.loopexit>, scalar.ph

ir-bb<for.end3409.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or3405.us.lcssa = vp<%8>
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6193 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6194, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %retval17.26036.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %368 = load ptr, ptr %arrayidx3400.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %369 = load ptr, ptr %arrayidx3402.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %370 = load ptr, ptr %369, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp3403.us = icmp ne ptr %368, %370 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or3405.us = or i32 %retval17.26036.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6194 = add nuw nsw i64 %indvars.iv6193, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6196.not = icmp eq i64 %indvars.iv.next6194, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6196.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6193 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6194, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %retval17.26036.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %368 = load ptr, ptr %arrayidx3400.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %369 = load ptr, ptr %arrayidx3402.us, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %370 = load ptr, ptr %369, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp3403.us = icmp ne ptr %368, %370 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or3405.us = or i32 %retval17.26036.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6194 = add nuw nsw i64 %indvars.iv6193, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6196.not = icmp eq i64 %indvars.iv.next6194, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6196.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6193 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6194, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %retval17.26036.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %368 = load ptr, ptr %arrayidx3400.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %369 = load ptr, ptr %arrayidx3402.us, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %370 = load ptr, ptr %369, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp3403.us = icmp ne ptr %368, %370 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or3405.us = or i32 %retval17.26036.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6194 = add nuw nsw i64 %indvars.iv6193, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6196.not = icmp eq i64 %indvars.iv.next6194, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6196.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 15
B VF: 2, EstimatedWidthB: 2, CostB: 10
CostA * EstimatedWidthB: 30, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6193 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6194, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %retval17.26036.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %368 = load ptr, ptr %arrayidx3400.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %369 = load ptr, ptr %arrayidx3402.us, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %370 = load ptr, ptr %369, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp3403.us = icmp ne ptr %368, %370 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or3405.us = or i32 %retval17.26036.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6194 = add nuw nsw i64 %indvars.iv6193, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6196.not = icmp eq i64 %indvars.iv.next6194, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6196.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Vector loop of width vscale x 1 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 10
B VF: 4, EstimatedWidthB: 4, CostB: 15
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 30

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6193 = phi i64 [ 0, %for.body3368.us.preheader ], [ %indvars.iv.next6194, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %retval17.26036.us = phi i32 [ 0, %for.body3368.us.preheader ], [ %or3405.us, %for.body3368.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3400.us = getelementptr inbounds [30 x ptr], ptr %substed_operand, i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %368 = load ptr, ptr %arrayidx3400.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3402.us = getelementptr inbounds [30 x ptr], ptr getelementptr inbounds (i8, ptr @recog_data, i64 240), i64 0, i64 %indvars.iv6193 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %369 = load ptr, ptr %arrayidx3402.us, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %370 = load ptr, ptr %369, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp3403.us = icmp ne ptr %368, %370 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %conv3404.us = zext i1 %cmp3403.us to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or3405.us = or i32 %retval17.26036.us, %conv3404.us of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6194 = add nuw nsw i64 %indvars.iv6193, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6196.not = icmp eq i64 %indvars.iv.next6194, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6196.not, label %for.end3409.loopexit, label %for.body3368.us of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 15, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 15
B VF: 4, EstimatedWidthB: 4, CostB: 15
CostA * EstimatedWidthB: 60, CostB * EstimatedWidthA: 60
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3368.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-REDUCTION-PHI ir<%retval17.26036.us> = phi ir<0>, ir<%or3405.us>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx3400.us> = getelementptr inbounds ir<%substed_operand>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx3400.us>
    WIDEN ir<%368> = load vp<%5>
    CLONE ir<%arrayidx3402.us> = getelementptr inbounds ir<getelementptr inbounds (i8, ptr @recog_data, i64 240)>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx3402.us>
    WIDEN ir<%369> = load vp<%6>
    WIDEN ir<%370> = load ir<%369>
    WIDEN ir<%cmp3403.us> = icmp ne ir<%368>, ir<%370>
    WIDEN-CAST ir<%conv3404.us> = zext  ir<%cmp3403.us> to i32
    WIDEN ir<%or3405.us> = or ir<%retval17.26036.us>, ir<%conv3404.us>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%retval17.26036.us>, ir<%or3405.us>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end3409.loopexit>, scalar.ph

ir-bb<for.end3409.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or3405.us.lcssa = vp<%9>
}
================ Final VPlan ================

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3584.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %499 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6199 = phi 0, %indvars.iv.next6200, ir<1>
    CLONE ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv6199>, ir<2>
    CLONE ir<%500> = load ir<%what>
    CLONE ir<%501> = zext ir<%500>
    CLONE ir<%cmp3587> = icmp eq ir<%indvars.iv6205>, ir<%501>
  Successor(s): if.then3589

  if.then3589:
    CLONE store ir<%488>, ir<%what>, ir<%cmp3587>
  Successor(s): for.inc3594

  for.inc3594:
    EMIT vp<%4> = not ir<%cmp3587>
    EMIT vp<%5> = or vp<%4>, ir<%cmp3587>
    CLONE ir<%indvars.iv.next6200> = add nuw nsw ir<%indvars.iv6199>, ir<1>
    CLONE ir<%exitcond6202.not> = icmp eq ir<%indvars.iv.next6200>, ir<%wide.trip.count6201>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end3596.loopexit>, scalar.ph

ir-bb<for.end3596.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3584.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %499 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6199 = phi 0, %indvars.iv.next6200, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv6199>, ir<2>
    WIDEN ir<%500> = load ir<%what>
    WIDEN-CAST ir<%501> = zext  ir<%500> to i64
    WIDEN ir<%cmp3587> = icmp eq ir<%indvars.iv6205>, ir<%501>
  Successor(s): if.then3589

  if.then3589:
    WIDEN store ir<%what>, ir<%488>, ir<%cmp3587>
  Successor(s): for.inc3594

  for.inc3594:
    EMIT vp<%4> = not ir<%cmp3587>
    EMIT vp<%5> = or vp<%4>, ir<%cmp3587>
    WIDEN ir<%indvars.iv.next6200> = add nuw nsw ir<%indvars.iv6199>, ir<1>
    CLONE ir<%exitcond6202.not> = icmp eq ir<%indvars.iv.next6200>, ir<%wide.trip.count6201>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3584.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %499 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6199 = phi 0, %indvars.iv.next6200, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv6199>, ir<2>
    WIDEN ir<%500> = load ir<%what>
    WIDEN-CAST ir<%501> = zext  ir<%500> to i64
    WIDEN ir<%cmp3587> = icmp eq ir<%indvars.iv6205>, ir<%501>
  Successor(s): if.then3589

  if.then3589:
    WIDEN store ir<%what>, ir<%488>, ir<%cmp3587>
  Successor(s): for.inc3594

  for.inc3594:
    EMIT vp<%4> = not ir<%cmp3587>
    EMIT vp<%5> = or vp<%4>, ir<%cmp3587>
    WIDEN ir<%indvars.iv.next6200> = add nuw nsw ir<%indvars.iv6199>, ir<1>
    CLONE ir<%exitcond6202.not> = icmp eq ir<%indvars.iv.next6200>, ir<%wide.trip.count6201>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6199 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6200, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6199, i32 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %500 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %501 = zext i32 %500 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6205, %501 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %488, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6200 = add nuw nsw i64 %indvars.iv6199, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6202.not = icmp eq i64 %indvars.iv.next6200, %wide.trip.count6201 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6202.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6199 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6200, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6199, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %500 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %501 = zext i32 %500 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6205, %501 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %488, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6200 = add nuw nsw i64 %indvars.iv6199, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6202.not = icmp eq i64 %indvars.iv.next6200, %wide.trip.count6201 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6202.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 8589934588, RTCostB: 8589934588
A is not scalable.	B is not scalable.	
RTCostA: 8589934588, RTCostB: 8589934588

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6199 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6200, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6199, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %500 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %501 = zext i32 %500 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6205, %501 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %488, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next6200 = add nuw nsw i64 %indvars.iv6199, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6202.not = icmp eq i64 %indvars.iv.next6200, %wide.trip.count6201 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6202.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 8053063677, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8053063677, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6199 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6200, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6199, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %500 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 4 for VF 8 For instruction:   %501 = zext i32 %500 to i64 of type:zext
LV: Found an estimated cost of 4 for VF 8 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6205, %501 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %488, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next6200 = add nuw nsw i64 %indvars.iv6199, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6202.not = icmp eq i64 %indvars.iv.next6200, %wide.trip.count6201 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6202.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7784628223, RTCostB: 8589934588
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7784628223, RTCostB: 8053063677
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6199 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6200, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6199, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %500 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %501 = zext i32 %500 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6205, %501 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %488, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6200 = add nuw nsw i64 %indvars.iv6199, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6202.not = icmp eq i64 %indvars.iv.next6200, %wide.trip.count6201 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6202.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 8589934588, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934588, RTCostB: 7784628223

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6199 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6200, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6199, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %500 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %501 = zext i32 %500 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6205, %501 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %488, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next6200 = add nuw nsw i64 %indvars.iv6199, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6202.not = icmp eq i64 %indvars.iv.next6200, %wide.trip.count6201 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6202.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 8053063677, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8053063677, RTCostB: 7784628223

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6199 = phi i64 [ 0, %for.body3584.preheader ], [ %indvars.iv.next6200, %for.inc3594 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv6199, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %500 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %501 = zext i32 %500 to i64 of type:zext
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %cmp3587 = icmp eq i64 %indvars.iv6205, %501 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp3587, label %if.then3589, label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 %488, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc3594 of type:br

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next6200 = add nuw nsw i64 %indvars.iv6199, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6202.not = icmp eq i64 %indvars.iv.next6200, %wide.trip.count6201 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6202.not, label %for.end3596.loopexit, label %for.body3584 of type:br
LV: Vector loop of width vscale x 4 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7784628223, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7784628223, RTCostB: 7784628223
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3584.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %499 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv6199 = phi 0, %indvars.iv.next6200, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv6199>, ir<2>
    WIDEN ir<%500> = load ir<%what>
    WIDEN-CAST ir<%501> = zext  ir<%500> to i64
    WIDEN ir<%cmp3587> = icmp eq ir<%indvars.iv6205>, ir<%501>
    WIDEN store ir<%what>, ir<%488>, ir<%cmp3587>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4 -> Cost: 2 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4 -> Cost: 2 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4 -> Cost: 3 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4 -> Cost: 3 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx3866, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 -2, ptr %arrayidx3868, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)
========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3864.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv6213 = phi 0, %indvars.iv.next6214, ir<1>
    CLONE ir<%arrayidx3866> = getelementptr inbounds ir<%first_outpaddr_num>, ir<0>, ir<%indvars.iv6213>
    CLONE store ir<-2>, ir<%arrayidx3866>
    CLONE ir<%arrayidx3868> = getelementptr inbounds ir<%first_inpaddr_num>, ir<0>, ir<%indvars.iv6213>
    CLONE store ir<-2>, ir<%arrayidx3868>
    CLONE ir<%indvars.iv.next6214> = add nuw nsw ir<%indvars.iv6213>, ir<1>
    CLONE ir<%exitcond6216.not> = icmp eq ir<%indvars.iv.next6214>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond3873.preheader>, scalar.ph

ir-bb<for.cond3873.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3864.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6213 = phi 0, %indvars.iv.next6214, ir<1>
    CLONE ir<%arrayidx3866> = getelementptr inbounds ir<%first_outpaddr_num>, ir<0>, ir<%indvars.iv6213>
    vp<%4> = vector-pointer ir<%arrayidx3866>
    WIDEN store vp<%4>, ir<-2>
    CLONE ir<%arrayidx3868> = getelementptr inbounds ir<%first_inpaddr_num>, ir<0>, ir<%indvars.iv6213>
    vp<%5> = vector-pointer ir<%arrayidx3868>
    WIDEN store vp<%5>, ir<-2>
    CLONE ir<%indvars.iv.next6214> = add nuw nsw ir<%indvars.iv6213>, ir<1>
    CLONE ir<%exitcond6216.not> = icmp eq ir<%indvars.iv.next6214>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond3873.preheader>, scalar.ph

ir-bb<for.cond3873.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: find_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3864.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv6213 = phi 0, %indvars.iv.next6214, ir<1>
    CLONE ir<%arrayidx3866> = getelementptr inbounds ir<%first_outpaddr_num>, ir<0>, ir<%indvars.iv6213>
    vp<%4> = vector-pointer ir<%arrayidx3866>
    WIDEN store vp<%4>, ir<-2>
    CLONE ir<%arrayidx3868> = getelementptr inbounds ir<%first_inpaddr_num>, ir<0>, ir<%indvars.iv6213>
    vp<%5> = vector-pointer ir<%arrayidx3868>
    WIDEN store vp<%5>, ir<-2>
    CLONE ir<%indvars.iv.next6214> = add nuw nsw ir<%indvars.iv6213>, ir<1>
    CLONE ir<%exitcond6216.not> = icmp eq ir<%indvars.iv.next6214>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond3873.preheader>, scalar.ph

ir-bb<for.cond3873.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv6213 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6214, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -2, ptr %arrayidx3866, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -2, ptr %arrayidx3868, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next6214 = add nuw nsw i64 %indvars.iv6213, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond6216.not = icmp eq i64 %indvars.iv.next6214, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond6216.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv6213 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6214, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -2, ptr %arrayidx3866, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -2, ptr %arrayidx3868, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next6214 = add nuw nsw i64 %indvars.iv6213, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond6216.not = icmp eq i64 %indvars.iv.next6214, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond6216.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv6213 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6214, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 -2, ptr %arrayidx3866, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 -2, ptr %arrayidx3868, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next6214 = add nuw nsw i64 %indvars.iv6213, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond6216.not = icmp eq i64 %indvars.iv.next6214, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond6216.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv6213 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6214, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 8 For instruction:   store i32 -2, ptr %arrayidx3866, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 8 For instruction:   store i32 -2, ptr %arrayidx3868, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next6214 = add nuw nsw i64 %indvars.iv6213, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond6216.not = icmp eq i64 %indvars.iv.next6214, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond6216.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv6213 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6214, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 -2, ptr %arrayidx3866, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 -2, ptr %arrayidx3868, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next6214 = add nuw nsw i64 %indvars.iv6213, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond6216.not = icmp eq i64 %indvars.iv.next6214, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond6216.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv6213 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6214, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 -2, ptr %arrayidx3866, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 -2, ptr %arrayidx3868, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next6214 = add nuw nsw i64 %indvars.iv6213, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond6216.not = icmp eq i64 %indvars.iv.next6214, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond6216.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'find_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv6213 = phi i64 [ 0, %for.body3864.preheader ], [ %indvars.iv.next6214, %for.body3864 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3866 = getelementptr inbounds [30 x i32], ptr %first_outpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 -2, ptr %arrayidx3866, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx3868 = getelementptr inbounds [30 x i32], ptr %first_inpaddr_num, i64 0, i64 %indvars.iv6213 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 -2, ptr %arrayidx3868, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next6214 = add nuw nsw i64 %indvars.iv6213, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond6216.not = icmp eq i64 %indvars.iv.next6214, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond6216.not, label %for.cond3873.preheader, label %for.body3864 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 8
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: find_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body3864.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx3866> = getelementptr inbounds ir<%first_outpaddr_num>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx3866>
    WIDEN store vp<%5>, ir<-2>
    CLONE ir<%arrayidx3868> = getelementptr inbounds ir<%first_inpaddr_num>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx3868>
    WIDEN store vp<%6>, ir<-2>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond3873.preheader>, scalar.ph

ir-bb<for.cond3873.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 9
Loops Analyzed: 59
Loops Epilogues Vectorized: 0
================================================
========== Loop: combine_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body461.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %56 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1116 = phi 0, %indvars.iv.next1117, ir<1>
    CLONE ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv1116>, ir<2>
    CLONE ir<%57> = load ir<%what>
    CLONE ir<%cmp464> = icmp eq ir<%57>, ir<%output_reload.1.lcssa>
  Successor(s): if.then466

  if.then466:
    CLONE store ir<%44>, ir<%what>, ir<%cmp464>
  Successor(s): for.inc471

  for.inc471:
    EMIT vp<%4> = not ir<%cmp464>
    EMIT vp<%5> = or vp<%4>, ir<%cmp464>
    CLONE ir<%indvars.iv.next1117> = add nuw nsw ir<%indvars.iv1116>, ir<1>
    CLONE ir<%exitcond1119.not> = icmp eq ir<%indvars.iv.next1117>, ir<%wide.trip.count1118>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit1141>, scalar.ph

ir-bb<cleanup.loopexit1141>:
No successors

scalar.ph:
No successors
}

========== Loop: combine_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body461.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %56 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1116 = phi 0, %indvars.iv.next1117, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv1116>, ir<2>
    WIDEN ir<%57> = load ir<%what>
    WIDEN ir<%cmp464> = icmp eq ir<%57>, ir<%output_reload.1.lcssa>
  Successor(s): if.then466

  if.then466:
    WIDEN store ir<%what>, ir<%44>, ir<%cmp464>
  Successor(s): for.inc471

  for.inc471:
    EMIT vp<%4> = not ir<%cmp464>
    EMIT vp<%5> = or vp<%4>, ir<%cmp464>
    WIDEN ir<%indvars.iv.next1117> = add nuw nsw ir<%indvars.iv1116>, ir<1>
    CLONE ir<%exitcond1119.not> = icmp eq ir<%indvars.iv.next1117>, ir<%wide.trip.count1118>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: combine_reloads' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body461.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %56 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1116 = phi 0, %indvars.iv.next1117, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv1116>, ir<2>
    WIDEN ir<%57> = load ir<%what>
    WIDEN ir<%cmp464> = icmp eq ir<%57>, ir<%output_reload.1.lcssa>
  Successor(s): if.then466

  if.then466:
    WIDEN store ir<%what>, ir<%44>, ir<%cmp464>
  Successor(s): for.inc471

  for.inc471:
    EMIT vp<%4> = not ir<%cmp464>
    EMIT vp<%5> = or vp<%4>, ir<%cmp464>
    WIDEN ir<%indvars.iv.next1117> = add nuw nsw ir<%indvars.iv1116>, ir<1>
    CLONE ir<%exitcond1119.not> = icmp eq ir<%indvars.iv.next1117>, ir<%wide.trip.count1118>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1116 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1117, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1116, i32 2 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %57 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %44, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1117 = add nuw nsw i64 %indvars.iv1116, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1119.not = icmp eq i64 %indvars.iv.next1117, %wide.trip.count1118 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1119.not, label %cleanup.loopexit1141, label %for.body461 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1116 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1117, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1116, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %57 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %44, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1117 = add nuw nsw i64 %indvars.iv1116, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1119.not = icmp eq i64 %indvars.iv.next1117, %wide.trip.count1118 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1119.not, label %cleanup.loopexit1141, label %for.body461 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192765, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192765, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1116 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1117, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1116, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %57 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %44, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1117 = add nuw nsw i64 %indvars.iv1116, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1119.not = icmp eq i64 %indvars.iv.next1117, %wide.trip.count1118 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1119.not, label %cleanup.loopexit1141, label %for.body461 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 7516192765
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1116 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1117, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1116, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %57 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %44, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next1117 = add nuw nsw i64 %indvars.iv1116, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1119.not = icmp eq i64 %indvars.iv.next1117, %wide.trip.count1118 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1119.not, label %cleanup.loopexit1141, label %for.body461 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 6174015493, RTCostB: 8589934588
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6174015493, RTCostB: 6442450944
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1116 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1117, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1116, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %57 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %44, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1117 = add nuw nsw i64 %indvars.iv1116, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1119.not = icmp eq i64 %indvars.iv.next1117, %wide.trip.count1118 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1119.not, label %cleanup.loopexit1141, label %for.body461 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7516192765, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192765, RTCostB: 6174015493

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1116 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1117, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1116, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %57 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %44, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1117 = add nuw nsw i64 %indvars.iv1116, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1119.not = icmp eq i64 %indvars.iv.next1117, %wide.trip.count1118 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1119.not, label %cleanup.loopexit1141, label %for.body461 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450944, RTCostB: 6174015493

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1116 = phi i64 [ 0, %for.body461.preheader ], [ %indvars.iv.next1117, %for.inc471 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %what = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv1116, i32 2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %57 = load i32, ptr %what, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp464 = icmp eq i32 %57, %output_reload.1.lcssa of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp464, label %if.then466, label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 %44, ptr %what, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc471 of type:br

-----------------Function that is being costed:'combine_reloads' from reload.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next1117 = add nuw nsw i64 %indvars.iv1116, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1119.not = icmp eq i64 %indvars.iv.next1117, %wide.trip.count1118 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1119.not, label %cleanup.loopexit1141, label %for.body461 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 6174015493, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6174015493, RTCostB: 6174015493
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: combine_reloads at line: reload.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body461.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %56 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1116 = phi 0, %indvars.iv.next1117, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%what> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv1116>, ir<2>
    WIDEN ir<%57> = load ir<%what>
    WIDEN ir<%cmp464> = icmp eq ir<%57>, ir<%output_reload.1.lcssa>
    WIDEN store ir<%what>, ir<%44>, ir<%cmp464>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 10
Loops Analyzed: 68
Loops Epilogues Vectorized: 0
================================================
========== Loop: move_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>
    CLONE ir<%subreg_loc> = getelementptr inbounds ir<%arrayidx>, ir<8>
    CLONE ir<%1> = load ir<%subreg_loc>
    CLONE ir<%cmp1> = icmp eq ir<%1>, ir<%x>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%cmp1>
    CLONE ir<%2> = load ir<%arrayidx>, vp<%4>
    CLONE ir<%cmp7> = icmp eq ir<%2>, ir<%x>
  Successor(s): if.then8

  if.then8:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp7>
    CLONE store ir<%y>, ir<%arrayidx>, vp<%5>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%6> = or ir<%cmp1>, vp<%5>
    BLEND ir<%y.sink> = ir<null> ir<%y>/ir<%cmp1>
    CLONE store ir<%y.sink>, ir<%subreg_loc>, vp<%6>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%7> = not ir<%cmp7>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: move_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%subreg_loc> = getelementptr inbounds ir<%arrayidx>, ir<8>
    WIDEN ir<%1> = load ir<%subreg_loc>
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%x>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%cmp1>
    WIDEN ir<%2> = load ir<%arrayidx>, vp<%4>
    WIDEN ir<%cmp7> = icmp eq ir<%2>, ir<%x>
  Successor(s): if.then8

  if.then8:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp7>
    WIDEN store ir<%arrayidx>, ir<%y>, vp<%5>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%6> = or ir<%cmp1>, vp<%5>
    BLEND ir<%y.sink> = ir<null> ir<%y>/ir<%cmp1>
    WIDEN store ir<%subreg_loc>, ir<%y.sink>, vp<%6>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%7> = not ir<%cmp7>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: move_replacements' from reload.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%10>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@replacements>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%subreg_loc> = getelementptr inbounds ir<%arrayidx>, ir<8>
    WIDEN ir<%1> = load ir<%subreg_loc>
    WIDEN ir<%cmp1> = icmp eq ir<%1>, ir<%x>
  Successor(s): if.else

  if.else:
    EMIT vp<%4> = not ir<%cmp1>
    WIDEN ir<%2> = load ir<%arrayidx>, vp<%4>
    WIDEN ir<%cmp7> = icmp eq ir<%2>, ir<%x>
  Successor(s): if.then8

  if.then8:
    EMIT vp<%5> = logical-and vp<%4>, ir<%cmp7>
    WIDEN store ir<%arrayidx>, ir<%y>, vp<%5>
  Successor(s): for.inc.sink.split

  for.inc.sink.split:
    EMIT vp<%6> = or ir<%cmp1>, vp<%5>
    BLEND ir<%y.sink> = ir<null> ir<%y>/ir<%cmp1>
    WIDEN store ir<%subreg_loc>, ir<%y.sink>, vp<%6>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%7> = not ir<%cmp7>
    EMIT vp<%8> = logical-and vp<%4>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %subreg_loc = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1 = load ptr, ptr %subreg_loc, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1 = icmp eq ptr %1, %x of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp7 = icmp eq ptr %2, %x of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp7, label %if.then8, label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %y, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc.sink.split of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %y.sink = phi ptr [ null, %if.then8 ], [ %y, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %y.sink, ptr %subreg_loc, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %subreg_loc = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %1 = load ptr, ptr %subreg_loc, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1 = icmp eq ptr %1, %x of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %2 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp7 = icmp eq ptr %2, %x of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp7, label %if.then8, label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %y, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc.sink.split of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %y.sink = phi ptr [ null, %if.then8 ], [ %y, %for.body ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %y.sink, ptr %subreg_loc, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 13958643704, RTCostB: 10737418235
A is not scalable.	B is not scalable.	
RTCostA: 13958643704, RTCostB: 10737418235

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %subreg_loc = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %1 = load ptr, ptr %subreg_loc, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp1 = icmp eq ptr %1, %x of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %2 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp7 = icmp eq ptr %2, %x of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp7, label %if.then8, label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %y, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc.sink.split of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %y.sink = phi ptr [ null, %if.then8 ], [ %y, %for.body ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %y.sink, ptr %subreg_loc, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 13421772790, RTCostB: 10737418235
A is not scalable.	B is not scalable.	
RTCostA: 13421772790, RTCostB: 10737418235

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %subreg_loc = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %1 = load ptr, ptr %subreg_loc, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1 = icmp eq ptr %1, %x of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %2 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp7 = icmp eq ptr %2, %x of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp7, label %if.then8, label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %y, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc.sink.split of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %y.sink = phi ptr [ null, %if.then8 ], [ %y, %for.body ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %y.sink, ptr %subreg_loc, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 6
A is scalable.	B is not scalable.	
RTCostA: 13958643704, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: 13958643704, RTCostB: 10737418235

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [150 x %struct.replacement], ptr @replacements, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %subreg_loc = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %1 = load ptr, ptr %subreg_loc, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp1 = icmp eq ptr %1, %x of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1, label %for.inc.sink.split, label %if.else of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %2 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %cmp7 = icmp eq ptr %2, %x of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp7, label %if.then8, label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %y, ptr %arrayidx, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc.sink.split of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %y.sink = phi ptr [ null, %if.then8 ], [ %y, %for.body ] of type:phi
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %y.sink, ptr %subreg_loc, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'move_replacements' from reload.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 6
A is scalable.	B is not scalable.	
RTCostA: 13421772790, RTCostB: 10737418235
A is scalable.	B is not scalable.	
RTCostA: 13421772790, RTCostB: 10737418235
LV: Selecting VF: 1 With Cost: 5.
maxbefore: 1
maxafter: 1
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o reload1.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         reload1.c
========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115.1207 to i64) + (-1 * (1 umin (zext i32 %cond115.1207 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.1 = phi %46, %indvars.iv.next.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188.1> = phi ir<%to.promoted.1>, ir<%or.1>
    CLONE ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<-1>
    CLONE ir<%48> = add nsw ir<%indvars.iv.next.1>, ir<%47>
    CLONE ir<%shl122.1> = shl nuw ir<1>, ir<%48>
    CLONE ir<%or.1> = or ir<%or188.1>, ir<%shl122.1>
    CLONE ir<%cmp117.1> = icmp ugt ir<%indvars.iv.1>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115.1207 to i64) + (-1 * (1 umin (zext i32 %cond115.1207 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.1 = phi %46, %indvars.iv.next.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188.1> = phi ir<%to.promoted.1>, ir<%or.1>
    WIDEN ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<-1>
    WIDEN ir<%48> = add nsw ir<%indvars.iv.next.1>, ir<%47>
    WIDEN ir<%shl122.1> = shl nuw ir<1>, ir<%48>
    WIDEN ir<%or.1> = or ir<%or188.1>, ir<%shl122.1>
    CLONE ir<%cmp117.1> = icmp ugt ir<%indvars.iv.1>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115.1207 to i64) + (-1 * (1 umin (zext i32 %cond115.1207 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.1 = phi %46, %indvars.iv.next.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188.1> = phi ir<%to.promoted.1>, ir<%or.1>
    WIDEN ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<-1>
    WIDEN ir<%48> = add nsw ir<%indvars.iv.next.1>, ir<%47>
    WIDEN ir<%shl122.1> = shl nuw ir<1>, ir<%48>
    WIDEN ir<%or.1> = or ir<%or188.1>, ir<%shl122.1>
    CLONE ir<%cmp117.1> = icmp ugt ir<%indvars.iv.1>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}


-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv.1 = phi i64 [ %46, %while.body119.lr.ph.1 ], [ %indvars.iv.next.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or188.1 = phi i64 [ %to.promoted.1, %while.body119.lr.ph.1 ], [ %or.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %48 = add nsw i64 %indvars.iv.next.1, %47 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl122.1 = shl nuw i64 1, %48 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.1 = or i64 %or188.1, %shl122.1 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp117.1 = icmp ugt i64 %indvars.iv.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp117.1, label %while.body119.1, label %while.cond116.if.end124.loopexit_crit_edge.1 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv.1 = phi i64 [ %46, %while.body119.lr.ph.1 ], [ %indvars.iv.next.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or188.1 = phi i64 [ %to.promoted.1, %while.body119.lr.ph.1 ], [ %or.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %48 = add nsw i64 %indvars.iv.next.1, %47 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl122.1 = shl nuw i64 1, %48 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.1 = or i64 %or188.1, %shl122.1 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp117.1 = icmp ugt i64 %indvars.iv.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp117.1, label %while.body119.1, label %while.cond116.if.end124.loopexit_crit_edge.1 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv.1 = phi i64 [ %46, %while.body119.lr.ph.1 ], [ %indvars.iv.next.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or188.1 = phi i64 [ %to.promoted.1, %while.body119.lr.ph.1 ], [ %or.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %48 = add nsw i64 %indvars.iv.next.1, %47 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl122.1 = shl nuw i64 1, %48 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or.1 = or i64 %or188.1, %shl122.1 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp117.1 = icmp ugt i64 %indvars.iv.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp117.1, label %while.body119.1, label %while.cond116.if.end124.loopexit_crit_edge.1 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv.1 = phi i64 [ %46, %while.body119.lr.ph.1 ], [ %indvars.iv.next.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or188.1 = phi i64 [ %to.promoted.1, %while.body119.lr.ph.1 ], [ %or.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %48 = add nsw i64 %indvars.iv.next.1, %47 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl122.1 = shl nuw i64 1, %48 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.1 = or i64 %or188.1, %shl122.1 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp117.1 = icmp ugt i64 %indvars.iv.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp117.1, label %while.body119.1, label %while.cond116.if.end124.loopexit_crit_edge.1 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv.1 = phi i64 [ %46, %while.body119.lr.ph.1 ], [ %indvars.iv.next.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or188.1 = phi i64 [ %to.promoted.1, %while.body119.lr.ph.1 ], [ %or.1, %while.body119.1 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next.1 = add nsw i64 %indvars.iv.1, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %48 = add nsw i64 %indvars.iv.next.1, %47 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl122.1 = shl nuw i64 1, %48 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or.1 = or i64 %or188.1, %shl122.1 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp117.1 = icmp ugt i64 %indvars.iv.1, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp117.1, label %while.body119.1, label %while.cond116.if.end124.loopexit_crit_edge.1 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: compute_use_by_pseudos at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph.1>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115.1207 to i64) + (-1 * (1 umin (zext i32 %cond115.1207 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv.1 = phi %46, %indvars.iv.next.1, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188.1> = phi ir<%to.promoted.1>, ir<%or.1>
    WIDEN ir<%indvars.iv.next.1> = add nsw ir<%indvars.iv.1>, ir<-1>
    WIDEN ir<%48> = add nsw ir<%indvars.iv.next.1>, ir<%47>
    WIDEN ir<%shl122.1> = shl nuw ir<1>, ir<%48>
    WIDEN ir<%or.1> = or ir<%or188.1>, ir<%shl122.1>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188.1>, ir<%or.1>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge.1>:
No successors

scalar.ph:
No successors

Live-out i64 %or.1.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115204 to i64) + (-1 * (1 umin (zext i32 %cond115204 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188> = phi ir<%to.promoted>, ir<%or>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    CLONE ir<%shl122> = shl nuw ir<1>, ir<%25>
    CLONE ir<%or> = or ir<%or188>, ir<%shl122>
    CLONE ir<%cmp117> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115204 to i64) + (-1 * (1 umin (zext i32 %cond115204 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188> = phi ir<%to.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    WIDEN ir<%shl122> = shl nuw ir<1>, ir<%25>
    WIDEN ir<%or> = or ir<%or188>, ir<%shl122>
    CLONE ir<%cmp117> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: compute_use_by_pseudos' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115204 to i64) + (-1 * (1 umin (zext i32 %cond115204 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188> = phi ir<%to.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    WIDEN ir<%shl122> = shl nuw ir<1>, ir<%25>
    WIDEN ir<%or> = or ir<%or188>, ir<%shl122>
    CLONE ir<%cmp117> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %23, %while.body119.lr.ph ], [ %indvars.iv.next, %while.body119 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or188 = phi i64 [ %to.promoted, %while.body119.lr.ph ], [ %or, %while.body119 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl122 = shl nuw i64 1, %25 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or188, %shl122 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp117 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp117, label %while.body119, label %while.cond116.if.end124.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %23, %while.body119.lr.ph ], [ %indvars.iv.next, %while.body119 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or188 = phi i64 [ %to.promoted, %while.body119.lr.ph ], [ %or, %while.body119 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl122 = shl nuw i64 1, %25 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or188, %shl122 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp117 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp117, label %while.body119, label %while.cond116.if.end124.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %23, %while.body119.lr.ph ], [ %indvars.iv.next, %while.body119 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or188 = phi i64 [ %to.promoted, %while.body119.lr.ph ], [ %or, %while.body119 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl122 = shl nuw i64 1, %25 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or188, %shl122 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp117 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp117, label %while.body119, label %while.cond116.if.end124.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %23, %while.body119.lr.ph ], [ %indvars.iv.next, %while.body119 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or188 = phi i64 [ %to.promoted, %while.body119.lr.ph ], [ %or, %while.body119 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl122 = shl nuw i64 1, %25 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or188, %shl122 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp117 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp117, label %while.body119, label %while.cond116.if.end124.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'compute_use_by_pseudos' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %23, %while.body119.lr.ph ], [ %indvars.iv.next, %while.body119 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or188 = phi i64 [ %to.promoted, %while.body119.lr.ph ], [ %or, %while.body119 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl122 = shl nuw i64 1, %25 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or188, %shl122 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp117 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp117, label %while.body119, label %while.cond116.if.end124.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: compute_use_by_pseudos at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body119.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond115204 to i64) + (-1 * (1 umin (zext i32 %cond115204 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or188> = phi ir<%to.promoted>, ir<%or>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    WIDEN ir<%shl122> = shl nuw ir<1>, ir<%25>
    WIDEN ir<%or> = or ir<%or188>, ir<%shl122>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or188>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond116.if.end124.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond116.if.end124.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %12 = load i8, ptr %arrayidx, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %13 = load i8, ptr %arrayidx45, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx49, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%12> = load ir<%arrayidx>
    CLONE ir<%tobool43.not> = icmp eq ir<%12>, ir<0>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%13> = load ir<%arrayidx45>
    CLONE ir<%tobool46.not> = icmp eq ir<%13>, ir<0>
  Successor(s): if.then47

  if.then47:
    EMIT vp<%3> = logical-and ir<%tobool43.not>, ir<%tobool46.not>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv>
    CLONE store ir<1>, ir<%arrayidx49>, vp<%3>
  Successor(s): for.inc51

  for.inc51:
    EMIT vp<%4> = not ir<%tobool43.not>
    EMIT vp<%5> = not ir<%tobool46.not>
    EMIT vp<%6> = logical-and ir<%tobool43.not>, vp<%5>
    EMIT vp<%7> = or vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, vp<%3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%12> = load vp<%3>
    WIDEN ir<%tobool43.not> = icmp eq ir<%12>, ir<0>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx45> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%13> = load vp<%4>
    WIDEN ir<%tobool46.not> = icmp eq ir<%13>, ir<0>
  Successor(s): if.then47

  if.then47:
    EMIT vp<%5> = logical-and ir<%tobool43.not>, ir<%tobool46.not>
    CLONE ir<%arrayidx49> = getelementptr ir<@regs_ever_live>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%6>, ir<1>, vp<%5>
  Successor(s): for.inc51

  for.inc51:
    EMIT vp<%7> = not ir<%tobool43.not>
    EMIT vp<%8> = not ir<%tobool46.not>
    EMIT vp<%9> = logical-and ir<%tobool43.not>, vp<%8>
    EMIT vp<%10> = or vp<%7>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%5>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx>
    WIDEN ir<%12> = load vp<%3>
    WIDEN ir<%tobool43.not> = icmp eq ir<%12>, ir<0>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%arrayidx45> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%13> = load vp<%4>
    WIDEN ir<%tobool46.not> = icmp eq ir<%13>, ir<0>
  Successor(s): if.then47

  if.then47:
    EMIT vp<%5> = logical-and ir<%tobool43.not>, ir<%tobool46.not>
    CLONE ir<%arrayidx49> = getelementptr ir<@regs_ever_live>, ir<0>, ir<%indvars.iv>
    vp<%6> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%6>, ir<1>, vp<%5>
  Successor(s): for.inc51

  for.inc51:
    EMIT vp<%7> = not ir<%tobool43.not>
    EMIT vp<%8> = not ir<%tobool46.not>
    EMIT vp<%9> = logical-and ir<%tobool43.not>, vp<%8>
    EMIT vp<%10> = or vp<%7>, vp<%9>
    EMIT vp<%11> = or vp<%10>, vp<%5>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 187, RTCostB: 265
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 187, RTCostB: 265
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 96, RTCostB: 265
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 96, RTCostB: 187
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 67, RTCostB: 265
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 67, RTCostB: 96
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 265
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 67
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 32 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 117, RTCostB: 265
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 117, RTCostB: 46

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 187, RTCostB: 265
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 187, RTCostB: 46

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 96, RTCostB: 265
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 96, RTCostB: 46

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 67, RTCostB: 265
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 67, RTCostB: 46

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 265
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 46
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc51 ], [ 0, %for.body42.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %12 = load i8, ptr %arrayidx, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %tobool43.not = icmp eq i8 %12, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool43.not, label %land.lhs.true, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %13 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %tobool46.not = icmp eq i8 %13, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool46.not, label %if.then47, label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx49 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx49, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc51 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %if.end54.loopexit, label %for.body42 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 117, RTCostB: 265
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 117, RTCostB: 46
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 8, UF=1 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%12> = load vp<%4>
    WIDEN ir<%tobool43.not> = icmp eq ir<%12>, ir<0>
    CLONE ir<%arrayidx45> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%13> = load vp<%5>
    WIDEN ir<%tobool46.not> = icmp eq ir<%13>, ir<0>
    EMIT vp<%6> = logical-and ir<%tobool43.not>, ir<%tobool46.not>
    CLONE ir<%arrayidx49> = getelementptr ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%7> = vector-pointer ir<%arrayidx49>
    WIDEN store vp<%7>, ir<1>, vp<%6>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end54.loopexit>, scalar.ph

ir-bb<if.end54.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %44 = load i8, ptr %arrayidx135, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 1, ptr %arrayidx139, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1591 = phi %indvars.iv.next1592, 0, ir<1>
    CLONE ir<%arrayidx135> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1591>
    CLONE ir<%44> = load ir<%arrayidx135>
    CLONE ir<%tobool136.not> = icmp eq ir<%44>, ir<0>
  Successor(s): if.then137

  if.then137:
    CLONE ir<%arrayidx139> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1591>
    CLONE store ir<1>, ir<%arrayidx139>, ir<%tobool136.not>
  Successor(s): for.inc141

  for.inc141:
    EMIT vp<%3> = not ir<%tobool136.not>
    EMIT vp<%4> = or vp<%3>, ir<%tobool136.not>
    CLONE ir<%indvars.iv.next1592> = add nuw nsw ir<%indvars.iv1591>, ir<1>
    CLONE ir<%exitcond1593.not> = icmp eq ir<%indvars.iv.next1592>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end144.loopexit>, scalar.ph

ir-bb<if.end144.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv1591 = phi %indvars.iv.next1592, 0, ir<1>
    CLONE ir<%arrayidx135> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1591>
    vp<%3> = vector-pointer ir<%arrayidx135>
    WIDEN ir<%44> = load vp<%3>
    WIDEN ir<%tobool136.not> = icmp eq ir<%44>, ir<0>
  Successor(s): if.then137

  if.then137:
    CLONE ir<%arrayidx139> = getelementptr ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1591>
    vp<%4> = vector-pointer ir<%arrayidx139>
    WIDEN store vp<%4>, ir<1>, ir<%tobool136.not>
  Successor(s): for.inc141

  for.inc141:
    EMIT vp<%5> = not ir<%tobool136.not>
    EMIT vp<%6> = or vp<%5>, ir<%tobool136.not>
    CLONE ir<%indvars.iv.next1592> = add nuw nsw ir<%indvars.iv1591>, ir<1>
    CLONE ir<%exitcond1593.not> = icmp eq ir<%indvars.iv.next1592>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end144.loopexit>, scalar.ph

ir-bb<if.end144.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv1591 = phi %indvars.iv.next1592, 0, ir<1>
    CLONE ir<%arrayidx135> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1591>
    vp<%3> = vector-pointer ir<%arrayidx135>
    WIDEN ir<%44> = load vp<%3>
    WIDEN ir<%tobool136.not> = icmp eq ir<%44>, ir<0>
  Successor(s): if.then137

  if.then137:
    CLONE ir<%arrayidx139> = getelementptr ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1591>
    vp<%4> = vector-pointer ir<%arrayidx139>
    WIDEN store vp<%4>, ir<1>, ir<%tobool136.not>
  Successor(s): for.inc141

  for.inc141:
    EMIT vp<%5> = not ir<%tobool136.not>
    EMIT vp<%6> = or vp<%5>, ir<%tobool136.not>
    CLONE ir<%indvars.iv.next1592> = add nuw nsw ir<%indvars.iv1591>, ir<1>
    CLONE ir<%exitcond1593.not> = icmp eq ir<%indvars.iv.next1592>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<if.end144.loopexit>, scalar.ph

ir-bb<if.end144.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 134, RTCostB: 212
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 134, RTCostB: 212
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 69, RTCostB: 212
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 69, RTCostB: 134
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 50, RTCostB: 212
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 50, RTCostB: 69
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 35, RTCostB: 212
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 35, RTCostB: 50
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 2 for VF 32 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 32 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 92, RTCostB: 212
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 92, RTCostB: 35

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 134, RTCostB: 212
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 134, RTCostB: 35

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 69, RTCostB: 212
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 69, RTCostB: 35

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 50, RTCostB: 212
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 50, RTCostB: 35

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 35, RTCostB: 212
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 35, RTCostB: 35
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv1591 = phi i64 [ %indvars.iv.next1592, %for.inc141 ], [ 0, %for.body133.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx135 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %44 = load i8, ptr %arrayidx135, align 1 of type:load
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %tobool136.not = icmp eq i8 %44, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool136.not, label %if.then137, label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx139 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1591 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 1, ptr %arrayidx139, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br label %for.inc141 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next1592 = add nuw nsw i64 %indvars.iv1591, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond1593.not = icmp eq i64 %indvars.iv.next1592, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond1593.not, label %if.end144.loopexit, label %for.body133 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 92, RTCostB: 212
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 92, RTCostB: 35
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 8, UF=1 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx135> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx135>
    WIDEN ir<%44> = load vp<%4>
    WIDEN ir<%tobool136.not> = icmp eq ir<%44>, ir<0>
    CLONE ir<%arrayidx139> = getelementptr ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx139>
    WIDEN store vp<%5>, ir<1>, ir<%tobool136.not>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end144.loopexit>, scalar.ph

ir-bb<if.end144.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %221 = load i8, ptr %arrayidx1147, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %222 = load i8, ptr %arrayidx1152, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %223 = load i8, ptr %arrayidx1156, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %221 = load i8, ptr %arrayidx1147, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %222 = load i8, ptr %arrayidx1152, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %223 = load i8, ptr %arrayidx1156, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %221 = load i8, ptr %arrayidx1147, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %222 = load i8, ptr %arrayidx1152, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %223 = load i8, ptr %arrayidx1156, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %221 = load i8, ptr %arrayidx1147, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %222 = load i8, ptr %arrayidx1152, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %223 = load i8, ptr %arrayidx1156, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv1605 = phi 0, %indvars.iv.next1606, ir<1>
    WIDEN-REDUCTION-PHI ir<%size.01581> = phi ir<%add1141>, ir<%size.1>
    CLONE ir<%arrayidx1147> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1605>
    CLONE ir<%221> = load ir<%arrayidx1147>
    CLONE ir<%tobool1149.not> = icmp eq ir<%221>, ir<0>
  Successor(s): land.lhs.true1150

  land.lhs.true1150:
    EMIT vp<%3> = not ir<%tobool1149.not>
    CLONE ir<%arrayidx1152> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1605>
    CLONE ir<%222> = load ir<%arrayidx1152>
    CLONE ir<%tobool1153.not> = icmp eq ir<%222>, ir<0>
  Successor(s): land.lhs.true1154

  land.lhs.true1154:
    EMIT vp<%4> = logical-and vp<%3>, ir<%tobool1153.not>
    CLONE ir<%arrayidx1156> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1605>
    CLONE ir<%223> = load ir<%arrayidx1156>
    CLONE ir<%tobool1158.not> = icmp eq ir<%223>, ir<0>
    CLONE ir<%add1164> = select ir<%tobool1158.not>, ir<0>, ir<%cond1162>
    CLONE ir<%spec.select1587> = add ir<%size.01581>, ir<%add1164>
  Successor(s): for.inc1166

  for.inc1166:
    EMIT vp<%5> = or vp<%4>, ir<%tobool1149.not>
    EMIT vp<%6> = not ir<%tobool1153.not>
    EMIT vp<%7> = logical-and vp<%3>, vp<%6>
    EMIT vp<%8> = or vp<%5>, vp<%7>
    BLEND ir<%size.1> = ir<%size.01581> ir<%size.01581>/ir<%tobool1149.not> ir<%spec.select1587>/vp<%4>
    CLONE ir<%indvars.iv.next1606> = add nuw nsw ir<%indvars.iv1605>, ir<1>
    CLONE ir<%exitcond1607.not> = icmp eq ir<%indvars.iv.next1606>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%size.01581>, ir<%size.1>
  EMIT vp<%12> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end1168>, scalar.ph

ir-bb<for.end1168>:
No successors

scalar.ph:
No successors

Live-out i64 %size.1.lcssa = vp<%11>
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv1605 = phi 0, %indvars.iv.next1606, ir<1>
    WIDEN-REDUCTION-PHI ir<%size.01581> = phi ir<%add1141>, ir<%size.1>
    CLONE ir<%arrayidx1147> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1605>
    vp<%3> = vector-pointer ir<%arrayidx1147>
    WIDEN ir<%221> = load vp<%3>
    WIDEN ir<%tobool1149.not> = icmp eq ir<%221>, ir<0>
  Successor(s): land.lhs.true1150

  land.lhs.true1150:
    EMIT vp<%4> = not ir<%tobool1149.not>
    CLONE ir<%arrayidx1152> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv1605>
    vp<%5> = vector-pointer ir<%arrayidx1152>
    WIDEN ir<%222> = load vp<%5>
    WIDEN ir<%tobool1153.not> = icmp eq ir<%222>, ir<0>
  Successor(s): land.lhs.true1154

  land.lhs.true1154:
    EMIT vp<%6> = logical-and vp<%4>, ir<%tobool1153.not>
    CLONE ir<%arrayidx1156> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv1605>
    vp<%7> = vector-pointer ir<%arrayidx1156>
    WIDEN ir<%223> = load vp<%7>
    WIDEN ir<%tobool1158.not> = icmp eq ir<%223>, ir<0>
    WIDEN-SELECT ir<%add1164> = select ir<%tobool1158.not>, ir<0>, ir<%cond1162>
    WIDEN ir<%spec.select1587> = add ir<%size.01581>, ir<%add1164>
  Successor(s): for.inc1166

  for.inc1166:
    EMIT vp<%8> = or vp<%6>, ir<%tobool1149.not>
    EMIT vp<%9> = not ir<%tobool1153.not>
    EMIT vp<%10> = logical-and vp<%4>, vp<%9>
    EMIT vp<%11> = or vp<%8>, vp<%10>
    BLEND ir<%size.1> = ir<%size.01581> ir<%size.01581>/ir<%tobool1149.not> ir<%spec.select1587>/vp<%6>
    CLONE ir<%indvars.iv.next1606> = add nuw nsw ir<%indvars.iv1605>, ir<1>
    CLONE ir<%exitcond1607.not> = icmp eq ir<%indvars.iv.next1606>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = compute-reduction-result ir<%size.01581>, ir<%size.1>
  EMIT vp<%15> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end1168>, scalar.ph

ir-bb<for.end1168>:
No successors

scalar.ph:
No successors

Live-out i64 %size.1.lcssa = vp<%14>
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-INDUCTION %indvars.iv1605 = phi 0, %indvars.iv.next1606, ir<1>
    WIDEN-REDUCTION-PHI ir<%size.01581> = phi ir<%add1141>, ir<%size.1>
    CLONE ir<%arrayidx1147> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, ir<%indvars.iv1605>
    vp<%3> = vector-pointer ir<%arrayidx1147>
    WIDEN ir<%221> = load vp<%3>
    WIDEN ir<%tobool1149.not> = icmp eq ir<%221>, ir<0>
  Successor(s): land.lhs.true1150

  land.lhs.true1150:
    EMIT vp<%4> = not ir<%tobool1149.not>
    CLONE ir<%arrayidx1152> = getelementptr ir<@fixed_regs>, ir<0>, ir<%indvars.iv1605>
    vp<%5> = vector-pointer ir<%arrayidx1152>
    WIDEN ir<%222> = load vp<%5>
    WIDEN ir<%tobool1153.not> = icmp eq ir<%222>, ir<0>
  Successor(s): land.lhs.true1154

  land.lhs.true1154:
    EMIT vp<%6> = logical-and vp<%4>, ir<%tobool1153.not>
    CLONE ir<%arrayidx1156> = getelementptr ir<@call_used_regs>, ir<0>, ir<%indvars.iv1605>
    vp<%7> = vector-pointer ir<%arrayidx1156>
    WIDEN ir<%223> = load vp<%7>
    WIDEN ir<%tobool1158.not> = icmp eq ir<%223>, ir<0>
    WIDEN-SELECT ir<%add1164> = select ir<%tobool1158.not>, ir<0>, ir<%cond1162>
    WIDEN ir<%spec.select1587> = add ir<%size.01581>, ir<%add1164>
  Successor(s): for.inc1166

  for.inc1166:
    EMIT vp<%8> = or vp<%6>, ir<%tobool1149.not>
    EMIT vp<%9> = not ir<%tobool1153.not>
    EMIT vp<%10> = logical-and vp<%4>, vp<%9>
    EMIT vp<%11> = or vp<%8>, vp<%10>
    BLEND ir<%size.1> = ir<%size.01581> ir<%size.01581>/ir<%tobool1149.not> ir<%spec.select1587>/vp<%6>
    CLONE ir<%indvars.iv.next1606> = add nuw nsw ir<%indvars.iv1605>, ir<1>
    CLONE ir<%exitcond1607.not> = icmp eq ir<%indvars.iv.next1606>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = compute-reduction-result ir<%size.01581>, ir<%size.1>
  EMIT vp<%15> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end1168>, scalar.ph

ir-bb<for.end1168>:
No successors

scalar.ph:
No successors

Live-out i64 %size.1.lcssa = vp<%14>
}


-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1605 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1606, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %221 = load i8, ptr %arrayidx1147, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool1149.not = icmp eq i8 %221, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %222 = load i8, ptr %arrayidx1152, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool1153.not = icmp eq i8 %222, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %223 = load i8, ptr %arrayidx1156, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool1158.not = icmp eq i8 %223, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1606 = add nuw nsw i64 %indvars.iv1605, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1607.not = icmp eq i64 %indvars.iv.next1606, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1607.not, label %for.end1168, label %for.body1145 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1605 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1606, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %221 = load i8, ptr %arrayidx1147, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool1149.not = icmp eq i8 %221, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %222 = load i8, ptr %arrayidx1152, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool1153.not = icmp eq i8 %222, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %223 = load i8, ptr %arrayidx1156, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool1158.not = icmp eq i8 %223, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1606 = add nuw nsw i64 %indvars.iv1605, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1607.not = icmp eq i64 %indvars.iv.next1606, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1607.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 319, RTCostB: 371
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 319, RTCostB: 371
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1605 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1606, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %221 = load i8, ptr %arrayidx1147, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool1149.not = icmp eq i8 %221, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %222 = load i8, ptr %arrayidx1152, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool1153.not = icmp eq i8 %222, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %223 = load i8, ptr %arrayidx1156, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool1158.not = icmp eq i8 %223, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 2 for VF 4 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 4 for VF 4 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1606 = add nuw nsw i64 %indvars.iv1605, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1607.not = icmp eq i64 %indvars.iv.next1606, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1607.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 215, RTCostB: 371
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 215, RTCostB: 319
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1605 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1606, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %221 = load i8, ptr %arrayidx1147, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool1149.not = icmp eq i8 %221, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %222 = load i8, ptr %arrayidx1152, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool1153.not = icmp eq i8 %222, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %223 = load i8, ptr %arrayidx1156, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool1158.not = icmp eq i8 %223, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1606 = add nuw nsw i64 %indvars.iv1605, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1607.not = icmp eq i64 %indvars.iv.next1606, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1607.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width vscale x 1 costs: 6
A is scalable.	B is not scalable.	
RTCostA: 319, RTCostB: 371
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 319, RTCostB: 215

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1605 = phi i64 [ 0, %if.then1134 ], [ %indvars.iv.next1606, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %size.01581 = phi i64 [ %add1141, %if.then1134 ], [ %size.1, %for.inc1166 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1147 = getelementptr inbounds [53 x i8], ptr @regs_ever_live, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %221 = load i8, ptr %arrayidx1147, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool1149.not = icmp eq i8 %221, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool1149.not, label %for.inc1166, label %land.lhs.true1150 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1152 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %222 = load i8, ptr %arrayidx1152, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool1153.not = icmp eq i8 %222, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool1153.not, label %land.lhs.true1154, label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1156 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1605 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %223 = load i8, ptr %arrayidx1156, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool1158.not = icmp eq i8 %223, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %add1164 = select i1 %tobool1158.not, i64 0, i64 %cond1162 of type:select
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %spec.select1587 = add nsw i64 %size.01581, %add1164 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc1166 of type:br

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %size.1 = phi i64 [ %size.01581, %land.lhs.true1150 ], [ %size.01581, %for.body1145 ], [ %spec.select1587, %land.lhs.true1154 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1606 = add nuw nsw i64 %indvars.iv1605, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1607.not = icmp eq i64 %indvars.iv.next1606, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1607.not, label %for.end1168, label %for.body1145 of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 215, RTCostB: 371
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 215, RTCostB: 215
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 4.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-REDUCTION-PHI ir<%size.01581> = phi ir<%add1141>, ir<%size.1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx1147> = getelementptr inbounds ir<@regs_ever_live>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx1147>
    WIDEN ir<%221> = load vp<%4>
    WIDEN ir<%tobool1149.not> = icmp eq ir<%221>, ir<0>
    EMIT vp<%5> = not ir<%tobool1149.not>
    CLONE ir<%arrayidx1152> = getelementptr ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%6> = vector-pointer ir<%arrayidx1152>
    WIDEN ir<%222> = load vp<%6>
    WIDEN ir<%tobool1153.not> = icmp eq ir<%222>, ir<0>
    EMIT vp<%7> = logical-and vp<%5>, ir<%tobool1153.not>
    CLONE ir<%arrayidx1156> = getelementptr ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%8> = vector-pointer ir<%arrayidx1156>
    WIDEN ir<%223> = load vp<%8>
    WIDEN ir<%tobool1158.not> = icmp eq ir<%223>, ir<0>
    WIDEN-SELECT ir<%add1164> = select ir<%tobool1158.not>, ir<0>, ir<%cond1162>
    WIDEN ir<%spec.select1587> = add ir<%size.01581>, ir<%add1164>
    BLEND ir<%size.1> = ir<%size.01581> ir<%size.01581>/ir<%tobool1149.not> ir<%spec.select1587>/vp<%7>
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%size.01581>, ir<%size.1>
  EMIT vp<%12> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end1168>, scalar.ph

ir-bb<for.end1168>:
No successors

scalar.ph:
No successors

Live-out i64 %size.1.lcssa = vp<%11>
}
================ Final VPlan ================

@@ Instruction =>  %257 = load i16, ptr %arrayidx1199, align 2 -> Cost: 1 -> VectorType: <2 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %257 = load i16, ptr %arrayidx1199, align 2 -> Cost: 1 -> VectorType: <4 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %257 = load i16, ptr %arrayidx1199, align 2 -> Cost: 1 -> VectorType: <vscale x 1 x i16> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %257 = load i16, ptr %arrayidx1199, align 2 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MemoryOpCost(1)
========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1197.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %256 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1608 = phi 0, %indvars.iv.next1609, ir<1>
    WIDEN-REDUCTION-PHI ir<%or120315831585> = phi ir<0>, ir<%or1203>
    CLONE ir<%arrayidx1199> = getelementptr inbounds ir<@spill_regs>, ir<0>, ir<%indvars.iv1608>
    CLONE ir<%257> = load ir<%arrayidx1199>
    CLONE ir<%conv1200> = sext ir<%257>
    CLONE ir<%sh_prom1201> = and ir<%conv1200>, ir<4294967295>
    CLONE ir<%shl1202> = shl nuw ir<1>, ir<%sh_prom1201>
    CLONE ir<%or1203> = or ir<%shl1202>, ir<%or120315831585>
    CLONE ir<%indvars.iv.next1609> = add nuw nsw ir<%indvars.iv1608>, ir<1>
    CLONE ir<%exitcond1610.not> = icmp eq ir<%indvars.iv.next1609>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or120315831585>, ir<%or1203>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond1194.for.end1206_crit_edge>, scalar.ph

ir-bb<for.cond1194.for.end1206_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1203.lcssa = vp<%6>
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1197.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %256 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1608 = phi 0, %indvars.iv.next1609, ir<1>
    WIDEN-REDUCTION-PHI ir<%or120315831585> = phi ir<0>, ir<%or1203>
    CLONE ir<%arrayidx1199> = getelementptr inbounds ir<@spill_regs>, ir<0>, ir<%indvars.iv1608>
    vp<%4> = vector-pointer ir<%arrayidx1199>
    WIDEN ir<%257> = load vp<%4>
    WIDEN-CAST ir<%conv1200> = sext  ir<%257> to i64
    WIDEN ir<%sh_prom1201> = and ir<%conv1200>, ir<4294967295>
    WIDEN ir<%shl1202> = shl nuw ir<1>, ir<%sh_prom1201>
    WIDEN ir<%or1203> = or ir<%shl1202>, ir<%or120315831585>
    CLONE ir<%indvars.iv.next1609> = add nuw nsw ir<%indvars.iv1608>, ir<1>
    CLONE ir<%exitcond1610.not> = icmp eq ir<%indvars.iv.next1609>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%or120315831585>, ir<%or1203>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond1194.for.end1206_crit_edge>, scalar.ph

ir-bb<for.cond1194.for.end1206_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1203.lcssa = vp<%7>
}

========== Loop: reload' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1197.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %256 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1608 = phi 0, %indvars.iv.next1609, ir<1>
    WIDEN-REDUCTION-PHI ir<%or120315831585> = phi ir<0>, ir<%or1203>
    CLONE ir<%arrayidx1199> = getelementptr inbounds ir<@spill_regs>, ir<0>, ir<%indvars.iv1608>
    vp<%4> = vector-pointer ir<%arrayidx1199>
    WIDEN ir<%257> = load vp<%4>
    WIDEN-CAST ir<%conv1200> = sext  ir<%257> to i64
    WIDEN ir<%sh_prom1201> = and ir<%conv1200>, ir<4294967295>
    WIDEN ir<%shl1202> = shl nuw ir<1>, ir<%sh_prom1201>
    WIDEN ir<%or1203> = or ir<%shl1202>, ir<%or120315831585>
    CLONE ir<%indvars.iv.next1609> = add nuw nsw ir<%indvars.iv1608>, ir<1>
    CLONE ir<%exitcond1610.not> = icmp eq ir<%indvars.iv.next1609>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%or120315831585>, ir<%or1203>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond1194.for.end1206_crit_edge>, scalar.ph

ir-bb<for.cond1194.for.end1206_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1203.lcssa = vp<%7>
}


-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1608 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1609, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1608 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %257 = load i16, ptr %arrayidx1199, align 2 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv1200 = sext i16 %257 to i64 of type:sext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1609 = add nuw nsw i64 %indvars.iv1608, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1610.not = icmp eq i64 %indvars.iv.next1609, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1610.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1608 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1609, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1608 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %257 = load i16, ptr %arrayidx1199, align 2 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1200 = sext i16 %257 to i64 of type:sext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1609 = add nuw nsw i64 %indvars.iv1608, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1610.not = icmp eq i64 %indvars.iv.next1609, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1610.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192767, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192767, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1608 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1609, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1608 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %257 = load i16, ptr %arrayidx1199, align 2 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %conv1200 = sext i16 %257 to i64 of type:sext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next1609 = add nuw nsw i64 %indvars.iv1608, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1610.not = icmp eq i64 %indvars.iv.next1609, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1610.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5905580039, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5905580039, RTCostB: 7516192767
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1608 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1609, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1608 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %257 = load i16, ptr %arrayidx1199, align 2 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv1200 = sext i16 %257 to i64 of type:sext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1609 = add nuw nsw i64 %indvars.iv1608, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1610.not = icmp eq i64 %indvars.iv.next1609, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1610.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7516192767, RTCostB: 12884901882
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192767, RTCostB: 5905580039

-----------------Function that is being costed:'reload' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1608 = phi i64 [ 0, %for.body1197.preheader ], [ %indvars.iv.next1609, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or120315831585 = phi i64 [ 0, %for.body1197.preheader ], [ %or1203, %for.body1197 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1199 = getelementptr inbounds [53 x i16], ptr @spill_regs, i64 0, i64 %indvars.iv1608 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %257 = load i16, ptr %arrayidx1199, align 2 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %conv1200 = sext i16 %257 to i64 of type:sext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom1201 = and i64 %conv1200, 4294967295 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl1202 = shl nuw i64 1, %sh_prom1201 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or1203 = or i64 %shl1202, %or120315831585 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next1609 = add nuw nsw i64 %indvars.iv1608, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1610.not = icmp eq i64 %indvars.iv.next1609, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1610.not, label %for.cond1194.for.end1206_crit_edge, label %for.body1197 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5905580039, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5905580039, RTCostB: 5905580039
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: reload at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1197.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %256 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%or120315831585> = phi ir<0>, ir<%or1203>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx1199> = getelementptr inbounds ir<@spill_regs>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx1199>
    WIDEN ir<%257> = load vp<%5>
    WIDEN-CAST ir<%conv1200> = sext  ir<%257> to i64
    WIDEN ir<%sh_prom1201> = and ir<%conv1200>, ir<4294967295>
    WIDEN ir<%shl1202> = shl nuw ir<1>, ir<%sh_prom1201>
    WIDEN ir<%or1203> = or ir<%shl1202>, ir<%or120315831585>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%or120315831585>, ir<%or1203>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1194.for.end1206_crit_edge>, scalar.ph

ir-bb<for.cond1194.for.end1206_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1203.lcssa = vp<%8>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 19
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %7 = load ptr, ptr %arrayidx25, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load ptr, ptr %arrayidx25, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %7 = load ptr, ptr %arrayidx25, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load ptr, ptr %arrayidx25, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: maybe_fix_stack_asms' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body21.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%14>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%clobbered.0348> = phi ir<0>, ir<%clobbered.1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    CLONE ir<%7> = load ir<%arrayidx25>
    CLONE ir<%bf.load26> = load ir<%7>
    CLONE ir<%bf.clear27> = and ir<%bf.load26>, ir<65535>
    CLONE ir<%cmp28> = icmp eq ir<%bf.clear27>, ir<49>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%fld30> = getelementptr inbounds ir<%7>, ir<8>
    CLONE ir<%8> = load ir<%fld30>, ir<%cmp28>
    CLONE ir<%bf.load32> = load ir<%8>, ir<%cmp28>
    CLONE ir<%bf.clear33> = and ir<%bf.load32>, ir<65535>
    CLONE ir<%cmp34> = icmp eq ir<%bf.clear33>, ir<61>
  Successor(s): land.lhs.true36

  land.lhs.true36:
    EMIT vp<%4> = logical-and ir<%cmp28>, ir<%cmp34>
    CLONE ir<%fld39> = getelementptr inbounds ir<%8>, ir<8>
    CLONE ir<%9> = load ir<%fld39>, vp<%4>
    CLONE ir<%10> = and ir<%9>, ir<-8>
    CLONE ir<%or.cond339> = icmp eq ir<%10>, ir<8>
  Successor(s): if.then50

  if.then50:
    EMIT vp<%5> = logical-and vp<%4>, ir<%or.cond339>
    CLONE ir<%sh_prom> = zext nneg ir<%9>
    CLONE ir<%shl> = shl nuw nsw ir<1>, ir<%sh_prom>
    CLONE ir<%or> = or ir<%shl>, ir<%clobbered.0348>
  Successor(s): if.end55

  if.end55:
    EMIT vp<%6> = not ir<%or.cond339>
    EMIT vp<%7> = logical-and vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%5>, vp<%7>
    EMIT vp<%9> = not ir<%cmp34>
    EMIT vp<%10> = logical-and ir<%cmp28>, vp<%9>
    EMIT vp<%11> = or vp<%8>, vp<%10>
    EMIT vp<%12> = not ir<%cmp28>
    EMIT vp<%13> = or vp<%11>, vp<%12>
    BLEND ir<%clobbered.1> = ir<%or> ir<%clobbered.0348>/vp<%7> ir<%clobbered.0348>/vp<%10> ir<%clobbered.0348>/vp<%12>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%14> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%14>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%16> = compute-reduction-result ir<%clobbered.0348>, ir<%clobbered.1>
  EMIT vp<%17> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%17>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %clobbered.1.lcssa = vp<%16>
}

========== Loop: maybe_fix_stack_asms' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body21.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%clobbered.0348> = phi ir<0>, ir<%clobbered.1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx25>
    WIDEN ir<%7> = load vp<%4>
    WIDEN ir<%bf.load26> = load ir<%7>
    WIDEN ir<%bf.clear27> = and ir<%bf.load26>, ir<65535>
    WIDEN ir<%cmp28> = icmp eq ir<%bf.clear27>, ir<49>
  Successor(s): land.lhs.true

  land.lhs.true:
    WIDEN-GEP Var[Inv] ir<%fld30> = getelementptr inbounds ir<%7>, ir<8>
    WIDEN ir<%8> = load ir<%fld30>, ir<%cmp28>
    WIDEN ir<%bf.load32> = load ir<%8>, ir<%cmp28>
    WIDEN ir<%bf.clear33> = and ir<%bf.load32>, ir<65535>
    WIDEN ir<%cmp34> = icmp eq ir<%bf.clear33>, ir<61>
  Successor(s): land.lhs.true36

  land.lhs.true36:
    EMIT vp<%5> = logical-and ir<%cmp28>, ir<%cmp34>
    WIDEN-GEP Var[Inv] ir<%fld39> = getelementptr inbounds ir<%8>, ir<8>
    WIDEN ir<%9> = load ir<%fld39>, vp<%5>
    WIDEN ir<%10> = and ir<%9>, ir<-8>
    WIDEN ir<%or.cond339> = icmp eq ir<%10>, ir<8>
  Successor(s): if.then50

  if.then50:
    EMIT vp<%6> = logical-and vp<%5>, ir<%or.cond339>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%9> to i64
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%clobbered.0348>
  Successor(s): if.end55

  if.end55:
    EMIT vp<%7> = not ir<%or.cond339>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    EMIT vp<%10> = not ir<%cmp34>
    EMIT vp<%11> = logical-and ir<%cmp28>, vp<%10>
    EMIT vp<%12> = or vp<%9>, vp<%11>
    EMIT vp<%13> = not ir<%cmp28>
    EMIT vp<%14> = or vp<%12>, vp<%13>
    BLEND ir<%clobbered.1> = ir<%or> ir<%clobbered.0348>/vp<%8> ir<%clobbered.0348>/vp<%11> ir<%clobbered.0348>/vp<%13>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = compute-reduction-result ir<%clobbered.0348>, ir<%clobbered.1>
  EMIT vp<%18> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%18>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %clobbered.1.lcssa = vp<%17>
}

========== Loop: maybe_fix_stack_asms' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body21.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%15>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%clobbered.0348> = phi ir<0>, ir<%clobbered.1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx25>
    WIDEN ir<%7> = load vp<%4>
    WIDEN ir<%bf.load26> = load ir<%7>
    WIDEN ir<%bf.clear27> = and ir<%bf.load26>, ir<65535>
    WIDEN ir<%cmp28> = icmp eq ir<%bf.clear27>, ir<49>
  Successor(s): land.lhs.true

  land.lhs.true:
    WIDEN-GEP Var[Inv] ir<%fld30> = getelementptr inbounds ir<%7>, ir<8>
    WIDEN ir<%8> = load ir<%fld30>, ir<%cmp28>
    WIDEN ir<%bf.load32> = load ir<%8>, ir<%cmp28>
    WIDEN ir<%bf.clear33> = and ir<%bf.load32>, ir<65535>
    WIDEN ir<%cmp34> = icmp eq ir<%bf.clear33>, ir<61>
  Successor(s): land.lhs.true36

  land.lhs.true36:
    EMIT vp<%5> = logical-and ir<%cmp28>, ir<%cmp34>
    WIDEN-GEP Var[Inv] ir<%fld39> = getelementptr inbounds ir<%8>, ir<8>
    WIDEN ir<%9> = load ir<%fld39>, vp<%5>
    WIDEN ir<%10> = and ir<%9>, ir<-8>
    WIDEN ir<%or.cond339> = icmp eq ir<%10>, ir<8>
  Successor(s): if.then50

  if.then50:
    EMIT vp<%6> = logical-and vp<%5>, ir<%or.cond339>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%9> to i64
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%clobbered.0348>
  Successor(s): if.end55

  if.end55:
    EMIT vp<%7> = not ir<%or.cond339>
    EMIT vp<%8> = logical-and vp<%5>, vp<%7>
    EMIT vp<%9> = or vp<%6>, vp<%8>
    EMIT vp<%10> = not ir<%cmp34>
    EMIT vp<%11> = logical-and ir<%cmp28>, vp<%10>
    EMIT vp<%12> = or vp<%9>, vp<%11>
    EMIT vp<%13> = not ir<%cmp28>
    EMIT vp<%14> = or vp<%12>, vp<%13>
    BLEND ir<%clobbered.1> = ir<%or> ir<%clobbered.0348>/vp<%8> ir<%clobbered.0348>/vp<%11> ir<%clobbered.0348>/vp<%13>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%15> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%15>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%17> = compute-reduction-result ir<%clobbered.0348>, ir<%clobbered.1>
  EMIT vp<%18> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%18>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %clobbered.1.lcssa = vp<%17>
}


-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %8 = load ptr, ptr %fld30, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load i32, ptr %fld39, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Scalar loop costs: 10.
-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %8 = load ptr, ptr %fld30, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %9 = load i32, ptr %fld39, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 3 for VF 2 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Vector loop of width 2 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 24696061939, RTCostB: 21474836470
A is not scalable.	B is not scalable.	
RTCostA: 24696061939, RTCostB: 21474836470

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %8 = load ptr, ptr %fld30, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %9 = load i32, ptr %fld39, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 6 for VF 4 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Vector loop of width 4 costs: 9
A is not scalable.	B is not scalable.	
RTCostA: 20401094648, RTCostB: 21474836470
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 20401094648, RTCostB: 21474836470
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %8 = load ptr, ptr %fld30, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %9 = load i32, ptr %fld39, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Vector loop of width vscale x 1 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 24696061939, RTCostB: 21474836470
A is scalable.	B is not scalable.	
RTCostA: 24696061939, RTCostB: 20401094648

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body21.lr.ph ], [ %indvars.iv.next, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %clobbered.0348 = phi i64 [ 0, %for.body21.lr.ph ], [ %clobbered.1, %if.end55 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx25 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %7 = load ptr, ptr %arrayidx25, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %bf.load26 = load i32, ptr %7, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear27 = and i32 %bf.load26, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp28 = icmp eq i32 %bf.clear27, 49 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp28, label %land.lhs.true, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fld30 = getelementptr inbounds i8, ptr %7, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %8 = load ptr, ptr %fld30, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %bf.load32 = load i32, ptr %8, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear33 = and i32 %bf.load32, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp34 = icmp eq i32 %bf.clear33, 61 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp34, label %land.lhs.true36, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fld39 = getelementptr inbounds i8, ptr %8, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %9 = load i32, ptr %fld39, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %10 = and i32 %9, -8 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond339 = icmp eq i32 %10, 8 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %or.cond339, label %if.then50, label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %9 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw nsw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %shl, %clobbered.0348 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %if.end55 of type:br

-----------------Function that is being costed:'maybe_fix_stack_asms' from reload1.c-----------------
LV: Found an estimated cost of 6 for VF vscale x 2 For instruction:   %clobbered.1 = phi i64 [ %or, %if.then50 ], [ %clobbered.0348, %land.lhs.true36 ], [ %clobbered.0348, %land.lhs.true ], [ %clobbered.0348, %for.body21 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body21 of type:br
LV: Vector loop of width vscale x 2 costs: 9
A is scalable.	B is not scalable.	
RTCostA: 20401094648, RTCostB: 21474836470
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 20401094648, RTCostB: 20401094648
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 9.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: maybe_fix_stack_asms at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body21.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %6 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    WIDEN-REDUCTION-PHI ir<%clobbered.0348> = phi ir<0>, ir<%clobbered.1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx25> = getelementptr inbounds ir<%elem>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx25>
    WIDEN ir<%7> = load vp<%5>
    WIDEN ir<%bf.load26> = load ir<%7>
    WIDEN ir<%bf.clear27> = and ir<%bf.load26>, ir<65535>
    WIDEN ir<%cmp28> = icmp eq ir<%bf.clear27>, ir<49>
    WIDEN-GEP Var[Inv] ir<%fld30> = getelementptr inbounds ir<%7>, ir<8>
    WIDEN ir<%8> = load ir<%fld30>, ir<%cmp28>
    WIDEN ir<%bf.load32> = load ir<%8>, ir<%cmp28>
    WIDEN ir<%bf.clear33> = and ir<%bf.load32>, ir<65535>
    WIDEN ir<%cmp34> = icmp eq ir<%bf.clear33>, ir<61>
    EMIT vp<%6> = logical-and ir<%cmp28>, ir<%cmp34>
    WIDEN-GEP Var[Inv] ir<%fld39> = getelementptr inbounds ir<%8>, ir<8>
    WIDEN ir<%9> = load ir<%fld39>, vp<%6>
    WIDEN ir<%10> = and ir<%9>, ir<-8>
    WIDEN ir<%or.cond339> = icmp eq ir<%10>, ir<8>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%9> to i64
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%sh_prom>
    WIDEN ir<%or> = or ir<%shl>, ir<%clobbered.0348>
    EMIT vp<%7> = not ir<%or.cond339>
    EMIT vp<%8> = logical-and vp<%6>, vp<%7>
    EMIT vp<%9> = not ir<%cmp34>
    EMIT vp<%10> = logical-and ir<%cmp28>, vp<%9>
    EMIT vp<%11> = not ir<%cmp28>
    BLEND ir<%clobbered.1> = ir<%or> ir<%clobbered.0348>/vp<%8> ir<%clobbered.0348>/vp<%10> ir<%clobbered.0348>/vp<%11>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = compute-reduction-result ir<%clobbered.0348>, ir<%clobbered.1>
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %clobbered.1.lcssa = vp<%14>
}
================ Final VPlan ================

================================================
Loops Vectorized: 7
Loops Analyzed: 25
Loops Epilogues Vectorized: 0
================================================
========== Loop: clear_reload_reg_in_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body191.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %end_regno.3 to i64) + (-1 * (zext i32 %start_regno.3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv286 = phi %25, %indvars.iv.next287, ir<1>
    WIDEN-REDUCTION-PHI ir<%and192284> = phi ir<%used_in_set.0273.promoted>, ir<%and192>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%indvars.iv286>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and192> = and ir<%and192284>, ir<%not>
    CLONE ir<%indvars.iv.next287> = add nuw nsw ir<%indvars.iv286>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next287>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and192284>, ir<%and192>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond188.for.end194_crit_edge>, scalar.ph

ir-bb<for.cond188.for.end194_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and192.lcssa = vp<%6>
}

========== Loop: clear_reload_reg_in_use' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body191.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %end_regno.3 to i64) + (-1 * (zext i32 %start_regno.3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv286 = phi %25, %indvars.iv.next287, ir<1>
    WIDEN-REDUCTION-PHI ir<%and192284> = phi ir<%used_in_set.0273.promoted>, ir<%and192>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv286>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and192> = and ir<%and192284>, ir<%not>
    WIDEN ir<%indvars.iv.next287> = add nuw nsw ir<%indvars.iv286>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next287>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and192284>, ir<%and192>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond188.for.end194_crit_edge>, scalar.ph

ir-bb<for.cond188.for.end194_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and192.lcssa = vp<%6>
}

========== Loop: clear_reload_reg_in_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body191.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %end_regno.3 to i64) + (-1 * (zext i32 %start_regno.3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv286 = phi %25, %indvars.iv.next287, ir<1>
    WIDEN-REDUCTION-PHI ir<%and192284> = phi ir<%used_in_set.0273.promoted>, ir<%and192>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv286>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and192> = and ir<%and192284>, ir<%not>
    WIDEN ir<%indvars.iv.next287> = add nuw nsw ir<%indvars.iv286>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next287>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and192284>, ir<%and192>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond188.for.end194_crit_edge>, scalar.ph

ir-bb<for.cond188.for.end194_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and192.lcssa = vp<%6>
}


-----------------Function that is being costed:'clear_reload_reg_in_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv286 = phi i64 [ %25, %for.body191.lr.ph ], [ %indvars.iv.next287, %for.body191 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and192284 = phi i64 [ %used_in_set.0273.promoted, %for.body191.lr.ph ], [ %and192, %for.body191 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv286 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and192 = and i64 %and192284, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next287 = add nuw nsw i64 %indvars.iv286, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next287, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond188.for.end194_crit_edge, label %for.body191 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'clear_reload_reg_in_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv286 = phi i64 [ %25, %for.body191.lr.ph ], [ %indvars.iv.next287, %for.body191 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and192284 = phi i64 [ %used_in_set.0273.promoted, %for.body191.lr.ph ], [ %and192, %for.body191 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv286 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and192 = and i64 %and192284, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next287 = add nuw nsw i64 %indvars.iv286, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next287, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond188.for.end194_crit_edge, label %for.body191 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'clear_reload_reg_in_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv286 = phi i64 [ %25, %for.body191.lr.ph ], [ %indvars.iv.next287, %for.body191 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and192284 = phi i64 [ %used_in_set.0273.promoted, %for.body191.lr.ph ], [ %and192, %for.body191 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %indvars.iv286 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and192 = and i64 %and192284, %not of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next287 = add nuw nsw i64 %indvars.iv286, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next287, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond188.for.end194_crit_edge, label %for.body191 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'clear_reload_reg_in_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv286 = phi i64 [ %25, %for.body191.lr.ph ], [ %indvars.iv.next287, %for.body191 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and192284 = phi i64 [ %used_in_set.0273.promoted, %for.body191.lr.ph ], [ %and192, %for.body191 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %indvars.iv286 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and192 = and i64 %and192284, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next287 = add nuw nsw i64 %indvars.iv286, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next287, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond188.for.end194_crit_edge, label %for.body191 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'clear_reload_reg_in_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv286 = phi i64 [ %25, %for.body191.lr.ph ], [ %indvars.iv.next287, %for.body191 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and192284 = phi i64 [ %used_in_set.0273.promoted, %for.body191.lr.ph ], [ %and192, %for.body191 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %indvars.iv286 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and192 = and i64 %and192284, %not of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next287 = add nuw nsw i64 %indvars.iv286, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next287, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond188.for.end194_crit_edge, label %for.body191 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: clear_reload_reg_in_use at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body191.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 %end_regno.3 to i64) + (-1 * (zext i32 %start_regno.3 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv286 = phi %25, %indvars.iv.next287, ir<1>
    WIDEN-REDUCTION-PHI ir<%and192284> = phi ir<%used_in_set.0273.promoted>, ir<%and192>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%indvars.iv286>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and192> = and ir<%and192284>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and192284>, ir<%and192>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond188.for.end194_crit_edge>, scalar.ph

ir-bb<for.cond188.for.end194_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and192.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 55
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %arrayidx45, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv1137 = phi 0, %indvars.iv.next1138, ir<1>
    CLONE ir<%arrayidx43> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1137>
    CLONE ir<%store_ruid> = getelementptr inbounds ir<%arrayidx43>, ir<112>
    CLONE store ir<0>, ir<%store_ruid>
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1137>
    CLONE ir<%16> = load ir<%arrayidx45>
    CLONE ir<%tobool46.not> = icmp eq ir<%16>, ir<0>
    CLONE ir<%spec.select1157> = select ir<%tobool46.not>, ir<6>, ir<-1>
    CLONE ir<%17> = getelementptr inbounds ir<%arrayidx43>, ir<96>
    CLONE store ir<%spec.select1157>, ir<%17>
    CLONE ir<%indvars.iv.next1138> = add nuw nsw ir<%indvars.iv1137>, ir<1>
    CLONE ir<%exitcond1139.not> = icmp eq ir<%indvars.iv.next1138>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end56>, scalar.ph

ir-bb<for.end56>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1137 = phi 0, %indvars.iv.next1138, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx43> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1137>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx43>, ir<112>
    WIDEN store ir<%store_ruid>, ir<0>
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1137>
    vp<%3> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%16> = load vp<%3>
    WIDEN ir<%tobool46.not> = icmp eq ir<%16>, ir<0>
    WIDEN-SELECT ir<%spec.select1157> = select ir<%tobool46.not>, ir<6>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%17> = getelementptr inbounds ir<%arrayidx43>, ir<96>
    WIDEN store ir<%17>, ir<%spec.select1157>
    WIDEN ir<%indvars.iv.next1138> = add nuw nsw ir<%indvars.iv1137>, ir<1>
    CLONE ir<%exitcond1139.not> = icmp eq ir<%indvars.iv.next1138>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end56>, scalar.ph

ir-bb<for.end56>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1137 = phi 0, %indvars.iv.next1138, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx43> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1137>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx43>, ir<112>
    WIDEN store ir<%store_ruid>, ir<0>
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1137>
    vp<%3> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%16> = load vp<%3>
    WIDEN ir<%tobool46.not> = icmp eq ir<%16>, ir<0>
    WIDEN-SELECT ir<%spec.select1157> = select ir<%tobool46.not>, ir<6>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%17> = getelementptr inbounds ir<%arrayidx43>, ir<96>
    WIDEN store ir<%17>, ir<%spec.select1157>
    WIDEN ir<%indvars.iv.next1138> = add nuw nsw ir<%indvars.iv1137>, ir<1>
    CLONE ir<%exitcond1139.not> = icmp eq ir<%indvars.iv.next1138>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end56>, scalar.ph

ir-bb<for.end56>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1137 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1138, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 0, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %16 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select1157 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %spec.select1157, ptr %17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1138 = add nuw nsw i64 %indvars.iv1137, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1139.not = icmp eq i64 %indvars.iv.next1138, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1139.not, label %for.end56, label %for.body41 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1137 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1138, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 0, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %16 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select1157 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %spec.select1157, ptr %17, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1138 = add nuw nsw i64 %indvars.iv1137, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1139.not = icmp eq i64 %indvars.iv.next1138, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1139.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 241, RTCostB: 371
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 241, RTCostB: 371
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1137 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1138, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 0, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %16 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select1157 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %spec.select1157, ptr %17, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1138 = add nuw nsw i64 %indvars.iv1137, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1139.not = icmp eq i64 %indvars.iv.next1138, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1139.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 189, RTCostB: 371
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 189, RTCostB: 241
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1137 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1138, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 0, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %16 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select1157 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF 8 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %spec.select1157, ptr %17, align 8 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next1138 = add nuw nsw i64 %indvars.iv1137, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1139.not = icmp eq i64 %indvars.iv.next1138, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1139.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 185, RTCostB: 371
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 185, RTCostB: 189
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1137 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1138, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 0, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %16 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select1157 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %spec.select1157, ptr %17, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1138 = add nuw nsw i64 %indvars.iv1137, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1139.not = icmp eq i64 %indvars.iv.next1138, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1139.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 241, RTCostB: 371
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 241, RTCostB: 185

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1137 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1138, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 0, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %16 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select1157 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %spec.select1157, ptr %17, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1138 = add nuw nsw i64 %indvars.iv1137, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1139.not = icmp eq i64 %indvars.iv.next1138, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1139.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 189, RTCostB: 371
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 189, RTCostB: 185

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1137 = phi i64 [ 0, %for.end37 ], [ %indvars.iv.next1138, %for.body41 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx43 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx43, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 0, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx45 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1137 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %16 = load i8, ptr %arrayidx45, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool46.not = icmp eq i8 %16, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %spec.select1157 = select i1 %tobool46.not, i32 6, i32 -1 of type:select
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %17 = getelementptr inbounds i8, ptr %arrayidx43, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 %spec.select1157, ptr %17, align 8 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next1138 = add nuw nsw i64 %indvars.iv1137, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1139.not = icmp eq i64 %indvars.iv.next1138, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1139.not, label %for.end56, label %for.body41 of type:br
LV: Vector loop of width vscale x 4 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 185, RTCostB: 371
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 185, RTCostB: 185
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: reload_combine at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1137 = phi 0, %indvars.iv.next1138, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx43> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1137>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx43>, ir<112>
    WIDEN store ir<%store_ruid>, ir<0>
    CLONE ir<%arrayidx45> = getelementptr inbounds ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx45>
    WIDEN ir<%16> = load vp<%4>
    WIDEN ir<%tobool46.not> = icmp eq ir<%16>, ir<0>
    WIDEN-SELECT ir<%spec.select1157> = select ir<%tobool46.not>, ir<6>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%17> = getelementptr inbounds ir<%arrayidx43>, ir<96>
    WIDEN store ir<%17>, ir<%spec.select1157>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end56>, scalar.ph

ir-bb<for.end56>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %95 = load i8, ptr %arrayidx611, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %95 = load i8, ptr %arrayidx611, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %95 = load i8, ptr %arrayidx611, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %95 = load i8, ptr %arrayidx611, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %95 = load i8, ptr %arrayidx611, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %95 = load i8, ptr %arrayidx611, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1148 = phi 0, %indvars.iv.next1149, ir<1>
    CLONE ir<%arrayidx611> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1148>
    CLONE ir<%95> = load ir<%arrayidx611>
    CLONE ir<%tobool612.not> = icmp eq ir<%95>, ir<0>
  Successor(s): if.then613

  if.then613:
    EMIT vp<%3> = not ir<%tobool612.not>
    CLONE ir<%arrayidx615> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1148>
    CLONE ir<%use_index616> = getelementptr inbounds ir<%arrayidx615>, ir<96>
    CLONE store ir<6>, ir<%use_index616>, vp<%3>
    CLONE ir<%store_ruid619> = getelementptr inbounds ir<%arrayidx615>, ir<112>
    CLONE store ir<%94>, ir<%store_ruid619>, vp<%3>
  Successor(s): for.inc621

  for.inc621:
    EMIT vp<%4> = or ir<%tobool612.not>, vp<%3>
    CLONE ir<%indvars.iv.next1149> = add nuw nsw ir<%indvars.iv1148>, ir<1>
    CLONE ir<%exitcond1150.not> = icmp eq ir<%indvars.iv.next1149>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end623>, scalar.ph

ir-bb<for.end623>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1148 = phi 0, %indvars.iv.next1149, ir<1>
    CLONE ir<%arrayidx611> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1148>
    vp<%3> = vector-pointer ir<%arrayidx611>
    WIDEN ir<%95> = load vp<%3>
    WIDEN ir<%tobool612.not> = icmp eq ir<%95>, ir<0>
  Successor(s): if.then613

  if.then613:
    EMIT vp<%4> = not ir<%tobool612.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx615> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1148>
    WIDEN-GEP Var[Inv] ir<%use_index616> = getelementptr inbounds ir<%arrayidx615>, ir<96>
    WIDEN store ir<%use_index616>, ir<6>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%store_ruid619> = getelementptr inbounds ir<%arrayidx615>, ir<112>
    WIDEN store ir<%store_ruid619>, ir<%94>, vp<%4>
  Successor(s): for.inc621

  for.inc621:
    EMIT vp<%5> = or ir<%tobool612.not>, vp<%4>
    WIDEN ir<%indvars.iv.next1149> = add nuw nsw ir<%indvars.iv1148>, ir<1>
    CLONE ir<%exitcond1150.not> = icmp eq ir<%indvars.iv.next1149>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end623>, scalar.ph

ir-bb<for.end623>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1148 = phi 0, %indvars.iv.next1149, ir<1>
    CLONE ir<%arrayidx611> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv1148>
    vp<%3> = vector-pointer ir<%arrayidx611>
    WIDEN ir<%95> = load vp<%3>
    WIDEN ir<%tobool612.not> = icmp eq ir<%95>, ir<0>
  Successor(s): if.then613

  if.then613:
    EMIT vp<%4> = not ir<%tobool612.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx615> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1148>
    WIDEN-GEP Var[Inv] ir<%use_index616> = getelementptr inbounds ir<%arrayidx615>, ir<96>
    WIDEN store ir<%use_index616>, ir<6>, vp<%4>
    WIDEN-GEP Var[Inv] ir<%store_ruid619> = getelementptr inbounds ir<%arrayidx615>, ir<112>
    WIDEN store ir<%store_ruid619>, ir<%94>, vp<%4>
  Successor(s): for.inc621

  for.inc621:
    EMIT vp<%5> = or ir<%tobool612.not>, vp<%4>
    WIDEN ir<%indvars.iv.next1149> = add nuw nsw ir<%indvars.iv1148>, ir<1>
    CLONE ir<%exitcond1150.not> = icmp eq ir<%indvars.iv.next1149>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end623>, scalar.ph

ir-bb<for.end623>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1148 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1149, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %95 = load i8, ptr %arrayidx611, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool612.not = icmp eq i8 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 6, ptr %use_index616, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %94, ptr %store_ruid619, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1149 = add nuw nsw i64 %indvars.iv1148, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1150.not = icmp eq i64 %indvars.iv.next1149, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1150.not, label %for.end623, label %for.body609 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1148 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1149, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %95 = load i8, ptr %arrayidx611, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool612.not = icmp eq i8 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 6, ptr %use_index616, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %94, ptr %store_ruid619, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1149 = add nuw nsw i64 %indvars.iv1148, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1150.not = icmp eq i64 %indvars.iv.next1149, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1150.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 213, RTCostB: 265
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 213, RTCostB: 265
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1148 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1149, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %95 = load i8, ptr %arrayidx611, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool612.not = icmp eq i8 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 6, ptr %use_index616, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %94, ptr %store_ruid619, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1149 = add nuw nsw i64 %indvars.iv1148, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1150.not = icmp eq i64 %indvars.iv.next1149, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1150.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 174, RTCostB: 265
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 174, RTCostB: 213
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1148 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1149, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %95 = load i8, ptr %arrayidx611, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool612.not = icmp eq i8 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 6, ptr %use_index616, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %94, ptr %store_ruid619, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next1149 = add nuw nsw i64 %indvars.iv1148, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1150.not = icmp eq i64 %indvars.iv.next1149, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1150.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 163, RTCostB: 265
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 163, RTCostB: 174
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1148 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1149, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %95 = load i8, ptr %arrayidx611, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool612.not = icmp eq i8 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 6, ptr %use_index616, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %94, ptr %store_ruid619, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1149 = add nuw nsw i64 %indvars.iv1148, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1150.not = icmp eq i64 %indvars.iv.next1149, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1150.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 213, RTCostB: 265
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 213, RTCostB: 163

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1148 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1149, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %95 = load i8, ptr %arrayidx611, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool612.not = icmp eq i8 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 6, ptr %use_index616, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %94, ptr %store_ruid619, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1149 = add nuw nsw i64 %indvars.iv1148, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1150.not = icmp eq i64 %indvars.iv.next1149, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1150.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 174, RTCostB: 265
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 174, RTCostB: 163

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1148 = phi i64 [ 0, %for.cond606.preheader ], [ %indvars.iv.next1149, %for.inc621 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx611 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %95 = load i8, ptr %arrayidx611, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool612.not = icmp eq i8 %95, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool612.not, label %for.inc621, label %if.then613 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx615 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1148 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index616 = getelementptr inbounds i8, ptr %arrayidx615, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 6, ptr %use_index616, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %store_ruid619 = getelementptr inbounds i8, ptr %arrayidx615, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 %94, ptr %store_ruid619, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc621 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next1149 = add nuw nsw i64 %indvars.iv1148, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1150.not = icmp eq i64 %indvars.iv.next1149, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1150.not, label %for.end623, label %for.body609 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 163, RTCostB: 265
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 163, RTCostB: 163
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: reload_combine at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1148 = phi 0, %indvars.iv.next1149, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx611> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx611>
    WIDEN ir<%95> = load vp<%4>
    WIDEN ir<%tobool612.not> = icmp eq ir<%95>, ir<0>
    EMIT vp<%5> = not ir<%tobool612.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx615> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1148>
    WIDEN-GEP Var[Inv] ir<%use_index616> = getelementptr inbounds ir<%arrayidx615>, ir<96>
    WIDEN store ir<%use_index616>, ir<6>, vp<%5>
    WIDEN-GEP Var[Inv] ir<%store_ruid619> = getelementptr inbounds ir<%arrayidx615>, ir<112>
    WIDEN store ir<%store_ruid619>, ir<%94>, vp<%5>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end623>, scalar.ph

ir-bb<for.end623>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1146 = phi 52, %indvars.iv.next1147, ir<-1>
    CLONE ir<%shl794> = shl nuw ir<1>, ir<%indvars.iv1146>
    CLONE ir<%and795> = and ir<%live769.0.sroa.speculated>, ir<%shl794>
    CLONE ir<%tobool796.not> = icmp eq ir<%and795>, ir<0>
  Successor(s): if.then797

  if.then797:
    EMIT vp<%3> = not ir<%tobool796.not>
    CLONE ir<%use_index800> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1146>, ir<1>
    CLONE store ir<-1>, ir<%use_index800>, vp<%3>
  Successor(s): for.inc802

  for.inc802:
    EMIT vp<%4> = or ir<%tobool796.not>, vp<%3>
    CLONE ir<%indvars.iv.next1147> = add nsw ir<%indvars.iv1146>, ir<-1>
    CLONE ir<%cmp790.not> = icmp eq ir<%indvars.iv1146>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end806.loopexit1159>, scalar.ph

ir-bb<if.end806.loopexit1159>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1146 = phi 52, %indvars.iv.next1147, ir<-1>
    WIDEN ir<%shl794> = shl nuw ir<1>, ir<%indvars.iv1146>
    WIDEN ir<%and795> = and ir<%live769.0.sroa.speculated>, ir<%shl794>
    WIDEN ir<%tobool796.not> = icmp eq ir<%and795>, ir<0>
  Successor(s): if.then797

  if.then797:
    EMIT vp<%3> = not ir<%tobool796.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index800> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1146>, ir<1>
    WIDEN store ir<%use_index800>, ir<-1>, vp<%3>
  Successor(s): for.inc802

  for.inc802:
    EMIT vp<%4> = or ir<%tobool796.not>, vp<%3>
    WIDEN ir<%indvars.iv.next1147> = add nsw ir<%indvars.iv1146>, ir<-1>
    CLONE ir<%cmp790.not> = icmp eq ir<%indvars.iv1146>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end806.loopexit1159>, scalar.ph

ir-bb<if.end806.loopexit1159>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1146 = phi 52, %indvars.iv.next1147, ir<-1>
    WIDEN ir<%shl794> = shl nuw ir<1>, ir<%indvars.iv1146>
    WIDEN ir<%and795> = and ir<%live769.0.sroa.speculated>, ir<%shl794>
    WIDEN ir<%tobool796.not> = icmp eq ir<%and795>, ir<0>
  Successor(s): if.then797

  if.then797:
    EMIT vp<%3> = not ir<%tobool796.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index800> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1146>, ir<1>
    WIDEN store ir<%use_index800>, ir<-1>, vp<%3>
  Successor(s): for.inc802

  for.inc802:
    EMIT vp<%4> = or ir<%tobool796.not>, vp<%3>
    WIDEN ir<%indvars.iv.next1147> = add nsw ir<%indvars.iv1146>, ir<-1>
    CLONE ir<%cmp790.not> = icmp eq ir<%indvars.iv1146>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end806.loopexit1159>, scalar.ph

ir-bb<if.end806.loopexit1159>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1146 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1147, %for.inc802 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1146 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1146, i32 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -1, ptr %use_index800, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1147 = add nsw i64 %indvars.iv1146, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1146, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1159, label %for.body792 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1146 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1147, %for.inc802 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1146 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1146, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -1, ptr %use_index800, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1147 = add nsw i64 %indvars.iv1146, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1146, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1159, label %for.body792 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 187, RTCostB: 265
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 187, RTCostB: 265
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1146 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1147, %for.inc802 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1146 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1146, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 -1, ptr %use_index800, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1147 = add nsw i64 %indvars.iv1146, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1146, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1159, label %for.body792 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 174, RTCostB: 265
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 174, RTCostB: 187
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1146 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1147, %for.inc802 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1146 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1146, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 -1, ptr %use_index800, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next1147 = add nsw i64 %indvars.iv1146, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1146, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1159, label %for.body792 of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 175, RTCostB: 265
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 175, RTCostB: 174

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1146 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1147, %for.inc802 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1146 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1146, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 -1, ptr %use_index800, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1147 = add nsw i64 %indvars.iv1146, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1146, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1159, label %for.body792 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 187, RTCostB: 265
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 187, RTCostB: 174

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1146 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1147, %for.inc802 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1146 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1146, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 -1, ptr %use_index800, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1147 = add nsw i64 %indvars.iv1146, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1146, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1159, label %for.body792 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 174, RTCostB: 265
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 174, RTCostB: 174
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1146 = phi i64 [ 52, %if.end788 ], [ %indvars.iv.next1147, %for.inc802 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %shl794 = shl nuw i64 1, %indvars.iv1146 of type:shl
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %and795 = and i64 %live769.0.sroa.speculated, %shl794 of type:and
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %tobool796.not = icmp eq i64 %and795, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool796.not, label %for.inc802, label %if.then797 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index800 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1146, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 -1, ptr %use_index800, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc802 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next1147 = add nsw i64 %indvars.iv1146, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp790.not = icmp eq i64 %indvars.iv1146, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp790.not, label %if.end806.loopexit1159, label %for.body792 of type:br
LV: Vector loop of width vscale x 4 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 175, RTCostB: 265
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 175, RTCostB: 174
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: reload_combine at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1146 = phi 52, %indvars.iv.next1147, ir<-1>
    WIDEN ir<%shl794> = shl nuw ir<1>, ir<%indvars.iv1146>
    WIDEN ir<%and795> = and ir<%live769.0.sroa.speculated>, ir<%shl794>
    WIDEN ir<%tobool796.not> = icmp eq ir<%and795>, ir<0>
    EMIT vp<%3> = not ir<%tobool796.not>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index800> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1146>, ir<1>
    WIDEN store ir<%use_index800>, ir<-1>, vp<%3>
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end806.loopexit1159>, scalar.ph

ir-bb<if.end806.loopexit1159>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %40 = load i8, ptr %arrayidx77, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load i8, ptr %arrayidx77, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load i8, ptr %arrayidx77, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load i8, ptr %arrayidx77, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load i8, ptr %arrayidx77, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %40 = load i8, ptr %arrayidx77, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1140 = phi %indvars.iv.next1141, 0, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1140>
    CLONE ir<%40> = load ir<%arrayidx77>
    CLONE ir<%tobool78.not> = icmp eq ir<%40>, ir<0>
  Successor(s): if.then79

  if.then79:
    CLONE ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1140>, ir<1>
    CLONE store ir<6>, ir<%use_index82>, ir<%tobool78.not>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%3> = not ir<%tobool78.not>
    EMIT vp<%4> = or vp<%3>, ir<%tobool78.not>
    CLONE ir<%indvars.iv.next1141> = add nuw nsw ir<%indvars.iv1140>, ir<1>
    CLONE ir<%exitcond1142.not> = icmp eq ir<%indvars.iv.next1141>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1140 = phi %indvars.iv.next1141, 0, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1140>
    vp<%3> = vector-pointer ir<%arrayidx77>
    WIDEN ir<%40> = load vp<%3>
    WIDEN ir<%tobool78.not> = icmp eq ir<%40>, ir<0>
  Successor(s): if.then79

  if.then79:
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1140>, ir<1>
    WIDEN store ir<%use_index82>, ir<6>, ir<%tobool78.not>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%4> = not ir<%tobool78.not>
    EMIT vp<%5> = or vp<%4>, ir<%tobool78.not>
    WIDEN ir<%indvars.iv.next1141> = add nuw nsw ir<%indvars.iv1140>, ir<1>
    CLONE ir<%exitcond1142.not> = icmp eq ir<%indvars.iv.next1141>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1140 = phi %indvars.iv.next1141, 0, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, ir<%indvars.iv1140>
    vp<%3> = vector-pointer ir<%arrayidx77>
    WIDEN ir<%40> = load vp<%3>
    WIDEN ir<%tobool78.not> = icmp eq ir<%40>, ir<0>
  Successor(s): if.then79

  if.then79:
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1140>, ir<1>
    WIDEN store ir<%use_index82>, ir<6>, ir<%tobool78.not>
  Successor(s): for.inc84

  for.inc84:
    EMIT vp<%4> = not ir<%tobool78.not>
    EMIT vp<%5> = or vp<%4>, ir<%tobool78.not>
    WIDEN ir<%indvars.iv.next1141> = add nuw nsw ir<%indvars.iv1140>, ir<1>
    CLONE ir<%exitcond1142.not> = icmp eq ir<%indvars.iv.next1141>, ir<53>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1140 = phi i64 [ %indvars.iv.next1141, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1140 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %40 = load i8, ptr %arrayidx77, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool78.not = icmp eq i8 %40, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1140, i32 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 6, ptr %use_index82, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1141 = add nuw nsw i64 %indvars.iv1140, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1141, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1142.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1140 = phi i64 [ %indvars.iv.next1141, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1140 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %40 = load i8, ptr %arrayidx77, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool78.not = icmp eq i8 %40, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1140, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 6, ptr %use_index82, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1141 = add nuw nsw i64 %indvars.iv1140, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1141, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1142.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 160, RTCostB: 212
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 160, RTCostB: 212
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1140 = phi i64 [ %indvars.iv.next1141, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1140 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %40 = load i8, ptr %arrayidx77, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool78.not = icmp eq i8 %40, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1140, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 6, ptr %use_index82, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1141 = add nuw nsw i64 %indvars.iv1140, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1141, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1142.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 121, RTCostB: 212
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 121, RTCostB: 160
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv1140 = phi i64 [ %indvars.iv.next1141, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1140 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %40 = load i8, ptr %arrayidx77, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool78.not = icmp eq i8 %40, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1140, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 6, ptr %use_index82, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next1141 = add nuw nsw i64 %indvars.iv1140, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1141, 53 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond1142.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 110, RTCostB: 212
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 110, RTCostB: 121
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1140 = phi i64 [ %indvars.iv.next1141, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1140 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %40 = load i8, ptr %arrayidx77, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool78.not = icmp eq i8 %40, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1140, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 6, ptr %use_index82, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1141 = add nuw nsw i64 %indvars.iv1140, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1141, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1142.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 160, RTCostB: 212
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 160, RTCostB: 110

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1140 = phi i64 [ %indvars.iv.next1141, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1140 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %40 = load i8, ptr %arrayidx77, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool78.not = icmp eq i8 %40, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1140, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 6, ptr %use_index82, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1141 = add nuw nsw i64 %indvars.iv1140, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1141, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1142.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 121, RTCostB: 212
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 121, RTCostB: 110

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv1140 = phi i64 [ %indvars.iv.next1141, %for.inc84 ], [ 0, %for.body75.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx77 = getelementptr inbounds [53 x i8], ptr @fixed_regs, i64 0, i64 %indvars.iv1140 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %40 = load i8, ptr %arrayidx77, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool78.not = icmp eq i8 %40, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool78.not, label %if.then79, label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index82 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv1140, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 6, ptr %use_index82, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc84 of type:br

-----------------Function that is being costed:'reload_combine' from reload1.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next1141 = add nuw nsw i64 %indvars.iv1140, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond1142.not = icmp eq i64 %indvars.iv.next1141, 53 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond1142.not, label %if.end88.loopexit, label %for.body75 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 110, RTCostB: 212
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 110, RTCostB: 110
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: reload_combine at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv1140 = phi %indvars.iv.next1141, 0, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx77> = getelementptr inbounds ir<@fixed_regs>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx77>
    WIDEN ir<%40> = load vp<%4>
    WIDEN ir<%tobool78.not> = icmp eq ir<%40>, ir<0>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index82> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv1140>, ir<1>
    WIDEN store ir<%use_index82>, ir<6>, ir<%tobool78.not>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end88.loopexit>, scalar.ph

ir-bb<if.end88.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 12
Loops Analyzed: 67
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4 -> Cost: 4 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1 -> Cost: 4 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4 -> Cost: 4 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1 -> Cost: 4 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4 -> Cost: 10 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1 -> Cost: 2 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %37 = load i8, ptr %arrayidx337, align 1 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 0, ptr %arrayidx341, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: reload_cse_move2add' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 52, ir<-1>
    CLONE ir<%arrayidx337> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    CLONE ir<%37> = load ir<%arrayidx337>
    CLONE ir<%tobool338.not> = icmp eq ir<%37>, ir<0>
  Successor(s): if.then339

  if.then339:
    EMIT vp<%3> = not ir<%tobool338.not>
    CLONE ir<%arrayidx341> = getelementptr inbounds ir<@reg_set_luid>, ir<0>, ir<%indvars.iv>
    CLONE store ir<0>, ir<%arrayidx341>, vp<%3>
  Successor(s): for.inc343

  for.inc343:
    EMIT vp<%4> = or ir<%tobool338.not>, vp<%3>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp333.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<cleanup347.loopexit>, scalar.ph

ir-bb<cleanup347.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_cse_move2add' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 52, ir<-1>
    CLONE ir<%arrayidx337> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx337>
    WIDEN ir<%37> = load vp<%3>
    WIDEN ir<%tobool338.not> = icmp eq ir<%37>, ir<0>
  Successor(s): if.then339

  if.then339:
    EMIT vp<%4> = not ir<%tobool338.not>
    CLONE ir<%arrayidx341> = getelementptr ir<@reg_set_luid>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx341>
    WIDEN store vp<%5>, ir<0>, vp<%4>
  Successor(s): for.inc343

  for.inc343:
    EMIT vp<%6> = or ir<%tobool338.not>, vp<%4>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp333.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup347.loopexit>, scalar.ph

ir-bb<cleanup347.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_cse_move2add' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 52, ir<-1>
    CLONE ir<%arrayidx337> = getelementptr inbounds ir<@call_used_regs>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx337>
    WIDEN ir<%37> = load vp<%3>
    WIDEN ir<%tobool338.not> = icmp eq ir<%37>, ir<0>
  Successor(s): if.then339

  if.then339:
    EMIT vp<%4> = not ir<%tobool338.not>
    CLONE ir<%arrayidx341> = getelementptr ir<@reg_set_luid>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx341>
    WIDEN store vp<%5>, ir<0>, vp<%4>
  Successor(s): for.inc343

  for.inc343:
    EMIT vp<%6> = or ir<%tobool338.not>, vp<%4>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp333.not> = icmp eq ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup347.loopexit>, scalar.ph

ir-bb<cleanup347.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %37 = load i8, ptr %arrayidx337, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 0, ptr %arrayidx341, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %37 = load i8, ptr %arrayidx337, align 1 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i32 0, ptr %arrayidx341, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 290, RTCostB: 212
A is not scalable.	B is not scalable.	
RTCostA: 290, RTCostB: 212

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %37 = load i8, ptr %arrayidx337, align 1 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 0, ptr %arrayidx341, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 147, RTCostB: 212
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 147, RTCostB: 212
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 8 For instruction:   %37 = load i8, ptr %arrayidx337, align 1 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 8 For instruction:   store i32 0, ptr %arrayidx341, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 212
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 147
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %37 = load i8, ptr %arrayidx337, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 0, ptr %arrayidx341, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 186, RTCostB: 212
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 186, RTCostB: 122

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %37 = load i8, ptr %arrayidx337, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 0, ptr %arrayidx341, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 95, RTCostB: 212
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 95, RTCostB: 122
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 8

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc343 ], [ 52, %for.body335.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx337 = getelementptr inbounds [53 x i8], ptr @call_used_regs, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %37 = load i8, ptr %arrayidx337, align 1 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool338.not = icmp eq i8 %37, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool338.not, label %for.inc343, label %if.then339 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx341 = getelementptr inbounds [53 x i32], ptr @reg_set_luid, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 0, ptr %arrayidx341, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc343 of type:br

-----------------Function that is being costed:'reload_cse_move2add' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp333.not = icmp eq i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp333.not, label %cleanup347.loopexit, label %for.body335 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 68, RTCostB: 212
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 68, RTCostB: 95
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: reload_cse_move2add at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<53> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%3>    = DERIVED-IV ir<52> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%arrayidx337> = getelementptr inbounds ir<@call_used_regs>, ir<0>, vp<%4>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx337>
    WIDEN ir<%37> = load vp<%5>
    WIDEN ir<%tobool338.not> = icmp eq ir<%37>, ir<0>
    EMIT vp<%6> = not ir<%tobool338.not>
    CLONE ir<%arrayidx341> = getelementptr ir<@reg_set_luid>, ir<0>, vp<%4>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx341>
    WIDEN store vp<%7>, ir<0>, vp<%6>
    EMIT vp<%8> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq ir<53>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup347.loopexit>, scalar.ph

ir-bb<cleanup347.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 13
Loops Analyzed: 69
Loops Epilogues Vectorized: 0
================================================
========== Loop: find_reg' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used_by_other_reload.1618> = phi ir<%used_by_other_reload.0621>, ir<%or21>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    CLONE ir<%add> = add ir<%8>, ir<%9>
    CLONE ir<%sh_prom> = zext nneg ir<%add>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%or21> = or ir<%shl>, ir<%used_by_other_reload.1618>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used_by_other_reload.1618>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}

========== Loop: find_reg' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used_by_other_reload.1618> = phi ir<%used_by_other_reload.0621>, ir<%or21>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    WIDEN ir<%add> = add ir<%8>, ir<%9>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or21> = or ir<%shl>, ir<%used_by_other_reload.1618>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used_by_other_reload.1618>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}

========== Loop: find_reg' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%used_by_other_reload.1618> = phi ir<%used_by_other_reload.0621>, ir<%or21>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    WIDEN ir<%add> = add ir<%8>, ir<%9>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or21> = or ir<%shl>, ir<%used_by_other_reload.1618>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used_by_other_reload.1618>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}


-----------------Function that is being costed:'find_reg' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %used_by_other_reload.1618 = phi i64 [ %used_by_other_reload.0621, %for.body17.lr.ph ], [ %or21, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %9 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add = add i32 %8, %9 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom = zext nneg i32 %add to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or21 = or i64 %shl, %used_by_other_reload.1618 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body17 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'find_reg' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %used_by_other_reload.1618 = phi i64 [ %used_by_other_reload.0621, %for.body17.lr.ph ], [ %or21, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %9 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add = add i32 %8, %9 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom = zext nneg i32 %add to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or21 = or i64 %shl, %used_by_other_reload.1618 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body17 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'find_reg' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %used_by_other_reload.1618 = phi i64 [ %used_by_other_reload.0621, %for.body17.lr.ph ], [ %or21, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %9 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add = add i32 %8, %9 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom = zext nneg i32 %add to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or21 = or i64 %shl, %used_by_other_reload.1618 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body17 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'find_reg' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %used_by_other_reload.1618 = phi i64 [ %used_by_other_reload.0621, %for.body17.lr.ph ], [ %or21, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %9 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add = add i32 %8, %9 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %add to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or21 = or i64 %shl, %used_by_other_reload.1618 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 10737418248

-----------------Function that is being costed:'find_reg' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body17.lr.ph ], [ %indvars.iv.next, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %used_by_other_reload.1618 = phi i64 [ %used_by_other_reload.0621, %for.body17.lr.ph ], [ %or21, %for.body17 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %9 = trunc nuw i64 %indvars.iv to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add = add i32 %8, %9 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %add to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or21 = or i64 %shl, %used_by_other_reload.1618 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %if.end.loopexit, label %for.body17 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 10737418248
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: find_reg at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body17.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %7 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-REDUCTION-PHI ir<%used_by_other_reload.1618> = phi ir<%used_by_other_reload.0621>, ir<%or21>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%9>, ir<1>
    WIDEN ir<%add> = add ir<%8>, ir<%9>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%add> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%or21> = or ir<%shl>, ir<%used_by_other_reload.1618>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%used_by_other_reload.1618>, ir<%or21>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end.loopexit>, scalar.ph

ir-bb<if.end.loopexit>:
No successors

scalar.ph:
No successors

Live-out i64 %or21.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 14
Loops Analyzed: 95
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4 -> Cost: 4 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4 -> Cost: 4 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4 -> Cost: 4 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4 -> Cost: 4 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4 -> Cost: 10 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4 -> Cost: 10 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %25 = load i32, ptr %arrayidx103, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %add104, ptr %arrayidx103, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: count_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond98140 to i64) + (-1 * (1 umin (zext i32 %cond98140 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %22, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%24> = add nsw ir<%indvars.iv.next>, ir<%23>
    CLONE ir<%arrayidx103> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%24>
    CLONE ir<%25> = load ir<%arrayidx103>
    CLONE ir<%add104> = add nsw ir<%25>, ir<%2>
    CLONE store ir<%add104>, ir<%arrayidx103>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: count_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond98140 to i64) + (-1 * (1 umin (zext i32 %cond98140 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %22, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%24> = add nsw ir<%indvars.iv.next>, ir<%23>
    CLONE ir<%arrayidx103> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%24>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN ir<%25> = load vp<%4>
    WIDEN ir<%add104> = add nsw ir<%25>, ir<%2>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN store vp<%5>, ir<%add104>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: count_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond98140 to i64) + (-1 * (1 umin (zext i32 %cond98140 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %22, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%24> = add nsw ir<%indvars.iv.next>, ir<%23>
    CLONE ir<%arrayidx103> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%24>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN ir<%25> = load vp<%4>
    WIDEN ir<%add104> = add nsw ir<%25>, ir<%2>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN store vp<%5>, ir<%add104>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %25 = load i32, ptr %arrayidx103, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %add104, ptr %arrayidx103, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %25 = load i32, ptr %arrayidx103, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i32 %add104, ptr %arrayidx103, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 6442450938, RTCostB: 6442450938
A is not scalable.	B is not scalable.	
RTCostA: 6442450938, RTCostB: 6442450938

-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %25 = load i32, ptr %arrayidx103, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %add104, ptr %arrayidx103, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 6442450938
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 6442450938
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 8 For instruction:   %25 = load i32, ptr %arrayidx103, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 8 For instruction:   store i32 %add104, ptr %arrayidx103, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3355443217, RTCostB: 6442450938
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3355443217, RTCostB: 3221225478

-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %25 = load i32, ptr %arrayidx103, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %add104, ptr %arrayidx103, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 4294967294, RTCostB: 6442450938
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967294, RTCostB: 3221225478

-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %25 = load i32, ptr %arrayidx103, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %add104, ptr %arrayidx103, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2147483658, RTCostB: 6442450938
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483658, RTCostB: 3221225478
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'count_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %22, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %24 = add nsw i64 %indvars.iv.next, %23 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx103 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %24 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   %25 = load i32, ptr %arrayidx103, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %add104 = add nsw i32 %25, %2 of type:add
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 %add104, ptr %arrayidx103, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1476395039, RTCostB: 6442450938
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1476395039, RTCostB: 2147483658
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: count_pseudo at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond98140 to i64) + (-1 * (1 umin (zext i32 %cond98140 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%22> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%24> = add nsw ir<%indvars.iv.next>, ir<%23>
    CLONE ir<%arrayidx103> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%24>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN ir<%25> = load vp<%6>
    WIDEN ir<%add104> = add nsw ir<%25>, ir<%2>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx103>
    WIDEN store vp<%7>, ir<%add104>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 15
Loops Analyzed: 96
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4 -> Cost: 4 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4 -> Cost: 4 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4 -> Cost: 4 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4 -> Cost: 4 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4 -> Cost: 10 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4 -> Cost: 10 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %26 = load i32, ptr %arrayidx107, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  store i32 %sub108, ptr %arrayidx107, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: count_spilled_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    CLONE ir<%arrayidx107> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%25>
    CLONE ir<%26> = load ir<%arrayidx107>
    CLONE ir<%sub108> = sub nsw ir<%26>, ir<%21>
    CLONE store ir<%sub108>, ir<%arrayidx107>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: count_spilled_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    CLONE ir<%arrayidx107> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%25>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN ir<%26> = load vp<%4>
    WIDEN ir<%sub108> = sub nsw ir<%26>, ir<%21>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN store vp<%5>, ir<%sub108>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: count_spilled_pseudo' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %23, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    CLONE ir<%arrayidx107> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%25>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN ir<%26> = load vp<%4>
    WIDEN ir<%sub108> = sub nsw ir<%26>, ir<%21>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN store vp<%5>, ir<%sub108>
    CLONE ir<%cmp99> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %26 = load i32, ptr %arrayidx107, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %26 = load i32, ptr %arrayidx107, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 6442450938, RTCostB: 6442450938
A is not scalable.	B is not scalable.	
RTCostA: 6442450938, RTCostB: 6442450938

-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   %26 = load i32, ptr %arrayidx107, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 6442450938
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225478, RTCostB: 6442450938
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 8 For instruction:   %26 = load i32, ptr %arrayidx107, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 8 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3355443217, RTCostB: 6442450938
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3355443217, RTCostB: 3221225478

-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %26 = load i32, ptr %arrayidx107, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 4294967294, RTCostB: 6442450938
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967294, RTCostB: 3221225478

-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %26 = load i32, ptr %arrayidx107, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2147483658, RTCostB: 6442450938
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483658, RTCostB: 3221225478
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'count_spilled_pseudo' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %23, %while.body.preheader ], [ %indvars.iv.next, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %25 = add nsw i64 %indvars.iv.next, %24 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx107 = getelementptr inbounds [53 x i32], ptr @spill_cost, i64 0, i64 %25 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   %26 = load i32, ptr %arrayidx107, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %sub108 = sub nsw i32 %26, %21 of type:sub
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 %sub108, ptr %arrayidx107, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp99 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp99, label %while.body, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 1476395039, RTCostB: 6442450938
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1476395039, RTCostB: 2147483658
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: count_spilled_pseudo at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond84 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%23> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw vp<%5>, ir<-1>
    CLONE ir<%25> = add nsw ir<%indvars.iv.next>, ir<%24>
    CLONE ir<%arrayidx107> = getelementptr inbounds ir<@spill_cost>, ir<0>, ir<%25>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN ir<%26> = load vp<%6>
    WIDEN ir<%sub108> = sub nsw ir<%26>, ir<%21>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx107>
    WIDEN store vp<%7>, ir<%sub108>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 16
Loops Analyzed: 97
Loops Epilogues Vectorized: 0
================================================
========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body556.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223542362 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2289 = phi 0, %indvars.iv.next2290, ir<1>
    WIDEN-REDUCTION-PHI ir<%or56022272229> = phi ir<%reload_reg_used_for_inherit.promoted>, ir<%or560>
    CLONE ir<%88> = add nsw ir<%indvars.iv2289>, ir<%idxprom214>
    CLONE ir<%shl559> = shl nuw ir<1>, ir<%88>
    CLONE ir<%or560> = or ir<%or56022272229>, ir<%shl559>
    CLONE ir<%indvars.iv.next2290> = add nuw nsw ir<%indvars.iv2289>, ir<1>
    CLONE ir<%exitcond2293.not> = icmp eq ir<%indvars.iv.next2290>, ir<%wide.trip.count2292>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or56022272229>, ir<%or560>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or560.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body556.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223542362 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2289 = phi 0, %indvars.iv.next2290, ir<1>
    WIDEN-REDUCTION-PHI ir<%or56022272229> = phi ir<%reload_reg_used_for_inherit.promoted>, ir<%or560>
    WIDEN ir<%88> = add nsw ir<%indvars.iv2289>, ir<%idxprom214>
    WIDEN ir<%shl559> = shl nuw ir<1>, ir<%88>
    WIDEN ir<%or560> = or ir<%or56022272229>, ir<%shl559>
    WIDEN ir<%indvars.iv.next2290> = add nuw nsw ir<%indvars.iv2289>, ir<1>
    CLONE ir<%exitcond2293.not> = icmp eq ir<%indvars.iv.next2290>, ir<%wide.trip.count2292>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or56022272229>, ir<%or560>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or560.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body556.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223542362 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2289 = phi 0, %indvars.iv.next2290, ir<1>
    WIDEN-REDUCTION-PHI ir<%or56022272229> = phi ir<%reload_reg_used_for_inherit.promoted>, ir<%or560>
    WIDEN ir<%88> = add nsw ir<%indvars.iv2289>, ir<%idxprom214>
    WIDEN ir<%shl559> = shl nuw ir<1>, ir<%88>
    WIDEN ir<%or560> = or ir<%or56022272229>, ir<%shl559>
    WIDEN ir<%indvars.iv.next2290> = add nuw nsw ir<%indvars.iv2289>, ir<1>
    CLONE ir<%exitcond2293.not> = icmp eq ir<%indvars.iv.next2290>, ir<%wide.trip.count2292>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or56022272229>, ir<%or560>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or560.lcssa = vp<%6>
}


-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv2289 = phi i64 [ 0, %for.body556.preheader ], [ %indvars.iv.next2290, %for.body556 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or56022272229 = phi i64 [ %reload_reg_used_for_inherit.promoted, %for.body556.preheader ], [ %or560, %for.body556 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %88 = add nsw i64 %indvars.iv2289, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl559 = shl nuw i64 1, %88 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or560 = or i64 %or56022272229, %shl559 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next2290 = add nuw nsw i64 %indvars.iv2289, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond2293.not = icmp eq i64 %indvars.iv.next2290, %wide.trip.count2292 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond2293.not, label %for.cond553.land.lhs.true570.loopexit_crit_edge, label %for.body556 of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv2289 = phi i64 [ 0, %for.body556.preheader ], [ %indvars.iv.next2290, %for.body556 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or56022272229 = phi i64 [ %reload_reg_used_for_inherit.promoted, %for.body556.preheader ], [ %or560, %for.body556 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %88 = add nsw i64 %indvars.iv2289, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl559 = shl nuw i64 1, %88 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or560 = or i64 %or56022272229, %shl559 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next2290 = add nuw nsw i64 %indvars.iv2289, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond2293.not = icmp eq i64 %indvars.iv.next2290, %wide.trip.count2292 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond2293.not, label %for.cond553.land.lhs.true570.loopexit_crit_edge, label %for.body556 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv2289 = phi i64 [ 0, %for.body556.preheader ], [ %indvars.iv.next2290, %for.body556 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or56022272229 = phi i64 [ %reload_reg_used_for_inherit.promoted, %for.body556.preheader ], [ %or560, %for.body556 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %88 = add nsw i64 %indvars.iv2289, %idxprom214 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl559 = shl nuw i64 1, %88 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or560 = or i64 %or56022272229, %shl559 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next2290 = add nuw nsw i64 %indvars.iv2289, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond2293.not = icmp eq i64 %indvars.iv.next2290, %wide.trip.count2292 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond2293.not, label %for.cond553.land.lhs.true570.loopexit_crit_edge, label %for.body556 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv2289 = phi i64 [ 0, %for.body556.preheader ], [ %indvars.iv.next2290, %for.body556 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or56022272229 = phi i64 [ %reload_reg_used_for_inherit.promoted, %for.body556.preheader ], [ %or560, %for.body556 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %88 = add nsw i64 %indvars.iv2289, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl559 = shl nuw i64 1, %88 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or560 = or i64 %or56022272229, %shl559 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next2290 = add nuw nsw i64 %indvars.iv2289, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond2293.not = icmp eq i64 %indvars.iv.next2290, %wide.trip.count2292 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond2293.not, label %for.cond553.land.lhs.true570.loopexit_crit_edge, label %for.body556 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv2289 = phi i64 [ 0, %for.body556.preheader ], [ %indvars.iv.next2290, %for.body556 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or56022272229 = phi i64 [ %reload_reg_used_for_inherit.promoted, %for.body556.preheader ], [ %or560, %for.body556 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %88 = add nsw i64 %indvars.iv2289, %idxprom214 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl559 = shl nuw i64 1, %88 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or560 = or i64 %or56022272229, %shl559 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next2290 = add nuw nsw i64 %indvars.iv2289, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond2293.not = icmp eq i64 %indvars.iv.next2290, %wide.trip.count2292 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond2293.not, label %for.cond553.land.lhs.true570.loopexit_crit_edge, label %for.body556 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: choose_reload_regs at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body556.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223542362 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2289 = phi 0, %indvars.iv.next2290, ir<1>
    WIDEN-REDUCTION-PHI ir<%or56022272229> = phi ir<%reload_reg_used_for_inherit.promoted>, ir<%or560>
    WIDEN ir<%88> = add nsw ir<%indvars.iv2289>, ir<%idxprom214>
    WIDEN ir<%shl559> = shl nuw ir<1>, ir<%88>
    WIDEN ir<%or560> = or ir<%or56022272229>, ir<%shl559>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or56022272229>, ir<%or560>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond553.land.lhs.true570.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or560.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body409.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223542362 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2282 = phi 0, %indvars.iv.next2283, ir<1>
    WIDEN-REDUCTION-PHI ir<%bad_for_class.02221> = phi ir<0>, ir<%or>
    CLONE ir<%61> = add nsw ir<%indvars.iv2282>, ir<%idxprom214>
    CLONE ir<%shl417> = shl nuw ir<1>, ir<%61>
    CLONE ir<%and418> = and ir<%59>, ir<%shl417>
    CLONE ir<%tobool419.not> = icmp eq ir<%and418>, ir<0>
    CLONE ir<%lnot.ext> = zext ir<%tobool419.not>
    CLONE ir<%or> = or ir<%bad_for_class.02221>, ir<%lnot.ext>
    CLONE ir<%indvars.iv.next2283> = add nuw nsw ir<%indvars.iv2282>, ir<1>
    CLONE ir<%exitcond2286.not> = icmp eq ir<%indvars.iv.next2283>, ir<%wide.trip.count2285>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%bad_for_class.02221>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond423.preheader.loopexit>, scalar.ph

ir-bb<for.cond423.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body409.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223542362 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2282 = phi 0, %indvars.iv.next2283, ir<1>
    WIDEN-REDUCTION-PHI ir<%bad_for_class.02221> = phi ir<0>, ir<%or>
    WIDEN ir<%61> = add nsw ir<%indvars.iv2282>, ir<%idxprom214>
    WIDEN ir<%shl417> = shl nuw ir<1>, ir<%61>
    WIDEN ir<%and418> = and ir<%59>, ir<%shl417>
    WIDEN ir<%tobool419.not> = icmp eq ir<%and418>, ir<0>
    WIDEN-CAST ir<%lnot.ext> = zext  ir<%tobool419.not> to i32
    WIDEN ir<%or> = or ir<%bad_for_class.02221>, ir<%lnot.ext>
    WIDEN ir<%indvars.iv.next2283> = add nuw nsw ir<%indvars.iv2282>, ir<1>
    CLONE ir<%exitcond2286.not> = icmp eq ir<%indvars.iv.next2283>, ir<%wide.trip.count2285>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%bad_for_class.02221>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond423.preheader.loopexit>, scalar.ph

ir-bb<for.cond423.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body409.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223542362 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2282 = phi 0, %indvars.iv.next2283, ir<1>
    WIDEN-REDUCTION-PHI ir<%bad_for_class.02221> = phi ir<0>, ir<%or>
    WIDEN ir<%61> = add nsw ir<%indvars.iv2282>, ir<%idxprom214>
    WIDEN ir<%shl417> = shl nuw ir<1>, ir<%61>
    WIDEN ir<%and418> = and ir<%59>, ir<%shl417>
    WIDEN ir<%tobool419.not> = icmp eq ir<%and418>, ir<0>
    WIDEN-CAST ir<%lnot.ext> = zext  ir<%tobool419.not> to i32
    WIDEN ir<%or> = or ir<%bad_for_class.02221>, ir<%lnot.ext>
    WIDEN ir<%indvars.iv.next2283> = add nuw nsw ir<%indvars.iv2282>, ir<1>
    CLONE ir<%exitcond2286.not> = icmp eq ir<%indvars.iv.next2283>, ir<%wide.trip.count2285>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%bad_for_class.02221>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond423.preheader.loopexit>, scalar.ph

ir-bb<for.cond423.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv2282 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2283, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %61 = add nsw i64 %indvars.iv2282, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next2283 = add nuw nsw i64 %indvars.iv2282, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond2286.not = icmp eq i64 %indvars.iv.next2283, %wide.trip.count2285 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond2286.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv2282 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2283, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %61 = add nsw i64 %indvars.iv2282, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next2283 = add nuw nsw i64 %indvars.iv2282, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond2286.not = icmp eq i64 %indvars.iv.next2283, %wide.trip.count2285 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond2286.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 4831838207, RTCostB: 8589934584
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4831838207, RTCostB: 8589934584
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv2282 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2283, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %61 = add nsw i64 %indvars.iv2282, %idxprom214 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next2283 = add nuw nsw i64 %indvars.iv2282, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond2286.not = icmp eq i64 %indvars.iv.next2283, %wide.trip.count2285 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond2286.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3758096394, RTCostB: 8589934584
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096394, RTCostB: 4831838207
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv2282 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2283, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %61 = add nsw i64 %indvars.iv2282, %idxprom214 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 4 for VF 8 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 4 for VF 8 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next2283 = add nuw nsw i64 %indvars.iv2282, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond2286.not = icmp eq i64 %indvars.iv.next2283, %wide.trip.count2285 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond2286.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width 8 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 3623878685, RTCostB: 8589934584
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3623878685, RTCostB: 3758096394
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv2282 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2283, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %61 = add nsw i64 %indvars.iv2282, %idxprom214 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next2283 = add nuw nsw i64 %indvars.iv2282, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond2286.not = icmp eq i64 %indvars.iv.next2283, %wide.trip.count2285 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond2286.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width vscale x 1 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 4831838207, RTCostB: 8589934584
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4831838207, RTCostB: 3623878685

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv2282 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2283, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %61 = add nsw i64 %indvars.iv2282, %idxprom214 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next2283 = add nuw nsw i64 %indvars.iv2282, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond2286.not = icmp eq i64 %indvars.iv.next2283, %wide.trip.count2285 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond2286.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 3758096394, RTCostB: 8589934584
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096394, RTCostB: 3623878685

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv2282 = phi i64 [ 0, %for.body409.lr.ph ], [ %indvars.iv.next2283, %for.body409 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %bad_for_class.02221 = phi i32 [ 0, %for.body409.lr.ph ], [ %or, %for.body409 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %61 = add nsw i64 %indvars.iv2282, %idxprom214 of type:add
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %shl417 = shl nuw i64 1, %61 of type:shl
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %and418 = and i64 %59, %shl417 of type:and
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %tobool419.not = icmp eq i64 %and418, 0 of type:icmp
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %lnot.ext = zext i1 %tobool419.not to i32 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %or = or i32 %bad_for_class.02221, %lnot.ext of type:or
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next2283 = add nuw nsw i64 %indvars.iv2282, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond2286.not = icmp eq i64 %indvars.iv.next2283, %wide.trip.count2285 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond2286.not, label %for.cond423.preheader.loopexit, label %for.body409 of type:br
LV: Vector loop of width vscale x 4 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 3623878685, RTCostB: 8589934584
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3623878685, RTCostB: 3623878685
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: choose_reload_regs at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body409.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond37223542362 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2282 = phi 0, %indvars.iv.next2283, ir<1>
    WIDEN-REDUCTION-PHI ir<%bad_for_class.02221> = phi ir<0>, ir<%or>
    WIDEN ir<%61> = add nsw ir<%indvars.iv2282>, ir<%idxprom214>
    WIDEN ir<%shl417> = shl nuw ir<1>, ir<%61>
    WIDEN ir<%and418> = and ir<%59>, ir<%shl417>
    WIDEN ir<%tobool419.not> = icmp eq ir<%and418>, ir<0>
    WIDEN-CAST ir<%lnot.ext> = zext  ir<%tobool419.not> to i32
    WIDEN ir<%or> = or ir<%bad_for_class.02221>, ir<%lnot.ext>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%bad_for_class.02221>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond423.preheader.loopexit>, scalar.ph

ir-bb<for.cond423.preheader.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %or.lcssa = vp<%6>
}
================ Final VPlan ================

@@ Instruction =>  %227 = load ptr, ptr %arrayidx1370, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %227 = load ptr, ptr %arrayidx1370, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %227 = load ptr, ptr %arrayidx1370, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %227 = load ptr, ptr %arrayidx1370, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1368.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %212 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv2311 = phi 0, %indvars.iv.next2312, ir<1>
    CLONE ir<%arrayidx1370> = getelementptr inbounds ir<@reload_override_in>, ir<0>, ir<%indvars.iv2311>
    CLONE ir<%227> = load ir<%arrayidx1370>
    CLONE ir<%tobool1371.not> = icmp eq ir<%227>, ir<null>
  Successor(s): if.then1372

  if.then1372:
    EMIT vp<%4> = not ir<%tobool1371.not>
    CLONE ir<%arrayidx1376> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv2311>
    CLONE store ir<%227>, ir<%arrayidx1376>, vp<%4>
  Successor(s): for.inc1379

  for.inc1379:
    EMIT vp<%5> = or ir<%tobool1371.not>, vp<%4>
    CLONE ir<%indvars.iv.next2312> = add nuw nsw ir<%indvars.iv2311>, ir<1>
    CLONE ir<%exitcond2314.not> = icmp eq ir<%indvars.iv.next2312>, ir<%wide.trip.count2313>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond1382.preheader>, scalar.ph

ir-bb<for.cond1382.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1368.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %212 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv2311 = phi 0, %indvars.iv.next2312, ir<1>
    CLONE ir<%arrayidx1370> = getelementptr inbounds ir<@reload_override_in>, ir<0>, ir<%indvars.iv2311>
    vp<%4> = vector-pointer ir<%arrayidx1370>
    WIDEN ir<%227> = load vp<%4>
    WIDEN ir<%tobool1371.not> = icmp eq ir<%227>, ir<null>
  Successor(s): if.then1372

  if.then1372:
    EMIT vp<%5> = not ir<%tobool1371.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1376> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv2311>
    WIDEN store ir<%arrayidx1376>, ir<%227>, vp<%5>
  Successor(s): for.inc1379

  for.inc1379:
    EMIT vp<%6> = or ir<%tobool1371.not>, vp<%5>
    WIDEN ir<%indvars.iv.next2312> = add nuw nsw ir<%indvars.iv2311>, ir<1>
    CLONE ir<%exitcond2314.not> = icmp eq ir<%indvars.iv.next2312>, ir<%wide.trip.count2313>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1382.preheader>, scalar.ph

ir-bb<for.cond1382.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1368.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %212 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv2311 = phi 0, %indvars.iv.next2312, ir<1>
    CLONE ir<%arrayidx1370> = getelementptr inbounds ir<@reload_override_in>, ir<0>, ir<%indvars.iv2311>
    vp<%4> = vector-pointer ir<%arrayidx1370>
    WIDEN ir<%227> = load vp<%4>
    WIDEN ir<%tobool1371.not> = icmp eq ir<%227>, ir<null>
  Successor(s): if.then1372

  if.then1372:
    EMIT vp<%5> = not ir<%tobool1371.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1376> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv2311>
    WIDEN store ir<%arrayidx1376>, ir<%227>, vp<%5>
  Successor(s): for.inc1379

  for.inc1379:
    EMIT vp<%6> = or ir<%tobool1371.not>, vp<%5>
    WIDEN ir<%indvars.iv.next2312> = add nuw nsw ir<%indvars.iv2311>, ir<1>
    CLONE ir<%exitcond2314.not> = icmp eq ir<%indvars.iv.next2312>, ir<%wide.trip.count2313>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1382.preheader>, scalar.ph

ir-bb<for.cond1382.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv2311 = phi i64 [ 0, %for.body1368.preheader ], [ %indvars.iv.next2312, %for.inc1379 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1370 = getelementptr inbounds [180 x ptr], ptr @reload_override_in, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %227 = load ptr, ptr %arrayidx1370, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool1371.not = icmp eq ptr %227, null of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool1371.not, label %for.inc1379, label %if.then1372 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1376 = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %227, ptr %arrayidx1376, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc1379 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next2312 = add nuw nsw i64 %indvars.iv2311, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond2314.not = icmp eq i64 %indvars.iv.next2312, %wide.trip.count2313 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond2314.not, label %for.cond1382.preheader, label %for.body1368 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv2311 = phi i64 [ 0, %for.body1368.preheader ], [ %indvars.iv.next2312, %for.inc1379 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1370 = getelementptr inbounds [180 x ptr], ptr @reload_override_in, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %227 = load ptr, ptr %arrayidx1370, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool1371.not = icmp eq ptr %227, null of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool1371.not, label %for.inc1379, label %if.then1372 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1376 = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %227, ptr %arrayidx1376, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc1379 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next2312 = add nuw nsw i64 %indvars.iv2311, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond2314.not = icmp eq i64 %indvars.iv.next2312, %wide.trip.count2313 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond2314.not, label %for.cond1382.preheader, label %for.body1368 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv2311 = phi i64 [ 0, %for.body1368.preheader ], [ %indvars.iv.next2312, %for.inc1379 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1370 = getelementptr inbounds [180 x ptr], ptr @reload_override_in, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %227 = load ptr, ptr %arrayidx1370, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %tobool1371.not = icmp eq ptr %227, null of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool1371.not, label %for.inc1379, label %if.then1372 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1376 = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %227, ptr %arrayidx1376, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc1379 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next2312 = add nuw nsw i64 %indvars.iv2311, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond2314.not = icmp eq i64 %indvars.iv.next2312, %wide.trip.count2313 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond2314.not, label %for.cond1382.preheader, label %for.body1368 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5905580033, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5905580033, RTCostB: 6442450942
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv2311 = phi i64 [ 0, %for.body1368.preheader ], [ %indvars.iv.next2312, %for.inc1379 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1370 = getelementptr inbounds [180 x ptr], ptr @reload_override_in, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %227 = load ptr, ptr %arrayidx1370, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool1371.not = icmp eq ptr %227, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool1371.not, label %for.inc1379, label %if.then1372 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1376 = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %227, ptr %arrayidx1376, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc1379 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next2312 = add nuw nsw i64 %indvars.iv2311, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond2314.not = icmp eq i64 %indvars.iv.next2312, %wide.trip.count2313 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond2314.not, label %for.cond1382.preheader, label %for.body1368 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 5905580033

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv2311 = phi i64 [ 0, %for.body1368.preheader ], [ %indvars.iv.next2312, %for.inc1379 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1370 = getelementptr inbounds [180 x ptr], ptr @reload_override_in, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %227 = load ptr, ptr %arrayidx1370, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %tobool1371.not = icmp eq ptr %227, null of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool1371.not, label %for.inc1379, label %if.then1372 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1376 = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv2311 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %227, ptr %arrayidx1376, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc1379 of type:br

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next2312 = add nuw nsw i64 %indvars.iv2311, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond2314.not = icmp eq i64 %indvars.iv.next2312, %wide.trip.count2313 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond2314.not, label %for.cond1382.preheader, label %for.body1368 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5905580033, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5905580033, RTCostB: 5905580033
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: choose_reload_regs at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1368.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %212 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv2311 = phi 0, %indvars.iv.next2312, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx1370> = getelementptr inbounds ir<@reload_override_in>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx1370>
    WIDEN ir<%227> = load vp<%5>
    WIDEN ir<%tobool1371.not> = icmp eq ir<%227>, ir<null>
    EMIT vp<%6> = not ir<%tobool1371.not>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1376> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv2311>
    WIDEN store ir<%arrayidx1376>, ir<%227>, vp<%6>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1382.preheader>, scalar.ph

ir-bb<for.cond1382.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1673.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond16682375 to i64) + (-1 * (1 umin (zext i32 %cond16682375 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2320 = phi %295, %indvars.iv.next2321, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or167722622264> = phi ir<%or1677.lcssa22702272>, ir<%or1677>
    CLONE ir<%indvars.iv.next2321> = add nsw ir<%indvars.iv2320>, ir<-1>
    CLONE ir<%297> = add nuw nsw ir<%indvars.iv.next2321>, ir<%296>
    CLONE ir<%shl1676> = shl nuw ir<1>, ir<%297>
    CLONE ir<%or1677> = or ir<%or167722622264>, ir<%shl1676>
    CLONE ir<%cmp1671> = icmp ugt ir<%indvars.iv2320>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or167722622264>, ir<%or1677>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1677.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1673.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond16682375 to i64) + (-1 * (1 umin (zext i32 %cond16682375 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2320 = phi %295, %indvars.iv.next2321, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or167722622264> = phi ir<%or1677.lcssa22702272>, ir<%or1677>
    WIDEN ir<%indvars.iv.next2321> = add nsw ir<%indvars.iv2320>, ir<-1>
    WIDEN ir<%297> = add nuw nsw ir<%indvars.iv.next2321>, ir<%296>
    WIDEN ir<%shl1676> = shl nuw ir<1>, ir<%297>
    WIDEN ir<%or1677> = or ir<%or167722622264>, ir<%shl1676>
    CLONE ir<%cmp1671> = icmp ugt ir<%indvars.iv2320>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or167722622264>, ir<%or1677>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1677.lcssa = vp<%6>
}

========== Loop: choose_reload_regs' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1673.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond16682375 to i64) + (-1 * (1 umin (zext i32 %cond16682375 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2320 = phi %295, %indvars.iv.next2321, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or167722622264> = phi ir<%or1677.lcssa22702272>, ir<%or1677>
    WIDEN ir<%indvars.iv.next2321> = add nsw ir<%indvars.iv2320>, ir<-1>
    WIDEN ir<%297> = add nuw nsw ir<%indvars.iv.next2321>, ir<%296>
    WIDEN ir<%shl1676> = shl nuw ir<1>, ir<%297>
    WIDEN ir<%or1677> = or ir<%or167722622264>, ir<%shl1676>
    CLONE ir<%cmp1671> = icmp ugt ir<%indvars.iv2320>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or167722622264>, ir<%or1677>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1677.lcssa = vp<%6>
}


-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv2320 = phi i64 [ %295, %while.body1673.preheader ], [ %indvars.iv.next2321, %while.body1673 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or167722622264 = phi i64 [ %or1677.lcssa22702272, %while.body1673.preheader ], [ %or1677, %while.body1673 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next2321 = add nsw i64 %indvars.iv2320, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %297 = add nuw nsw i64 %indvars.iv.next2321, %296 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl1676 = shl nuw i64 1, %297 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or1677 = or i64 %or167722622264, %shl1676 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1671 = icmp ugt i64 %indvars.iv2320, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1671, label %while.body1673, label %while.cond1669.if.end1679.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv2320 = phi i64 [ %295, %while.body1673.preheader ], [ %indvars.iv.next2321, %while.body1673 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or167722622264 = phi i64 [ %or1677.lcssa22702272, %while.body1673.preheader ], [ %or1677, %while.body1673 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next2321 = add nsw i64 %indvars.iv2320, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %297 = add nuw nsw i64 %indvars.iv.next2321, %296 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl1676 = shl nuw i64 1, %297 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or1677 = or i64 %or167722622264, %shl1676 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1671 = icmp ugt i64 %indvars.iv2320, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp1671, label %while.body1673, label %while.cond1669.if.end1679.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv2320 = phi i64 [ %295, %while.body1673.preheader ], [ %indvars.iv.next2321, %while.body1673 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or167722622264 = phi i64 [ %or1677.lcssa22702272, %while.body1673.preheader ], [ %or1677, %while.body1673 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next2321 = add nsw i64 %indvars.iv2320, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %297 = add nuw nsw i64 %indvars.iv.next2321, %296 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl1676 = shl nuw i64 1, %297 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or1677 = or i64 %or167722622264, %shl1676 of type:or
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1671 = icmp ugt i64 %indvars.iv2320, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp1671, label %while.body1673, label %while.cond1669.if.end1679.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2684354560
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv2320 = phi i64 [ %295, %while.body1673.preheader ], [ %indvars.iv.next2321, %while.body1673 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or167722622264 = phi i64 [ %or1677.lcssa22702272, %while.body1673.preheader ], [ %or1677, %while.body1673 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next2321 = add nsw i64 %indvars.iv2320, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %297 = add nuw nsw i64 %indvars.iv.next2321, %296 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl1676 = shl nuw i64 1, %297 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or1677 = or i64 %or167722622264, %shl1676 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1671 = icmp ugt i64 %indvars.iv2320, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1671, label %while.body1673, label %while.cond1669.if.end1679.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 5368709115
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354560, RTCostB: 2415919110

-----------------Function that is being costed:'choose_reload_regs' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv2320 = phi i64 [ %295, %while.body1673.preheader ], [ %indvars.iv.next2321, %while.body1673 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or167722622264 = phi i64 [ %or1677.lcssa22702272, %while.body1673.preheader ], [ %or1677, %while.body1673 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next2321 = add nsw i64 %indvars.iv2320, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %297 = add nuw nsw i64 %indvars.iv.next2321, %296 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl1676 = shl nuw i64 1, %297 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or1677 = or i64 %or167722622264, %shl1676 of type:or
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1671 = icmp ugt i64 %indvars.iv2320, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1671, label %while.body1673, label %while.cond1669.if.end1679.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 5368709115
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919110, RTCostB: 2415919110
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: choose_reload_regs at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1673.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond16682375 to i64) + (-1 * (1 umin (zext i32 %cond16682375 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv2320 = phi %295, %indvars.iv.next2321, ir<-1>
    WIDEN-REDUCTION-PHI ir<%or167722622264> = phi ir<%or1677.lcssa22702272>, ir<%or1677>
    WIDEN ir<%indvars.iv.next2321> = add nsw ir<%indvars.iv2320>, ir<-1>
    WIDEN ir<%297> = add nuw nsw ir<%indvars.iv.next2321>, ir<%296>
    WIDEN ir<%shl1676> = shl nuw ir<1>, ir<%297>
    WIDEN ir<%or1677> = or ir<%or167722622264>, ir<%shl1676>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or167722622264>, ir<%or1677>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>, scalar.ph

ir-bb<while.cond1669.if.end1679.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or1677.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 20
Loops Analyzed: 110
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store i32 %cond790, ptr %arrayidx793, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx796, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %cond790, ptr %arrayidx793, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx796, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %cond790, ptr %arrayidx793, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx796, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %cond790, ptr %arrayidx793, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx796, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body775.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239172417341737 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1706 = phi 0, %indvars.iv.next1707, ir<1>
    WIDEN-REDUCTION-PHI ir<%and78016581663> = phi ir<%reg_reloaded_dead.promoted1657>, ir<%and780>
    WIDEN-REDUCTION-PHI ir<%or80016601662> = phi ir<%reg_reloaded_valid.promoted1659>, ir<%or800>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1706 = phi 0, %indvars.iv.next1707\l" +
    "  ir<%129>, ir<1>
    CLONE ir<%128> = add nuw nsw ir<%indvars.iv1706>, ir<%127>
    CLONE ir<%shl778> = shl nuw ir<1>, ir<%128>
    CLONE ir<%not779> = xor ir<%shl778>, ir<-1>
    CLONE ir<%and780> = and ir<%and78016581663>, ir<%not779>
    CLONE ir<%add788> = select ir<%or.cond1572>, ir<%129>, ir<0>
    CLONE ir<%cond790> = add nsw ir<%add788>, ir<%nregno564.0>
    CLONE ir<%arrayidx793> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%128>
    CLONE store ir<%cond790>, ir<%arrayidx793>
    CLONE ir<%arrayidx796> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%128>
    CLONE store ir<%0>, ir<%arrayidx796>
    CLONE ir<%or800> = or ir<%or80016601662>, ir<%shl778>
    CLONE ir<%indvars.iv.next1707> = add nuw nsw ir<%indvars.iv1706>, ir<1>
    CLONE ir<%exitcond1710.not> = icmp eq ir<%indvars.iv.next1707>, ir<%wide.trip.count1709>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and78016581663>, ir<%and780>
  EMIT vp<%7> = compute-reduction-result ir<%or80016601662>, ir<%or800>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>, scalar.ph

ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and780.lcssa = vp<%6>
Live-out i64 %or800.lcssa = vp<%7>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body775.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239172417341737 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1706 = phi 0, %indvars.iv.next1707, ir<1>
    WIDEN-REDUCTION-PHI ir<%and78016581663> = phi ir<%reg_reloaded_dead.promoted1657>, ir<%and780>
    WIDEN-REDUCTION-PHI ir<%or80016601662> = phi ir<%reg_reloaded_valid.promoted1659>, ir<%or800>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1706 = phi 0, %indvars.iv.next1707\l" +
    "  ir<%129>, ir<1>
    WIDEN ir<%128> = add nuw nsw ir<%indvars.iv1706>, ir<%127>
    WIDEN ir<%shl778> = shl nuw ir<1>, ir<%128>
    WIDEN ir<%not779> = xor ir<%shl778>, ir<-1>
    WIDEN ir<%and780> = and ir<%and78016581663>, ir<%not779>
    WIDEN-SELECT ir<%add788> = select ir<%or.cond1572>, ir<%129>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond790> = add nsw ir<%add788>, ir<%nregno564.0>
    CLONE ir<%arrayidx793> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%128>
    vp<%4> = vector-pointer ir<%arrayidx793>
    WIDEN store vp<%4>, ir<%cond790>
    CLONE ir<%arrayidx796> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%128>
    vp<%5> = vector-pointer ir<%arrayidx796>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or800> = or ir<%or80016601662>, ir<%shl778>
    WIDEN ir<%indvars.iv.next1707> = add nuw nsw ir<%indvars.iv1706>, ir<1>
    CLONE ir<%exitcond1710.not> = icmp eq ir<%indvars.iv.next1707>, ir<%wide.trip.count1709>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and78016581663>, ir<%and780>
  EMIT vp<%9> = compute-reduction-result ir<%or80016601662>, ir<%or800>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>, scalar.ph

ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and780.lcssa = vp<%8>
Live-out i64 %or800.lcssa = vp<%9>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body775.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239172417341737 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1706 = phi 0, %indvars.iv.next1707, ir<1>
    WIDEN-REDUCTION-PHI ir<%and78016581663> = phi ir<%reg_reloaded_dead.promoted1657>, ir<%and780>
    WIDEN-REDUCTION-PHI ir<%or80016601662> = phi ir<%reg_reloaded_valid.promoted1659>, ir<%or800>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1706 = phi 0, %indvars.iv.next1707\l" +
    "  ir<%129>, ir<1>
    WIDEN ir<%128> = add nuw nsw ir<%indvars.iv1706>, ir<%127>
    WIDEN ir<%shl778> = shl nuw ir<1>, ir<%128>
    WIDEN ir<%not779> = xor ir<%shl778>, ir<-1>
    WIDEN ir<%and780> = and ir<%and78016581663>, ir<%not779>
    WIDEN-SELECT ir<%add788> = select ir<%or.cond1572>, ir<%129>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond790> = add nsw ir<%add788>, ir<%nregno564.0>
    CLONE ir<%arrayidx793> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%128>
    vp<%4> = vector-pointer ir<%arrayidx793>
    WIDEN store vp<%4>, ir<%cond790>
    CLONE ir<%arrayidx796> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%128>
    vp<%5> = vector-pointer ir<%arrayidx796>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or800> = or ir<%or80016601662>, ir<%shl778>
    WIDEN ir<%indvars.iv.next1707> = add nuw nsw ir<%indvars.iv1706>, ir<1>
    CLONE ir<%exitcond1710.not> = icmp eq ir<%indvars.iv.next1707>, ir<%wide.trip.count1709>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and78016581663>, ir<%and780>
  EMIT vp<%9> = compute-reduction-result ir<%or80016601662>, ir<%or800>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>, scalar.ph

ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and780.lcssa = vp<%8>
Live-out i64 %or800.lcssa = vp<%9>
}


-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1706 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1707, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %128 = add nuw nsw i64 %indvars.iv1706, %127 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1706 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %0, ptr %arrayidx796, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1707 = add nuw nsw i64 %indvars.iv1706, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1707, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1710.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1706 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1707, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %128 = add nuw nsw i64 %indvars.iv1706, %127 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1706 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF 2 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %0, ptr %arrayidx796, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1707 = add nuw nsw i64 %indvars.iv1706, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1707, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1710.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 22
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 22
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1706 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1707, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %128 = add nuw nsw i64 %indvars.iv1706, %127 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1706 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF 4 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %0, ptr %arrayidx796, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1707 = add nuw nsw i64 %indvars.iv1706, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1707, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1710.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 44
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 20
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 52
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1706 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1707, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %128 = add nuw nsw i64 %indvars.iv1706, %127 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1706 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %0, ptr %arrayidx796, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1707 = add nuw nsw i64 %indvars.iv1706, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1707, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1710.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Vector loop of width vscale x 1 costs: 6
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 22
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 13
B VF: 4, EstimatedWidthB: 4, CostB: 20
CostA * EstimatedWidthB: 52, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1706 = phi i64 [ 0, %for.body775.lr.ph ], [ %indvars.iv.next1707, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and78016581663 = phi i64 [ %reg_reloaded_dead.promoted1657, %for.body775.lr.ph ], [ %and780, %for.body775 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or80016601662 = phi i64 [ %reg_reloaded_valid.promoted1659, %for.body775.lr.ph ], [ %or800, %for.body775 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %128 = add nuw nsw i64 %indvars.iv1706, %127 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl778 = shl nuw i64 1, %128 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not779 = xor i64 %shl778, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and780 = and i64 %and78016581663, %not779 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %129 = trunc nuw nsw i64 %indvars.iv1706 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %add788 = select i1 %or.cond1572, i32 %129, i32 0 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cond790 = add nsw i32 %add788, %nregno564.0 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx793 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %cond790, ptr %arrayidx793, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx796 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %128 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %0, ptr %arrayidx796, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or800 = or i64 %or80016601662, %shl778 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1707 = add nuw nsw i64 %indvars.iv1706, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1710.not = icmp eq i64 %indvars.iv.next1707, %wide.trip.count1709 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1710.not, label %for.cond772.if.end1216.loopexit1609_crit_edge, label %for.body775 of type:br
LV: Vector loop of width vscale x 2 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 44
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 20
B VF: 4, EstimatedWidthB: 4, CostB: 20
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 5.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: emit_reload_insns at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body775.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239172417341737 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1706 = phi 0, %indvars.iv.next1707, ir<1>
    WIDEN-REDUCTION-PHI ir<%and78016581663> = phi ir<%reg_reloaded_dead.promoted1657>, ir<%and780>
    WIDEN-REDUCTION-PHI ir<%or80016601662> = phi ir<%reg_reloaded_valid.promoted1659>, ir<%or800>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1706 = phi 0, %indvars.iv.next1707\l" +
    "  ir<%129>, ir<1>
    WIDEN ir<%128> = add nuw nsw ir<%indvars.iv1706>, ir<%127>
    WIDEN ir<%shl778> = shl nuw ir<1>, ir<%128>
    WIDEN ir<%not779> = xor ir<%shl778>, ir<-1>
    WIDEN ir<%and780> = and ir<%and78016581663>, ir<%not779>
    WIDEN-SELECT ir<%add788> = select ir<%or.cond1572>, ir<%129>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond790> = add nsw ir<%add788>, ir<%nregno564.0>
    CLONE ir<%arrayidx793> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%128>
    vp<%4> = vector-pointer ir<%arrayidx793>
    WIDEN store vp<%4>, ir<%cond790>
    CLONE ir<%arrayidx796> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%128>
    vp<%5> = vector-pointer ir<%arrayidx796>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or800> = or ir<%or80016601662>, ir<%shl778>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and78016581663>, ir<%and780>
  EMIT vp<%9> = compute-reduction-result ir<%or80016601662>, ir<%or800>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>, scalar.ph

ir-bb<for.cond772.if.end1216.loopexit1609_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and780.lcssa = vp<%8>
Live-out i64 %or800.lcssa = vp<%9>
}
================ Final VPlan ================

@@ Instruction =>  store i32 %cond489, ptr %arrayidx492, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx495, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %cond489, ptr %arrayidx492, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx495, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %cond489, ptr %arrayidx492, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx495, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %cond489, ptr %arrayidx492, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr %0, ptr %arrayidx495, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body474.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239172417341737 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1696 = phi 0, %indvars.iv.next1697, ir<1>
    WIDEN-REDUCTION-PHI ir<%and47916481653> = phi ir<%reg_reloaded_dead.promoted1647>, ir<%and479>
    WIDEN-REDUCTION-PHI ir<%or16501652> = phi ir<%reg_reloaded_valid.promoted1649>, ir<%or>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1696 = phi 0, %indvars.iv.next1697\l" +
    "  ir<%85>, ir<1>
    CLONE ir<%84> = add nuw nsw ir<%indvars.iv1696>, ir<%idxprom425>
    CLONE ir<%shl477> = shl nuw ir<1>, ir<%84>
    CLONE ir<%not478> = xor ir<%shl477>, ir<-1>
    CLONE ir<%and479> = and ir<%and47916481653>, ir<%not478>
    CLONE ir<%add487> = select ir<%or.cond1567>, ir<%85>, ir<0>
    CLONE ir<%cond489> = add nsw ir<%add487>, ir<%62>
    CLONE ir<%arrayidx492> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%84>
    CLONE store ir<%cond489>, ir<%arrayidx492>
    CLONE ir<%arrayidx495> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%84>
    CLONE store ir<%0>, ir<%arrayidx495>
    CLONE ir<%or> = or ir<%or16501652>, ir<%shl477>
    CLONE ir<%indvars.iv.next1697> = add nuw nsw ir<%indvars.iv1696>, ir<1>
    CLONE ir<%exitcond1700.not> = icmp eq ir<%indvars.iv.next1697>, ir<%wide.trip.count1699>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and47916481653>, ir<%and479>
  EMIT vp<%7> = compute-reduction-result ir<%or16501652>, ir<%or>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>, scalar.ph

ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and479.lcssa = vp<%6>
Live-out i64 %or.lcssa = vp<%7>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body474.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239172417341737 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1696 = phi 0, %indvars.iv.next1697, ir<1>
    WIDEN-REDUCTION-PHI ir<%and47916481653> = phi ir<%reg_reloaded_dead.promoted1647>, ir<%and479>
    WIDEN-REDUCTION-PHI ir<%or16501652> = phi ir<%reg_reloaded_valid.promoted1649>, ir<%or>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1696 = phi 0, %indvars.iv.next1697\l" +
    "  ir<%85>, ir<1>
    WIDEN ir<%84> = add nuw nsw ir<%indvars.iv1696>, ir<%idxprom425>
    WIDEN ir<%shl477> = shl nuw ir<1>, ir<%84>
    WIDEN ir<%not478> = xor ir<%shl477>, ir<-1>
    WIDEN ir<%and479> = and ir<%and47916481653>, ir<%not478>
    WIDEN-SELECT ir<%add487> = select ir<%or.cond1567>, ir<%85>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond489> = add nsw ir<%add487>, ir<%62>
    CLONE ir<%arrayidx492> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%84>
    vp<%4> = vector-pointer ir<%arrayidx492>
    WIDEN store vp<%4>, ir<%cond489>
    CLONE ir<%arrayidx495> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%84>
    vp<%5> = vector-pointer ir<%arrayidx495>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or> = or ir<%or16501652>, ir<%shl477>
    WIDEN ir<%indvars.iv.next1697> = add nuw nsw ir<%indvars.iv1696>, ir<1>
    CLONE ir<%exitcond1700.not> = icmp eq ir<%indvars.iv.next1697>, ir<%wide.trip.count1699>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and47916481653>, ir<%and479>
  EMIT vp<%9> = compute-reduction-result ir<%or16501652>, ir<%or>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>, scalar.ph

ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and479.lcssa = vp<%8>
Live-out i64 %or.lcssa = vp<%9>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body474.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239172417341737 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1696 = phi 0, %indvars.iv.next1697, ir<1>
    WIDEN-REDUCTION-PHI ir<%and47916481653> = phi ir<%reg_reloaded_dead.promoted1647>, ir<%and479>
    WIDEN-REDUCTION-PHI ir<%or16501652> = phi ir<%reg_reloaded_valid.promoted1649>, ir<%or>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1696 = phi 0, %indvars.iv.next1697\l" +
    "  ir<%85>, ir<1>
    WIDEN ir<%84> = add nuw nsw ir<%indvars.iv1696>, ir<%idxprom425>
    WIDEN ir<%shl477> = shl nuw ir<1>, ir<%84>
    WIDEN ir<%not478> = xor ir<%shl477>, ir<-1>
    WIDEN ir<%and479> = and ir<%and47916481653>, ir<%not478>
    WIDEN-SELECT ir<%add487> = select ir<%or.cond1567>, ir<%85>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond489> = add nsw ir<%add487>, ir<%62>
    CLONE ir<%arrayidx492> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%84>
    vp<%4> = vector-pointer ir<%arrayidx492>
    WIDEN store vp<%4>, ir<%cond489>
    CLONE ir<%arrayidx495> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%84>
    vp<%5> = vector-pointer ir<%arrayidx495>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or> = or ir<%or16501652>, ir<%shl477>
    WIDEN ir<%indvars.iv.next1697> = add nuw nsw ir<%indvars.iv1696>, ir<1>
    CLONE ir<%exitcond1700.not> = icmp eq ir<%indvars.iv.next1697>, ir<%wide.trip.count1699>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and47916481653>, ir<%and479>
  EMIT vp<%9> = compute-reduction-result ir<%or16501652>, ir<%or>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>, scalar.ph

ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and479.lcssa = vp<%8>
Live-out i64 %or.lcssa = vp<%9>
}


-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1696 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1697, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %84 = add nuw nsw i64 %indvars.iv1696, %idxprom425 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1696 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %0, ptr %arrayidx495, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1697 = add nuw nsw i64 %indvars.iv1696, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1700.not = icmp eq i64 %indvars.iv.next1697, %wide.trip.count1699 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1700.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1696 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1697, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %84 = add nuw nsw i64 %indvars.iv1696, %idxprom425 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1696 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF 2 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr %0, ptr %arrayidx495, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1697 = add nuw nsw i64 %indvars.iv1696, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1700.not = icmp eq i64 %indvars.iv.next1697, %wide.trip.count1699 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1700.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 22
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 22
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1696 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1697, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %84 = add nuw nsw i64 %indvars.iv1696, %idxprom425 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1696 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF 4 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr %0, ptr %arrayidx495, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1697 = add nuw nsw i64 %indvars.iv1696, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1700.not = icmp eq i64 %indvars.iv.next1697, %wide.trip.count1699 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1700.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 44
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 20
B VF: 2, EstimatedWidthB: 2, CostB: 13
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 52
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1696 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1697, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %84 = add nuw nsw i64 %indvars.iv1696, %idxprom425 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1696 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF vscale x 1 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr %0, ptr %arrayidx495, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1697 = add nuw nsw i64 %indvars.iv1696, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1700.not = icmp eq i64 %indvars.iv.next1697, %wide.trip.count1699 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1700.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Vector loop of width vscale x 1 costs: 6
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 22
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 13
B VF: 4, EstimatedWidthB: 4, CostB: 20
CostA * EstimatedWidthB: 52, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1696 = phi i64 [ 0, %for.body474.lr.ph ], [ %indvars.iv.next1697, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and47916481653 = phi i64 [ %reg_reloaded_dead.promoted1647, %for.body474.lr.ph ], [ %and479, %for.body474 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or16501652 = phi i64 [ %reg_reloaded_valid.promoted1649, %for.body474.lr.ph ], [ %or, %for.body474 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %84 = add nuw nsw i64 %indvars.iv1696, %idxprom425 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl477 = shl nuw i64 1, %84 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not478 = xor i64 %shl477, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and479 = and i64 %and47916481653, %not478 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %85 = trunc nuw nsw i64 %indvars.iv1696 to i32 of type:trunc
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %add487 = select i1 %or.cond1567, i32 %85, i32 0 of type:select
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cond489 = add nsw i32 %add487, %62 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx492 = getelementptr inbounds [53 x i32], ptr @reg_reloaded_contents, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %cond489, ptr %arrayidx492, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx495 = getelementptr inbounds [53 x ptr], ptr @reg_reloaded_insn, i64 0, i64 %84 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr %0, ptr %arrayidx495, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or16501652, %shl477 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1697 = add nuw nsw i64 %indvars.iv1696, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1700.not = icmp eq i64 %indvars.iv.next1697, %wide.trip.count1699 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1700.not, label %for.cond471.if.end1216.loopexit1610_crit_edge, label %for.body474 of type:br
LV: Vector loop of width vscale x 2 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 20
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 44
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 20
B VF: 4, EstimatedWidthB: 4, CostB: 20
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 5.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: emit_reload_insns at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body474.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond239172417341737 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv1696 = phi 0, %indvars.iv.next1697, ir<1>
    WIDEN-REDUCTION-PHI ir<%and47916481653> = phi ir<%reg_reloaded_dead.promoted1647>, ir<%and479>
    WIDEN-REDUCTION-PHI ir<%or16501652> = phi ir<%reg_reloaded_valid.promoted1649>, ir<%or>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv1696 = phi 0, %indvars.iv.next1697\l" +
    "  ir<%85>, ir<1>
    WIDEN ir<%84> = add nuw nsw ir<%indvars.iv1696>, ir<%idxprom425>
    WIDEN ir<%shl477> = shl nuw ir<1>, ir<%84>
    WIDEN ir<%not478> = xor ir<%shl477>, ir<-1>
    WIDEN ir<%and479> = and ir<%and47916481653>, ir<%not478>
    WIDEN-SELECT ir<%add487> = select ir<%or.cond1567>, ir<%85>, ir<0> (condition is loop invariant)
    WIDEN ir<%cond489> = add nsw ir<%add487>, ir<%62>
    CLONE ir<%arrayidx492> = getelementptr inbounds ir<@reg_reloaded_contents>, ir<0>, ir<%84>
    vp<%4> = vector-pointer ir<%arrayidx492>
    WIDEN store vp<%4>, ir<%cond489>
    CLONE ir<%arrayidx495> = getelementptr inbounds ir<@reg_reloaded_insn>, ir<0>, ir<%84>
    vp<%5> = vector-pointer ir<%arrayidx495>
    WIDEN store vp<%5>, ir<%0>
    WIDEN ir<%or> = or ir<%or16501652>, ir<%shl477>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%and47916481653>, ir<%and479>
  EMIT vp<%9> = compute-reduction-result ir<%or16501652>, ir<%or>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>, scalar.ph

ir-bb<for.cond471.if.end1216.loopexit1610_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and479.lcssa = vp<%8>
Live-out i64 %or.lcssa = vp<%9>
}
================ Final VPlan ================

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body261.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond2391725 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1686 = phi 0, %indvars.iv.next1687, ir<1>
    WIDEN-REDUCTION-PHI ir<%and26316411643> = phi ir<%reg_reloaded_valid.promoted1640>, ir<%and263>
    CLONE ir<%59> = add nuw nsw ir<%indvars.iv1686>, ir<%58>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%59>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and263> = and ir<%and26316411643>, ir<%not>
    CLONE ir<%indvars.iv.next1687> = add nuw nsw ir<%indvars.iv1686>, ir<1>
    CLONE ir<%exitcond1690.not> = icmp eq ir<%indvars.iv.next1687>, ir<%wide.trip.count1689>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and26316411643>, ir<%and263>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond258.for.end266_crit_edge>, scalar.ph

ir-bb<for.cond258.for.end266_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and263.lcssa = vp<%6>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body261.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond2391725 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1686 = phi 0, %indvars.iv.next1687, ir<1>
    WIDEN-REDUCTION-PHI ir<%and26316411643> = phi ir<%reg_reloaded_valid.promoted1640>, ir<%and263>
    WIDEN ir<%59> = add nuw nsw ir<%indvars.iv1686>, ir<%58>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%59>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and263> = and ir<%and26316411643>, ir<%not>
    WIDEN ir<%indvars.iv.next1687> = add nuw nsw ir<%indvars.iv1686>, ir<1>
    CLONE ir<%exitcond1690.not> = icmp eq ir<%indvars.iv.next1687>, ir<%wide.trip.count1689>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and26316411643>, ir<%and263>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond258.for.end266_crit_edge>, scalar.ph

ir-bb<for.cond258.for.end266_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and263.lcssa = vp<%6>
}

========== Loop: emit_reload_insns' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body261.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond2391725 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1686 = phi 0, %indvars.iv.next1687, ir<1>
    WIDEN-REDUCTION-PHI ir<%and26316411643> = phi ir<%reg_reloaded_valid.promoted1640>, ir<%and263>
    WIDEN ir<%59> = add nuw nsw ir<%indvars.iv1686>, ir<%58>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%59>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and263> = and ir<%and26316411643>, ir<%not>
    WIDEN ir<%indvars.iv.next1687> = add nuw nsw ir<%indvars.iv1686>, ir<1>
    CLONE ir<%exitcond1690.not> = icmp eq ir<%indvars.iv.next1687>, ir<%wide.trip.count1689>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and26316411643>, ir<%and263>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond258.for.end266_crit_edge>, scalar.ph

ir-bb<for.cond258.for.end266_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and263.lcssa = vp<%6>
}


-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1686 = phi i64 [ 0, %for.body261.preheader ], [ %indvars.iv.next1687, %for.body261 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and26316411643 = phi i64 [ %reg_reloaded_valid.promoted1640, %for.body261.preheader ], [ %and263, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %59 = add nuw nsw i64 %indvars.iv1686, %58 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %59 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and263 = and i64 %and26316411643, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1687 = add nuw nsw i64 %indvars.iv1686, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond1690.not = icmp eq i64 %indvars.iv.next1687, %wide.trip.count1689 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond1690.not, label %for.cond258.for.end266_crit_edge, label %for.body261 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1686 = phi i64 [ 0, %for.body261.preheader ], [ %indvars.iv.next1687, %for.body261 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and26316411643 = phi i64 [ %reg_reloaded_valid.promoted1640, %for.body261.preheader ], [ %and263, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %59 = add nuw nsw i64 %indvars.iv1686, %58 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %59 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and263 = and i64 %and26316411643, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1687 = add nuw nsw i64 %indvars.iv1686, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond1690.not = icmp eq i64 %indvars.iv.next1687, %wide.trip.count1689 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond1690.not, label %for.cond258.for.end266_crit_edge, label %for.body261 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1686 = phi i64 [ 0, %for.body261.preheader ], [ %indvars.iv.next1687, %for.body261 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and26316411643 = phi i64 [ %reg_reloaded_valid.promoted1640, %for.body261.preheader ], [ %and263, %for.body261 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %59 = add nuw nsw i64 %indvars.iv1686, %58 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %59 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and263 = and i64 %and26316411643, %not of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1687 = add nuw nsw i64 %indvars.iv1686, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond1690.not = icmp eq i64 %indvars.iv.next1687, %wide.trip.count1689 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond1690.not, label %for.cond258.for.end266_crit_edge, label %for.body261 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1686 = phi i64 [ 0, %for.body261.preheader ], [ %indvars.iv.next1687, %for.body261 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and26316411643 = phi i64 [ %reg_reloaded_valid.promoted1640, %for.body261.preheader ], [ %and263, %for.body261 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %59 = add nuw nsw i64 %indvars.iv1686, %58 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %59 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and263 = and i64 %and26316411643, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1687 = add nuw nsw i64 %indvars.iv1686, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond1690.not = icmp eq i64 %indvars.iv.next1687, %wide.trip.count1689 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond1690.not, label %for.cond258.for.end266_crit_edge, label %for.body261 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 22

-----------------Function that is being costed:'emit_reload_insns' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1686 = phi i64 [ 0, %for.body261.preheader ], [ %indvars.iv.next1687, %for.body261 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and26316411643 = phi i64 [ %reg_reloaded_valid.promoted1640, %for.body261.preheader ], [ %and263, %for.body261 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %59 = add nuw nsw i64 %indvars.iv1686, %58 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %59 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and263 = and i64 %and26316411643, %not of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1687 = add nuw nsw i64 %indvars.iv1686, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond1690.not = icmp eq i64 %indvars.iv.next1687, %wide.trip.count1689 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond1690.not, label %for.cond258.for.end266_crit_edge, label %for.body261 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 44
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: emit_reload_insns at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body261.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond2391725 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1686 = phi 0, %indvars.iv.next1687, ir<1>
    WIDEN-REDUCTION-PHI ir<%and26316411643> = phi ir<%reg_reloaded_valid.promoted1640>, ir<%and263>
    WIDEN ir<%59> = add nuw nsw ir<%indvars.iv1686>, ir<%58>
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%59>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and263> = and ir<%and26316411643>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and26316411643>, ir<%and263>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond258.for.end266_crit_edge>, scalar.ph

ir-bb<for.cond258.for.end266_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and263.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 23
Loops Analyzed: 125
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  store ptr null, ptr %arrayidx94.us, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr null, ptr %arrayidx94.us, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store ptr null, ptr %arrayidx94.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store ptr null, ptr %arrayidx94.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond78189 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv177 = phi %indvars.iv.next178, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%and91164166.us> = phi ir<%reg_reloaded_valid.promoted>, ir<%and91.us>
    CLONE ir<%19> = add nuw nsw ir<%indvars.iv177>, ir<%18>
    CLONE ir<%shl90.us> = shl nuw ir<1>, ir<%19>
    CLONE ir<%not.us> = xor ir<%shl90.us>, ir<-1>
    CLONE ir<%and91.us> = and ir<%and91164166.us>, ir<%not.us>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<@spill_reg_store>, ir<0>, ir<%19>
    CLONE store ir<null>, ir<%arrayidx94.us>
    CLONE ir<%indvars.iv.next178> = add nuw nsw ir<%indvars.iv177>, ir<1>
    CLONE ir<%exitcond181.not> = icmp eq ir<%indvars.iv.next178>, ir<%wide.trip.count180>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and91164166.us>, ir<%and91.us>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>, scalar.ph

ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>:
No successors

scalar.ph:
No successors

Live-out i64 %and91.us.lcssa = vp<%6>
}

========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond78189 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv177 = phi %indvars.iv.next178, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%and91164166.us> = phi ir<%reg_reloaded_valid.promoted>, ir<%and91.us>
    WIDEN ir<%19> = add nuw nsw ir<%indvars.iv177>, ir<%18>
    WIDEN ir<%shl90.us> = shl nuw ir<1>, ir<%19>
    WIDEN ir<%not.us> = xor ir<%shl90.us>, ir<-1>
    WIDEN ir<%and91.us> = and ir<%and91164166.us>, ir<%not.us>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<@spill_reg_store>, ir<0>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx94.us>
    WIDEN store vp<%4>, ir<null>
    WIDEN ir<%indvars.iv.next178> = add nuw nsw ir<%indvars.iv177>, ir<1>
    CLONE ir<%exitcond181.not> = icmp eq ir<%indvars.iv.next178>, ir<%wide.trip.count180>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%and91164166.us>, ir<%and91.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>, scalar.ph

ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>:
No successors

scalar.ph:
No successors

Live-out i64 %and91.us.lcssa = vp<%7>
}

========== Loop: forget_old_reloads_1' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond78189 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv177 = phi %indvars.iv.next178, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%and91164166.us> = phi ir<%reg_reloaded_valid.promoted>, ir<%and91.us>
    WIDEN ir<%19> = add nuw nsw ir<%indvars.iv177>, ir<%18>
    WIDEN ir<%shl90.us> = shl nuw ir<1>, ir<%19>
    WIDEN ir<%not.us> = xor ir<%shl90.us>, ir<-1>
    WIDEN ir<%and91.us> = and ir<%and91164166.us>, ir<%not.us>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<@spill_reg_store>, ir<0>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx94.us>
    WIDEN store vp<%4>, ir<null>
    WIDEN ir<%indvars.iv.next178> = add nuw nsw ir<%indvars.iv177>, ir<1>
    CLONE ir<%exitcond181.not> = icmp eq ir<%indvars.iv.next178>, ir<%wide.trip.count180>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%and91164166.us>, ir<%and91.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>, scalar.ph

ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>:
No successors

scalar.ph:
No successors

Live-out i64 %and91.us.lcssa = vp<%7>
}


-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv177 = phi i64 [ %indvars.iv.next178, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and91164166.us = phi i64 [ %and91.us, %for.body.us ], [ %reg_reloaded_valid.promoted, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %19 = add nuw nsw i64 %indvars.iv177, %18 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl90.us = shl nuw i64 1, %19 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not.us = xor i64 %shl90.us, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and91.us = and i64 %and91164166.us, %not.us of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx94.us = getelementptr inbounds [53 x ptr], ptr @spill_reg_store, i64 0, i64 %19 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr null, ptr %arrayidx94.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %wide.trip.count180 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond181.not, label %for.cond.if.end96.loopexit_crit_edge.split.us, label %for.body.us of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv177 = phi i64 [ %indvars.iv.next178, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and91164166.us = phi i64 [ %and91.us, %for.body.us ], [ %reg_reloaded_valid.promoted, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %19 = add nuw nsw i64 %indvars.iv177, %18 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl90.us = shl nuw i64 1, %19 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not.us = xor i64 %shl90.us, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and91.us = and i64 %and91164166.us, %not.us of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx94.us = getelementptr inbounds [53 x ptr], ptr @spill_reg_store, i64 0, i64 %19 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store ptr null, ptr %arrayidx94.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %wide.trip.count180 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond181.not, label %for.cond.if.end96.loopexit_crit_edge.split.us, label %for.body.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv177 = phi i64 [ %indvars.iv.next178, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and91164166.us = phi i64 [ %and91.us, %for.body.us ], [ %reg_reloaded_valid.promoted, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %19 = add nuw nsw i64 %indvars.iv177, %18 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl90.us = shl nuw i64 1, %19 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not.us = xor i64 %shl90.us, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and91.us = and i64 %and91164166.us, %not.us of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx94.us = getelementptr inbounds [53 x ptr], ptr @spill_reg_store, i64 0, i64 %19 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store ptr null, ptr %arrayidx94.us, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %wide.trip.count180 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond181.not, label %for.cond.if.end96.loopexit_crit_edge.split.us, label %for.body.us of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 13
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 26, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv177 = phi i64 [ %indvars.iv.next178, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and91164166.us = phi i64 [ %and91.us, %for.body.us ], [ %reg_reloaded_valid.promoted, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %19 = add nuw nsw i64 %indvars.iv177, %18 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl90.us = shl nuw i64 1, %19 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not.us = xor i64 %shl90.us, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and91.us = and i64 %and91164166.us, %not.us of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx94.us = getelementptr inbounds [53 x ptr], ptr @spill_reg_store, i64 0, i64 %19 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store ptr null, ptr %arrayidx94.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %wide.trip.count180 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond181.not, label %for.cond.if.end96.loopexit_crit_edge.split.us, label %for.body.us of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 13
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'forget_old_reloads_1' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv177 = phi i64 [ %indvars.iv.next178, %for.body.us ], [ 0, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and91164166.us = phi i64 [ %and91.us, %for.body.us ], [ %reg_reloaded_valid.promoted, %for.body.us.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %19 = add nuw nsw i64 %indvars.iv177, %18 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl90.us = shl nuw i64 1, %19 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not.us = xor i64 %shl90.us, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and91.us = and i64 %and91164166.us, %not.us of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx94.us = getelementptr inbounds [53 x ptr], ptr @spill_reg_store, i64 0, i64 %19 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store ptr null, ptr %arrayidx94.us, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next178 = add nuw nsw i64 %indvars.iv177, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond181.not = icmp eq i64 %indvars.iv.next178, %wide.trip.count180 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond181.not, label %for.cond.if.end96.loopexit_crit_edge.split.us, label %for.body.us of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 13
B VF: 4, EstimatedWidthB: 4, CostB: 13
CostA * EstimatedWidthB: 52, CostB * EstimatedWidthA: 52
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: forget_old_reloads_1 at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.us.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %cond78189 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv177 = phi %indvars.iv.next178, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%and91164166.us> = phi ir<%reg_reloaded_valid.promoted>, ir<%and91.us>
    WIDEN ir<%19> = add nuw nsw ir<%indvars.iv177>, ir<%18>
    WIDEN ir<%shl90.us> = shl nuw ir<1>, ir<%19>
    WIDEN ir<%not.us> = xor ir<%shl90.us>, ir<-1>
    WIDEN ir<%and91.us> = and ir<%and91164166.us>, ir<%not.us>
    CLONE ir<%arrayidx94.us> = getelementptr inbounds ir<@spill_reg_store>, ir<0>, ir<%19>
    vp<%4> = vector-pointer ir<%arrayidx94.us>
    WIDEN store vp<%4>, ir<null>
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%and91164166.us>, ir<%and91.us>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>, scalar.ph

ir-bb<for.cond.if.end96.loopexit_crit_edge.split.us>:
No successors

scalar.ph:
No successors

Live-out i64 %and91.us.lcssa = vp<%7>
}
================ Final VPlan ================

================================================
Loops Vectorized: 24
Loops Analyzed: 129
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load ptr, ptr %arrayidx, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)
========== Loop: choose_reload_regs_init' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%save_reload_reg_rtx>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx>
    CLONE ir<%reg_rtx> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv>, ir<11>
    CLONE store ir<%1>, ir<%reg_rtx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs_init' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%save_reload_reg_rtx>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%reg_rtx> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv>, ir<11>
    WIDEN store ir<%reg_rtx>, ir<%1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: choose_reload_regs_init' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%save_reload_reg_rtx>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%1> = load vp<%4>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%reg_rtx> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv>, ir<11>
    WIDEN store ir<%reg_rtx>, ir<%1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'choose_reload_regs_init' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %save_reload_reg_rtx, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %reg_rtx = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv, i32 11 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store ptr %1, ptr %reg_rtx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'choose_reload_regs_init' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %save_reload_reg_rtx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %reg_rtx = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv, i32 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store ptr %1, ptr %reg_rtx, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709119, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709119, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'choose_reload_regs_init' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %save_reload_reg_rtx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %reg_rtx = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv, i32 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store ptr %1, ptr %reg_rtx, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4831838211, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4831838211, RTCostB: 5368709119
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'choose_reload_regs_init' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %save_reload_reg_rtx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %1 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %reg_rtx = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv, i32 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store ptr %1, ptr %reg_rtx, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709119, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709119, RTCostB: 4831838211

-----------------Function that is being costed:'choose_reload_regs_init' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds ptr, ptr %save_reload_reg_rtx, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %1 = load ptr, ptr %arrayidx, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %reg_rtx = getelementptr inbounds [180 x %struct.reload], ptr @rld, i64 0, i64 %indvars.iv, i32 11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store ptr %1, ptr %reg_rtx, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4831838211, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4831838211, RTCostB: 4831838211
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: choose_reload_regs_init at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%save_reload_reg_rtx>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%5>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%reg_rtx> = getelementptr inbounds ir<@rld>, ir<0>, ir<%indvars.iv>, ir<11>
    WIDEN store ir<%reg_rtx>, ir<%4>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 25
Loops Analyzed: 131
Loops Epilogues Vectorized: 0
================================================
========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond87) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %20, %indvars.iv.next, ir<-1>
    CLONE ir<%arrayidx93> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv>
    CLONE ir<%use_index> = getelementptr inbounds ir<%arrayidx93>, ir<96>
    CLONE store ir<-1>, ir<%use_index>
    CLONE ir<%store_ruid> = getelementptr inbounds ir<%arrayidx93>, ir<112>
    CLONE store ir<%19>, ir<%store_ruid>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv>, ir<%21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit257>, scalar.ph

ir-bb<cleanup.loopexit257>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond87) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %20, %indvars.iv.next, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx93> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%use_index> = getelementptr inbounds ir<%arrayidx93>, ir<96>
    WIDEN store ir<%use_index>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx93>, ir<112>
    WIDEN store ir<%store_ruid>, ir<%19>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv>, ir<%21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit257>, scalar.ph

ir-bb<cleanup.loopexit257>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond87) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %20, %indvars.iv.next, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx93> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%use_index> = getelementptr inbounds ir<%arrayidx93>, ir<96>
    WIDEN store ir<%use_index>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx93>, ir<112>
    WIDEN store ir<%store_ruid>, ir<%19>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp90.not.not> = icmp sgt ir<%indvars.iv>, ir<%21>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit257>, scalar.ph

ir-bb<cleanup.loopexit257>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %19, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit257 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %19, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit257 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %19, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit257 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %19, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit257 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 21
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 88
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %19, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit257 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 21
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 42

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %19, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit257 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 8, EstimatedWidthB: 8, CostB: 21
CostA * EstimatedWidthB: 88, CostB * EstimatedWidthA: 84

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %20, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx93 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index = getelementptr inbounds i8, ptr %arrayidx93, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %store_ruid = getelementptr inbounds i8, ptr %arrayidx93, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 %19, ptr %store_ruid, align 8 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp90.not.not = icmp sgt i64 %indvars.iv, %21 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp90.not.not, label %for.body, label %cleanup.loopexit257 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 21
B VF: 8, EstimatedWidthB: 8, CostB: 21
CostA * EstimatedWidthB: 168, CostB * EstimatedWidthA: 168
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: reload_combine_note_store at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond87) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %20, %indvars.iv.next, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx93> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%use_index> = getelementptr inbounds ir<%arrayidx93>, ir<96>
    WIDEN store ir<%use_index>, ir<-1>
    WIDEN-GEP Var[Inv] ir<%store_ruid> = getelementptr inbounds ir<%arrayidx93>, ir<112>
    WIDEN store ir<%store_ruid>, ir<%19>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit257>, scalar.ph

ir-bb<cleanup.loopexit257>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body169.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond163) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv253 = phi %54, %indvars.iv.next254, ir<-1>
    CLONE ir<%arrayidx171> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv253>
    CLONE ir<%store_ruid172> = getelementptr inbounds ir<%arrayidx171>, ir<112>
    CLONE store ir<%53>, ir<%store_ruid172>
    CLONE ir<%use_index175> = getelementptr inbounds ir<%arrayidx171>, ir<96>
    CLONE store ir<6>, ir<%use_index175>
    CLONE ir<%indvars.iv.next254> = add nsw ir<%indvars.iv253>, ir<-1>
    CLONE ir<%cmp167.not.not> = icmp sgt ir<%indvars.iv253>, ir<%55>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body169.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond163) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv253 = phi %54, %indvars.iv.next254, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx171> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv253>
    WIDEN-GEP Var[Inv] ir<%store_ruid172> = getelementptr inbounds ir<%arrayidx171>, ir<112>
    WIDEN store ir<%store_ruid172>, ir<%53>
    WIDEN-GEP Var[Inv] ir<%use_index175> = getelementptr inbounds ir<%arrayidx171>, ir<96>
    WIDEN store ir<%use_index175>, ir<6>
    WIDEN ir<%indvars.iv.next254> = add nsw ir<%indvars.iv253>, ir<-1>
    CLONE ir<%cmp167.not.not> = icmp sgt ir<%indvars.iv253>, ir<%55>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_store' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body169.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond163) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv253 = phi %54, %indvars.iv.next254, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx171> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv253>
    WIDEN-GEP Var[Inv] ir<%store_ruid172> = getelementptr inbounds ir<%arrayidx171>, ir<112>
    WIDEN store ir<%store_ruid172>, ir<%53>
    WIDEN-GEP Var[Inv] ir<%use_index175> = getelementptr inbounds ir<%arrayidx171>, ir<96>
    WIDEN store ir<%use_index175>, ir<6>
    WIDEN ir<%indvars.iv.next254> = add nsw ir<%indvars.iv253>, ir<-1>
    CLONE ir<%cmp167.not.not> = icmp sgt ir<%indvars.iv253>, ir<%55>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv253 = phi i64 [ %54, %for.body169.lr.ph ], [ %indvars.iv.next254, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv253 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %53, ptr %store_ruid172, align 8 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 6, ptr %use_index175, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next254 = add nsw i64 %indvars.iv253, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv253, %55 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv253 = phi i64 [ %54, %for.body169.lr.ph ], [ %indvars.iv.next254, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv253 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %53, ptr %store_ruid172, align 8 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 6, ptr %use_index175, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next254 = add nsw i64 %indvars.iv253, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv253, %55 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv253 = phi i64 [ %54, %for.body169.lr.ph ], [ %indvars.iv.next254, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv253 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 %53, ptr %store_ruid172, align 8 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 6, ptr %use_index175, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next254 = add nsw i64 %indvars.iv253, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv253, %55 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 11
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 22, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv253 = phi i64 [ %54, %for.body169.lr.ph ], [ %indvars.iv.next254, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv253 of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 %53, ptr %store_ruid172, align 8 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 6, ptr %use_index175, align 8 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next254 = add nsw i64 %indvars.iv253, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv253, %55 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 32
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 21
B VF: 4, EstimatedWidthB: 4, CostB: 11
CostA * EstimatedWidthB: 84, CostB * EstimatedWidthA: 88
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv253 = phi i64 [ %54, %for.body169.lr.ph ], [ %indvars.iv.next254, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv253 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 %53, ptr %store_ruid172, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 6, ptr %use_index175, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next254 = add nsw i64 %indvars.iv253, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv253, %55 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 21
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 42

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv253 = phi i64 [ %54, %for.body169.lr.ph ], [ %indvars.iv.next254, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv253 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 %53, ptr %store_ruid172, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 6, ptr %use_index175, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next254 = add nsw i64 %indvars.iv253, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv253, %55 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 11
B VF: 8, EstimatedWidthB: 8, CostB: 21
CostA * EstimatedWidthB: 88, CostB * EstimatedWidthA: 84

-----------------Function that is being costed:'reload_combine_note_store' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv253 = phi i64 [ %54, %for.body169.lr.ph ], [ %indvars.iv.next254, %for.body169 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx171 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %indvars.iv253 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %store_ruid172 = getelementptr inbounds i8, ptr %arrayidx171, i64 112 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 %53, ptr %store_ruid172, align 8 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index175 = getelementptr inbounds i8, ptr %arrayidx171, i64 96 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 6, ptr %use_index175, align 8 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next254 = add nsw i64 %indvars.iv253, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp167.not.not = icmp sgt i64 %indvars.iv253, %55 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp167.not.not, label %for.body169, label %cleanup.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 21
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 21, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 21
B VF: 8, EstimatedWidthB: 8, CostB: 21
CostA * EstimatedWidthB: 168, CostB * EstimatedWidthA: 168
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: reload_combine_note_store at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body169.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (sext i32 (-1 + %4 + %regno.0 + %cond163) to i64) + (-1 * (sext i32 (%4 + %regno.0) to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv253 = phi %54, %indvars.iv.next254, ir<-1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx171> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%indvars.iv253>
    WIDEN-GEP Var[Inv] ir<%store_ruid172> = getelementptr inbounds ir<%arrayidx171>, ir<112>
    WIDEN store ir<%store_ruid172>, ir<%53>
    WIDEN-GEP Var[Inv] ir<%use_index175> = getelementptr inbounds ir<%arrayidx171>, ir<96>
    WIDEN store ir<%use_index175>, ir<6>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.loopexit>, scalar.ph

ir-bb<cleanup.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 27
Loops Analyzed: 186
Loops Epilogues Vectorized: 0
================================================
========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body221.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond213473 to i64) + (-1 * (1 umin (zext i32 %cond213473 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %34, %indvars.iv.next, ir<-1>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%36> = add nsw ir<%indvars.iv.next>, ir<%35>
    CLONE ir<%use_index225> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%36>, ir<1>
    CLONE store ir<-1>, ir<%use_index225>
    CLONE ir<%cmp219> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit494>, scalar.ph

ir-bb<cleanup309.loopexit494>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body221.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond213473 to i64) + (-1 * (1 umin (zext i32 %cond213473 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %34, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%36> = add nsw ir<%indvars.iv.next>, ir<%35>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index225> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%36>, ir<1>
    WIDEN store ir<%use_index225>, ir<-1>
    CLONE ir<%cmp219> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit494>, scalar.ph

ir-bb<cleanup309.loopexit494>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body221.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond213473 to i64) + (-1 * (1 umin (zext i32 %cond213473 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %34, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%36> = add nsw ir<%indvars.iv.next>, ir<%35>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index225> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%36>, ir<1>
    WIDEN store ir<%use_index225>, ir<-1>
    CLONE ir<%cmp219> = icmp ugt ir<%indvars.iv>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit494>, scalar.ph

ir-bb<cleanup309.loopexit494>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -1, ptr %use_index225, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit494 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -1, ptr %use_index225, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit494 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354559, RTCostB: 4294967292
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354559, RTCostB: 4294967292
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 -1, ptr %use_index225, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit494 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919107, RTCostB: 4294967292
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919107, RTCostB: 2684354559
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 -1, ptr %use_index225, align 8 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit494 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2281701387, RTCostB: 4294967292
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2281701387, RTCostB: 2415919107
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 -1, ptr %use_index225, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit494 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354559, RTCostB: 4294967292
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354559, RTCostB: 2281701387

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 -1, ptr %use_index225, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit494 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919107, RTCostB: 4294967292
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919107, RTCostB: 2281701387

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %34, %while.body221.preheader ], [ %indvars.iv.next, %while.body221 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %36 = add nsw i64 %indvars.iv.next, %35 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index225 = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %36, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 -1, ptr %use_index225, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp219 = icmp ugt i64 %indvars.iv, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp219, label %while.body221, label %cleanup309.loopexit494 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2281701387, RTCostB: 4294967292
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2281701387, RTCostB: 2281701387
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: reload_combine_note_use at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body221.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond213473 to i64) + (-1 * (1 umin (zext i32 %cond213473 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %34, %indvars.iv.next, ir<-1>
    WIDEN ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    WIDEN ir<%36> = add nsw ir<%indvars.iv.next>, ir<%35>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index225> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%36>, ir<1>
    WIDEN store ir<%use_index225>, ir<-1>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit494>, scalar.ph

ir-bb<cleanup309.loopexit494>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond77470 to i64) + (-1 * (1 umin (zext i32 %cond77470 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv460 = phi %14, %indvars.iv.next461, ir<-1>
    CLONE ir<%indvars.iv.next461> = add nsw ir<%indvars.iv460>, ir<-1>
    CLONE ir<%16> = add nsw ir<%indvars.iv.next461>, ir<%15>
    CLONE ir<%use_index> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%16>, ir<1>
    CLONE store ir<-1>, ir<%use_index>
    CLONE ir<%cmp78> = icmp ugt ir<%indvars.iv460>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit493>, scalar.ph

ir-bb<cleanup309.loopexit493>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond77470 to i64) + (-1 * (1 umin (zext i32 %cond77470 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv460 = phi %14, %indvars.iv.next461, ir<-1>
    WIDEN ir<%indvars.iv.next461> = add nsw ir<%indvars.iv460>, ir<-1>
    WIDEN ir<%16> = add nsw ir<%indvars.iv.next461>, ir<%15>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%16>, ir<1>
    WIDEN store ir<%use_index>, ir<-1>
    CLONE ir<%cmp78> = icmp ugt ir<%indvars.iv460>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit493>, scalar.ph

ir-bb<cleanup309.loopexit493>:
No successors

scalar.ph:
No successors
}

========== Loop: reload_combine_note_use' from reload1.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond77470 to i64) + (-1 * (1 umin (zext i32 %cond77470 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv460 = phi %14, %indvars.iv.next461, ir<-1>
    WIDEN ir<%indvars.iv.next461> = add nsw ir<%indvars.iv460>, ir<-1>
    WIDEN ir<%16> = add nsw ir<%indvars.iv.next461>, ir<%15>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%16>, ir<1>
    WIDEN store ir<%use_index>, ir<-1>
    CLONE ir<%cmp78> = icmp ugt ir<%indvars.iv460>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit493>, scalar.ph

ir-bb<cleanup309.loopexit493>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv460 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next461, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next461 = add nsw i64 %indvars.iv460, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %16 = add nsw i64 %indvars.iv.next461, %15 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv460, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit493 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv460 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next461, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next461 = add nsw i64 %indvars.iv460, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %16 = add nsw i64 %indvars.iv.next461, %15 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv460, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit493 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354559, RTCostB: 4294967292
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354559, RTCostB: 4294967292
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv460 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next461, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next461 = add nsw i64 %indvars.iv460, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %16 = add nsw i64 %indvars.iv.next461, %15 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv460, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit493 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2415919107, RTCostB: 4294967292
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2415919107, RTCostB: 2684354559
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv460 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next461, %while.body ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next461 = add nsw i64 %indvars.iv460, -1 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %16 = add nsw i64 %indvars.iv.next461, %15 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv460, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit493 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 2281701387, RTCostB: 4294967292
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2281701387, RTCostB: 2415919107
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv460 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next461, %while.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next461 = add nsw i64 %indvars.iv460, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %16 = add nsw i64 %indvars.iv.next461, %15 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv460, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit493 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2684354559, RTCostB: 4294967292
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354559, RTCostB: 2281701387

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv460 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next461, %while.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next461 = add nsw i64 %indvars.iv460, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %16 = add nsw i64 %indvars.iv.next461, %15 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv460, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit493 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2415919107, RTCostB: 4294967292
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2415919107, RTCostB: 2281701387

-----------------Function that is being costed:'reload_combine_note_use' from reload1.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv460 = phi i64 [ %14, %while.body.preheader ], [ %indvars.iv.next461, %while.body ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next461 = add nsw i64 %indvars.iv460, -1 of type:add
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %16 = add nsw i64 %indvars.iv.next461, %15 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %use_index = getelementptr inbounds [53 x %struct.anon.5], ptr @reg_state, i64 0, i64 %16, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 -1, ptr %use_index, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp78 = icmp ugt i64 %indvars.iv460, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp78, label %while.body, label %cleanup309.loopexit493 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 2281701387, RTCostB: 4294967292
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2281701387, RTCostB: 2281701387
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: reload_combine_note_use at line: reload1.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 %cond77470 to i64) + (-1 * (1 umin (zext i32 %cond77470 to i64)))<nuw><nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv460 = phi %14, %indvars.iv.next461, ir<-1>
    WIDEN ir<%indvars.iv.next461> = add nsw ir<%indvars.iv460>, ir<-1>
    WIDEN ir<%16> = add nsw ir<%indvars.iv.next461>, ir<%15>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%use_index> = getelementptr inbounds ir<@reg_state>, ir<0>, ir<%16>, ir<1>
    WIDEN store ir<%use_index>, ir<-1>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup309.loopexit493>, scalar.ph

ir-bb<cleanup309.loopexit493>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 29
Loops Analyzed: 190
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o reorg.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         reorg.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o resource.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         resource.c
========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body164.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond155 + %.fr644) to i64) + (-1 * (zext i32 %.fr644 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv726 = phi %23, %indvars.iv.next727, ir<1>
    WIDEN-REDUCTION-PHI ir<%24> = phi ir<%regs167.promoted>, ir<%or168>
    CLONE ir<%shl166> = shl nuw nsw ir<1>, ir<%indvars.iv726>
    CLONE ir<%or168> = or ir<%24>, ir<%shl166>
    CLONE ir<%indvars.iv.next727> = add nuw nsw ir<%indvars.iv726>, ir<1>
    CLONE ir<%exitcond729.not> = icmp eq ir<%indvars.iv.next727>, ir<%wide.trip.count728>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%24>, ir<%or168>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>, scalar.ph

ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or168.lcssa = vp<%6>
}

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body164.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond155 + %.fr644) to i64) + (-1 * (zext i32 %.fr644 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv726 = phi %23, %indvars.iv.next727, ir<1>
    WIDEN-REDUCTION-PHI ir<%24> = phi ir<%regs167.promoted>, ir<%or168>
    WIDEN ir<%shl166> = shl nuw nsw ir<1>, ir<%indvars.iv726>
    WIDEN ir<%or168> = or ir<%24>, ir<%shl166>
    WIDEN ir<%indvars.iv.next727> = add nuw nsw ir<%indvars.iv726>, ir<1>
    CLONE ir<%exitcond729.not> = icmp eq ir<%indvars.iv.next727>, ir<%wide.trip.count728>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%24>, ir<%or168>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>, scalar.ph

ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or168.lcssa = vp<%6>
}

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body164.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond155 + %.fr644) to i64) + (-1 * (zext i32 %.fr644 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv726 = phi %23, %indvars.iv.next727, ir<1>
    WIDEN-REDUCTION-PHI ir<%24> = phi ir<%regs167.promoted>, ir<%or168>
    WIDEN ir<%shl166> = shl nuw nsw ir<1>, ir<%indvars.iv726>
    WIDEN ir<%or168> = or ir<%24>, ir<%shl166>
    WIDEN ir<%indvars.iv.next727> = add nuw nsw ir<%indvars.iv726>, ir<1>
    CLONE ir<%exitcond729.not> = icmp eq ir<%indvars.iv.next727>, ir<%wide.trip.count728>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%24>, ir<%or168>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>, scalar.ph

ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or168.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv726 = phi i64 [ %23, %for.body164.lr.ph ], [ %indvars.iv.next727, %for.body164 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %24 = phi i64 [ %regs167.promoted, %for.body164.lr.ph ], [ %or168, %for.body164 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl166 = shl nuw nsw i64 1, %indvars.iv726 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or168 = or i64 %24, %shl166 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next727 = add nuw nsw i64 %indvars.iv726, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond729.not = icmp eq i64 %indvars.iv.next727, %wide.trip.count728 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond729.not, label %for.cond161.cleanup410.loopexit561_crit_edge, label %for.body164 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv726 = phi i64 [ %23, %for.body164.lr.ph ], [ %indvars.iv.next727, %for.body164 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %24 = phi i64 [ %regs167.promoted, %for.body164.lr.ph ], [ %or168, %for.body164 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl166 = shl nuw nsw i64 1, %indvars.iv726 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or168 = or i64 %24, %shl166 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next727 = add nuw nsw i64 %indvars.iv726, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond729.not = icmp eq i64 %indvars.iv.next727, %wide.trip.count728 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond729.not, label %for.cond161.cleanup410.loopexit561_crit_edge, label %for.body164 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv726 = phi i64 [ %23, %for.body164.lr.ph ], [ %indvars.iv.next727, %for.body164 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %24 = phi i64 [ %regs167.promoted, %for.body164.lr.ph ], [ %or168, %for.body164 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl166 = shl nuw nsw i64 1, %indvars.iv726 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or168 = or i64 %24, %shl166 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next727 = add nuw nsw i64 %indvars.iv726, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond729.not = icmp eq i64 %indvars.iv.next727, %wide.trip.count728 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond729.not, label %for.cond161.cleanup410.loopexit561_crit_edge, label %for.body164 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv726 = phi i64 [ %23, %for.body164.lr.ph ], [ %indvars.iv.next727, %for.body164 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %24 = phi i64 [ %regs167.promoted, %for.body164.lr.ph ], [ %or168, %for.body164 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl166 = shl nuw nsw i64 1, %indvars.iv726 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or168 = or i64 %24, %shl166 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next727 = add nuw nsw i64 %indvars.iv726, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond729.not = icmp eq i64 %indvars.iv.next727, %wide.trip.count728 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond729.not, label %for.cond161.cleanup410.loopexit561_crit_edge, label %for.body164 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv726 = phi i64 [ %23, %for.body164.lr.ph ], [ %indvars.iv.next727, %for.body164 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %24 = phi i64 [ %regs167.promoted, %for.body164.lr.ph ], [ %or168, %for.body164 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl166 = shl nuw nsw i64 1, %indvars.iv726 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or168 = or i64 %24, %shl166 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next727 = add nuw nsw i64 %indvars.iv726, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond729.not = icmp eq i64 %indvars.iv.next727, %wide.trip.count728 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond729.not, label %for.cond161.cleanup410.loopexit561_crit_edge, label %for.body164 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_referenced_resources at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body164.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond155 + %.fr644) to i64) + (-1 * (zext i32 %.fr644 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv726 = phi %23, %indvars.iv.next727, ir<1>
    WIDEN-REDUCTION-PHI ir<%24> = phi ir<%regs167.promoted>, ir<%or168>
    WIDEN ir<%shl166> = shl nuw nsw ir<1>, ir<%indvars.iv726>
    WIDEN ir<%or168> = or ir<%24>, ir<%shl166>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%24>, ir<%or168>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>, scalar.ph

ir-bb<for.cond161.cleanup410.loopexit561_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or168.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond60 + %call.fr) to i64) + (-1 * (zext i32 %call.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv730 = phi %11, %indvars.iv.next731, ir<1>
    WIDEN-REDUCTION-PHI ir<%12> = phi ir<%regs.promoted>, ir<%or>
    CLONE ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv730>
    CLONE ir<%or> = or ir<%12>, ir<%shl>
    CLONE ir<%indvars.iv.next731> = add nuw nsw ir<%indvars.iv730>, ir<1>
    CLONE ir<%exitcond733.not> = icmp eq ir<%indvars.iv.next731>, ir<%wide.trip.count732>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%12>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup410.loopexit560_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup410.loopexit560_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond60 + %call.fr) to i64) + (-1 * (zext i32 %call.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv730 = phi %11, %indvars.iv.next731, ir<1>
    WIDEN-REDUCTION-PHI ir<%12> = phi ir<%regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv730>
    WIDEN ir<%or> = or ir<%12>, ir<%shl>
    WIDEN ir<%indvars.iv.next731> = add nuw nsw ir<%indvars.iv730>, ir<1>
    CLONE ir<%exitcond733.not> = icmp eq ir<%indvars.iv.next731>, ir<%wide.trip.count732>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%12>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup410.loopexit560_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup410.loopexit560_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}

========== Loop: mark_referenced_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond60 + %call.fr) to i64) + (-1 * (zext i32 %call.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv730 = phi %11, %indvars.iv.next731, ir<1>
    WIDEN-REDUCTION-PHI ir<%12> = phi ir<%regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv730>
    WIDEN ir<%or> = or ir<%12>, ir<%shl>
    WIDEN ir<%indvars.iv.next731> = add nuw nsw ir<%indvars.iv730>, ir<1>
    CLONE ir<%exitcond733.not> = icmp eq ir<%indvars.iv.next731>, ir<%wide.trip.count732>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%12>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup410.loopexit560_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup410.loopexit560_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv730 = phi i64 [ %11, %for.body.lr.ph ], [ %indvars.iv.next731, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %12 = phi i64 [ %regs.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv730 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %12, %shl of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next731 = add nuw nsw i64 %indvars.iv730, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond733.not = icmp eq i64 %indvars.iv.next731, %wide.trip.count732 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond733.not, label %for.cond.cleanup410.loopexit560_crit_edge, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv730 = phi i64 [ %11, %for.body.lr.ph ], [ %indvars.iv.next731, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %12 = phi i64 [ %regs.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv730 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %12, %shl of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next731 = add nuw nsw i64 %indvars.iv730, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond733.not = icmp eq i64 %indvars.iv.next731, %wide.trip.count732 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond733.not, label %for.cond.cleanup410.loopexit560_crit_edge, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv730 = phi i64 [ %11, %for.body.lr.ph ], [ %indvars.iv.next731, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %12 = phi i64 [ %regs.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv730 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %12, %shl of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next731 = add nuw nsw i64 %indvars.iv730, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond733.not = icmp eq i64 %indvars.iv.next731, %wide.trip.count732 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond733.not, label %for.cond.cleanup410.loopexit560_crit_edge, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv730 = phi i64 [ %11, %for.body.lr.ph ], [ %indvars.iv.next731, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %12 = phi i64 [ %regs.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv730 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %12, %shl of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next731 = add nuw nsw i64 %indvars.iv730, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond733.not = icmp eq i64 %indvars.iv.next731, %wide.trip.count732 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond733.not, label %for.cond.cleanup410.loopexit560_crit_edge, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'mark_referenced_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv730 = phi i64 [ %11, %for.body.lr.ph ], [ %indvars.iv.next731, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %12 = phi i64 [ %regs.promoted, %for.body.lr.ph ], [ %or, %for.body ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw nsw i64 1, %indvars.iv730 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %12, %shl of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next731 = add nuw nsw i64 %indvars.iv730, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond733.not = icmp eq i64 %indvars.iv.next731, %wide.trip.count732 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond733.not, label %for.cond.cleanup410.loopexit560_crit_edge, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_referenced_resources at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond60 + %call.fr) to i64) + (-1 * (zext i32 %call.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv730 = phi %11, %indvars.iv.next731, ir<1>
    WIDEN-REDUCTION-PHI ir<%12> = phi ir<%regs.promoted>, ir<%or>
    WIDEN ir<%shl> = shl nuw nsw ir<1>, ir<%indvars.iv730>
    WIDEN ir<%or> = or ir<%12>, ir<%shl>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%12>, ir<%or>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup410.loopexit560_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup410.loopexit560_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body356.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond347 + %.fr725) to i64) + (-1 * (zext i32 %.fr725 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv855 = phi %54, %indvars.iv.next856, ir<1>
    WIDEN-REDUCTION-PHI ir<%55> = phi ir<%regs359.promoted>, ir<%or360>
    CLONE ir<%shl358> = shl nuw nsw ir<1>, ir<%indvars.iv855>
    CLONE ir<%or360> = or ir<%55>, ir<%shl358>
    CLONE ir<%indvars.iv.next856> = add nuw nsw ir<%indvars.iv855>, ir<1>
    CLONE ir<%exitcond857.not> = icmp eq ir<%indvars.iv.next856>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%55>, ir<%or360>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond353.cleanup.loopexit607_crit_edge>, scalar.ph

ir-bb<for.cond353.cleanup.loopexit607_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or360.lcssa = vp<%6>
}

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body356.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond347 + %.fr725) to i64) + (-1 * (zext i32 %.fr725 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv855 = phi %54, %indvars.iv.next856, ir<1>
    WIDEN-REDUCTION-PHI ir<%55> = phi ir<%regs359.promoted>, ir<%or360>
    WIDEN ir<%shl358> = shl nuw nsw ir<1>, ir<%indvars.iv855>
    WIDEN ir<%or360> = or ir<%55>, ir<%shl358>
    WIDEN ir<%indvars.iv.next856> = add nuw nsw ir<%indvars.iv855>, ir<1>
    CLONE ir<%exitcond857.not> = icmp eq ir<%indvars.iv.next856>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%55>, ir<%or360>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond353.cleanup.loopexit607_crit_edge>, scalar.ph

ir-bb<for.cond353.cleanup.loopexit607_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or360.lcssa = vp<%6>
}

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body356.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond347 + %.fr725) to i64) + (-1 * (zext i32 %.fr725 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv855 = phi %54, %indvars.iv.next856, ir<1>
    WIDEN-REDUCTION-PHI ir<%55> = phi ir<%regs359.promoted>, ir<%or360>
    WIDEN ir<%shl358> = shl nuw nsw ir<1>, ir<%indvars.iv855>
    WIDEN ir<%or360> = or ir<%55>, ir<%shl358>
    WIDEN ir<%indvars.iv.next856> = add nuw nsw ir<%indvars.iv855>, ir<1>
    CLONE ir<%exitcond857.not> = icmp eq ir<%indvars.iv.next856>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%55>, ir<%or360>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond353.cleanup.loopexit607_crit_edge>, scalar.ph

ir-bb<for.cond353.cleanup.loopexit607_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or360.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv855 = phi i64 [ %54, %for.body356.lr.ph ], [ %indvars.iv.next856, %for.body356 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %55 = phi i64 [ %regs359.promoted, %for.body356.lr.ph ], [ %or360, %for.body356 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl358 = shl nuw nsw i64 1, %indvars.iv855 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or360 = or i64 %55, %shl358 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next856 = add nuw nsw i64 %indvars.iv855, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond857.not = icmp eq i64 %indvars.iv.next856, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond857.not, label %for.cond353.cleanup.loopexit607_crit_edge, label %for.body356 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv855 = phi i64 [ %54, %for.body356.lr.ph ], [ %indvars.iv.next856, %for.body356 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %55 = phi i64 [ %regs359.promoted, %for.body356.lr.ph ], [ %or360, %for.body356 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl358 = shl nuw nsw i64 1, %indvars.iv855 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or360 = or i64 %55, %shl358 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next856 = add nuw nsw i64 %indvars.iv855, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond857.not = icmp eq i64 %indvars.iv.next856, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond857.not, label %for.cond353.cleanup.loopexit607_crit_edge, label %for.body356 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv855 = phi i64 [ %54, %for.body356.lr.ph ], [ %indvars.iv.next856, %for.body356 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %55 = phi i64 [ %regs359.promoted, %for.body356.lr.ph ], [ %or360, %for.body356 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl358 = shl nuw nsw i64 1, %indvars.iv855 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or360 = or i64 %55, %shl358 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next856 = add nuw nsw i64 %indvars.iv855, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond857.not = icmp eq i64 %indvars.iv.next856, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond857.not, label %for.cond353.cleanup.loopexit607_crit_edge, label %for.body356 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv855 = phi i64 [ %54, %for.body356.lr.ph ], [ %indvars.iv.next856, %for.body356 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %55 = phi i64 [ %regs359.promoted, %for.body356.lr.ph ], [ %or360, %for.body356 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl358 = shl nuw nsw i64 1, %indvars.iv855 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or360 = or i64 %55, %shl358 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next856 = add nuw nsw i64 %indvars.iv855, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond857.not = icmp eq i64 %indvars.iv.next856, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond857.not, label %for.cond353.cleanup.loopexit607_crit_edge, label %for.body356 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv855 = phi i64 [ %54, %for.body356.lr.ph ], [ %indvars.iv.next856, %for.body356 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %55 = phi i64 [ %regs359.promoted, %for.body356.lr.ph ], [ %or360, %for.body356 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl358 = shl nuw nsw i64 1, %indvars.iv855 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or360 = or i64 %55, %shl358 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next856 = add nuw nsw i64 %indvars.iv855, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond857.not = icmp eq i64 %indvars.iv.next856, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond857.not, label %for.cond353.cleanup.loopexit607_crit_edge, label %for.body356 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_set_resources at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body356.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond347 + %.fr725) to i64) + (-1 * (zext i32 %.fr725 to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv855 = phi %54, %indvars.iv.next856, ir<1>
    WIDEN-REDUCTION-PHI ir<%55> = phi ir<%regs359.promoted>, ir<%or360>
    WIDEN ir<%shl358> = shl nuw nsw ir<1>, ir<%indvars.iv855>
    WIDEN ir<%or360> = or ir<%55>, ir<%shl358>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%55>, ir<%or360>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond353.cleanup.loopexit607_crit_edge>, scalar.ph

ir-bb<for.cond353.cleanup.loopexit607_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or360.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body247.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond238 + %call162.fr) to i64) + (-1 * (zext i32 %call162.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv858 = phi %42, %indvars.iv.next859, ir<1>
    WIDEN-REDUCTION-PHI ir<%43> = phi ir<%regs250.promoted>, ir<%or251>
    CLONE ir<%shl249> = shl nuw nsw ir<1>, ir<%indvars.iv858>
    CLONE ir<%or251> = or ir<%43>, ir<%shl249>
    CLONE ir<%indvars.iv.next859> = add nuw nsw ir<%indvars.iv858>, ir<1>
    CLONE ir<%exitcond861.not> = icmp eq ir<%indvars.iv.next859>, ir<%wide.trip.count860>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%43>, ir<%or251>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond244.cleanup.loopexit606_crit_edge>, scalar.ph

ir-bb<for.cond244.cleanup.loopexit606_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or251.lcssa = vp<%6>
}

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body247.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond238 + %call162.fr) to i64) + (-1 * (zext i32 %call162.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv858 = phi %42, %indvars.iv.next859, ir<1>
    WIDEN-REDUCTION-PHI ir<%43> = phi ir<%regs250.promoted>, ir<%or251>
    WIDEN ir<%shl249> = shl nuw nsw ir<1>, ir<%indvars.iv858>
    WIDEN ir<%or251> = or ir<%43>, ir<%shl249>
    WIDEN ir<%indvars.iv.next859> = add nuw nsw ir<%indvars.iv858>, ir<1>
    CLONE ir<%exitcond861.not> = icmp eq ir<%indvars.iv.next859>, ir<%wide.trip.count860>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%43>, ir<%or251>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond244.cleanup.loopexit606_crit_edge>, scalar.ph

ir-bb<for.cond244.cleanup.loopexit606_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or251.lcssa = vp<%6>
}

========== Loop: mark_set_resources' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body247.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond238 + %call162.fr) to i64) + (-1 * (zext i32 %call162.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv858 = phi %42, %indvars.iv.next859, ir<1>
    WIDEN-REDUCTION-PHI ir<%43> = phi ir<%regs250.promoted>, ir<%or251>
    WIDEN ir<%shl249> = shl nuw nsw ir<1>, ir<%indvars.iv858>
    WIDEN ir<%or251> = or ir<%43>, ir<%shl249>
    WIDEN ir<%indvars.iv.next859> = add nuw nsw ir<%indvars.iv858>, ir<1>
    CLONE ir<%exitcond861.not> = icmp eq ir<%indvars.iv.next859>, ir<%wide.trip.count860>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%43>, ir<%or251>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond244.cleanup.loopexit606_crit_edge>, scalar.ph

ir-bb<for.cond244.cleanup.loopexit606_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or251.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv858 = phi i64 [ %42, %for.body247.lr.ph ], [ %indvars.iv.next859, %for.body247 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %43 = phi i64 [ %regs250.promoted, %for.body247.lr.ph ], [ %or251, %for.body247 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl249 = shl nuw nsw i64 1, %indvars.iv858 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or251 = or i64 %43, %shl249 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next859 = add nuw nsw i64 %indvars.iv858, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond861.not = icmp eq i64 %indvars.iv.next859, %wide.trip.count860 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond861.not, label %for.cond244.cleanup.loopexit606_crit_edge, label %for.body247 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv858 = phi i64 [ %42, %for.body247.lr.ph ], [ %indvars.iv.next859, %for.body247 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %43 = phi i64 [ %regs250.promoted, %for.body247.lr.ph ], [ %or251, %for.body247 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl249 = shl nuw nsw i64 1, %indvars.iv858 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or251 = or i64 %43, %shl249 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next859 = add nuw nsw i64 %indvars.iv858, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond861.not = icmp eq i64 %indvars.iv.next859, %wide.trip.count860 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond861.not, label %for.cond244.cleanup.loopexit606_crit_edge, label %for.body247 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv858 = phi i64 [ %42, %for.body247.lr.ph ], [ %indvars.iv.next859, %for.body247 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %43 = phi i64 [ %regs250.promoted, %for.body247.lr.ph ], [ %or251, %for.body247 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl249 = shl nuw nsw i64 1, %indvars.iv858 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or251 = or i64 %43, %shl249 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next859 = add nuw nsw i64 %indvars.iv858, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond861.not = icmp eq i64 %indvars.iv.next859, %wide.trip.count860 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond861.not, label %for.cond244.cleanup.loopexit606_crit_edge, label %for.body247 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv858 = phi i64 [ %42, %for.body247.lr.ph ], [ %indvars.iv.next859, %for.body247 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %43 = phi i64 [ %regs250.promoted, %for.body247.lr.ph ], [ %or251, %for.body247 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl249 = shl nuw nsw i64 1, %indvars.iv858 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or251 = or i64 %43, %shl249 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next859 = add nuw nsw i64 %indvars.iv858, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond861.not = icmp eq i64 %indvars.iv.next859, %wide.trip.count860 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond861.not, label %for.cond244.cleanup.loopexit606_crit_edge, label %for.body247 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'mark_set_resources' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv858 = phi i64 [ %42, %for.body247.lr.ph ], [ %indvars.iv.next859, %for.body247 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %43 = phi i64 [ %regs250.promoted, %for.body247.lr.ph ], [ %or251, %for.body247 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl249 = shl nuw nsw i64 1, %indvars.iv858 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or251 = or i64 %43, %shl249 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next859 = add nuw nsw i64 %indvars.iv858, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond861.not = icmp eq i64 %indvars.iv.next859, %wide.trip.count860 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond861.not, label %for.cond244.cleanup.loopexit606_crit_edge, label %for.body247 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_set_resources at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body247.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV ((zext i32 (%cond238 + %call162.fr) to i64) + (-1 * (zext i32 %call162.fr to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv858 = phi %42, %indvars.iv.next859, ir<1>
    WIDEN-REDUCTION-PHI ir<%43> = phi ir<%regs250.promoted>, ir<%or251>
    WIDEN ir<%shl249> = shl nuw nsw ir<1>, ir<%indvars.iv858>
    WIDEN ir<%or251> = or ir<%43>, ir<%shl249>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%43>, ir<%or251>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond244.cleanup.loopexit606_crit_edge>, scalar.ph

ir-bb<for.cond244.cleanup.loopexit606_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or251.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 16
Loops Epilogues Vectorized: 0
================================================
========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body620.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %96 to i64))<nsw> + ((1 + (zext i32 %96 to i64))<nuw><nsw> umax ((zext i32 %96 to i64) + (zext i32 %cond6151088 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1068 = phi %103, %indvars.iv.next1069, ir<1>
    WIDEN-REDUCTION-PHI ir<%and62410371039> = phi ir<%and624.lcssa10441047>, ir<%and624>
    CLONE ir<%shl622> = shl nuw ir<1>, ir<%indvars.iv1068>
    CLONE ir<%not623> = xor ir<%shl622>, ir<-1>
    CLONE ir<%and624> = and ir<%and62410371039>, ir<%not623>
    CLONE ir<%indvars.iv.next1069> = add nuw nsw ir<%indvars.iv1068>, ir<1>
    CLONE ir<%cmp618> = icmp ult ir<%indvars.iv.next1069>, ir<%104>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and62410371039>, ir<%and624>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond617.for.inc629.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond617.for.inc629.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and624.lcssa = vp<%6>
}

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body620.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %96 to i64))<nsw> + ((1 + (zext i32 %96 to i64))<nuw><nsw> umax ((zext i32 %96 to i64) + (zext i32 %cond6151088 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1068 = phi %103, %indvars.iv.next1069, ir<1>
    WIDEN-REDUCTION-PHI ir<%and62410371039> = phi ir<%and624.lcssa10441047>, ir<%and624>
    WIDEN ir<%shl622> = shl nuw ir<1>, ir<%indvars.iv1068>
    WIDEN ir<%not623> = xor ir<%shl622>, ir<-1>
    WIDEN ir<%and624> = and ir<%and62410371039>, ir<%not623>
    WIDEN ir<%indvars.iv.next1069> = add nuw nsw ir<%indvars.iv1068>, ir<1>
    CLONE ir<%cmp618> = icmp ult ir<%indvars.iv.next1069>, ir<%104>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and62410371039>, ir<%and624>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond617.for.inc629.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond617.for.inc629.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and624.lcssa = vp<%6>
}

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body620.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %96 to i64))<nsw> + ((1 + (zext i32 %96 to i64))<nuw><nsw> umax ((zext i32 %96 to i64) + (zext i32 %cond6151088 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1068 = phi %103, %indvars.iv.next1069, ir<1>
    WIDEN-REDUCTION-PHI ir<%and62410371039> = phi ir<%and624.lcssa10441047>, ir<%and624>
    WIDEN ir<%shl622> = shl nuw ir<1>, ir<%indvars.iv1068>
    WIDEN ir<%not623> = xor ir<%shl622>, ir<-1>
    WIDEN ir<%and624> = and ir<%and62410371039>, ir<%not623>
    WIDEN ir<%indvars.iv.next1069> = add nuw nsw ir<%indvars.iv1068>, ir<1>
    CLONE ir<%cmp618> = icmp ult ir<%indvars.iv.next1069>, ir<%104>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and62410371039>, ir<%and624>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond617.for.inc629.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond617.for.inc629.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and624.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1068 = phi i64 [ %103, %for.body620.preheader ], [ %indvars.iv.next1069, %for.body620 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and62410371039 = phi i64 [ %and624.lcssa10441047, %for.body620.preheader ], [ %and624, %for.body620 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl622 = shl nuw i64 1, %indvars.iv1068 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not623 = xor i64 %shl622, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and624 = and i64 %and62410371039, %not623 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1069 = add nuw nsw i64 %indvars.iv1068, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp618 = icmp ult i64 %indvars.iv.next1069, %104 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp618, label %for.body620, label %for.cond617.for.inc629.loopexit_crit_edge of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1068 = phi i64 [ %103, %for.body620.preheader ], [ %indvars.iv.next1069, %for.body620 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and62410371039 = phi i64 [ %and624.lcssa10441047, %for.body620.preheader ], [ %and624, %for.body620 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl622 = shl nuw i64 1, %indvars.iv1068 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not623 = xor i64 %shl622, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and624 = and i64 %and62410371039, %not623 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1069 = add nuw nsw i64 %indvars.iv1068, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp618 = icmp ult i64 %indvars.iv.next1069, %104 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp618, label %for.body620, label %for.cond617.for.inc629.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1068 = phi i64 [ %103, %for.body620.preheader ], [ %indvars.iv.next1069, %for.body620 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and62410371039 = phi i64 [ %and624.lcssa10441047, %for.body620.preheader ], [ %and624, %for.body620 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl622 = shl nuw i64 1, %indvars.iv1068 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not623 = xor i64 %shl622, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and624 = and i64 %and62410371039, %not623 of type:and
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1069 = add nuw nsw i64 %indvars.iv1068, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp618 = icmp ult i64 %indvars.iv.next1069, %104 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp618, label %for.body620, label %for.cond617.for.inc629.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 9
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1068 = phi i64 [ %103, %for.body620.preheader ], [ %indvars.iv.next1069, %for.body620 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and62410371039 = phi i64 [ %and624.lcssa10441047, %for.body620.preheader ], [ %and624, %for.body620 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl622 = shl nuw i64 1, %indvars.iv1068 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not623 = xor i64 %shl622, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and624 = and i64 %and62410371039, %not623 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1069 = add nuw nsw i64 %indvars.iv1068, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp618 = icmp ult i64 %indvars.iv.next1069, %104 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp618, label %for.body620, label %for.cond617.for.inc629.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1068 = phi i64 [ %103, %for.body620.preheader ], [ %indvars.iv.next1069, %for.body620 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and62410371039 = phi i64 [ %and624.lcssa10441047, %for.body620.preheader ], [ %and624, %for.body620 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl622 = shl nuw i64 1, %indvars.iv1068 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not623 = xor i64 %shl622, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and624 = and i64 %and62410371039, %not623 of type:and
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1069 = add nuw nsw i64 %indvars.iv1068, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp618 = icmp ult i64 %indvars.iv.next1069, %104 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp618, label %for.body620, label %for.cond617.for.inc629.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 9
B VF: 4, EstimatedWidthB: 4, CostB: 9
CostA * EstimatedWidthB: 36, CostB * EstimatedWidthA: 36
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_target_live_regs at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body620.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %96 to i64))<nsw> + ((1 + (zext i32 %96 to i64))<nuw><nsw> umax ((zext i32 %96 to i64) + (zext i32 %cond6151088 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1068 = phi %103, %indvars.iv.next1069, ir<1>
    WIDEN-REDUCTION-PHI ir<%and62410371039> = phi ir<%and624.lcssa10441047>, ir<%and624>
    WIDEN ir<%shl622> = shl nuw ir<1>, ir<%indvars.iv1068>
    WIDEN ir<%not623> = xor ir<%shl622>, ir<-1>
    WIDEN ir<%and624> = and ir<%and62410371039>, ir<%not623>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and62410371039>, ir<%and624>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond617.for.inc629.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond617.for.inc629.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and624.lcssa = vp<%6>
}
================ Final VPlan ================

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body478.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %82 to i64))<nsw> + ((1 + (zext i32 %82 to i64))<nuw><nsw> umax ((zext i32 %82 to i64) + (zext i32 %cond4731085 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1066 = phi %89, %indvars.iv.next1067, ir<1>
    WIDEN-REDUCTION-PHI ir<%or48110241026> = phi ir<%or481.lcssa10311034>, ir<%or481>
    CLONE ir<%shl480> = shl nuw ir<1>, ir<%indvars.iv1066>
    CLONE ir<%or481> = or ir<%or48110241026>, ir<%shl480>
    CLONE ir<%indvars.iv.next1067> = add nuw nsw ir<%indvars.iv1066>, ir<1>
    CLONE ir<%cmp476> = icmp ult ir<%indvars.iv.next1067>, ir<%90>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or48110241026>, ir<%or481>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond475.for.inc486.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond475.for.inc486.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or481.lcssa = vp<%6>
}

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body478.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %82 to i64))<nsw> + ((1 + (zext i32 %82 to i64))<nuw><nsw> umax ((zext i32 %82 to i64) + (zext i32 %cond4731085 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1066 = phi %89, %indvars.iv.next1067, ir<1>
    WIDEN-REDUCTION-PHI ir<%or48110241026> = phi ir<%or481.lcssa10311034>, ir<%or481>
    WIDEN ir<%shl480> = shl nuw ir<1>, ir<%indvars.iv1066>
    WIDEN ir<%or481> = or ir<%or48110241026>, ir<%shl480>
    WIDEN ir<%indvars.iv.next1067> = add nuw nsw ir<%indvars.iv1066>, ir<1>
    CLONE ir<%cmp476> = icmp ult ir<%indvars.iv.next1067>, ir<%90>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or48110241026>, ir<%or481>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond475.for.inc486.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond475.for.inc486.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or481.lcssa = vp<%6>
}

========== Loop: mark_target_live_regs' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body478.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %82 to i64))<nsw> + ((1 + (zext i32 %82 to i64))<nuw><nsw> umax ((zext i32 %82 to i64) + (zext i32 %cond4731085 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1066 = phi %89, %indvars.iv.next1067, ir<1>
    WIDEN-REDUCTION-PHI ir<%or48110241026> = phi ir<%or481.lcssa10311034>, ir<%or481>
    WIDEN ir<%shl480> = shl nuw ir<1>, ir<%indvars.iv1066>
    WIDEN ir<%or481> = or ir<%or48110241026>, ir<%shl480>
    WIDEN ir<%indvars.iv.next1067> = add nuw nsw ir<%indvars.iv1066>, ir<1>
    CLONE ir<%cmp476> = icmp ult ir<%indvars.iv.next1067>, ir<%90>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or48110241026>, ir<%or481>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond475.for.inc486.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond475.for.inc486.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or481.lcssa = vp<%6>
}


-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv1066 = phi i64 [ %89, %for.body478.preheader ], [ %indvars.iv.next1067, %for.body478 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or48110241026 = phi i64 [ %or481.lcssa10311034, %for.body478.preheader ], [ %or481, %for.body478 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl480 = shl nuw i64 1, %indvars.iv1066 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or481 = or i64 %or48110241026, %shl480 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next1067 = add nuw nsw i64 %indvars.iv1066, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp476 = icmp ult i64 %indvars.iv.next1067, %90 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp476, label %for.body478, label %for.cond475.for.inc486.loopexit_crit_edge of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv1066 = phi i64 [ %89, %for.body478.preheader ], [ %indvars.iv.next1067, %for.body478 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or48110241026 = phi i64 [ %or481.lcssa10311034, %for.body478.preheader ], [ %or481, %for.body478 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl480 = shl nuw i64 1, %indvars.iv1066 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or481 = or i64 %or48110241026, %shl480 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next1067 = add nuw nsw i64 %indvars.iv1066, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp476 = icmp ult i64 %indvars.iv.next1067, %90 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp476, label %for.body478, label %for.cond475.for.inc486.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv1066 = phi i64 [ %89, %for.body478.preheader ], [ %indvars.iv.next1067, %for.body478 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or48110241026 = phi i64 [ %or481.lcssa10311034, %for.body478.preheader ], [ %or481, %for.body478 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl480 = shl nuw i64 1, %indvars.iv1066 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or481 = or i64 %or48110241026, %shl480 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next1067 = add nuw nsw i64 %indvars.iv1066, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp476 = icmp ult i64 %indvars.iv.next1067, %90 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp476, label %for.body478, label %for.cond475.for.inc486.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv1066 = phi i64 [ %89, %for.body478.preheader ], [ %indvars.iv.next1067, %for.body478 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or48110241026 = phi i64 [ %or481.lcssa10311034, %for.body478.preheader ], [ %or481, %for.body478 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl480 = shl nuw i64 1, %indvars.iv1066 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or481 = or i64 %or48110241026, %shl480 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next1067 = add nuw nsw i64 %indvars.iv1066, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp476 = icmp ult i64 %indvars.iv.next1067, %90 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp476, label %for.body478, label %for.cond475.for.inc486.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 8
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'mark_target_live_regs' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv1066 = phi i64 [ %89, %for.body478.preheader ], [ %indvars.iv.next1067, %for.body478 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or48110241026 = phi i64 [ %or481.lcssa10311034, %for.body478.preheader ], [ %or481, %for.body478 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl480 = shl nuw i64 1, %indvars.iv1066 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or481 = or i64 %or48110241026, %shl480 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next1067 = add nuw nsw i64 %indvars.iv1066, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp476 = icmp ult i64 %indvars.iv.next1067, %90 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp476, label %for.body478, label %for.cond475.for.inc486.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 4
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: mark_target_live_regs at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body478.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (zext i32 %82 to i64))<nsw> + ((1 + (zext i32 %82 to i64))<nuw><nsw> umax ((zext i32 %82 to i64) + (zext i32 %cond4731085 to i64))<nuw>))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv1066 = phi %89, %indvars.iv.next1067, ir<1>
    WIDEN-REDUCTION-PHI ir<%or48110241026> = phi ir<%or481.lcssa10311034>, ir<%or481>
    WIDEN ir<%shl480> = shl nuw ir<1>, ir<%indvars.iv1066>
    WIDEN ir<%or481> = or ir<%or48110241026>, ir<%shl480>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or48110241026>, ir<%or481>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond475.for.inc486.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond475.for.inc486.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or481.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 25
Loops Epilogues Vectorized: 0
================================================
========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body84.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.1139 = phi %inc92, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or134138> = phi ir<%current_live_regs.promoted>, ir<%or>
    WIDEN-REDUCTION-PHI ir<%and90135137> = phi ir<%pending_dead_regs.promoted>, ir<%and90>
    CLONE ir<%sh_prom85> = zext nneg ir<%i.1139>
    CLONE ir<%shl86> = shl nuw ir<1>, ir<%sh_prom85>
    CLONE ir<%or> = or ir<%or134138>, ir<%shl86>
    CLONE ir<%not89> = xor ir<%shl86>, ir<-1>
    CLONE ir<%and90> = and ir<%and90135137>, ir<%not89>
    CLONE ir<%inc92> = add nsw ir<%i.1139>, ir<1>
    CLONE ir<%cmp82> = icmp slt ir<%inc92>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or134138>, ir<%or>
  EMIT vp<%7> = compute-reduction-result ir<%and90135137>, ir<%and90>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond81.cleanup.loopexit133_crit_edge>, scalar.ph

ir-bb<for.cond81.cleanup.loopexit133_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
Live-out i64 %and90.lcssa = vp<%7>
}

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body84.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.1139 = phi %inc92, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or134138> = phi ir<%current_live_regs.promoted>, ir<%or>
    WIDEN-REDUCTION-PHI ir<%and90135137> = phi ir<%pending_dead_regs.promoted>, ir<%and90>
    WIDEN-CAST ir<%sh_prom85> = zext  nneg ir<%i.1139> to i64
    WIDEN ir<%shl86> = shl nuw ir<1>, ir<%sh_prom85>
    WIDEN ir<%or> = or ir<%or134138>, ir<%shl86>
    WIDEN ir<%not89> = xor ir<%shl86>, ir<-1>
    WIDEN ir<%and90> = and ir<%and90135137>, ir<%not89>
    WIDEN ir<%inc92> = add nsw ir<%i.1139>, ir<1>
    CLONE ir<%cmp82> = icmp slt ir<%inc92>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or134138>, ir<%or>
  EMIT vp<%7> = compute-reduction-result ir<%and90135137>, ir<%and90>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond81.cleanup.loopexit133_crit_edge>, scalar.ph

ir-bb<for.cond81.cleanup.loopexit133_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
Live-out i64 %and90.lcssa = vp<%7>
}

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body84.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.1139 = phi %inc92, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or134138> = phi ir<%current_live_regs.promoted>, ir<%or>
    WIDEN-REDUCTION-PHI ir<%and90135137> = phi ir<%pending_dead_regs.promoted>, ir<%and90>
    WIDEN-CAST ir<%sh_prom85> = zext  nneg ir<%i.1139> to i64
    WIDEN ir<%shl86> = shl nuw ir<1>, ir<%sh_prom85>
    WIDEN ir<%or> = or ir<%or134138>, ir<%shl86>
    WIDEN ir<%not89> = xor ir<%shl86>, ir<-1>
    WIDEN ir<%and90> = and ir<%and90135137>, ir<%not89>
    WIDEN ir<%inc92> = add nsw ir<%i.1139>, ir<1>
    CLONE ir<%cmp82> = icmp slt ir<%inc92>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or134138>, ir<%or>
  EMIT vp<%7> = compute-reduction-result ir<%and90135137>, ir<%and90>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond81.cleanup.loopexit133_crit_edge>, scalar.ph

ir-bb<for.cond81.cleanup.loopexit133_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
Live-out i64 %and90.lcssa = vp<%7>
}


-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.1139 = phi i32 [ %inc92, %for.body84 ], [ %first_regno.0.fr, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %or134138 = phi i64 [ %or, %for.body84 ], [ %current_live_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and90135137 = phi i64 [ %and90, %for.body84 ], [ %pending_dead_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom85 = zext nneg i32 %i.1139 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl86 = shl nuw i64 1, %sh_prom85 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or = or i64 %or134138, %shl86 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not89 = xor i64 %shl86, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and90 = and i64 %and90135137, %not89 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc92 = add nsw i32 %i.1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp82 = icmp slt i32 %inc92, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp82, label %for.body84, label %for.cond81.cleanup.loopexit133_crit_edge of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.1139 = phi i32 [ %inc92, %for.body84 ], [ %first_regno.0.fr, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %or134138 = phi i64 [ %or, %for.body84 ], [ %current_live_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and90135137 = phi i64 [ %and90, %for.body84 ], [ %pending_dead_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom85 = zext nneg i32 %i.1139 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl86 = shl nuw i64 1, %sh_prom85 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or = or i64 %or134138, %shl86 of type:or
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not89 = xor i64 %shl86, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and90 = and i64 %and90135137, %not89 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc92 = add nsw i32 %i.1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp82 = icmp slt i32 %inc92, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp82, label %for.body84, label %for.cond81.cleanup.loopexit133_crit_edge of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.1139 = phi i32 [ %inc92, %for.body84 ], [ %first_regno.0.fr, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %or134138 = phi i64 [ %or, %for.body84 ], [ %current_live_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and90135137 = phi i64 [ %and90, %for.body84 ], [ %pending_dead_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom85 = zext nneg i32 %i.1139 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl86 = shl nuw i64 1, %sh_prom85 of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or = or i64 %or134138, %shl86 of type:or
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not89 = xor i64 %shl86, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and90 = and i64 %and90135137, %not89 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc92 = add nsw i32 %i.1139, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp82 = icmp slt i32 %inc92, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp82, label %for.body84, label %for.cond81.cleanup.loopexit133_crit_edge of type:br
LV: Vector loop of width 4 costs: 3
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 12
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.1139 = phi i32 [ %inc92, %for.body84 ], [ %first_regno.0.fr, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %or134138 = phi i64 [ %or, %for.body84 ], [ %current_live_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and90135137 = phi i64 [ %and90, %for.body84 ], [ %pending_dead_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom85 = zext nneg i32 %i.1139 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl86 = shl nuw i64 1, %sh_prom85 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or = or i64 %or134138, %shl86 of type:or
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not89 = xor i64 %shl86, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and90 = and i64 %and90135137, %not89 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc92 = add nsw i32 %i.1139, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp82 = icmp slt i32 %inc92, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp82, label %for.body84, label %for.cond81.cleanup.loopexit133_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 14
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 7
B VF: 4, EstimatedWidthB: 4, CostB: 12
CostA * EstimatedWidthB: 28, CostB * EstimatedWidthA: 24

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.1139 = phi i32 [ %inc92, %for.body84 ], [ %first_regno.0.fr, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %or134138 = phi i64 [ %or, %for.body84 ], [ %current_live_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and90135137 = phi i64 [ %and90, %for.body84 ], [ %pending_dead_regs.promoted, %for.body84.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom85 = zext nneg i32 %i.1139 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl86 = shl nuw i64 1, %sh_prom85 of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or = or i64 %or134138, %shl86 of type:or
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not89 = xor i64 %shl86, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and90 = and i64 %and90135137, %not89 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc92 = add nsw i32 %i.1139, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp82 = icmp slt i32 %inc92, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp82, label %for.body84, label %for.cond81.cleanup.loopexit133_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 12
B VF: 4, EstimatedWidthB: 4, CostB: 12
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 3.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: update_live_status at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body84.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.1139 = phi %inc92, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%or134138> = phi ir<%current_live_regs.promoted>, ir<%or>
    WIDEN-REDUCTION-PHI ir<%and90135137> = phi ir<%pending_dead_regs.promoted>, ir<%and90>
    WIDEN-CAST ir<%sh_prom85> = zext  nneg ir<%i.1139> to i64
    WIDEN ir<%shl86> = shl nuw ir<1>, ir<%sh_prom85>
    WIDEN ir<%or> = or ir<%or134138>, ir<%shl86>
    WIDEN ir<%not89> = xor ir<%shl86>, ir<-1>
    WIDEN ir<%and90> = and ir<%and90135137>, ir<%not89>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%or134138>, ir<%or>
  EMIT vp<%7> = compute-reduction-result ir<%and90135137>, ir<%and90>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond81.cleanup.loopexit133_crit_edge>, scalar.ph

ir-bb<for.cond81.cleanup.loopexit133_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %or.lcssa = vp<%6>
Live-out i64 %and90.lcssa = vp<%7>
}
================ Final VPlan ================

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0144 = phi %inc, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%and79141143> = phi ir<%current_live_regs.promoted140>, ir<%and79>
    CLONE ir<%sh_prom> = zext nneg ir<%i.0144>
    CLONE ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    CLONE ir<%not> = xor ir<%shl>, ir<-1>
    CLONE ir<%and79> = and ir<%and79141143>, ir<%not>
    CLONE ir<%inc> = add nsw ir<%i.0144>, ir<1>
    CLONE ir<%cmp77> = icmp slt ir<%inc>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and79141143>, ir<%and79>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and79.lcssa = vp<%6>
}

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0144 = phi %inc, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%and79141143> = phi ir<%current_live_regs.promoted140>, ir<%and79>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0144> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and79> = and ir<%and79141143>, ir<%not>
    WIDEN ir<%inc> = add nsw ir<%i.0144>, ir<1>
    CLONE ir<%cmp77> = icmp slt ir<%inc>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and79141143>, ir<%and79>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and79.lcssa = vp<%6>
}

========== Loop: update_live_status' from resource.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0144 = phi %inc, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%and79141143> = phi ir<%current_live_regs.promoted140>, ir<%and79>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0144> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and79> = and ir<%and79141143>, ir<%not>
    WIDEN ir<%inc> = add nsw ir<%i.0144>, ir<1>
    CLONE ir<%cmp77> = icmp slt ir<%inc>, ir<%add71>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and79141143>, ir<%and79>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and79.lcssa = vp<%6>
}


-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0144 = phi i32 [ %inc, %for.body ], [ %first_regno.0.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %and79141143 = phi i64 [ %and79, %for.body ], [ %current_live_regs.promoted140, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sh_prom = zext nneg i32 %i.0144 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and79 = and i64 %and79141143, %not of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc = add nsw i32 %i.0144, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp77 = icmp slt i32 %inc, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp77, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0144 = phi i32 [ %inc, %for.body ], [ %first_regno.0.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %and79141143 = phi i64 [ %and79, %for.body ], [ %current_live_regs.promoted140, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sh_prom = zext nneg i32 %i.0144 to i64 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and79 = and i64 %and79141143, %not of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc = add nsw i32 %i.0144, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp77 = icmp slt i32 %inc, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp77, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0144 = phi i32 [ %inc, %for.body ], [ %first_regno.0.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %and79141143 = phi i64 [ %and79, %for.body ], [ %current_live_regs.promoted140, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %sh_prom = zext nneg i32 %i.0144 to i64 of type:zext
LV: Found an estimated cost of 2 for VF 4 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF 4 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and79 = and i64 %and79141143, %not of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc = add nsw i32 %i.0144, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp77 = icmp slt i32 %inc, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp77, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0144 = phi i32 [ %inc, %for.body ], [ %first_regno.0.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %and79141143 = phi i64 [ %and79, %for.body ], [ %current_live_regs.promoted140, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sh_prom = zext nneg i32 %i.0144 to i64 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and79 = and i64 %and79141143, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc = add nsw i32 %i.0144, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp77 = icmp slt i32 %inc, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp77, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'update_live_status' from resource.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0144 = phi i32 [ %inc, %for.body ], [ %first_regno.0.fr, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %and79141143 = phi i64 [ %and79, %for.body ], [ %current_live_regs.promoted140, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %sh_prom = zext nneg i32 %i.0144 to i64 of type:zext
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %shl = shl nuw i64 1, %sh_prom of type:shl
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %not = xor i64 %shl, -1 of type:xor
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and79 = and i64 %and79141143, %not of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc = add nsw i32 %i.0144, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp77 = icmp slt i32 %inc, %add71 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp77, label %for.body, label %for.cond.cleanup.loopexit_crit_edge of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 10
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: update_live_status at line: resource.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * %first_regno.0.fr) + ((1 + %first_regno.0.fr) smax (%cond70 + %first_regno.0.fr)))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %i.0144 = phi %inc, %first_regno.0.fr, ir<1>
    WIDEN-REDUCTION-PHI ir<%and79141143> = phi ir<%current_live_regs.promoted140>, ir<%and79>
    WIDEN-CAST ir<%sh_prom> = zext  nneg ir<%i.0144> to i64
    WIDEN ir<%shl> = shl nuw ir<1>, ir<%sh_prom>
    WIDEN ir<%not> = xor ir<%shl>, ir<-1>
    WIDEN ir<%and79> = and ir<%and79141143>, ir<%not>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%and79141143>, ir<%and79>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond.cleanup.loopexit_crit_edge>, scalar.ph

ir-bb<for.cond.cleanup.loopexit_crit_edge>:
No successors

scalar.ph:
No successors

Live-out i64 %and79.lcssa = vp<%6>
}
================ Final VPlan ================

================================================
Loops Vectorized: 8
Loops Analyzed: 29
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o rtl.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         rtl.c
@@ Instruction =>  %1 = load i64, ptr %arrayidx49, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %1, ptr %arrayidx46, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i64, ptr %arrayidx49, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %1, ptr %arrayidx46, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1 = load i64, ptr %arrayidx49, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %1, ptr %arrayidx46, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1 = load i64, ptr %arrayidx49, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %1, ptr %arrayidx46, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: shallow_copy_rtx' from rtl.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%fld>, ir<0>, ir<%indvars.iv>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%fld47>, ir<0>, ir<%indvars.iv>
    CLONE ir<%1> = load ir<%arrayidx49>
    CLONE store ir<%1>, ir<%arrayidx46>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: shallow_copy_rtx' from rtl.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%fld>, ir<0>, ir<%indvars.iv>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%fld47>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%1> = load vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx46>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: shallow_copy_rtx' from rtl.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%fld>, ir<0>, ir<%indvars.iv>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%fld47>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%1> = load vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx46>
    WIDEN store vp<%5>, ir<%1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'shallow_copy_rtx' from rtl.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx46 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx49 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld47, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %1, ptr %arrayidx46, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'shallow_copy_rtx' from rtl.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx46 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx49 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld47, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %1, ptr %arrayidx46, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 512, RTCostB: 1020
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 512, RTCostB: 1020
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'shallow_copy_rtx' from rtl.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx46 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx49 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld47, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i64 %1, ptr %arrayidx46, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 390, RTCostB: 1020
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 390, RTCostB: 512
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'shallow_copy_rtx' from rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx46 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx49 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld47, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %1 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i64 %1, ptr %arrayidx46, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 512, RTCostB: 1020
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 512, RTCostB: 390

-----------------Function that is being costed:'shallow_copy_rtx' from rtl.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx46 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx49 = getelementptr inbounds [1 x %union.rtunion_def], ptr %fld47, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %1 = load i64, ptr %arrayidx49, align 8 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i64 %1, ptr %arrayidx46, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 390, RTCostB: 1020
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 390, RTCostB: 390
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: shallow_copy_rtx at line: rtl.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %0 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx46> = getelementptr inbounds ir<%fld>, ir<0>, vp<%4>
    CLONE ir<%arrayidx49> = getelementptr inbounds ir<%fld47>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx49>
    WIDEN ir<%5> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx46>
    WIDEN store vp<%6>, ir<%5>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 2
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o rtlanal.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         rtlanal.c
@@ Instruction =>  %4 = load ptr, ptr %arrayidx11, align 8 -> Cost: 4 -> VectorType: <2 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %4 = load ptr, ptr %arrayidx11, align 8 -> Cost: 10 -> VectorType: <4 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %4 = load ptr, ptr %arrayidx11, align 8 -> Cost: 2 -> VectorType: <vscale x 1 x ptr> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
@@ Instruction =>  %4 = load ptr, ptr %arrayidx11, align 8 -> Cost: 3 -> VectorType: <vscale x 2 x ptr> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1)	-> Mask = []	-> ASM: [VID_V, VRSUB_VX, VRGATHER_VV]
========== Loop: computed_jump_p' from rtlanal.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi %3, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%has_use_labelref.0115> = phi ir<false>, ir<%has_use_labelref.1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx11>
    CLONE ir<%bf.load12> = load ir<%4>
    CLONE ir<%bf.clear13> = and ir<%bf.load12>, ir<65535>
    CLONE ir<%cmp14> = icmp eq ir<%bf.clear13>, ir<48>
  Successor(s): land.lhs.true

  land.lhs.true:
    CLONE ir<%fld20> = getelementptr inbounds ir<%4>, ir<8>
    CLONE ir<%5> = load ir<%fld20>, ir<%cmp14>
    CLONE ir<%bf.load22> = load ir<%5>, ir<%cmp14>
    CLONE ir<%bf.clear23> = and ir<%bf.load22>, ir<65535>
    CLONE ir<%cmp24> = icmp eq ir<%bf.clear23>, ir<67>
    EMIT vp<%4> = or ir<%has_use_labelref.0115>, ir<%cmp24>
    CLONE ir<%spec.select> = select ir<%cmp24>, ir<1>, ir<%has_use_labelref.0115>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%5> = not ir<%cmp14>
    EMIT vp<%6> = or ir<%cmp14>, vp<%5>
    BLEND ir<%has_use_labelref.1> = ir<%has_use_labelref.0115> vp<%4>/ir<%cmp14>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp8> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%has_use_labelref.0115>, ir<%has_use_labelref.1>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %has_use_labelref.1.lcssa = vp<%9>
}

========== Loop: computed_jump_p' from rtlanal.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %3, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%has_use_labelref.0115> = phi ir<false>, ir<%has_use_labelref.1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN ir<%4> = load vp<%4>
    WIDEN ir<%bf.load12> = load ir<%4>
    WIDEN ir<%bf.clear13> = and ir<%bf.load12>, ir<65535>
    WIDEN ir<%cmp14> = icmp eq ir<%bf.clear13>, ir<48>
  Successor(s): land.lhs.true

  land.lhs.true:
    WIDEN-GEP Var[Inv] ir<%fld20> = getelementptr inbounds ir<%4>, ir<8>
    WIDEN ir<%5> = load ir<%fld20>, ir<%cmp14>
    WIDEN ir<%bf.load22> = load ir<%5>, ir<%cmp14>
    WIDEN ir<%bf.clear23> = and ir<%bf.load22>, ir<65535>
    WIDEN ir<%cmp24> = icmp eq ir<%bf.clear23>, ir<67>
    EMIT vp<%5> = or ir<%has_use_labelref.0115>, ir<%cmp24>
    WIDEN-SELECT ir<%spec.select> = select ir<%cmp24>, ir<1>, ir<%has_use_labelref.0115>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp14>
    EMIT vp<%7> = or ir<%cmp14>, vp<%6>
    BLEND ir<%has_use_labelref.1> = ir<%has_use_labelref.0115> vp<%5>/ir<%cmp14>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp8> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%has_use_labelref.0115>, ir<%has_use_labelref.1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %has_use_labelref.1.lcssa = vp<%10>
}

========== Loop: computed_jump_p' from rtlanal.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv = phi %3, %indvars.iv.next, ir<-1>
    WIDEN-REDUCTION-PHI ir<%has_use_labelref.0115> = phi ir<false>, ir<%has_use_labelref.1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%elem>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN ir<%4> = load vp<%4>
    WIDEN ir<%bf.load12> = load ir<%4>
    WIDEN ir<%bf.clear13> = and ir<%bf.load12>, ir<65535>
    WIDEN ir<%cmp14> = icmp eq ir<%bf.clear13>, ir<48>
  Successor(s): land.lhs.true

  land.lhs.true:
    WIDEN-GEP Var[Inv] ir<%fld20> = getelementptr inbounds ir<%4>, ir<8>
    WIDEN ir<%5> = load ir<%fld20>, ir<%cmp14>
    WIDEN ir<%bf.load22> = load ir<%5>, ir<%cmp14>
    WIDEN ir<%bf.clear23> = and ir<%bf.load22>, ir<65535>
    WIDEN ir<%cmp24> = icmp eq ir<%bf.clear23>, ir<67>
    EMIT vp<%5> = or ir<%has_use_labelref.0115>, ir<%cmp24>
    WIDEN-SELECT ir<%spec.select> = select ir<%cmp24>, ir<1>, ir<%has_use_labelref.0115>
  Successor(s): for.inc

  for.inc:
    EMIT vp<%6> = not ir<%cmp14>
    EMIT vp<%7> = or ir<%cmp14>, vp<%6>
    BLEND ir<%has_use_labelref.1> = ir<%has_use_labelref.0115> vp<%5>/ir<%cmp14>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%cmp8> = icmp sgt ir<%indvars.iv>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%has_use_labelref.0115>, ir<%has_use_labelref.1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %has_use_labelref.1.lcssa = vp<%10>
}


-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = load ptr, ptr %fld20, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 4 for VF 2 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %5 = load ptr, ptr %fld20, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Vector loop of width 2 costs: 9
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 16
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 18
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 18, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 10 for VF 4 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %5 = load ptr, ptr %fld20, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Vector loop of width 4 costs: 7
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 30
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 30, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 30
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 30, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 1

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %5 = load ptr, ptr %fld20, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Vector loop of width vscale x 1 costs: 8
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 16
B VF: 4, EstimatedWidthB: 4, CostB: 30
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 60

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %3, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %has_use_labelref.0115 = phi i32 [ 0, %for.body.lr.ph ], [ %has_use_labelref.1, %for.inc ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx11 = getelementptr inbounds [1 x ptr], ptr %elem, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF vscale x 2 For instruction:   %4 = load ptr, ptr %arrayidx11, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %bf.load12 = load i32, ptr %4, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear13 = and i32 %bf.load12, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp14 = icmp eq i32 %bf.clear13, 48 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp14, label %land.lhs.true, label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %fld20 = getelementptr inbounds i8, ptr %4, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %5 = load ptr, ptr %fld20, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %bf.load22 = load i32, ptr %5, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear23 = and i32 %bf.load22, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp24 = icmp eq i32 %bf.clear23, 67 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = select i1 %cmp24, i32 1, i32 %has_use_labelref.0115 of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc of type:br

-----------------Function that is being costed:'computed_jump_p' from rtlanal.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %has_use_labelref.1 = phi i32 [ %has_use_labelref.0115, %for.body ], [ %spec.select, %land.lhs.true ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp8 = icmp sgt i64 %indvars.iv, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp8, label %for.body, label %for.end of type:br
LV: Vector loop of width vscale x 2 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 23
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 23, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 23
B VF: 4, EstimatedWidthB: 4, CostB: 30
CostA * EstimatedWidthB: 92, CostB * EstimatedWidthA: 120
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 5.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: computed_jump_p at line: rtlanal.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %2) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-REDUCTION-PHI ir<%has_use_labelref.0115> = phi ir<false>, ir<%has_use_labelref.1>
    vp<%4>    = DERIVED-IV ir<%3> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%elem>, ir<0>, vp<%5>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx11>
    WIDEN ir<%4> = load vp<%6>
    WIDEN ir<%bf.load12> = load ir<%4>
    WIDEN ir<%bf.clear13> = and ir<%bf.load12>, ir<65535>
    WIDEN ir<%cmp14> = icmp eq ir<%bf.clear13>, ir<48>
    WIDEN-GEP Var[Inv] ir<%fld20> = getelementptr inbounds ir<%4>, ir<8>
    WIDEN ir<%5> = load ir<%fld20>, ir<%cmp14>
    WIDEN ir<%bf.load22> = load ir<%5>, ir<%cmp14>
    WIDEN ir<%bf.clear23> = and ir<%bf.load22>, ir<65535>
    WIDEN ir<%cmp24> = icmp eq ir<%bf.clear23>, ir<67>
    EMIT vp<%7> = or ir<%has_use_labelref.0115>, ir<%cmp24>
    BLEND ir<%has_use_labelref.1> = ir<%has_use_labelref.0115> vp<%7>/ir<%cmp14>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = compute-reduction-result ir<%has_use_labelref.0115>, ir<%has_use_labelref.1>
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors

Live-out i32 %has_use_labelref.1.lcssa = vp<%10>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 64
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o rtl-error.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         rtl-error.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o sbitmap.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         sbitmap.c
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and.us, ptr %r.055.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %and.us, ptr %r.055.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and.us, ptr %r.055.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %and.us, ptr %r.055.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: sbitmap_intersection_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    CLONE ir<%9> = load ir<%p.054.us>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    CLONE ir<%10> = load ir<%r.055.us>
    CLONE ir<%and.us> = and ir<%10>, ir<%9>
    CLONE store ir<%and.us>, ir<%r.055.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_intersection_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.054.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.055.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%and.us> = and ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.055.us>
    WIDEN store vp<%6>, ir<%and.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_intersection_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.054.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.055.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%and.us> = and ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.055.us>
    WIDEN store vp<%6>, ir<%and.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_intersection_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %and.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'sbitmap_intersection_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %and.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_intersection_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i64 %and.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'sbitmap_intersection_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i64 %and.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 10737418248

-----------------Function that is being costed:'sbitmap_intersection_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i64 %and.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 10737418248
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: sbitmap_intersection_of_succs at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms19>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms.us>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%13> = load vp<%10>
    vp<%11> = vector-pointer vp<%6>
    WIDEN ir<%14> = load vp<%11>
    WIDEN ir<%and.us> = and ir<%14>, ir<%13>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%and.us>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 15
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and.us, ptr %r.053.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %and.us, ptr %r.053.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %and.us, ptr %r.053.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %and.us, ptr %r.053.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: sbitmap_intersection_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    CLONE ir<%9> = load ir<%p.052.us>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    CLONE ir<%10> = load ir<%r.053.us>
    CLONE ir<%and.us> = and ir<%10>, ir<%9>
    CLONE store ir<%and.us>, ir<%r.053.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_intersection_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.052.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.053.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%and.us> = and ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.053.us>
    WIDEN store vp<%6>, ir<%and.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_intersection_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.052.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.053.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%and.us> = and ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.053.us>
    WIDEN store vp<%6>, ir<%and.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_intersection_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %and.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'sbitmap_intersection_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %and.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_intersection_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i64 %and.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'sbitmap_intersection_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i64 %and.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 10737418248

-----------------Function that is being costed:'sbitmap_intersection_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %and.us = and i64 %10, %9 of type:and
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i64 %and.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 10737418248
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: sbitmap_intersection_of_preds at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms20>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms.us>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%13> = load vp<%10>
    vp<%11> = vector-pointer vp<%6>
    WIDEN ir<%14> = load vp<%11>
    WIDEN ir<%and.us> = and ir<%14>, ir<%13>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%and.us>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 18
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or.us, ptr %r.055.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %or.us, ptr %r.055.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or.us, ptr %r.055.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.054.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i64, ptr %r.055.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %or.us, ptr %r.055.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: sbitmap_union_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    CLONE ir<%9> = load ir<%p.054.us>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    CLONE ir<%10> = load ir<%r.055.us>
    CLONE ir<%or.us> = or ir<%10>, ir<%9>
    CLONE store ir<%or.us>, ir<%r.055.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_union_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.054.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.055.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%or.us> = or ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.055.us>
    WIDEN store vp<%6>, ir<%or.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_union_of_succs' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.055.us> = WIDEN-POINTER-INDUCTION ir<%elms19>, 8
    EMIT ir<%p.054.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.053.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.054.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.054.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr24.us> = getelementptr inbounds ir<%r.055.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.055.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%or.us> = or ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.055.us>
    WIDEN store vp<%6>, ir<%or.us>
    CLONE ir<%inc.us> = add nuw ir<%i.053.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_union_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %or.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'sbitmap_union_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %or.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_union_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i64 %or.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'sbitmap_union_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i64 %or.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 10737418248

-----------------Function that is being costed:'sbitmap_union_of_succs' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.055.us = phi ptr [ %elms19, %if.end14.us ], [ %incdec.ptr24.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.054.us = phi ptr [ %elms.us, %if.end14.us ], [ %incdec.ptr.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.053.us = phi i32 [ 0, %if.end14.us ], [ %inc.us, %for.body23.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.054.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %9 = load i64, ptr %p.054.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr24.us = getelementptr inbounds i8, ptr %r.055.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %10 = load i64, ptr %r.055.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i64 %or.us, ptr %r.055.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us = add nuw i32 %i.053.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body23.us of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 10737418248
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: sbitmap_union_of_succs at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end14.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms19>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms.us>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%13> = load vp<%10>
    vp<%11> = vector-pointer vp<%6>
    WIDEN ir<%14> = load vp<%11>
    WIDEN ir<%or.us> = or ir<%14>, ir<%13>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%or.us>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 21
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or.us, ptr %r.053.us, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %or.us, ptr %r.053.us, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i64 %or.us, ptr %r.053.us, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i64, ptr %p.052.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %10 = load i64, ptr %r.053.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i64 %or.us, ptr %r.053.us, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
========== Loop: sbitmap_union_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    CLONE ir<%9> = load ir<%p.052.us>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    CLONE ir<%10> = load ir<%r.053.us>
    CLONE ir<%or.us> = or ir<%10>, ir<%9>
    CLONE store ir<%or.us>, ir<%r.053.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_union_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.052.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.053.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%or.us> = or ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.053.us>
    WIDEN store vp<%6>, ir<%or.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sbitmap_union_of_preds' from sbitmap.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    EMIT ir<%r.053.us> = WIDEN-POINTER-INDUCTION ir<%elms20>, 8
    EMIT ir<%p.052.us> = WIDEN-POINTER-INDUCTION ir<%elms.us>, 8
    WIDEN-INDUCTION %i.051.us = phi 0, %inc.us, ir<1>
    CLONE ir<%incdec.ptr.us> = getelementptr inbounds ir<%p.052.us>, ir<8>
    vp<%4> = vector-pointer ir<%p.052.us>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%incdec.ptr25.us> = getelementptr inbounds ir<%r.053.us>, ir<8>
    vp<%5> = vector-pointer ir<%r.053.us>
    WIDEN ir<%10> = load vp<%5>
    WIDEN ir<%or.us> = or ir<%10>, ir<%9>
    vp<%6> = vector-pointer ir<%r.053.us>
    WIDEN store vp<%6>, ir<%or.us>
    CLONE ir<%inc.us> = add nuw ir<%i.051.us>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%inc.us>, ir<%.fr>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sbitmap_union_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i64 %or.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'sbitmap_union_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i64 %or.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sbitmap_union_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i64 %or.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 12884901888
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'sbitmap_union_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i64 %or.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 25769803770
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 12884901888, RTCostB: 10737418248

-----------------Function that is being costed:'sbitmap_union_of_preds' from sbitmap.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %r.053.us = phi ptr [ %elms20, %if.end15.us ], [ %incdec.ptr25.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %p.052.us = phi ptr [ %elms.us, %if.end15.us ], [ %incdec.ptr.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.051.us = phi i32 [ 0, %if.end15.us ], [ %inc.us, %for.body24.us ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr.us = getelementptr inbounds i8, ptr %p.052.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %9 = load i64, ptr %p.052.us, align 8 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr25.us = getelementptr inbounds i8, ptr %r.053.us, i64 8 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %10 = load i64, ptr %r.053.us, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %or.us = or i64 %10, %9 of type:or
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i64 %or.us, ptr %r.053.us, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc.us = add nuw i32 %i.051.us, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i32 %inc.us, %.fr of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %cleanup.us.loopexit, label %for.body24.us of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 25769803770
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 10737418248, RTCostB: 10737418248
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: sbitmap_union_of_preds at line: sbitmap.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<if.end15.us>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %.fr to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%13>
    vp<%4>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<8>
    EMIT vp<%6> = ptradd ir<%elms20>, vp<%5>
    vp<%7>    = DERIVED-IV ir<0> + vp<%3> * ir<8>
    vp<%8> = SCALAR-STEPS vp<%7>, ir<8>
    EMIT vp<%9> = ptradd ir<%elms.us>, vp<%8>
    vp<%10> = vector-pointer vp<%9>
    WIDEN ir<%13> = load vp<%10>
    vp<%11> = vector-pointer vp<%6>
    WIDEN ir<%14> = load vp<%11>
    WIDEN ir<%or.us> = or ir<%14>, ir<%13>
    vp<%12> = vector-pointer vp<%6>
    WIDEN store vp<%12>, ir<%or.us>
    EMIT vp<%13> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%13>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%15> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%15>
Successor(s): ir-bb<cleanup.us.loopexit>, scalar.ph

ir-bb<cleanup.us.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 4
Loops Analyzed: 24
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o sched-deps.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         sched-deps.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o sched-ebb.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         sched-ebb.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o sched-rgn.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         sched-rgn.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o sched-vis.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         sched-vis.c
========== Loop: get_visual_tbl_length' from sched-vis.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<26> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.032> = phi ir<%add>, ir<%n.2>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<@function_units>, ir<0>, ir<%indvars.iv>
    CLONE ir<%bitmask> = getelementptr inbounds ir<%arrayidx>, ir<8>
    CLONE ir<%2> = load ir<%bitmask>
    CLONE ir<%and> = and ir<%1>, ir<%2>
    CLONE ir<%tobool.not> = icmp eq ir<%and>, ir<0>
  Successor(s): for.cond3.preheader

  for.cond3.preheader:
    EMIT vp<%3> = not ir<%tobool.not>
    CLONE ir<%multiplicity> = getelementptr inbounds ir<%arrayidx>, ir<12>
    CLONE ir<%3> = load ir<%multiplicity>, vp<%3>
    CLONE ir<%cmp629> = icmp sgt ir<%3>, ir<0>
  Successor(s): for.body8.preheader

  for.body8.preheader:
    EMIT vp<%4> = logical-and vp<%3>, ir<%cmp629>
    CLONE ir<%4> = mul ir<%3>, ir<%conv>
    CLONE ir<%5> = add ir<%n.032>, ir<%4>
  Successor(s): for.inc10

  for.inc10:
    EMIT vp<%5> = not ir<%cmp629>
    EMIT vp<%6> = logical-and vp<%3>, vp<%5>
    EMIT vp<%7> = or vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, ir<%tobool.not>
    BLEND ir<%n.2> = ir<%n.032> ir<%n.032>/vp<%6> ir<%5>/vp<%4>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<26>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%n.032>, ir<%n.2>
  EMIT vp<%12> = icmp eq ir<26>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end12>, scalar.ph

ir-bb<for.end12>:
No successors

scalar.ph:
No successors

Live-out i32 %n.2.lcssa = vp<%11>
}

========== Loop: get_visual_tbl_length' from sched-vis.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<26> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.032> = phi ir<%add>, ir<%n.2>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@function_units>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%bitmask> = getelementptr inbounds ir<%arrayidx>, ir<8>
    WIDEN ir<%2> = load ir<%bitmask>
    WIDEN ir<%and> = and ir<%1>, ir<%2>
    WIDEN ir<%tobool.not> = icmp eq ir<%and>, ir<0>
  Successor(s): for.cond3.preheader

  for.cond3.preheader:
    EMIT vp<%3> = not ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%multiplicity> = getelementptr inbounds ir<%arrayidx>, ir<12>
    WIDEN ir<%3> = load ir<%multiplicity>, vp<%3>
    WIDEN ir<%cmp629> = icmp sgt ir<%3>, ir<0>
  Successor(s): for.body8.preheader

  for.body8.preheader:
    EMIT vp<%4> = logical-and vp<%3>, ir<%cmp629>
    WIDEN ir<%4> = mul ir<%3>, ir<%conv>
    WIDEN ir<%5> = add ir<%n.032>, ir<%4>
  Successor(s): for.inc10

  for.inc10:
    EMIT vp<%5> = not ir<%cmp629>
    EMIT vp<%6> = logical-and vp<%3>, vp<%5>
    EMIT vp<%7> = or vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, ir<%tobool.not>
    BLEND ir<%n.2> = ir<%n.032> ir<%n.032>/vp<%6> ir<%5>/vp<%4>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<26>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%n.032>, ir<%n.2>
  EMIT vp<%12> = icmp eq ir<26>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end12>, scalar.ph

ir-bb<for.end12>:
No successors

scalar.ph:
No successors

Live-out i32 %n.2.lcssa = vp<%11>
}

========== Loop: get_visual_tbl_length' from sched-vis.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<26> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%9>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.032> = phi ir<%add>, ir<%n.2>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@function_units>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%bitmask> = getelementptr inbounds ir<%arrayidx>, ir<8>
    WIDEN ir<%2> = load ir<%bitmask>
    WIDEN ir<%and> = and ir<%1>, ir<%2>
    WIDEN ir<%tobool.not> = icmp eq ir<%and>, ir<0>
  Successor(s): for.cond3.preheader

  for.cond3.preheader:
    EMIT vp<%3> = not ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%multiplicity> = getelementptr inbounds ir<%arrayidx>, ir<12>
    WIDEN ir<%3> = load ir<%multiplicity>, vp<%3>
    WIDEN ir<%cmp629> = icmp sgt ir<%3>, ir<0>
  Successor(s): for.body8.preheader

  for.body8.preheader:
    EMIT vp<%4> = logical-and vp<%3>, ir<%cmp629>
    WIDEN ir<%4> = mul ir<%3>, ir<%conv>
    WIDEN ir<%5> = add ir<%n.032>, ir<%4>
  Successor(s): for.inc10

  for.inc10:
    EMIT vp<%5> = not ir<%cmp629>
    EMIT vp<%6> = logical-and vp<%3>, vp<%5>
    EMIT vp<%7> = or vp<%4>, vp<%6>
    EMIT vp<%8> = or vp<%7>, ir<%tobool.not>
    BLEND ir<%n.2> = ir<%n.032> ir<%n.032>/vp<%6> ir<%5>/vp<%4>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<26>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%9> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = compute-reduction-result ir<%n.032>, ir<%n.2>
  EMIT vp<%12> = icmp eq ir<26>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<for.end12>, scalar.ph

ir-bb<for.end12>:
No successors

scalar.ph:
No successors

Live-out i32 %n.2.lcssa = vp<%11>
}


-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = load i32, ptr %bitmask, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %3 = load i32, ptr %multiplicity, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %2 = load i32, ptr %bitmask, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %3 = load i32, ptr %multiplicity, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 169, RTCostB: 182
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 169, RTCostB: 182
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %2 = load i32, ptr %bitmask, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %3 = load i32, ptr %multiplicity, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF 4 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 182
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 169
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF 8 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %2 = load i32, ptr %bitmask, align 8 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 2 for VF 8 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %3 = load i32, ptr %multiplicity, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 2 for VF 8 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 2 for VF 8 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 4 for VF 8 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width 8 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 119, RTCostB: 182
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 119, RTCostB: 122
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %2 = load i32, ptr %bitmask, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %3 = load i32, ptr %multiplicity, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 6
A is scalable.	B is not scalable.	
RTCostA: 169, RTCostB: 182
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 169, RTCostB: 119

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %2 = load i32, ptr %bitmask, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %3 = load i32, ptr %multiplicity, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 182
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 122, RTCostB: 119

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %n.032 = phi i32 [ %add, %entry ], [ %n.2, %for.inc10 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds [0 x %struct.function_unit_desc], ptr @function_units, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %bitmask = getelementptr inbounds i8, ptr %arrayidx, i64 8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %2 = load i32, ptr %bitmask, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %and = and i32 %1, %2 of type:and
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i32 %and, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %for.inc10, label %for.cond3.preheader of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %multiplicity = getelementptr inbounds i8, ptr %arrayidx, i64 12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %3 = load i32, ptr %multiplicity, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp629 = icmp sgt i32 %3, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp629, label %for.body8.preheader, label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %4 = mul i32 %3, %conv of type:mul
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %5 = add i32 %n.032, %4 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc10 of type:br

-----------------Function that is being costed:'get_visual_tbl_length' from sched-vis.c-----------------
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %n.2 = phi i32 [ %n.032, %for.body ], [ %n.032, %for.cond3.preheader ], [ %5, %for.body8.preheader ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 26 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end12, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 119, RTCostB: 182
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 119, RTCostB: 119
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 4.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: get_visual_tbl_length at line: sched-vis.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<26> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-REDUCTION-PHI ir<%n.032> = phi ir<%add>, ir<%n.2>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx> = getelementptr inbounds ir<@function_units>, ir<0>, ir<%indvars.iv>
    WIDEN-GEP Var[Inv] ir<%bitmask> = getelementptr inbounds ir<%arrayidx>, ir<8>
    WIDEN ir<%2> = load ir<%bitmask>
    WIDEN ir<%and> = and ir<%1>, ir<%2>
    WIDEN ir<%tobool.not> = icmp eq ir<%and>, ir<0>
    EMIT vp<%3> = not ir<%tobool.not>
    WIDEN-GEP Var[Inv] ir<%multiplicity> = getelementptr inbounds ir<%arrayidx>, ir<12>
    WIDEN ir<%3> = load ir<%multiplicity>, vp<%3>
    WIDEN ir<%cmp629> = icmp sgt ir<%3>, ir<0>
    EMIT vp<%4> = logical-and vp<%3>, ir<%cmp629>
    WIDEN ir<%4> = mul ir<%3>, ir<%conv>
    WIDEN ir<%5> = add ir<%n.032>, ir<%4>
    EMIT vp<%5> = not ir<%cmp629>
    EMIT vp<%6> = logical-and vp<%3>, vp<%5>
    BLEND ir<%n.2> = ir<%n.032> ir<%n.032>/vp<%6> ir<%5>/vp<%4>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = compute-reduction-result ir<%n.032>, ir<%n.2>
  EMIT vp<%10> = icmp eq ir<26>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end12>, scalar.ph

ir-bb<for.end12>:
No successors

scalar.ph:
No successors

Live-out i32 %n.2.lcssa = vp<%9>
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o sdbout.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         sdbout.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o sibcall.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         sibcall.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o simplify-rtx.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         simplify-rtx.c
========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body258.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.1.lcssa1009 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv969 = phi 0, %indvars.iv.next970, ir<1>
    WIDEN-REDUCTION-PHI ir<%input_consts.4938> = phi ir<%input_consts.1.lcssa1008>, ir<%spec.select>
    CLONE ir<%arrayidx260> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv969>
    CLONE ir<%26> = load ir<%arrayidx260>
    CLONE ir<%bf.load262> = load ir<%26>
    CLONE ir<%bf.clear263> = and ir<%bf.load262>, ir<65535>
    CLONE ir<%cmp264> = icmp eq ir<%bf.clear263>, ir<58>
    CLONE ir<%inc267> = zext ir<%cmp264>
    CLONE ir<%spec.select> = add ir<%input_consts.4938>, ir<%inc267>
    CLONE ir<%indvars.iv.next970> = add nuw nsw ir<%indvars.iv969>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next970>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%input_consts.4938>, ir<%spec.select>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<do.body272.preheader>, scalar.ph

ir-bb<do.body272.preheader>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%6>
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body258.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.1.lcssa1009 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv969 = phi 0, %indvars.iv.next970, ir<1>
    WIDEN-REDUCTION-PHI ir<%input_consts.4938> = phi ir<%input_consts.1.lcssa1008>, ir<%spec.select>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx260> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv969>
    WIDEN ir<%26> = load ir<%arrayidx260>
    WIDEN ir<%bf.load262> = load ir<%26>
    WIDEN ir<%bf.clear263> = and ir<%bf.load262>, ir<65535>
    WIDEN ir<%cmp264> = icmp eq ir<%bf.clear263>, ir<58>
    WIDEN-CAST ir<%inc267> = zext  ir<%cmp264> to i32
    WIDEN ir<%spec.select> = add ir<%input_consts.4938>, ir<%inc267>
    WIDEN ir<%indvars.iv.next970> = add nuw nsw ir<%indvars.iv969>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next970>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%input_consts.4938>, ir<%spec.select>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body258.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.1.lcssa1009 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv969 = phi 0, %indvars.iv.next970, ir<1>
    WIDEN-REDUCTION-PHI ir<%input_consts.4938> = phi ir<%input_consts.1.lcssa1008>, ir<%spec.select>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx260> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv969>
    WIDEN ir<%26> = load ir<%arrayidx260>
    WIDEN ir<%bf.load262> = load ir<%26>
    WIDEN ir<%bf.clear263> = and ir<%bf.load262>, ir<65535>
    WIDEN ir<%cmp264> = icmp eq ir<%bf.clear263>, ir<58>
    WIDEN-CAST ir<%inc267> = zext  ir<%cmp264> to i32
    WIDEN ir<%spec.select> = add ir<%input_consts.4938>, ir<%inc267>
    WIDEN ir<%indvars.iv.next970> = add nuw nsw ir<%indvars.iv969>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next970>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%input_consts.4938>, ir<%spec.select>
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next970, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1008, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next970, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next970, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1008, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next970, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 11811160061, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 11811160061, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next970, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1008, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next970, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 8589934600, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934600, RTCostB: 11811160061
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next970, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1008, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next970, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Vector loop of width vscale x 1 costs: 5
A is scalable.	B is not scalable.	
RTCostA: 11811160061, RTCostB: 17179869176
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 11811160061, RTCostB: 8589934600

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv969 = phi i64 [ 0, %for.body258.preheader ], [ %indvars.iv.next970, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %input_consts.4938 = phi i32 [ %input_consts.1.lcssa1008, %for.body258.preheader ], [ %spec.select, %for.body258 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx260 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv969 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %26 = load ptr, ptr %arrayidx260, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %bf.load262 = load i32, ptr %26, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear263 = and i32 %bf.load262, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp264 = icmp eq i32 %bf.clear263, 58 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc267 = zext i1 %cmp264 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = add nsw i32 %input_consts.4938, %inc267 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next970 = add nuw nsw i64 %indvars.iv969, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next970, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %do.body272.preheader, label %for.body258 of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
RTCostA: 8589934600, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934600, RTCostB: 8589934600
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 4.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: simplify_plus_minus at line: simplify-rtx.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body258.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.1.lcssa1009 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv969 = phi 0, %indvars.iv.next970, ir<1>
    WIDEN-REDUCTION-PHI ir<%input_consts.4938> = phi ir<%input_consts.1.lcssa1008>, ir<%spec.select>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx260> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv969>
    WIDEN ir<%26> = load ir<%arrayidx260>
    WIDEN ir<%bf.load262> = load ir<%26>
    WIDEN ir<%bf.clear263> = and ir<%bf.load262>, ir<65535>
    WIDEN ir<%cmp264> = icmp eq ir<%bf.clear263>, ir<58>
    WIDEN-CAST ir<%inc267> = zext  ir<%cmp264> to i32
    WIDEN ir<%spec.select> = add ir<%input_consts.4938>, ir<%inc267>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%input_consts.4938>, ir<%spec.select>
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body608.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41031 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv985 = phi 0, %indvars.iv.next986, ir<1>
    WIDEN-REDUCTION-PHI ir<%n_consts.0954> = phi ir<0>, ir<%spec.select904>
    CLONE ir<%arrayidx610> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv985>
    CLONE ir<%57> = load ir<%arrayidx610>
    CLONE ir<%bf.load612> = load ir<%57>
    CLONE ir<%bf.clear613> = and ir<%bf.load612>, ir<65535>
    CLONE ir<%cmp614> = icmp eq ir<%bf.clear613>, ir<58>
    CLONE ir<%inc617> = zext ir<%cmp614>
    CLONE ir<%spec.select904> = add ir<%n_consts.0954>, ir<%inc617>
    CLONE ir<%indvars.iv.next986> = add nuw nsw ir<%indvars.iv985>, ir<1>
    CLONE ir<%exitcond988.not> = icmp eq ir<%indvars.iv.next986>, ir<%wide.trip.count987>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%n_consts.0954>, ir<%spec.select904>
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end621.loopexit>, scalar.ph

ir-bb<for.end621.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select904.lcssa = vp<%6>
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body608.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41031 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv985 = phi 0, %indvars.iv.next986, ir<1>
    WIDEN-REDUCTION-PHI ir<%n_consts.0954> = phi ir<0>, ir<%spec.select904>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx610> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv985>
    WIDEN ir<%57> = load ir<%arrayidx610>
    WIDEN ir<%bf.load612> = load ir<%57>
    WIDEN ir<%bf.clear613> = and ir<%bf.load612>, ir<65535>
    WIDEN ir<%cmp614> = icmp eq ir<%bf.clear613>, ir<58>
    WIDEN-CAST ir<%inc617> = zext  ir<%cmp614> to i32
    WIDEN ir<%spec.select904> = add ir<%n_consts.0954>, ir<%inc617>
    WIDEN ir<%indvars.iv.next986> = add nuw nsw ir<%indvars.iv985>, ir<1>
    CLONE ir<%exitcond988.not> = icmp eq ir<%indvars.iv.next986>, ir<%wide.trip.count987>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%n_consts.0954>, ir<%spec.select904>
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body608.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41031 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv985 = phi 0, %indvars.iv.next986, ir<1>
    WIDEN-REDUCTION-PHI ir<%n_consts.0954> = phi ir<0>, ir<%spec.select904>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx610> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv985>
    WIDEN ir<%57> = load ir<%arrayidx610>
    WIDEN ir<%bf.load612> = load ir<%57>
    WIDEN ir<%bf.clear613> = and ir<%bf.load612>, ir<65535>
    WIDEN ir<%cmp614> = icmp eq ir<%bf.clear613>, ir<58>
    WIDEN-CAST ir<%inc617> = zext  ir<%cmp614> to i32
    WIDEN ir<%spec.select904> = add ir<%n_consts.0954>, ir<%inc617>
    WIDEN ir<%indvars.iv.next986> = add nuw nsw ir<%indvars.iv985>, ir<1>
    CLONE ir<%exitcond988.not> = icmp eq ir<%indvars.iv.next986>, ir<%wide.trip.count987>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%n_consts.0954>, ir<%spec.select904>
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv985 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next986, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv985 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %57 = load ptr, ptr %arrayidx610, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.load612 = load i32, ptr %57, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next986 = add nuw nsw i64 %indvars.iv985, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond988.not = icmp eq i64 %indvars.iv.next986, %wide.trip.count987 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond988.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv985 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next986, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv985 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %57 = load ptr, ptr %arrayidx610, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %bf.load612 = load i32, ptr %57, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 2 for VF 2 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next986 = add nuw nsw i64 %indvars.iv985, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond988.not = icmp eq i64 %indvars.iv.next986, %wide.trip.count987 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond988.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv985 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next986, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv985 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %57 = load ptr, ptr %arrayidx610, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %bf.load612 = load i32, ptr %57, align 8 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next986 = add nuw nsw i64 %indvars.iv985, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond988.not = icmp eq i64 %indvars.iv.next986, %wide.trip.count987 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond988.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Vector loop of width 4 costs: 4
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 16
B VF: 2, EstimatedWidthB: 2, CostB: 11
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 44
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv985 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next986, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv985 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %57 = load ptr, ptr %arrayidx610, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %bf.load612 = load i32, ptr %57, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next986 = add nuw nsw i64 %indvars.iv985, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond988.not = icmp eq i64 %indvars.iv.next986, %wide.trip.count987 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond988.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Vector loop of width vscale x 1 costs: 5
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 11
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 11, CostB * EstimatedWidthA: 16
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 11
B VF: 4, EstimatedWidthB: 4, CostB: 16
CostA * EstimatedWidthB: 44, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv985 = phi i64 [ 0, %for.body608.preheader ], [ %indvars.iv.next986, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %n_consts.0954 = phi i32 [ 0, %for.body608.preheader ], [ %spec.select904, %for.body608 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx610 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv985 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %57 = load ptr, ptr %arrayidx610, align 8 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %bf.load612 = load i32, ptr %57, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %bf.clear613 = and i32 %bf.load612, 65535 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp614 = icmp eq i32 %bf.clear613, 58 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %inc617 = zext i1 %cmp614 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select904 = add nuw nsw i32 %n_consts.0954, %inc617 of type:add
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next986 = add nuw nsw i64 %indvars.iv985, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond988.not = icmp eq i64 %indvars.iv.next986, %wide.trip.count987 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond988.not, label %for.end621.loopexit, label %for.body608 of type:br
LV: Vector loop of width vscale x 2 costs: 4
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 16
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 16
B VF: 4, EstimatedWidthB: 4, CostB: 16
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 4.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: simplify_plus_minus at line: simplify-rtx.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body608.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41031 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv985 = phi 0, %indvars.iv.next986, ir<1>
    WIDEN-REDUCTION-PHI ir<%n_consts.0954> = phi ir<0>, ir<%spec.select904>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx610> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv985>
    WIDEN ir<%57> = load ir<%arrayidx610>
    WIDEN ir<%bf.load612> = load ir<%57>
    WIDEN ir<%bf.clear613> = and ir<%bf.load612>, ir<65535>
    WIDEN ir<%cmp614> = icmp eq ir<%bf.clear613>, ir<58>
    WIDEN-CAST ir<%inc617> = zext  ir<%cmp614> to i32
    WIDEN ir<%spec.select904> = add ir<%n_consts.0954>, ir<%inc617>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%n_consts.0954>, ir<%spec.select904>
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body653.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41030 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv993 = phi 0, %indvars.iv.next994, ir<1>
    CLONE ir<%neg656> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv993>, ir<1>
    CLONE store ir<0>, ir<%neg656>
    CLONE ir<%indvars.iv.next994> = add nuw nsw ir<%indvars.iv993>, ir<1>
    CLONE ir<%exitcond996.not> = icmp eq ir<%indvars.iv.next994>, ir<%wide.trip.count995>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end676.loopexit>, scalar.ph

ir-bb<if.end676.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body653.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41030 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv993 = phi 0, %indvars.iv.next994, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%neg656> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv993>, ir<1>
    WIDEN store ir<%neg656>, ir<0>
    WIDEN ir<%indvars.iv.next994> = add nuw nsw ir<%indvars.iv993>, ir<1>
    CLONE ir<%exitcond996.not> = icmp eq ir<%indvars.iv.next994>, ir<%wide.trip.count995>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end676.loopexit>, scalar.ph

ir-bb<if.end676.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: simplify_plus_minus' from simplify-rtx.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body653.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41030 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv993 = phi 0, %indvars.iv.next994, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%neg656> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv993>, ir<1>
    WIDEN store ir<%neg656>, ir<0>
    WIDEN ir<%indvars.iv.next994> = add nuw nsw ir<%indvars.iv993>, ir<1>
    CLONE ir<%exitcond996.not> = icmp eq ir<%indvars.iv.next994>, ir<%wide.trip.count995>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end676.loopexit>, scalar.ph

ir-bb<if.end676.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv993 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next994, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv993, i32 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 0, ptr %neg656, align 8 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next994 = add nuw nsw i64 %indvars.iv993, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond996.not = icmp eq i64 %indvars.iv.next994, %wide.trip.count995 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond996.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv993 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next994, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv993, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 0, ptr %neg656, align 8 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next994 = add nuw nsw i64 %indvars.iv993, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond996.not = icmp eq i64 %indvars.iv.next994, %wide.trip.count995 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond996.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv993 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next994, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv993, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   store i32 0, ptr %neg656, align 8 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next994 = add nuw nsw i64 %indvars.iv993, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond996.not = icmp eq i64 %indvars.iv.next994, %wide.trip.count995 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond996.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 12
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 7
B VF: 2, EstimatedWidthB: 2, CostB: 4
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv993 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next994, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv993, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   store i32 0, ptr %neg656, align 8 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next994 = add nuw nsw i64 %indvars.iv993, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond996.not = icmp eq i64 %indvars.iv.next994, %wide.trip.count995 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond996.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 24
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 13
B VF: 4, EstimatedWidthB: 4, CostB: 7
CostA * EstimatedWidthB: 52, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv993 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next994, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv993, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 0, ptr %neg656, align 8 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next994 = add nuw nsw i64 %indvars.iv993, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond996.not = icmp eq i64 %indvars.iv.next994, %wide.trip.count995 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond996.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 6
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 13
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 26

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv993 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next994, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv993, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   store i32 0, ptr %neg656, align 8 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next994 = add nuw nsw i64 %indvars.iv993, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond996.not = icmp eq i64 %indvars.iv.next994, %wide.trip.count995 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond996.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 13
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 52

-----------------Function that is being costed:'simplify_plus_minus' from simplify-rtx.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv993 = phi i64 [ 0, %for.body653.preheader ], [ %indvars.iv.next994, %for.body653 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %neg656 = getelementptr inbounds [8 x %struct.simplify_plus_minus_op_data], ptr %ops, i64 0, i64 %indvars.iv993, i32 1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   store i32 0, ptr %neg656, align 8 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next994 = add nuw nsw i64 %indvars.iv993, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond996.not = icmp eq i64 %indvars.iv.next994, %wide.trip.count995 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond996.not, label %if.end676.loopexit, label %for.body653 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 13
B VF: 1, EstimatedWidthB: 1, CostB: 3
CostA * EstimatedWidthB: 13, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 13
B VF: 8, EstimatedWidthB: 8, CostB: 13
CostA * EstimatedWidthB: 104, CostB * EstimatedWidthA: 104
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: simplify_plus_minus at line: simplify-rtx.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body653.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %n_ops.41030 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv993 = phi 0, %indvars.iv.next994, ir<1>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%neg656> = getelementptr inbounds ir<%ops>, ir<0>, ir<%indvars.iv993>, ir<1>
    WIDEN store ir<%neg656>, ir<0>
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end676.loopexit>, scalar.ph

ir-bb<if.end676.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o ssa.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         ssa.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o ssa-ccp.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         ssa-ccp.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o ssa-dce.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         ssa-dce.c
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4 -> Cost: 2 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4 -> Cost: 3 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(3)
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4 -> Cost: 2 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -3, ptr %arrayidx, align 4 -> Cost: 3 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(3)
========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    CLONE store ir<-3>, ir<%arrayidx>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<-3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%4>, ir<-3>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -3, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 3.
-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 -3, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 6442450941
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 6442450941
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i32 -3, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 6442450941
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 4294967295
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF 8 For instruction:   store i32 -3, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1342177296, RTCostB: 6442450941
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1342177296, RTCostB: 2147483653
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   store i32 -3, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 6442450941
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967295, RTCostB: 1342177296

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 -3, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 6442450941
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483653, RTCostB: 1342177296

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 3 for VF vscale x 4 For instruction:   store i32 -3, ptr %arrayidx, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177296, RTCostB: 6442450941
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177296, RTCostB: 1342177296
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: ssa_eliminate_dead_code at line: ssa-dce.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %2 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%call4>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN store vp<%5>, ir<-3>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %14 = load i32, ptr %arrayidx11, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %14 = load i32, ptr %arrayidx11, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %14 = load i32, ptr %arrayidx11, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MaskedMemoryOpCost(2)
@@ Instruction =>  %14 = load i32, ptr %arrayidx11, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %14 = load i32, ptr %arrayidx11, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %14 = load i32, ptr %arrayidx11, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 -2, ptr %arrayidx11, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MaskedMemoryOpCost(2)
========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %13 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv745 = phi 0, %indvars.iv.next746, ir<1>
    CLONE ir<%arrayidx11> = getelementptr inbounds ir<%call4>, ir<%indvars.iv745>
    CLONE ir<%14> = load ir<%arrayidx11>
    CLONE ir<%cmp12> = icmp eq ir<%14>, ir<-3>
  Successor(s): if.then

  if.then:
    CLONE store ir<-2>, ir<%arrayidx11>, ir<%cmp12>
  Successor(s): for.inc16

  for.inc16:
    EMIT vp<%4> = not ir<%cmp12>
    EMIT vp<%5> = or vp<%4>, ir<%cmp12>
    CLONE ir<%indvars.iv.next746> = add nuw nsw ir<%indvars.iv745>, ir<1>
    CLONE ir<%exitcond748.not> = icmp eq ir<%indvars.iv.next746>, ir<%wide.trip.count747>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end18.loopexit>, scalar.ph

ir-bb<for.end18.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %13 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv745 = phi 0, %indvars.iv.next746, ir<1>
    CLONE ir<%arrayidx11> = getelementptr ir<%call4>, ir<%indvars.iv745>
    vp<%4> = vector-pointer ir<%arrayidx11>
    WIDEN ir<%14> = load vp<%4>
    WIDEN ir<%cmp12> = icmp eq ir<%14>, ir<-3>
  Successor(s): if.then

  if.then:
    vp<%5> = vector-pointer ir<%arrayidx11>
    WIDEN store vp<%5>, ir<-2>, ir<%cmp12>
  Successor(s): for.inc16

  for.inc16:
    EMIT vp<%6> = not ir<%cmp12>
    EMIT vp<%7> = or vp<%6>, ir<%cmp12>
    CLONE ir<%indvars.iv.next746> = add nuw nsw ir<%indvars.iv745>, ir<1>
    CLONE ir<%exitcond748.not> = icmp eq ir<%indvars.iv.next746>, ir<%wide.trip.count747>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end18.loopexit>, scalar.ph

ir-bb<for.end18.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: ssa_eliminate_dead_code' from ssa-dce.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %13 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv745 = phi 0, %indvars.iv.next746, ir<1>
    CLONE ir<%arrayidx11> = getelementptr ir<%call4>, ir<%indvars.iv745>
    vp<%4> = vector-pointer ir<%arrayidx11>
    WIDEN ir<%14> = load vp<%4>
    WIDEN ir<%cmp12> = icmp eq ir<%14>, ir<-3>
  Successor(s): if.then

  if.then:
    vp<%5> = vector-pointer ir<%arrayidx11>
    WIDEN store vp<%5>, ir<-2>, ir<%cmp12>
  Successor(s): for.inc16

  for.inc16:
    EMIT vp<%6> = not ir<%cmp12>
    EMIT vp<%7> = or vp<%6>, ir<%cmp12>
    CLONE ir<%indvars.iv.next746> = add nuw nsw ir<%indvars.iv745>, ir<1>
    CLONE ir<%exitcond748.not> = icmp eq ir<%indvars.iv.next746>, ir<%wide.trip.count747>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end18.loopexit>, scalar.ph

ir-bb<for.end18.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next746, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv745 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %14 = load i32, ptr %arrayidx11, align 4 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp12 = icmp eq i32 %14, -3 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 -2, ptr %arrayidx11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond748.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count747 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond748.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next746, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv745 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %14 = load i32, ptr %arrayidx11, align 4 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp12 = icmp eq i32 %14, -3 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 -2, ptr %arrayidx11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond748.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count747 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond748.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5368709119, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5368709119, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next746, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv745 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %14 = load i32, ptr %arrayidx11, align 4 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp12 = icmp eq i32 %14, -3 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 -2, ptr %arrayidx11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond748.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count747 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond748.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354567, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354567, RTCostB: 5368709119
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next746, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv745 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   %14 = load i32, ptr %arrayidx11, align 4 of type:load
LV: Found an estimated cost of 2 for VF 8 For instruction:   %cmp12 = icmp eq i32 %14, -3 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 -2, ptr %arrayidx11, align 4 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond748.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count747 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond748.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483668, RTCostB: 8589934588
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2147483668, RTCostB: 2684354567
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next746, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv745 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %14 = load i32, ptr %arrayidx11, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp12 = icmp eq i32 %14, -3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 -2, ptr %arrayidx11, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond748.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count747 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond748.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5368709119, RTCostB: 8589934588
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5368709119, RTCostB: 2147483668

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next746, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv745 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %14 = load i32, ptr %arrayidx11, align 4 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp12 = icmp eq i32 %14, -3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 -2, ptr %arrayidx11, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond748.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count747 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond748.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354567, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354567, RTCostB: 2147483668

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv745 = phi i64 [ 0, %for.body9.preheader ], [ %indvars.iv.next746, %for.inc16 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx11 = getelementptr inbounds i32, ptr %call4, i64 %indvars.iv745 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %14 = load i32, ptr %arrayidx11, align 4 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp12 = icmp eq i32 %14, -3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp12, label %if.then, label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 -2, ptr %arrayidx11, align 4 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br label %for.inc16 of type:br

-----------------Function that is being costed:'ssa_eliminate_dead_code' from ssa-dce.c-----------------
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next746 = add nuw nsw i64 %indvars.iv745, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond748.not = icmp eq i64 %indvars.iv.next746, %wide.trip.count747 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond748.not, label %for.end18.loopexit, label %for.body9 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483668, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483668, RTCostB: 2147483668
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: ssa_eliminate_dead_code at line: ssa-dce.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body9.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %13 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx11> = getelementptr ir<%call4>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx11>
    WIDEN ir<%14> = load vp<%5>
    WIDEN ir<%cmp12> = icmp eq ir<%14>, ir<-3>
    vp<%6> = vector-pointer ir<%arrayidx11>
    WIDEN store vp<%6>, ir<-2>, ir<%cmp12>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end18.loopexit>, scalar.ph

ir-bb<for.end18.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 11
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o stmt.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         stmt.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o stor-layout.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         stor-layout.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o stringpool.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         stringpool.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o timevar.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         timevar.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o toplev.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         toplev.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o tree.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         tree.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o tree-dump.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         tree-dump.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o tree-inline.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         tree-inline.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o unroll.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         unroll.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o varasm.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         varasm.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o varray.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         varray.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o vmsdbgout.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         vmsdbgout.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o xcoffout.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         xcoffout.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o ggc-page.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         ggc-page.c
@@ Instruction =>  %2 = load i64, ptr %arrayidx23, align 8 -> Cost: 1 -> VectorType: <2 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %spec.select, ptr %arrayidx27, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i64, ptr %arrayidx23, align 8 -> Cost: 2 -> VectorType: <4 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %spec.select, ptr %arrayidx27, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i64, ptr %arrayidx23, align 8 -> Cost: 1 -> VectorType: <vscale x 1 x i64> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %spec.select, ptr %arrayidx27, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %2 = load i64, ptr %arrayidx23, align 8 -> Cost: 2 -> VectorType: <vscale x 2 x i64> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %spec.select, ptr %arrayidx27, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: init_ggc' from ggc-page.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<66> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@object_size_table>, ir<0>, ir<%indvars.iv>
    CLONE ir<%2> = load ir<%arrayidx23>
    CLONE ir<%div24> = udiv ir<%1>, ir<%2>
    CLONE ir<%conv25> = trunc ir<%div24>
    CLONE ir<%arrayidx27> = getelementptr inbounds ir<@objects_per_page_table>, ir<0>, ir<%indvars.iv>
    CLONE ir<%spec.select> = call @llvm.umax.i32(ir<%conv25>, ir<1>)
    CLONE store ir<%spec.select>, ir<%arrayidx27>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<66>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<66>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body55.lr.ph>, scalar.ph

ir-bb<for.body55.lr.ph>:
No successors

scalar.ph:
No successors
}

========== Loop: init_ggc' from ggc-page.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<66> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@object_size_table>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%2> = load vp<%3>
    WIDEN ir<%div24> = udiv ir<%1>, ir<%2>
    WIDEN-CAST ir<%conv25> = trunc  ir<%div24> to i32
    CLONE ir<%arrayidx27> = getelementptr inbounds ir<@objects_per_page_table>, ir<0>, ir<%indvars.iv>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i32(ir<%conv25>, ir<1>) (using vector intrinsic)
    vp<%4> = vector-pointer ir<%arrayidx27>
    WIDEN store vp<%4>, ir<%spec.select>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<66>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<66>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body55.lr.ph>, scalar.ph

ir-bb<for.body55.lr.ph>:
No successors

scalar.ph:
No successors
}

========== Loop: init_ggc' from ggc-page.c==========
========== VPlan for Vector Factor Range: 1 to 4==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<66> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@object_size_table>, ir<0>, ir<%indvars.iv>
    vp<%3> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%2> = load vp<%3>
    WIDEN ir<%div24> = udiv ir<%1>, ir<%2>
    WIDEN-CAST ir<%conv25> = trunc  ir<%div24> to i32
    CLONE ir<%arrayidx27> = getelementptr inbounds ir<@objects_per_page_table>, ir<0>, ir<%indvars.iv>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i32(ir<%conv25>, ir<1>) (using vector intrinsic)
    vp<%4> = vector-pointer ir<%arrayidx27>
    WIDEN store vp<%4>, ir<%spec.select>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<66>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<66>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body55.lr.ph>, scalar.ph

ir-bb<for.body55.lr.ph>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx23 = getelementptr inbounds [66 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx27 = getelementptr inbounds [66 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 66 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx23 = getelementptr inbounds [66 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx27 = getelementptr inbounds [66 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 66 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 231, RTCostB: 396
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 231, RTCostB: 396
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx23 = getelementptr inbounds [66 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %2 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx27 = getelementptr inbounds [66 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 66 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 156, RTCostB: 396
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 156, RTCostB: 231
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx23 = getelementptr inbounds [66 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %2 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx27 = getelementptr inbounds [66 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 66 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 231, RTCostB: 396
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 231, RTCostB: 156

-----------------Function that is being costed:'init_ggc' from ggc-page.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body21 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx23 = getelementptr inbounds [66 x i64], ptr @object_size_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %2 = load i64, ptr %arrayidx23, align 8 of type:load
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %div24 = udiv i64 %1, %2 of type:udiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv25 = trunc i64 %div24 to i32 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx27 = getelementptr inbounds [66 x i32], ptr @objects_per_page_table, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %conv25, i32 1) of type:call
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %spec.select, ptr %arrayidx27, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, 66 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.body55.lr.ph, label %for.body21 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 156, RTCostB: 396
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 156, RTCostB: 156
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4
LV: Selecting VF: vscale x 2 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 2, UF=1 at function: init_ggc at line: ggc-page.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<66> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx23> = getelementptr inbounds ir<@object_size_table>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx23>
    WIDEN ir<%2> = load vp<%4>
    WIDEN ir<%div24> = udiv ir<%1>, ir<%2>
    WIDEN-CAST ir<%conv25> = trunc  ir<%div24> to i32
    CLONE ir<%arrayidx27> = getelementptr inbounds ir<@objects_per_page_table>, ir<0>, vp<%3>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i32(ir<%conv25>, ir<1>) (using vector intrinsic)
    vp<%5> = vector-pointer ir<%arrayidx27>
    WIDEN store vp<%5>, ir<%spec.select>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<66>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.body55.lr.ph>, scalar.ph

ir-bb<for.body55.lr.ph>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 10
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o i386.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         i386.c
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4 -> Cost: 2 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4 -> Cost: 1 -> VectorType: <vscale x 1 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %24, ptr %arrayidx244, align 4 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(2)
========== Loop: classify_argument' from i386.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body239.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv766 = phi 0, %indvars.iv.next767, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv766 = phi 0, %indvars.iv.next767\l" +
    "  ir<%23>, ir<1>
    CLONE ir<%rem240> = srem ir<%23>, ir<%call214>
    CLONE ir<%idxprom241> = zext nneg ir<%rem240>
    CLONE ir<%arrayidx242> = getelementptr inbounds ir<%subclasses>, ir<0>, ir<%idxprom241>
    CLONE ir<%24> = load ir<%arrayidx242>
    CLONE ir<%arrayidx244> = getelementptr inbounds ir<%classes>, ir<%indvars.iv766>
    CLONE store ir<%24>, ir<%arrayidx244>
    CLONE ir<%indvars.iv.next767> = add nuw nsw ir<%indvars.iv766>, ir<1>
    CLONE ir<%exitcond769.not> = icmp eq ir<%indvars.iv.next767>, ir<%wide.trip.count768>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end390.loopexit803>, scalar.ph

ir-bb<if.end390.loopexit803>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_argument' from i386.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body239.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv766 = phi 0, %indvars.iv.next767, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv766 = phi 0, %indvars.iv.next767\l" +
    "  ir<%23>, ir<1>
    WIDEN ir<%rem240> = srem ir<%23>, ir<%call214>
    WIDEN-CAST ir<%idxprom241> = zext  nneg ir<%rem240> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx242> = getelementptr inbounds ir<%subclasses>, ir<0>, ir<%idxprom241>
    WIDEN ir<%24> = load ir<%arrayidx242>
    CLONE ir<%arrayidx244> = getelementptr inbounds ir<%classes>, ir<%indvars.iv766>
    vp<%4> = vector-pointer ir<%arrayidx244>
    WIDEN store vp<%4>, ir<%24>
    WIDEN ir<%indvars.iv.next767> = add nuw nsw ir<%indvars.iv766>, ir<1>
    CLONE ir<%exitcond769.not> = icmp eq ir<%indvars.iv.next767>, ir<%wide.trip.count768>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end390.loopexit803>, scalar.ph

ir-bb<if.end390.loopexit803>:
No successors

scalar.ph:
No successors
}

========== Loop: classify_argument' from i386.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body239.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv766 = phi 0, %indvars.iv.next767, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv766 = phi 0, %indvars.iv.next767\l" +
    "  ir<%23>, ir<1>
    WIDEN ir<%rem240> = srem ir<%23>, ir<%call214>
    WIDEN-CAST ir<%idxprom241> = zext  nneg ir<%rem240> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx242> = getelementptr inbounds ir<%subclasses>, ir<0>, ir<%idxprom241>
    WIDEN ir<%24> = load ir<%arrayidx242>
    CLONE ir<%arrayidx244> = getelementptr inbounds ir<%classes>, ir<%indvars.iv766>
    vp<%4> = vector-pointer ir<%arrayidx244>
    WIDEN store vp<%4>, ir<%24>
    WIDEN ir<%indvars.iv.next767> = add nuw nsw ir<%indvars.iv766>, ir<1>
    CLONE ir<%exitcond769.not> = icmp eq ir<%indvars.iv.next767>, ir<%wide.trip.count768>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<if.end390.loopexit803>, scalar.ph

ir-bb<if.end390.loopexit803>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv766 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next767, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv766 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %24 = load i32, ptr %arrayidx242, align 4 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv766 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i32 %24, ptr %arrayidx244, align 4 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next767 = add nuw nsw i64 %indvars.iv766, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond769.not = icmp eq i64 %indvars.iv.next767, %wide.trip.count768 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond769.not, label %if.end390.loopexit803, label %for.body239 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv766 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next767, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv766 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF 2 For instruction:   %24 = load i32, ptr %arrayidx242, align 4 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv766 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %24, ptr %arrayidx244, align 4 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next767 = add nuw nsw i64 %indvars.iv766, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond769.not = icmp eq i64 %indvars.iv.next767, %wide.trip.count768 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond769.not, label %if.end390.loopexit803, label %for.body239 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 7516192767, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 7516192767, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv766 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next767, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv766 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF 4 For instruction:   %24 = load i32, ptr %arrayidx242, align 4 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv766 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %24, ptr %arrayidx244, align 4 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next767 = add nuw nsw i64 %indvars.iv766, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond769.not = icmp eq i64 %indvars.iv.next767, %wide.trip.count768 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond769.not, label %if.end390.loopexit803, label %for.body239 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5905580039, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5905580039, RTCostB: 7516192767
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv766 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next767, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv766 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 8 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF 8 For instruction:   %24 = load i32, ptr %arrayidx242, align 4 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv766 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i32 %24, ptr %arrayidx244, align 4 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next767 = add nuw nsw i64 %indvars.iv766, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond769.not = icmp eq i64 %indvars.iv.next767, %wide.trip.count768 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond769.not, label %if.end390.loopexit803, label %for.body239 of type:br
LV: Vector loop of width 8 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 5637144597, RTCostB: 12884901882
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 5637144597, RTCostB: 5905580039
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv766 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next767, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv766 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %24 = load i32, ptr %arrayidx242, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv766 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i32 %24, ptr %arrayidx244, align 4 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next767 = add nuw nsw i64 %indvars.iv766, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond769.not = icmp eq i64 %indvars.iv.next767, %wide.trip.count768 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond769.not, label %if.end390.loopexit803, label %for.body239 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 7516192767, RTCostB: 12884901882
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 7516192767, RTCostB: 5637144597

-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv766 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next767, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv766 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 4 for VF vscale x 2 For instruction:   %24 = load i32, ptr %arrayidx242, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv766 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %24, ptr %arrayidx244, align 4 of type:store
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %indvars.iv.next767 = add nuw nsw i64 %indvars.iv766, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond769.not = icmp eq i64 %indvars.iv.next767, %wide.trip.count768 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond769.not, label %if.end390.loopexit803, label %for.body239 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5905580039, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5905580039, RTCostB: 5637144597

-----------------Function that is being costed:'classify_argument' from i386.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv766 = phi i64 [ 0, %for.body239.preheader ], [ %indvars.iv.next767, %for.body239 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %23 = trunc nuw nsw i64 %indvars.iv766 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %rem240 = srem i32 %23, %call214 of type:srem
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %idxprom241 = zext nneg i32 %rem240 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx242 = getelementptr inbounds [4 x i32], ptr %subclasses, i64 0, i64 %idxprom241 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 8 for VF vscale x 4 For instruction:   %24 = load i32, ptr %arrayidx242, align 4 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx244 = getelementptr inbounds i32, ptr %classes, i64 %indvars.iv766 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %24, ptr %arrayidx244, align 4 of type:store
LV: Found an estimated cost of 4 for VF vscale x 4 For instruction:   %indvars.iv.next767 = add nuw nsw i64 %indvars.iv766, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond769.not = icmp eq i64 %indvars.iv.next767, %wide.trip.count768 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond769.not, label %if.end390.loopexit803, label %for.body239 of type:br
LV: Vector loop of width vscale x 4 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 5637144597, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 5637144597, RTCostB: 5637144597
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 8
LV: Selecting VF: vscale x 4 With Cost: 2.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: classify_argument at line: i386.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body239.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %div to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv766 = phi 0, %indvars.iv.next767\l" +
    "  ir<%23>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    WIDEN ir<%rem240> = srem ir<%23>, ir<%call214>
    WIDEN-CAST ir<%idxprom241> = zext  nneg ir<%rem240> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx242> = getelementptr inbounds ir<%subclasses>, ir<0>, ir<%idxprom241>
    WIDEN ir<%24> = load ir<%arrayidx242>
    CLONE ir<%arrayidx244> = getelementptr inbounds ir<%classes>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx244>
    WIDEN store vp<%5>, ir<%24>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<if.end390.loopexit803>, scalar.ph

ir-bb<if.end390.loopexit803>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 36
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o xmalloc.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         xmalloc.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o xexit.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         xexit.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o hashtab.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         hashtab.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o safe-ctype.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         safe-ctype.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o splay-tree.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         splay-tree.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o xstrdup.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         xstrdup.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o md5.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         md5.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o fibheap.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         fibheap.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o xstrerror.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         xstrerror.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o concat.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         concat.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o partition.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         partition.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o hex.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         hex.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o lbasename.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         lbasename.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o getpwd.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         getpwd.c
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration  -c -o ucbqsort.o -DSPEC_CPU -DNDEBUG -I.   -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions       -DSPEC_CPU_LP64         ucbqsort.c
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i8, ptr %j.2102, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %5 = load i8, ptr %i.0101, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %5, ptr %j.2102, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %4, ptr %i.0101, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: specqsort' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%j.2102> = WIDEN-POINTER-INDUCTION ir<%spec.select.lcssa>, 1
    EMIT ir<%i.0101> = WIDEN-POINTER-INDUCTION ir<%base>, 1
    CLONE ir<%4> = load ir<%j.2102>
    CLONE ir<%5> = load ir<%i.0101>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%j.2102>, ir<1>
    CLONE store ir<%5>, ir<%j.2102>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%i.0101>, ir<1>
    CLONE store ir<%4>, ir<%i.0101>
    CLONE ir<%cmp19> = icmp ult ir<%incdec.ptr21>, ir<%add.ptr17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: specqsort' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%j.2102> = WIDEN-POINTER-INDUCTION ir<%spec.select.lcssa>, 1
    EMIT ir<%i.0101> = WIDEN-POINTER-INDUCTION ir<%base>, 1
    vp<%4> = vector-pointer ir<%j.2102>
    WIDEN ir<%4> = load vp<%4>
    vp<%5> = vector-pointer ir<%i.0101>
    WIDEN ir<%5> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%j.2102>, ir<1>
    vp<%6> = vector-pointer ir<%j.2102>
    WIDEN store vp<%6>, ir<%5>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%i.0101>, ir<1>
    vp<%7> = vector-pointer ir<%i.0101>
    WIDEN store vp<%7>, ir<%4>
    CLONE ir<%cmp19> = icmp ult ir<%incdec.ptr21>, ir<%add.ptr17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: specqsort' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%j.2102> = WIDEN-POINTER-INDUCTION ir<%spec.select.lcssa>, 1
    EMIT ir<%i.0101> = WIDEN-POINTER-INDUCTION ir<%base>, 1
    vp<%4> = vector-pointer ir<%j.2102>
    WIDEN ir<%4> = load vp<%4>
    vp<%5> = vector-pointer ir<%i.0101>
    WIDEN ir<%5> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%j.2102>, ir<1>
    vp<%6> = vector-pointer ir<%j.2102>
    WIDEN store vp<%6>, ir<%5>
    CLONE ir<%incdec.ptr21> = getelementptr inbounds ir<%i.0101>, ir<1>
    vp<%7> = vector-pointer ir<%i.0101>
    WIDEN store vp<%7>, ir<%4>
    CLONE ir<%cmp19> = icmp ult ir<%incdec.ptr21>, ir<%add.ptr17>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 5
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 20
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 5
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 5
B VF: 8, EstimatedWidthB: 8, CostB: 5
CostA * EstimatedWidthB: 40, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 160
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 9
B VF: 16, EstimatedWidthB: 16, CostB: 5
CostA * EstimatedWidthB: 144, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 10
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 9
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 18

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 9
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 36

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 9
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 72

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 5
B VF: 32, EstimatedWidthB: 32, CostB: 9
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 144

-----------------Function that is being costed:'specqsort' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %j.2102 = phi ptr [ %incdec.ptr, %for.body20 ], [ %spec.select.lcssa, %for.body20.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.0101 = phi ptr [ %incdec.ptr21, %for.body20 ], [ %base, %for.body20.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %4 = load i8, ptr %j.2102, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %5 = load i8, ptr %i.0101, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %j.2102, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %5, ptr %j.2102, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr21 = getelementptr inbounds i8, ptr %i.0101, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %4, ptr %i.0101, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp19 = icmp ult ptr %incdec.ptr21, %add.ptr17 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp19, label %for.body20, label %if.end23.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 9
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 9, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 9
B VF: 32, EstimatedWidthB: 32, CostB: 9
CostA * EstimatedWidthB: 288, CostB * EstimatedWidthA: 288
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: specqsort at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body20.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((-1 * (ptrtoint ptr %base to i64)) + ((1 + (ptrtoint ptr %base to i64)) umax ((sext i32 %3 to i64) + (ptrtoint ptr %base to i64))))
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%spec.select.lcssa>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%base>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%7> = load vp<%8>
    vp<%9> = vector-pointer vp<%7>
    WIDEN ir<%8> = load vp<%9>
    vp<%10> = vector-pointer vp<%5>
    WIDEN store vp<%10>, ir<%8>
    vp<%11> = vector-pointer vp<%7>
    WIDEN store vp<%11>, ir<%7>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end23.loopexit>, scalar.ph

ir-bb<if.end23.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 4
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %16 = load i8, ptr %i.3, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %17 = load i8, ptr %jj.1, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %17, ptr %i.3, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %16, ptr %jj.1, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%i.3> = WIDEN-POINTER-INDUCTION ir<%i.2.lcssa>, 1
    EMIT ir<%jj.1> = WIDEN-POINTER-INDUCTION ir<%jj.0>, 1
    WIDEN-INDUCTION %ii.1 = phi %15, %dec72, ir<-1>
    CLONE ir<%16> = load ir<%i.3>
    CLONE ir<%17> = load ir<%jj.1>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%i.3>, ir<1>
    CLONE store ir<%17>, ir<%i.3>
    CLONE ir<%incdec.ptr70> = getelementptr inbounds ir<%jj.1>, ir<1>
    CLONE store ir<%16>, ir<%jj.1>
    CLONE ir<%dec72> = add nsw ir<%ii.1>, ir<-1>
    CLONE ir<%tobool73.not> = icmp eq ir<%dec72>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.3> = WIDEN-POINTER-INDUCTION ir<%i.2.lcssa>, 1
    EMIT ir<%jj.1> = WIDEN-POINTER-INDUCTION ir<%jj.0>, 1
    WIDEN-INDUCTION %ii.1 = phi %15, %dec72, ir<-1>
    vp<%4> = vector-pointer ir<%i.3>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer ir<%jj.1>
    WIDEN ir<%17> = load vp<%5>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%i.3>, ir<1>
    vp<%6> = vector-pointer ir<%i.3>
    WIDEN store vp<%6>, ir<%17>
    CLONE ir<%incdec.ptr70> = getelementptr inbounds ir<%jj.1>, ir<1>
    vp<%7> = vector-pointer ir<%jj.1>
    WIDEN store vp<%7>, ir<%16>
    CLONE ir<%dec72> = add nsw ir<%ii.1>, ir<-1>
    CLONE ir<%tobool73.not> = icmp eq ir<%dec72>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.3> = WIDEN-POINTER-INDUCTION ir<%i.2.lcssa>, 1
    EMIT ir<%jj.1> = WIDEN-POINTER-INDUCTION ir<%jj.0>, 1
    WIDEN-INDUCTION %ii.1 = phi %15, %dec72, ir<-1>
    vp<%4> = vector-pointer ir<%i.3>
    WIDEN ir<%16> = load vp<%4>
    vp<%5> = vector-pointer ir<%jj.1>
    WIDEN ir<%17> = load vp<%5>
    CLONE ir<%incdec.ptr69> = getelementptr inbounds ir<%i.3>, ir<1>
    vp<%6> = vector-pointer ir<%i.3>
    WIDEN store vp<%6>, ir<%17>
    CLONE ir<%incdec.ptr70> = getelementptr inbounds ir<%jj.1>, ir<1>
    vp<%7> = vector-pointer ir<%jj.1>
    WIDEN store vp<%7>, ir<%16>
    CLONE ir<%dec72> = add nsw ir<%ii.1>, ir<-1>
    CLONE ir<%tobool73.not> = icmp eq ir<%dec72>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 192
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 160

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.3 = phi ptr [ %i.2.lcssa, %swap ], [ %incdec.ptr69, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %jj.1 = phi ptr [ %jj.0, %swap ], [ %incdec.ptr70, %do.body68 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %ii.1 = phi i32 [ %15, %swap ], [ %dec72, %do.body68 ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %16 = load i8, ptr %i.3, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %17 = load i8, ptr %jj.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr69 = getelementptr inbounds i8, ptr %i.3, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %17, ptr %i.3, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr70 = getelementptr inbounds i8, ptr %jj.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %16, ptr %jj.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec72 = add nsw i32 %ii.1, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool73.not = icmp eq i32 %dec72, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool73.not, label %for.cond.loopexit, label %do.body68 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 320, CostB * EstimatedWidthA: 320
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<swap>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %15)<nsw> to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%i.2.lcssa>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%jj.0>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%18> = load vp<%8>
    vp<%9> = vector-pointer vp<%7>
    WIDEN ir<%19> = load vp<%9>
    vp<%10> = vector-pointer vp<%5>
    WIDEN store vp<%10>, ir<%19>
    vp<%11> = vector-pointer vp<%7>
    WIDEN store vp<%11>, ir<%18>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<for.cond.loopexit>, scalar.ph

ir-bb<for.cond.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 2 -> VectorType: <32 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <vscale x 1 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %6 = load i8, ptr %i.0, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %7 = load i8, ptr %j.1, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %7, ptr %i.0, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %6, ptr %j.1, align 1 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(2)
========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    EMIT ir<%i.0> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 1
    EMIT ir<%j.1> = WIDEN-POINTER-INDUCTION ir<%j.0>, 1
    WIDEN-INDUCTION %ii.0 = phi %dec, %.pre170, ir<-1>
    CLONE ir<%6> = load ir<%i.0>
    CLONE ir<%7> = load ir<%j.1>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.0>, ir<1>
    CLONE store ir<%7>, ir<%i.0>
    CLONE ir<%incdec.ptr25> = getelementptr inbounds ir<%j.1>, ir<1>
    CLONE store ir<%6>, ir<%j.1>
    CLONE ir<%dec> = add nsw ir<%ii.0>, ir<-1>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 2 to 64==========
VPlan 'Initial VPlan for VF={2,4,8,16,32},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.0> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 1
    EMIT ir<%j.1> = WIDEN-POINTER-INDUCTION ir<%j.0>, 1
    WIDEN-INDUCTION %ii.0 = phi %dec, %.pre170, ir<-1>
    vp<%4> = vector-pointer ir<%i.0>
    WIDEN ir<%6> = load vp<%4>
    vp<%5> = vector-pointer ir<%j.1>
    WIDEN ir<%7> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.0>, ir<1>
    vp<%6> = vector-pointer ir<%i.0>
    WIDEN store vp<%6>, ir<%7>
    CLONE ir<%incdec.ptr25> = getelementptr inbounds ir<%j.1>, ir<1>
    vp<%7> = vector-pointer ir<%j.1>
    WIDEN store vp<%7>, ir<%6>
    CLONE ir<%dec> = add nsw ir<%ii.0>, ir<-1>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: qst' from ucbqsort.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    EMIT ir<%i.0> = WIDEN-POINTER-INDUCTION ir<%add.ptr>, 1
    EMIT ir<%j.1> = WIDEN-POINTER-INDUCTION ir<%j.0>, 1
    WIDEN-INDUCTION %ii.0 = phi %dec, %.pre170, ir<-1>
    vp<%4> = vector-pointer ir<%i.0>
    WIDEN ir<%6> = load vp<%4>
    vp<%5> = vector-pointer ir<%j.1>
    WIDEN ir<%7> = load vp<%5>
    CLONE ir<%incdec.ptr> = getelementptr inbounds ir<%i.0>, ir<1>
    vp<%6> = vector-pointer ir<%i.0>
    WIDEN store vp<%6>, ir<%7>
    CLONE ir<%incdec.ptr25> = getelementptr inbounds ir<%j.1>, ir<1>
    vp<%7> = vector-pointer ir<%j.1>
    WIDEN store vp<%7>, ir<%6>
    CLONE ir<%dec> = add nsw ir<%ii.0>, ir<-1>
    CLONE ir<%tobool.not> = icmp eq ir<%dec>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 6
B VF: 2, EstimatedWidthB: 2, CostB: 6
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 24
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF 8 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 6
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF 16 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 96
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 6
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 48, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF 32 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 32 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF 32 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 32 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF 32 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF 32 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 32 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width 32 costs: 0
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 192
Candidate VF: 32 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 32, EstimatedWidthA: 32, CostA: 10
B VF: 16, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 160, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: 32 and ChosenFactor VF: 16

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 1 costs: 3
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 12
Candidate VF: vscale x 1 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 24
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 48
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 96
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 192, CostB * EstimatedWidthA: 160

-----------------Function that is being costed:'qst' from ucbqsort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %i.0 = phi ptr [ %incdec.ptr, %do.body24 ], [ %add.ptr, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %j.1 = phi ptr [ %incdec.ptr25, %do.body24 ], [ %j.0, %do.body24.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %ii.0 = phi i32 [ %dec, %do.body24 ], [ %.pre170, %do.body24.preheader ] of type:phi
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %6 = load i8, ptr %i.0, align 1 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %7 = load i8, ptr %j.1, align 1 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr = getelementptr inbounds i8, ptr %i.0, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %7, ptr %i.0, align 1 of type:store
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %incdec.ptr25 = getelementptr inbounds i8, ptr %j.1, i64 1 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %6, ptr %j.1, align 1 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %dec = add nsw i32 %ii.0, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %tobool.not = icmp eq i32 %dec, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %tobool.not, label %if.end27.loopexit, label %do.body24 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 6
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 192
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 10
B VF: 32, EstimatedWidthB: 32, CostB: 10
CostA * EstimatedWidthB: 320, CostB * EstimatedWidthA: 320
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: 32
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 1
maxafter: 1
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 16, UF=1 at function: qst at line: ucbqsort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.body24.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %.pre170) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%5> = ptradd ir<%add.ptr>, vp<%4>
    vp<%6> = SCALAR-STEPS vp<%3>, ir<1>
    EMIT vp<%7> = ptradd ir<%j.0>, vp<%6>
    vp<%8> = vector-pointer vp<%5>
    WIDEN ir<%9> = load vp<%8>
    vp<%9> = vector-pointer vp<%7>
    WIDEN ir<%10> = load vp<%9>
    vp<%10> = vector-pointer vp<%5>
    WIDEN store vp<%10>, ir<%10>
    vp<%11> = vector-pointer vp<%7>
    WIDEN store vp<%11>, ir<%9>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<if.end27.loopexit>, scalar.ph

ir-bb<if.end27.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 8
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/riscv-custom/bin/clang -std=gnu89 --gcc-toolchain=/opt/riscv --sysroot=/opt/riscv/sysroot -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration    -mcpu=generic-rv64 -march=rv64gcv_zbb -O3  -mrvv-vector-bits=128  -fno-strict-aliasing  -fno-inline-functions  -DSPEC_CPU_LP64        alloca.o asprintf.o vasprintf.o c-parse.o c-lang.o attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o c-convert.o c-aux-info.o c-common.o c-format.o c-semantics.o c-objc-common.o main.o cpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpphash.o cpperror.o cppinit.o cppdefault.o line-map.o mkdeps.o prefix.o version.o mbchar.o alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o cfgrtl.o combine.o conflict.o convert.o cse.o cselib.o dbxout.o debug.o dependence.o df.o diagnostic.o doloop.o dominance.o dwarf2asm.o dwarf2out.o dwarfout.o emit-rtl.o except.o explow.o expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o genrtl.o ggc-common.o global.o graph.o haifa-sched.o hash.o hashtable.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o integrate.o intl.o jump.o langhooks.o lcm.o lists.o local-alloc.o loop.o obstack.o optabs.o params.o predict.o print-rtl.o print-tree.o profile.o real.o recog.o reg-stack.o regclass.o regmove.o regrename.o reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o stor-layout.o stringpool.o timevar.o toplev.o tree.o tree-dump.o tree-inline.o unroll.o varasm.o varray.o vmsdbgout.o xcoffout.o ggc-page.o i386.o xmalloc.o xexit.o hashtab.o safe-ctype.o splay-tree.o xstrdup.o md5.o fibheap.o xstrerror.o concat.o partition.o hex.o lbasename.o getpwd.o ucbqsort.o             -lm        -o gcc
