/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o spec.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                spec.c
@@ Instruction =>  store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: main' from spec.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-1 + (1027 smax (1048576 * %input_size.0136)))<nsw> to i64) /u 1027))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv144 = phi 0, %indvars.iv.next145, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1027>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    CLONE ir<%10> = load ir<%arrayidx36>
    CLONE ir<%arrayidx38> = getelementptr inbounds ir<%call25>, ir<%indvars.iv144>
    CLONE store ir<%10>, ir<%arrayidx38>
    CLONE ir<%indvars.iv.next145> = add nuw nsw ir<%indvars.iv144>, ir<1>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1027>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next145>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: main' from spec.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-1 + (1027 smax (1048576 * %input_size.0136)))<nsw> to i64) /u 1027))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv144 = phi 0, %indvars.iv.next145, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1027>
    REPLICATE ir<%arrayidx36> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    REPLICATE ir<%10> = load ir<%arrayidx36>
    CLONE ir<%arrayidx38> = getelementptr inbounds ir<%call25>, ir<%indvars.iv144>
    vp<%4> = vector-pointer ir<%arrayidx38>
    WIDEN store vp<%4>, ir<%10>
    CLONE ir<%indvars.iv.next145> = add nuw nsw ir<%indvars.iv144>, ir<1>
    REPLICATE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1027>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next145>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: main' from spec.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-1 + (1027 smax (1048576 * %input_size.0136)))<nsw> to i64) /u 1027))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv144 = phi 0, %indvars.iv.next145, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1027>
    WIDEN-GEP Inv[Var] ir<%arrayidx36> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    REPLICATE ir<%10> = load ir<%arrayidx36>
    CLONE ir<%arrayidx38> = getelementptr inbounds ir<%call25>, ir<%indvars.iv144>
    vp<%4> = vector-pointer ir<%arrayidx38>
    WIDEN store vp<%4>, ir<%10>
    CLONE ir<%indvars.iv.next145> = add nuw nsw ir<%indvars.iv144>, ir<1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1027>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next145>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: main' from spec.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-1 + (1027 smax (1048576 * %input_size.0136)))<nsw> to i64) /u 1027))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv144 = phi 0, %indvars.iv.next145, ir<1>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1027>
    WIDEN-GEP Inv[Var] ir<%arrayidx36> = getelementptr inbounds ir<%6>, ir<%indvars.iv>
    WIDEN ir<%10> = load ir<%arrayidx36>
    CLONE ir<%arrayidx38> = getelementptr inbounds ir<%call25>, ir<%indvars.iv144>
    vp<%4> = vector-pointer ir<%arrayidx38>
    WIDEN store vp<%4>, ir<%10>
    CLONE ir<%indvars.iv.next145> = add nuw nsw ir<%indvars.iv144>, ir<1>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1027>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next145>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 18
A is not scalable.	B is not scalable.	
RTCostA: 38683981, RTCostB: 14637182
A is not scalable.	B is not scalable.	
RTCostA: 38683981, RTCostB: 14637182

-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 16
A is not scalable.	B is not scalable.	
RTCostA: 33979154, RTCostB: 14637182
A is not scalable.	B is not scalable.	
RTCostA: 33979154, RTCostB: 14637182

-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 15
A is not scalable.	B is not scalable.	
RTCostA: 32410886, RTCostB: 14637182
A is not scalable.	B is not scalable.	
RTCostA: 32410886, RTCostB: 14637182

-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 15
A is not scalable.	B is not scalable.	
RTCostA: 31888130, RTCostB: 14637182
A is not scalable.	B is not scalable.	
RTCostA: 31888130, RTCostB: 14637182

-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 14637182
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 14637182

-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 23524034, RTCostB: 14637182
A is scalable.	B is not scalable.	
RTCostA: 23524034, RTCostB: 14637182

-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 22478522, RTCostB: 14637182
A is scalable.	B is not scalable.	
RTCostA: 22478522, RTCostB: 14637182

-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 21955766, RTCostB: 14637182
A is scalable.	B is not scalable.	
RTCostA: 21955766, RTCostB: 14637182

-----------------Function that is being costed:'main' from spec.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv144 = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next145, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx36 = getelementptr inbounds i8, ptr %6, i64 %indvars.iv of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   %10 = load i8, ptr %arrayidx36, align 1, !tbaa !18 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx38 = getelementptr inbounds i8, ptr %call25, i64 %indvars.iv144 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %10, ptr %arrayidx38, align 1, !tbaa !18 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next145 = add nuw nsw i64 %indvars.iv144, 1 of type:add
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1027 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next145, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 21694334, RTCostB: 14637182
A is scalable.	B is not scalable.	
RTCostA: 21694334, RTCostB: 14637182
LV: Selecting VF: 1 With Cost: 7.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: main at line: spec.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-1 + (1027 smax (1048576 * %input_size.0136)))<nsw> to i64) /u 1027))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    vp<%5>    = DERIVED-IV ir<0> + vp<%3> * ir<1027>
    vp<%6> = SCALAR-STEPS vp<%5>, ir<1027>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%6>, vp<%6>
    CLONE ir<%10> = load ir<%arrayidx36>
    CLONE ir<%arrayidx38> = getelementptr inbounds ir<%call25>, vp<%4>
    CLONE store ir<%10>, ir<%arrayidx38>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 0
Loops Analyzed: 11
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o blocksort.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                blocksort.c
@@ Instruction =>  store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv856 = phi 0, %indvars.iv.next857, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv856 = phi 0, %indvars.iv.next857\l" +
    "  ir<%114>, ir<1>
    CLONE ir<%arrayidx219> = getelementptr inbounds ir<%runningOrder>, ir<0>, ir<%indvars.iv856>
    CLONE store ir<%114>, ir<%arrayidx219>
    CLONE ir<%indvars.iv.next857> = add nuw nsw ir<%indvars.iv856>, ir<1>
    CLONE ir<%exitcond859.not> = icmp eq ir<%indvars.iv.next857>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body230.preheader>, scalar.ph

ir-bb<for.body230.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv856 = phi 0, %indvars.iv.next857, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv856 = phi 0, %indvars.iv.next857\l" +
    "  ir<%114>, ir<1>
    CLONE ir<%arrayidx219> = getelementptr inbounds ir<%runningOrder>, ir<0>, ir<%indvars.iv856>
    vp<%3> = vector-pointer ir<%arrayidx219>
    WIDEN store vp<%3>, ir<%114>
    WIDEN ir<%indvars.iv.next857> = add nuw nsw ir<%indvars.iv856>, ir<1>
    CLONE ir<%exitcond859.not> = icmp eq ir<%indvars.iv.next857>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body230.preheader>, scalar.ph

ir-bb<for.body230.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv856 = phi 0, %indvars.iv.next857, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv856 = phi 0, %indvars.iv.next857\l" +
    "  ir<%114>, ir<1>
    CLONE ir<%arrayidx219> = getelementptr inbounds ir<%runningOrder>, ir<0>, ir<%indvars.iv856>
    vp<%3> = vector-pointer ir<%arrayidx219>
    WIDEN store vp<%3>, ir<%114>
    WIDEN ir<%indvars.iv.next857> = add nuw nsw ir<%indvars.iv856>, ir<1>
    CLONE ir<%exitcond859.not> = icmp eq ir<%indvars.iv.next857>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.body230.preheader>, scalar.ph

ir-bb<for.body230.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv856 = phi i64 [ 0, %for.cond212.preheader ], [ %indvars.iv.next857, %for.body215 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx219 = getelementptr inbounds [256 x i32], ptr %runningOrder, i64 0, i64 %indvars.iv856 of type:getelementptr
LV: Found an estimated cost of 0 for VF 1 For instruction:   %114 = trunc nuw nsw i64 %indvars.iv856 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next857 = add nuw nsw i64 %indvars.iv856, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond859.not = icmp eq i64 %indvars.iv.next857, 256 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond859.not, label %for.body230.preheader, label %for.body215 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv856 = phi i64 [ 0, %for.cond212.preheader ], [ %indvars.iv.next857, %for.body215 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx219 = getelementptr inbounds [256 x i32], ptr %runningOrder, i64 0, i64 %indvars.iv856 of type:getelementptr
LV: Found an estimated cost of 0 for VF 2 For instruction:   %114 = trunc nuw nsw i64 %indvars.iv856 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next857 = add nuw nsw i64 %indvars.iv856, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond859.not = icmp eq i64 %indvars.iv.next857, 256 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond859.not, label %for.body230.preheader, label %for.body215 of type:br
LV: Vector loop of width 2 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 384, RTCostB: 1024
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 384, RTCostB: 1024
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv856 = phi i64 [ 0, %for.cond212.preheader ], [ %indvars.iv.next857, %for.body215 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx219 = getelementptr inbounds [256 x i32], ptr %runningOrder, i64 0, i64 %indvars.iv856 of type:getelementptr
LV: Found an estimated cost of 0 for VF 4 For instruction:   %114 = trunc nuw nsw i64 %indvars.iv856 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next857 = add nuw nsw i64 %indvars.iv856, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond859.not = icmp eq i64 %indvars.iv.next857, 256 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond859.not, label %for.body230.preheader, label %for.body215 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 256, RTCostB: 1024
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 256, RTCostB: 384
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv856 = phi i64 [ 0, %for.cond212.preheader ], [ %indvars.iv.next857, %for.body215 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx219 = getelementptr inbounds [256 x i32], ptr %runningOrder, i64 0, i64 %indvars.iv856 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %114 = trunc nuw nsw i64 %indvars.iv856 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next857 = add nuw nsw i64 %indvars.iv856, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond859.not = icmp eq i64 %indvars.iv.next857, 256 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond859.not, label %for.body230.preheader, label %for.body215 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1024
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 256

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv856 = phi i64 [ 0, %for.cond212.preheader ], [ %indvars.iv.next857, %for.body215 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx219 = getelementptr inbounds [256 x i32], ptr %runningOrder, i64 0, i64 %indvars.iv856 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %114 = trunc nuw nsw i64 %indvars.iv856 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next857 = add nuw nsw i64 %indvars.iv856, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond859.not = icmp eq i64 %indvars.iv.next857, 256 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond859.not, label %for.body230.preheader, label %for.body215 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 192, RTCostB: 1024
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 192, RTCostB: 256
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv856 = phi i64 [ 0, %for.cond212.preheader ], [ %indvars.iv.next857, %for.body215 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx219 = getelementptr inbounds [256 x i32], ptr %runningOrder, i64 0, i64 %indvars.iv856 of type:getelementptr
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %114 = trunc nuw nsw i64 %indvars.iv856 to i32 of type:trunc
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %114, ptr %arrayidx219, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next857 = add nuw nsw i64 %indvars.iv856, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond859.not = icmp eq i64 %indvars.iv.next857, 256 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond859.not, label %for.body230.preheader, label %for.body215 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 128, RTCostB: 1024
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 128, RTCostB: 192
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: mainSort at line: blocksort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv856 = phi 0, %indvars.iv.next857\l" +
    "  ir<%114>, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx219> = getelementptr inbounds ir<%runningOrder>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx219>
    WIDEN store vp<%4>, ir<%114>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body230.preheader>, scalar.ph

ir-bb<for.body230.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv878 = phi 0, %indvars.iv.next879, ir<1>
    CLONE ir<%.idx898> = shl ir<%indvars.iv878>, ir<10>
    CLONE ir<%gep914> = getelementptr ir<%invariant.gep913>, ir<%.idx898>
    CLONE ir<%206> = load ir<%gep914>
    CLONE ir<%or452> = or ir<%206>, ir<2097152>
    CLONE store ir<%or452>, ir<%gep914>
    CLONE ir<%indvars.iv.next879> = add nuw nsw ir<%indvars.iv878>, ir<1>
    CLONE ir<%exitcond883.not> = icmp eq ir<%indvars.iv.next879>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end455>, scalar.ph

ir-bb<for.end455>:
No successors

scalar.ph:
No successors
}

========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv878 = phi 0, %indvars.iv.next879, ir<1>
    WIDEN ir<%.idx898> = shl ir<%indvars.iv878>, ir<10>
    REPLICATE ir<%gep914> = getelementptr ir<%invariant.gep913>, ir<%.idx898>
    REPLICATE ir<%206> = load ir<%gep914>
    WIDEN ir<%or452> = or ir<%206>, ir<2097152>
    REPLICATE store ir<%or452>, ir<%gep914>
    WIDEN ir<%indvars.iv.next879> = add nuw nsw ir<%indvars.iv878>, ir<1>
    CLONE ir<%exitcond883.not> = icmp eq ir<%indvars.iv.next879>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end455>, scalar.ph

ir-bb<for.end455>:
No successors

scalar.ph:
No successors
}

========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv878 = phi 0, %indvars.iv.next879, ir<1>
    WIDEN ir<%.idx898> = shl ir<%indvars.iv878>, ir<10>
    WIDEN-GEP Inv[Var] ir<%gep914> = getelementptr ir<%invariant.gep913>, ir<%.idx898>
    REPLICATE ir<%206> = load ir<%gep914>
    WIDEN ir<%or452> = or ir<%206>, ir<2097152>
    REPLICATE store ir<%or452>, ir<%gep914>
    WIDEN ir<%indvars.iv.next879> = add nuw nsw ir<%indvars.iv878>, ir<1>
    CLONE ir<%exitcond883.not> = icmp eq ir<%indvars.iv.next879>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end455>, scalar.ph

ir-bb<for.end455>:
No successors

scalar.ph:
No successors
}

========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv878 = phi 0, %indvars.iv.next879, ir<1>
    WIDEN ir<%.idx898> = shl ir<%indvars.iv878>, ir<10>
    WIDEN-GEP Inv[Var] ir<%gep914> = getelementptr ir<%invariant.gep913>, ir<%.idx898>
    WIDEN ir<%206> = load ir<%gep914>
    WIDEN ir<%or452> = or ir<%206>, ir<2097152>
    WIDEN store ir<%gep914>, ir<%or452>
    WIDEN ir<%indvars.iv.next879> = add nuw nsw ir<%indvars.iv878>, ir<1>
    CLONE ir<%exitcond883.not> = icmp eq ir<%indvars.iv.next879>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end455>, scalar.ph

ir-bb<for.end455>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv878 = phi i64 [ 0, %if.end443 ], [ %indvars.iv.next879, %for.body447 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %.idx898 = shl i64 %indvars.iv878, 10 of type:shl
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep914 = getelementptr i8, ptr %invariant.gep913, i64 %.idx898 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %206 = load i32, ptr %gep914, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or452 = or i32 %206, 2097152 of type:or
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %or452, ptr %gep914, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next879 = add nuw nsw i64 %indvars.iv878, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next879, 256 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond883.not, label %for.end455, label %for.body447 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv878 = phi i64 [ 0, %if.end443 ], [ %indvars.iv.next879, %for.body447 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %.idx898 = shl i64 %indvars.iv878, 10 of type:shl
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep914 = getelementptr i8, ptr %invariant.gep913, i64 %.idx898 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %206 = load i32, ptr %gep914, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or452 = or i32 %206, 2097152 of type:or
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i32 %or452, ptr %gep914, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next879 = add nuw nsw i64 %indvars.iv878, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next879, 256 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond883.not, label %for.end455, label %for.body447 of type:br
LV: Vector loop of width 2 costs: 32
A is not scalable.	B is not scalable.	
RTCostA: 8192, RTCostB: 2048
A is not scalable.	B is not scalable.	
RTCostA: 8192, RTCostB: 2048

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv878 = phi i64 [ 0, %if.end443 ], [ %indvars.iv.next879, %for.body447 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %.idx898 = shl i64 %indvars.iv878, 10 of type:shl
LV: Found an estimated cost of 0 for VF 4 For instruction:   %gep914 = getelementptr i8, ptr %invariant.gep913, i64 %.idx898 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %206 = load i32, ptr %gep914, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or452 = or i32 %206, 2097152 of type:or
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i32 %or452, ptr %gep914, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next879 = add nuw nsw i64 %indvars.iv878, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next879, 256 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond883.not, label %for.end455, label %for.body447 of type:br
LV: Vector loop of width 4 costs: 31
A is not scalable.	B is not scalable.	
RTCostA: 8064, RTCostB: 2048
A is not scalable.	B is not scalable.	
RTCostA: 8064, RTCostB: 2048

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv878 = phi i64 [ 0, %if.end443 ], [ %indvars.iv.next879, %for.body447 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %.idx898 = shl i64 %indvars.iv878, 10 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %gep914 = getelementptr i8, ptr %invariant.gep913, i64 %.idx898 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %206 = load i32, ptr %gep914, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or452 = or i32 %206, 2097152 of type:or
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %or452, ptr %gep914, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next879 = add nuw nsw i64 %indvars.iv878, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next879, 256 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond883.not, label %for.end455, label %for.body447 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2048
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2048

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv878 = phi i64 [ 0, %if.end443 ], [ %indvars.iv.next879, %for.body447 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %.idx898 = shl i64 %indvars.iv878, 10 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %gep914 = getelementptr i8, ptr %invariant.gep913, i64 %.idx898 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %206 = load i32, ptr %gep914, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or452 = or i32 %206, 2097152 of type:or
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %or452, ptr %gep914, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next879 = add nuw nsw i64 %indvars.iv878, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next879, 256 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond883.not, label %for.end455, label %for.body447 of type:br
LV: Vector loop of width vscale x 2 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 5504, RTCostB: 2048
A is scalable.	B is not scalable.	
RTCostA: 5504, RTCostB: 2048

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv878 = phi i64 [ 0, %if.end443 ], [ %indvars.iv.next879, %for.body447 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %.idx898 = shl i64 %indvars.iv878, 10 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %gep914 = getelementptr i8, ptr %invariant.gep913, i64 %.idx898 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %206 = load i32, ptr %gep914, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or452 = or i32 %206, 2097152 of type:or
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i32 %or452, ptr %gep914, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next879 = add nuw nsw i64 %indvars.iv878, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond883.not = icmp eq i64 %indvars.iv.next879, 256 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond883.not, label %for.end455, label %for.body447 of type:br
LV: Vector loop of width vscale x 4 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 5376, RTCostB: 2048
A is scalable.	B is not scalable.	
RTCostA: 5376, RTCostB: 2048
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: mainSort at line: blocksort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%.idx898> = shl vp<%3>, ir<10>
    CLONE ir<%gep914> = getelementptr ir<%invariant.gep913>, ir<%.idx898>
    CLONE ir<%206> = load ir<%gep914>
    CLONE ir<%or452> = or ir<%206>, ir<2097152>
    CLONE store ir<%or452>, ir<%gep914>
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end455>, scalar.ph

ir-bb<for.end455>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv869 = phi 0, %indvars.iv.next870, ir<1>
    CLONE ir<%.idx> = shl ir<%indvars.iv869>, ir<10>
    CLONE ir<%gep912> = getelementptr ir<%invariant.gep911>, ir<%.idx>
    CLONE ir<%186> = load ir<%gep912>
    CLONE ir<%and343> = and ir<%186>, ir<-2097153>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<%copyStart>, ir<0>, ir<%indvars.iv869>
    CLONE store ir<%and343>, ir<%arrayidx345>
    CLONE ir<%arrayidx350> = getelementptr ir<%gep912>, ir<4>
    CLONE ir<%187> = load ir<%arrayidx350>
    CLONE ir<%and351> = and ir<%187>, ir<-2097153>
    CLONE ir<%sub352> = add ir<%and351>, ir<-1>
    CLONE ir<%arrayidx354> = getelementptr inbounds ir<%copyEnd>, ir<0>, ir<%indvars.iv869>
    CLONE store ir<%sub352>, ir<%arrayidx354>
    CLONE ir<%indvars.iv.next870> = add nuw nsw ir<%indvars.iv869>, ir<1>
    CLONE ir<%exitcond874.not> = icmp eq ir<%indvars.iv.next870>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end357>, scalar.ph

ir-bb<for.end357>:
No successors

scalar.ph:
No successors
}

========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv869 = phi 0, %indvars.iv.next870, ir<1>
    WIDEN ir<%.idx> = shl ir<%indvars.iv869>, ir<10>
    REPLICATE ir<%gep912> = getelementptr ir<%invariant.gep911>, ir<%.idx>
    REPLICATE ir<%186> = load ir<%gep912>
    WIDEN ir<%and343> = and ir<%186>, ir<-2097153>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<%copyStart>, ir<0>, ir<%indvars.iv869>
    vp<%3> = vector-pointer ir<%arrayidx345>
    WIDEN store vp<%3>, ir<%and343>
    REPLICATE ir<%arrayidx350> = getelementptr ir<%gep912>, ir<4>
    REPLICATE ir<%187> = load ir<%arrayidx350>
    WIDEN ir<%and351> = and ir<%187>, ir<-2097153>
    WIDEN ir<%sub352> = add ir<%and351>, ir<-1>
    CLONE ir<%arrayidx354> = getelementptr inbounds ir<%copyEnd>, ir<0>, ir<%indvars.iv869>
    vp<%4> = vector-pointer ir<%arrayidx354>
    WIDEN store vp<%4>, ir<%sub352>
    WIDEN ir<%indvars.iv.next870> = add nuw nsw ir<%indvars.iv869>, ir<1>
    CLONE ir<%exitcond874.not> = icmp eq ir<%indvars.iv.next870>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end357>, scalar.ph

ir-bb<for.end357>:
No successors

scalar.ph:
No successors
}

========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv869 = phi 0, %indvars.iv.next870, ir<1>
    WIDEN ir<%.idx> = shl ir<%indvars.iv869>, ir<10>
    WIDEN-GEP Inv[Var] ir<%gep912> = getelementptr ir<%invariant.gep911>, ir<%.idx>
    REPLICATE ir<%186> = load ir<%gep912>
    WIDEN ir<%and343> = and ir<%186>, ir<-2097153>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<%copyStart>, ir<0>, ir<%indvars.iv869>
    vp<%3> = vector-pointer ir<%arrayidx345>
    WIDEN store vp<%3>, ir<%and343>
    WIDEN-GEP Var[Inv] ir<%arrayidx350> = getelementptr ir<%gep912>, ir<4>
    REPLICATE ir<%187> = load ir<%arrayidx350>
    WIDEN ir<%and351> = and ir<%187>, ir<-2097153>
    WIDEN ir<%sub352> = add ir<%and351>, ir<-1>
    CLONE ir<%arrayidx354> = getelementptr inbounds ir<%copyEnd>, ir<0>, ir<%indvars.iv869>
    vp<%4> = vector-pointer ir<%arrayidx354>
    WIDEN store vp<%4>, ir<%sub352>
    WIDEN ir<%indvars.iv.next870> = add nuw nsw ir<%indvars.iv869>, ir<1>
    CLONE ir<%exitcond874.not> = icmp eq ir<%indvars.iv.next870>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end357>, scalar.ph

ir-bb<for.end357>:
No successors

scalar.ph:
No successors
}

========== Loop: mainSort' from blocksort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv869 = phi 0, %indvars.iv.next870, ir<1>
    WIDEN ir<%.idx> = shl ir<%indvars.iv869>, ir<10>
    WIDEN-GEP Inv[Var] ir<%gep912> = getelementptr ir<%invariant.gep911>, ir<%.idx>
    WIDEN ir<%186> = load ir<%gep912>
    WIDEN ir<%and343> = and ir<%186>, ir<-2097153>
    CLONE ir<%arrayidx345> = getelementptr inbounds ir<%copyStart>, ir<0>, ir<%indvars.iv869>
    vp<%3> = vector-pointer ir<%arrayidx345>
    WIDEN store vp<%3>, ir<%and343>
    WIDEN-GEP Var[Inv] ir<%arrayidx350> = getelementptr ir<%gep912>, ir<4>
    WIDEN ir<%187> = load ir<%arrayidx350>
    WIDEN ir<%and351> = and ir<%187>, ir<-2097153>
    WIDEN ir<%sub352> = add ir<%and351>, ir<-1>
    CLONE ir<%arrayidx354> = getelementptr inbounds ir<%copyEnd>, ir<0>, ir<%indvars.iv869>
    vp<%4> = vector-pointer ir<%arrayidx354>
    WIDEN store vp<%4>, ir<%sub352>
    WIDEN ir<%indvars.iv.next870> = add nuw nsw ir<%indvars.iv869>, ir<1>
    CLONE ir<%exitcond874.not> = icmp eq ir<%indvars.iv.next870>, ir<256>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end357>, scalar.ph

ir-bb<for.end357>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv869 = phi i64 [ 0, %if.end334 ], [ %indvars.iv.next870, %for.body338 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %.idx = shl i64 %indvars.iv869, 10 of type:shl
LV: Found an estimated cost of 0 for VF 1 For instruction:   %gep912 = getelementptr i8, ptr %invariant.gep911, i64 %.idx of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %186 = load i32, ptr %gep912, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and343 = and i32 %186, -2097153 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx345 = getelementptr inbounds [256 x i32], ptr %copyStart, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx350 = getelementptr i8, ptr %gep912, i64 4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %187 = load i32, ptr %arrayidx350, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %and351 = and i32 %187, -2097153 of type:and
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub352 = add i32 %and351, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx354 = getelementptr inbounds [256 x i32], ptr %copyEnd, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next870 = add nuw nsw i64 %indvars.iv869, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond874.not = icmp eq i64 %indvars.iv.next870, 256 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond874.not, label %for.end357, label %for.body338 of type:br
LV: Scalar loop costs: 14.
-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv869 = phi i64 [ 0, %if.end334 ], [ %indvars.iv.next870, %for.body338 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %.idx = shl i64 %indvars.iv869, 10 of type:shl
LV: Found an estimated cost of 0 for VF 2 For instruction:   %gep912 = getelementptr i8, ptr %invariant.gep911, i64 %.idx of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %186 = load i32, ptr %gep912, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and343 = and i32 %186, -2097153 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx345 = getelementptr inbounds [256 x i32], ptr %copyStart, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx350 = getelementptr i8, ptr %gep912, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %187 = load i32, ptr %arrayidx350, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %and351 = and i32 %187, -2097153 of type:and
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub352 = add i32 %and351, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx354 = getelementptr inbounds [256 x i32], ptr %copyEnd, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next870 = add nuw nsw i64 %indvars.iv869, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond874.not = icmp eq i64 %indvars.iv.next870, 256 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond874.not, label %for.end357, label %for.body338 of type:br
LV: Vector loop of width 2 costs: 34
A is not scalable.	B is not scalable.	
RTCostA: 8704, RTCostB: 3584
A is not scalable.	B is not scalable.	
RTCostA: 8704, RTCostB: 3584

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv869 = phi i64 [ 0, %if.end334 ], [ %indvars.iv.next870, %for.body338 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %.idx = shl i64 %indvars.iv869, 10 of type:shl
LV: Found an estimated cost of 0 for VF 4 For instruction:   %gep912 = getelementptr i8, ptr %invariant.gep911, i64 %.idx of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %186 = load i32, ptr %gep912, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and343 = and i32 %186, -2097153 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx345 = getelementptr inbounds [256 x i32], ptr %copyStart, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx350 = getelementptr i8, ptr %gep912, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %187 = load i32, ptr %arrayidx350, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %and351 = and i32 %187, -2097153 of type:and
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub352 = add i32 %and351, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx354 = getelementptr inbounds [256 x i32], ptr %copyEnd, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next870 = add nuw nsw i64 %indvars.iv869, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond874.not = icmp eq i64 %indvars.iv.next870, 256 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond874.not, label %for.end357, label %for.body338 of type:br
LV: Vector loop of width 4 costs: 32
A is not scalable.	B is not scalable.	
RTCostA: 8320, RTCostB: 3584
A is not scalable.	B is not scalable.	
RTCostA: 8320, RTCostB: 3584

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv869 = phi i64 [ 0, %if.end334 ], [ %indvars.iv.next870, %for.body338 ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %.idx = shl i64 %indvars.iv869, 10 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %gep912 = getelementptr i8, ptr %invariant.gep911, i64 %.idx of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %186 = load i32, ptr %gep912, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and343 = and i32 %186, -2097153 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx345 = getelementptr inbounds [256 x i32], ptr %copyStart, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx350 = getelementptr i8, ptr %gep912, i64 4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %187 = load i32, ptr %arrayidx350, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %and351 = and i32 %187, -2097153 of type:and
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub352 = add i32 %and351, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx354 = getelementptr inbounds [256 x i32], ptr %copyEnd, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next870 = add nuw nsw i64 %indvars.iv869, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond874.not = icmp eq i64 %indvars.iv.next870, 256 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond874.not, label %for.end357, label %for.body338 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3584
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3584

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv869 = phi i64 [ 0, %if.end334 ], [ %indvars.iv.next870, %for.body338 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %.idx = shl i64 %indvars.iv869, 10 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %gep912 = getelementptr i8, ptr %invariant.gep911, i64 %.idx of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %186 = load i32, ptr %gep912, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and343 = and i32 %186, -2097153 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx345 = getelementptr inbounds [256 x i32], ptr %copyStart, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx350 = getelementptr i8, ptr %gep912, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %187 = load i32, ptr %arrayidx350, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %and351 = and i32 %187, -2097153 of type:and
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub352 = add i32 %and351, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx354 = getelementptr inbounds [256 x i32], ptr %copyEnd, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next870 = add nuw nsw i64 %indvars.iv869, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond874.not = icmp eq i64 %indvars.iv.next870, 256 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond874.not, label %for.end357, label %for.body338 of type:br
LV: Vector loop of width vscale x 2 costs: 22
A is scalable.	B is not scalable.	
RTCostA: 5760, RTCostB: 3584
A is scalable.	B is not scalable.	
RTCostA: 5760, RTCostB: 3584

-----------------Function that is being costed:'mainSort' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv869 = phi i64 [ 0, %if.end334 ], [ %indvars.iv.next870, %for.body338 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %.idx = shl i64 %indvars.iv869, 10 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %gep912 = getelementptr i8, ptr %invariant.gep911, i64 %.idx of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %186 = load i32, ptr %gep912, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and343 = and i32 %186, -2097153 of type:and
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx345 = getelementptr inbounds [256 x i32], ptr %copyStart, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %and343, ptr %arrayidx345, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx350 = getelementptr i8, ptr %gep912, i64 4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %187 = load i32, ptr %arrayidx350, align 4, !tbaa !10 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %and351 = and i32 %187, -2097153 of type:and
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub352 = add i32 %and351, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx354 = getelementptr inbounds [256 x i32], ptr %copyEnd, i64 0, i64 %indvars.iv869 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %sub352, ptr %arrayidx354, align 4, !tbaa !10 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next870 = add nuw nsw i64 %indvars.iv869, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond874.not = icmp eq i64 %indvars.iv.next870, 256 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond874.not, label %for.end357, label %for.body338 of type:br
LV: Vector loop of width vscale x 4 costs: 21
A is scalable.	B is not scalable.	
RTCostA: 5504, RTCostB: 3584
A is scalable.	B is not scalable.	
RTCostA: 5504, RTCostB: 3584
LV: Selecting VF: 1 With Cost: 14.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 1
Loops Analyzed: 33
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: fallbackQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body146.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %gtHi.1.ph.lcssa343) + %2) smin ((-1 * %unHi.1.lcssa) + %gtHi.1.ph.lcssa343)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv449 = phi %36, %indvars.iv.next450, ir<1>
    WIDEN-INDUCTION %indvars.iv447 = phi %35, %indvars.iv.next448, ir<1>
    WIDEN-INDUCTION %yyn143.0389 = phi %sub130.sub131, %dec158, ir<-1>
    CLONE ir<%indvars.iv.next448> = add nsw ir<%indvars.iv447>, ir<1>
    CLONE ir<%arrayidx149> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv449>
    CLONE ir<%37> = load ir<%arrayidx149>
    CLONE ir<%arrayidx151> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv.next448>
    CLONE ir<%38> = load ir<%arrayidx151>
    CLONE store ir<%38>, ir<%arrayidx149>
    CLONE store ir<%37>, ir<%arrayidx151>
    CLONE ir<%indvars.iv.next450> = add nsw ir<%indvars.iv449>, ir<1>
    CLONE ir<%dec158> = add nsw ir<%yyn143.0389>, ir<-1>
    CLONE ir<%cmp145> = icmp ugt ir<%yyn143.0389>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end159.loopexit>, scalar.ph

ir-bb<while.end159.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: fallbackQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body146.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %gtHi.1.ph.lcssa343) + %2) smin ((-1 * %unHi.1.lcssa) + %gtHi.1.ph.lcssa343)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv449 = phi %36, %indvars.iv.next450, ir<1>
    WIDEN-INDUCTION %indvars.iv447 = phi %35, %indvars.iv.next448, ir<1>
    WIDEN-INDUCTION %yyn143.0389 = phi %sub130.sub131, %dec158, ir<-1>
    CLONE ir<%indvars.iv.next448> = add nsw ir<%indvars.iv447>, ir<1>
    CLONE ir<%arrayidx149> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv449>
    vp<%4> = vector-pointer ir<%arrayidx149>
    WIDEN ir<%37> = load vp<%4>
    CLONE ir<%arrayidx151> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv.next448>
    vp<%5> = vector-pointer ir<%arrayidx151>
    WIDEN ir<%38> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx149>
    WIDEN store vp<%6>, ir<%38>
    vp<%7> = vector-pointer ir<%arrayidx151>
    WIDEN store vp<%7>, ir<%37>
    CLONE ir<%indvars.iv.next450> = add nsw ir<%indvars.iv449>, ir<1>
    CLONE ir<%dec158> = add nsw ir<%yyn143.0389>, ir<-1>
    CLONE ir<%cmp145> = icmp ugt ir<%yyn143.0389>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end159.loopexit>, scalar.ph

ir-bb<while.end159.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: fallbackQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body146.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %gtHi.1.ph.lcssa343) + %2) smin ((-1 * %unHi.1.lcssa) + %gtHi.1.ph.lcssa343)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv449 = phi %36, %indvars.iv.next450, ir<1>
    WIDEN-INDUCTION %indvars.iv447 = phi %35, %indvars.iv.next448, ir<1>
    WIDEN-INDUCTION %yyn143.0389 = phi %sub130.sub131, %dec158, ir<-1>
    CLONE ir<%indvars.iv.next448> = add nsw ir<%indvars.iv447>, ir<1>
    CLONE ir<%arrayidx149> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv449>
    vp<%4> = vector-pointer ir<%arrayidx149>
    WIDEN ir<%37> = load vp<%4>
    CLONE ir<%arrayidx151> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv.next448>
    vp<%5> = vector-pointer ir<%arrayidx151>
    WIDEN ir<%38> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx149>
    WIDEN store vp<%6>, ir<%38>
    vp<%7> = vector-pointer ir<%arrayidx151>
    WIDEN store vp<%7>, ir<%37>
    CLONE ir<%indvars.iv.next450> = add nsw ir<%indvars.iv449>, ir<1>
    CLONE ir<%dec158> = add nsw ir<%yyn143.0389>, ir<-1>
    CLONE ir<%cmp145> = icmp ugt ir<%yyn143.0389>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end159.loopexit>, scalar.ph

ir-bb<while.end159.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv449 = phi i64 [ %36, %while.body146.preheader ], [ %indvars.iv.next450, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv447 = phi i64 [ %35, %while.body146.preheader ], [ %indvars.iv.next448, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %yyn143.0389 = phi i32 [ %sub130.sub131, %while.body146.preheader ], [ %dec158, %while.body146 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx149 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv449 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx151 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv.next448 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next450 = add nsw i64 %indvars.iv449, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec158 = add nsw i32 %yyn143.0389, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp145 = icmp ugt i32 %yyn143.0389, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp145, label %while.body146, label %while.end159.loopexit of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv449 = phi i64 [ %36, %while.body146.preheader ], [ %indvars.iv.next450, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv447 = phi i64 [ %35, %while.body146.preheader ], [ %indvars.iv.next448, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %yyn143.0389 = phi i32 [ %sub130.sub131, %while.body146.preheader ], [ %dec158, %while.body146 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx149 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv449 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx151 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv.next448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next450 = add nsw i64 %indvars.iv449, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec158 = add nsw i32 %yyn143.0389, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp145 = icmp ugt i32 %yyn143.0389, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp145, label %while.body146, label %while.end159.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 17179869188, RTCostB: 51539607540
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 17179869188, RTCostB: 51539607540
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv449 = phi i64 [ %36, %while.body146.preheader ], [ %indvars.iv.next450, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv447 = phi i64 [ %35, %while.body146.preheader ], [ %indvars.iv.next448, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %yyn143.0389 = phi i32 [ %sub130.sub131, %while.body146.preheader ], [ %dec158, %while.body146 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx149 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv449 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx151 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv.next448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next450 = add nsw i64 %indvars.iv449, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec158 = add nsw i32 %yyn143.0389, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp145 = icmp ugt i32 %yyn143.0389, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp145, label %while.body146, label %while.end159.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 51539607540
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 17179869188
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv449 = phi i64 [ %36, %while.body146.preheader ], [ %indvars.iv.next450, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv447 = phi i64 [ %35, %while.body146.preheader ], [ %indvars.iv.next448, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %yyn143.0389 = phi i32 [ %sub130.sub131, %while.body146.preheader ], [ %dec158, %while.body146 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx149 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv449 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx151 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv.next448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next450 = add nsw i64 %indvars.iv449, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec158 = add nsw i32 %yyn143.0389, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp145 = icmp ugt i32 %yyn143.0389, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp145, label %while.body146, label %while.end159.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 51539607540
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934620

-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv449 = phi i64 [ %36, %while.body146.preheader ], [ %indvars.iv.next450, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv447 = phi i64 [ %35, %while.body146.preheader ], [ %indvars.iv.next448, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %yyn143.0389 = phi i32 [ %sub130.sub131, %while.body146.preheader ], [ %dec158, %while.body146 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx149 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv449 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx151 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv.next448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next450 = add nsw i64 %indvars.iv449, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec158 = add nsw i32 %yyn143.0389, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp145 = icmp ugt i32 %yyn143.0389, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp145, label %while.body146, label %while.end159.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 51539607540
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 8589934620
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv449 = phi i64 [ %36, %while.body146.preheader ], [ %indvars.iv.next450, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv447 = phi i64 [ %35, %while.body146.preheader ], [ %indvars.iv.next448, %while.body146 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %yyn143.0389 = phi i32 [ %sub130.sub131, %while.body146.preheader ], [ %dec158, %while.body146 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next448 = add nsw i64 %indvars.iv447, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx149 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv449 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %37 = load i32, ptr %arrayidx149, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx151 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv.next448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %38 = load i32, ptr %arrayidx151, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %38, ptr %arrayidx149, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %37, ptr %arrayidx151, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next450 = add nsw i64 %indvars.iv449, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec158 = add nsw i32 %yyn143.0389, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp145 = icmp ugt i32 %yyn143.0389, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp145, label %while.body146, label %while.end159.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967372, RTCostB: 51539607540
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 4294967372, RTCostB: 8589934620
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: fallbackQSort3 at line: blocksort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body146.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %gtHi.1.ph.lcssa343) + %2) smin ((-1 * %unHi.1.lcssa) + %gtHi.1.ph.lcssa343)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%36> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%35> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%indvars.iv.next448> = add nsw vp<%7>, ir<1>
    CLONE ir<%arrayidx149> = getelementptr inbounds ir<%fmap>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx149>
    WIDEN ir<%43> = load vp<%8>
    CLONE ir<%arrayidx151> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv.next448>
    vp<%9> = vector-pointer ir<%arrayidx151>
    WIDEN ir<%44> = load vp<%9>
    vp<%10> = vector-pointer ir<%arrayidx149>
    WIDEN store vp<%10>, ir<%44>
    vp<%11> = vector-pointer ir<%arrayidx151>
    WIDEN store vp<%11>, ir<%43>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end159.loopexit>, scalar.ph

ir-bb<while.end159.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: fallbackQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body116.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %1) + %ltLo.1.ph.lcssa532) smin ((-1 * %ltLo.1.ph.lcssa532) + %unLo.1.lcssa529)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv442 = phi %32, %indvars.iv.next443, ir<1>
    WIDEN-INDUCTION %indvars.iv440 = phi %31, %indvars.iv.next441, ir<1>
    WIDEN-INDUCTION %yyn.0385 = phi %sub108.sub109, %dec128, ir<-1>
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv442>
    CLONE ir<%33> = load ir<%arrayidx119>
    CLONE ir<%arrayidx121> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv440>
    CLONE ir<%34> = load ir<%arrayidx121>
    CLONE store ir<%34>, ir<%arrayidx119>
    CLONE store ir<%33>, ir<%arrayidx121>
    CLONE ir<%indvars.iv.next443> = add nsw ir<%indvars.iv442>, ir<1>
    CLONE ir<%indvars.iv.next441> = add nsw ir<%indvars.iv440>, ir<1>
    CLONE ir<%dec128> = add nsw ir<%yyn.0385>, ir<-1>
    CLONE ir<%cmp115> = icmp ugt ir<%yyn.0385>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end129.loopexit>, scalar.ph

ir-bb<while.end129.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: fallbackQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body116.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %1) + %ltLo.1.ph.lcssa532) smin ((-1 * %ltLo.1.ph.lcssa532) + %unLo.1.lcssa529)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv442 = phi %32, %indvars.iv.next443, ir<1>
    WIDEN-INDUCTION %indvars.iv440 = phi %31, %indvars.iv.next441, ir<1>
    WIDEN-INDUCTION %yyn.0385 = phi %sub108.sub109, %dec128, ir<-1>
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv442>
    vp<%4> = vector-pointer ir<%arrayidx119>
    WIDEN ir<%33> = load vp<%4>
    CLONE ir<%arrayidx121> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv440>
    vp<%5> = vector-pointer ir<%arrayidx121>
    WIDEN ir<%34> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx119>
    WIDEN store vp<%6>, ir<%34>
    vp<%7> = vector-pointer ir<%arrayidx121>
    WIDEN store vp<%7>, ir<%33>
    CLONE ir<%indvars.iv.next443> = add nsw ir<%indvars.iv442>, ir<1>
    CLONE ir<%indvars.iv.next441> = add nsw ir<%indvars.iv440>, ir<1>
    CLONE ir<%dec128> = add nsw ir<%yyn.0385>, ir<-1>
    CLONE ir<%cmp115> = icmp ugt ir<%yyn.0385>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end129.loopexit>, scalar.ph

ir-bb<while.end129.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: fallbackQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body116.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %1) + %ltLo.1.ph.lcssa532) smin ((-1 * %ltLo.1.ph.lcssa532) + %unLo.1.lcssa529)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv442 = phi %32, %indvars.iv.next443, ir<1>
    WIDEN-INDUCTION %indvars.iv440 = phi %31, %indvars.iv.next441, ir<1>
    WIDEN-INDUCTION %yyn.0385 = phi %sub108.sub109, %dec128, ir<-1>
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv442>
    vp<%4> = vector-pointer ir<%arrayidx119>
    WIDEN ir<%33> = load vp<%4>
    CLONE ir<%arrayidx121> = getelementptr inbounds ir<%fmap>, ir<%indvars.iv440>
    vp<%5> = vector-pointer ir<%arrayidx121>
    WIDEN ir<%34> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx119>
    WIDEN store vp<%6>, ir<%34>
    vp<%7> = vector-pointer ir<%arrayidx121>
    WIDEN store vp<%7>, ir<%33>
    CLONE ir<%indvars.iv.next443> = add nsw ir<%indvars.iv442>, ir<1>
    CLONE ir<%indvars.iv.next441> = add nsw ir<%indvars.iv440>, ir<1>
    CLONE ir<%dec128> = add nsw ir<%yyn.0385>, ir<-1>
    CLONE ir<%cmp115> = icmp ugt ir<%yyn.0385>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end129.loopexit>, scalar.ph

ir-bb<while.end129.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv442 = phi i64 [ %32, %while.body116.preheader ], [ %indvars.iv.next443, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv440 = phi i64 [ %31, %while.body116.preheader ], [ %indvars.iv.next441, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %yyn.0385 = phi i32 [ %sub108.sub109, %while.body116.preheader ], [ %dec128, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx119 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv442 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx121 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv440 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next443 = add nsw i64 %indvars.iv442, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next441 = add nsw i64 %indvars.iv440, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec128 = add nsw i32 %yyn.0385, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp115 = icmp ugt i32 %yyn.0385, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp115, label %while.body116, label %while.end129.loopexit of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv442 = phi i64 [ %32, %while.body116.preheader ], [ %indvars.iv.next443, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv440 = phi i64 [ %31, %while.body116.preheader ], [ %indvars.iv.next441, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %yyn.0385 = phi i32 [ %sub108.sub109, %while.body116.preheader ], [ %dec128, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx119 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv442 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx121 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv440 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next443 = add nsw i64 %indvars.iv442, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next441 = add nsw i64 %indvars.iv440, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec128 = add nsw i32 %yyn.0385, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp115 = icmp ugt i32 %yyn.0385, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp115, label %while.body116, label %while.end129.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 17179869188, RTCostB: 51539607540
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 17179869188, RTCostB: 51539607540
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv442 = phi i64 [ %32, %while.body116.preheader ], [ %indvars.iv.next443, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv440 = phi i64 [ %31, %while.body116.preheader ], [ %indvars.iv.next441, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %yyn.0385 = phi i32 [ %sub108.sub109, %while.body116.preheader ], [ %dec128, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx119 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv442 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx121 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv440 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next443 = add nsw i64 %indvars.iv442, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next441 = add nsw i64 %indvars.iv440, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec128 = add nsw i32 %yyn.0385, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp115 = icmp ugt i32 %yyn.0385, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp115, label %while.body116, label %while.end129.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 51539607540
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 17179869188
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv442 = phi i64 [ %32, %while.body116.preheader ], [ %indvars.iv.next443, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv440 = phi i64 [ %31, %while.body116.preheader ], [ %indvars.iv.next441, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %yyn.0385 = phi i32 [ %sub108.sub109, %while.body116.preheader ], [ %dec128, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx119 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv442 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx121 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv440 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next443 = add nsw i64 %indvars.iv442, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next441 = add nsw i64 %indvars.iv440, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec128 = add nsw i32 %yyn.0385, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp115 = icmp ugt i32 %yyn.0385, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp115, label %while.body116, label %while.end129.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 51539607540
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934620

-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv442 = phi i64 [ %32, %while.body116.preheader ], [ %indvars.iv.next443, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv440 = phi i64 [ %31, %while.body116.preheader ], [ %indvars.iv.next441, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %yyn.0385 = phi i32 [ %sub108.sub109, %while.body116.preheader ], [ %dec128, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx119 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv442 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx121 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv440 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next443 = add nsw i64 %indvars.iv442, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next441 = add nsw i64 %indvars.iv440, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec128 = add nsw i32 %yyn.0385, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp115 = icmp ugt i32 %yyn.0385, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp115, label %while.body116, label %while.end129.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 51539607540
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 8589934620
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'fallbackQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv442 = phi i64 [ %32, %while.body116.preheader ], [ %indvars.iv.next443, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv440 = phi i64 [ %31, %while.body116.preheader ], [ %indvars.iv.next441, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %yyn.0385 = phi i32 [ %sub108.sub109, %while.body116.preheader ], [ %dec128, %while.body116 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx119 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv442 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %33 = load i32, ptr %arrayidx119, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx121 = getelementptr inbounds i32, ptr %fmap, i64 %indvars.iv440 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %34 = load i32, ptr %arrayidx121, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %34, ptr %arrayidx119, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %33, ptr %arrayidx121, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next443 = add nsw i64 %indvars.iv442, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next441 = add nsw i64 %indvars.iv440, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec128 = add nsw i32 %yyn.0385, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp115 = icmp ugt i32 %yyn.0385, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp115, label %while.body116, label %while.end129.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967372, RTCostB: 51539607540
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 4294967372, RTCostB: 8589934620
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: fallbackQSort3 at line: blocksort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body116.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %1) + %ltLo.1.ph.lcssa532) smin ((-1 * %ltLo.1.ph.lcssa532) + %unLo.1.lcssa529)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%32> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%31> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%arrayidx119> = getelementptr inbounds ir<%fmap>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx119>
    WIDEN ir<%40> = load vp<%8>
    CLONE ir<%arrayidx121> = getelementptr inbounds ir<%fmap>, vp<%7>
    vp<%9> = vector-pointer ir<%arrayidx121>
    WIDEN ir<%41> = load vp<%9>
    vp<%10> = vector-pointer ir<%arrayidx119>
    WIDEN store vp<%10>, ir<%41>
    vp<%11> = vector-pointer ir<%arrayidx121>
    WIDEN store vp<%11>, ir<%40>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end129.loopexit>, scalar.ph

ir-bb<while.end129.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 38
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: mainQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body172.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %gtHi.1.ph.lcssa513) + %1) smin ((-1 * %unHi.1.lcssa) + %gtHi.1.ph.lcssa513)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv630 = phi %40, %indvars.iv.next631, ir<1>
    WIDEN-INDUCTION %indvars.iv628 = phi %39, %indvars.iv.next629, ir<1>
    WIDEN-INDUCTION %yyn168.0567 = phi %sub154.sub155, %dec184, ir<-1>
    CLONE ir<%indvars.iv.next629> = add nsw ir<%indvars.iv628>, ir<1>
    CLONE ir<%arrayidx175> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv630>
    CLONE ir<%41> = load ir<%arrayidx175>
    CLONE ir<%arrayidx177> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv.next629>
    CLONE ir<%42> = load ir<%arrayidx177>
    CLONE store ir<%42>, ir<%arrayidx175>
    CLONE store ir<%41>, ir<%arrayidx177>
    CLONE ir<%indvars.iv.next631> = add nsw ir<%indvars.iv630>, ir<1>
    CLONE ir<%dec184> = add nsw ir<%yyn168.0567>, ir<-1>
    CLONE ir<%cmp170> = icmp ugt ir<%yyn168.0567>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end185.loopexit>, scalar.ph

ir-bb<while.end185.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: mainQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body172.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %gtHi.1.ph.lcssa513) + %1) smin ((-1 * %unHi.1.lcssa) + %gtHi.1.ph.lcssa513)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv630 = phi %40, %indvars.iv.next631, ir<1>
    WIDEN-INDUCTION %indvars.iv628 = phi %39, %indvars.iv.next629, ir<1>
    WIDEN-INDUCTION %yyn168.0567 = phi %sub154.sub155, %dec184, ir<-1>
    CLONE ir<%indvars.iv.next629> = add nsw ir<%indvars.iv628>, ir<1>
    CLONE ir<%arrayidx175> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv630>
    vp<%4> = vector-pointer ir<%arrayidx175>
    WIDEN ir<%41> = load vp<%4>
    CLONE ir<%arrayidx177> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv.next629>
    vp<%5> = vector-pointer ir<%arrayidx177>
    WIDEN ir<%42> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx175>
    WIDEN store vp<%6>, ir<%42>
    vp<%7> = vector-pointer ir<%arrayidx177>
    WIDEN store vp<%7>, ir<%41>
    CLONE ir<%indvars.iv.next631> = add nsw ir<%indvars.iv630>, ir<1>
    CLONE ir<%dec184> = add nsw ir<%yyn168.0567>, ir<-1>
    CLONE ir<%cmp170> = icmp ugt ir<%yyn168.0567>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end185.loopexit>, scalar.ph

ir-bb<while.end185.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: mainQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body172.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %gtHi.1.ph.lcssa513) + %1) smin ((-1 * %unHi.1.lcssa) + %gtHi.1.ph.lcssa513)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv630 = phi %40, %indvars.iv.next631, ir<1>
    WIDEN-INDUCTION %indvars.iv628 = phi %39, %indvars.iv.next629, ir<1>
    WIDEN-INDUCTION %yyn168.0567 = phi %sub154.sub155, %dec184, ir<-1>
    CLONE ir<%indvars.iv.next629> = add nsw ir<%indvars.iv628>, ir<1>
    CLONE ir<%arrayidx175> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv630>
    vp<%4> = vector-pointer ir<%arrayidx175>
    WIDEN ir<%41> = load vp<%4>
    CLONE ir<%arrayidx177> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv.next629>
    vp<%5> = vector-pointer ir<%arrayidx177>
    WIDEN ir<%42> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx175>
    WIDEN store vp<%6>, ir<%42>
    vp<%7> = vector-pointer ir<%arrayidx177>
    WIDEN store vp<%7>, ir<%41>
    CLONE ir<%indvars.iv.next631> = add nsw ir<%indvars.iv630>, ir<1>
    CLONE ir<%dec184> = add nsw ir<%yyn168.0567>, ir<-1>
    CLONE ir<%cmp170> = icmp ugt ir<%yyn168.0567>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end185.loopexit>, scalar.ph

ir-bb<while.end185.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv630 = phi i64 [ %40, %while.body172.preheader ], [ %indvars.iv.next631, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv628 = phi i64 [ %39, %while.body172.preheader ], [ %indvars.iv.next629, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %yyn168.0567 = phi i32 [ %sub154.sub155, %while.body172.preheader ], [ %dec184, %while.body172 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next629 = add nsw i64 %indvars.iv628, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx175 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv630 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx177 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv.next629 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next631 = add nsw i64 %indvars.iv630, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec184 = add nsw i32 %yyn168.0567, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp170 = icmp ugt i32 %yyn168.0567, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp170, label %while.body172, label %while.end185.loopexit of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv630 = phi i64 [ %40, %while.body172.preheader ], [ %indvars.iv.next631, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv628 = phi i64 [ %39, %while.body172.preheader ], [ %indvars.iv.next629, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %yyn168.0567 = phi i32 [ %sub154.sub155, %while.body172.preheader ], [ %dec184, %while.body172 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next629 = add nsw i64 %indvars.iv628, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx175 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv630 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx177 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv.next629 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next631 = add nsw i64 %indvars.iv630, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec184 = add nsw i32 %yyn168.0567, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp170 = icmp ugt i32 %yyn168.0567, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp170, label %while.body172, label %while.end185.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 17179869188, RTCostB: 51539607540
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 17179869188, RTCostB: 51539607540
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv630 = phi i64 [ %40, %while.body172.preheader ], [ %indvars.iv.next631, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv628 = phi i64 [ %39, %while.body172.preheader ], [ %indvars.iv.next629, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %yyn168.0567 = phi i32 [ %sub154.sub155, %while.body172.preheader ], [ %dec184, %while.body172 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next629 = add nsw i64 %indvars.iv628, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx175 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv630 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx177 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv.next629 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next631 = add nsw i64 %indvars.iv630, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec184 = add nsw i32 %yyn168.0567, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp170 = icmp ugt i32 %yyn168.0567, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp170, label %while.body172, label %while.end185.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 51539607540
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 17179869188
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv630 = phi i64 [ %40, %while.body172.preheader ], [ %indvars.iv.next631, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv628 = phi i64 [ %39, %while.body172.preheader ], [ %indvars.iv.next629, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %yyn168.0567 = phi i32 [ %sub154.sub155, %while.body172.preheader ], [ %dec184, %while.body172 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next629 = add nsw i64 %indvars.iv628, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx175 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv630 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx177 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv.next629 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next631 = add nsw i64 %indvars.iv630, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec184 = add nsw i32 %yyn168.0567, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp170 = icmp ugt i32 %yyn168.0567, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp170, label %while.body172, label %while.end185.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 51539607540
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934620

-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv630 = phi i64 [ %40, %while.body172.preheader ], [ %indvars.iv.next631, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv628 = phi i64 [ %39, %while.body172.preheader ], [ %indvars.iv.next629, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %yyn168.0567 = phi i32 [ %sub154.sub155, %while.body172.preheader ], [ %dec184, %while.body172 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next629 = add nsw i64 %indvars.iv628, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx175 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv630 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx177 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv.next629 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next631 = add nsw i64 %indvars.iv630, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec184 = add nsw i32 %yyn168.0567, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp170 = icmp ugt i32 %yyn168.0567, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp170, label %while.body172, label %while.end185.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 51539607540
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 8589934620
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv630 = phi i64 [ %40, %while.body172.preheader ], [ %indvars.iv.next631, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv628 = phi i64 [ %39, %while.body172.preheader ], [ %indvars.iv.next629, %while.body172 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %yyn168.0567 = phi i32 [ %sub154.sub155, %while.body172.preheader ], [ %dec184, %while.body172 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next629 = add nsw i64 %indvars.iv628, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx175 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv630 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %41 = load i32, ptr %arrayidx175, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx177 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv.next629 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %42 = load i32, ptr %arrayidx177, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %42, ptr %arrayidx175, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %41, ptr %arrayidx177, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next631 = add nsw i64 %indvars.iv630, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec184 = add nsw i32 %yyn168.0567, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp170 = icmp ugt i32 %yyn168.0567, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp170, label %while.body172, label %while.end185.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967372, RTCostB: 51539607540
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 4294967372, RTCostB: 8589934620
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: mainQSort3 at line: blocksort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body172.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %gtHi.1.ph.lcssa513) + %1) smin ((-1 * %unHi.1.lcssa) + %gtHi.1.ph.lcssa513)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%40> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%39> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%indvars.iv.next629> = add nsw vp<%7>, ir<1>
    CLONE ir<%arrayidx175> = getelementptr inbounds ir<%ptr>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx175>
    WIDEN ir<%48> = load vp<%8>
    CLONE ir<%arrayidx177> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv.next629>
    vp<%9> = vector-pointer ir<%arrayidx177>
    WIDEN ir<%49> = load vp<%9>
    vp<%10> = vector-pointer ir<%arrayidx175>
    WIDEN store vp<%10>, ir<%49>
    vp<%11> = vector-pointer ir<%arrayidx177>
    WIDEN store vp<%11>, ir<%48>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end185.loopexit>, scalar.ph

ir-bb<while.end185.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: mainQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body140.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %0) + %ltLo.1.ph.lcssa29) smin ((-1 * %ltLo.1.ph.lcssa29) + %unLo.1.lcssa26)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv623 = phi %idxprom19.lcssa, %indvars.iv.next624, ir<1>
    WIDEN-INDUCTION %indvars.iv621 = phi %36, %indvars.iv.next622, ir<1>
    WIDEN-INDUCTION %yyn.0563 = phi %sub130.sub131, %dec152, ir<-1>
    CLONE ir<%arrayidx143> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv623>
    CLONE ir<%37> = load ir<%arrayidx143>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv621>
    CLONE ir<%38> = load ir<%arrayidx145>
    CLONE store ir<%38>, ir<%arrayidx143>
    CLONE store ir<%37>, ir<%arrayidx145>
    CLONE ir<%indvars.iv.next624> = add nsw ir<%indvars.iv623>, ir<1>
    CLONE ir<%indvars.iv.next622> = add nsw ir<%indvars.iv621>, ir<1>
    CLONE ir<%dec152> = add nsw ir<%yyn.0563>, ir<-1>
    CLONE ir<%cmp138> = icmp ugt ir<%yyn.0563>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end153.loopexit>, scalar.ph

ir-bb<while.end153.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: mainQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body140.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %0) + %ltLo.1.ph.lcssa29) smin ((-1 * %ltLo.1.ph.lcssa29) + %unLo.1.lcssa26)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv623 = phi %idxprom19.lcssa, %indvars.iv.next624, ir<1>
    WIDEN-INDUCTION %indvars.iv621 = phi %36, %indvars.iv.next622, ir<1>
    WIDEN-INDUCTION %yyn.0563 = phi %sub130.sub131, %dec152, ir<-1>
    CLONE ir<%arrayidx143> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv623>
    vp<%4> = vector-pointer ir<%arrayidx143>
    WIDEN ir<%37> = load vp<%4>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv621>
    vp<%5> = vector-pointer ir<%arrayidx145>
    WIDEN ir<%38> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx143>
    WIDEN store vp<%6>, ir<%38>
    vp<%7> = vector-pointer ir<%arrayidx145>
    WIDEN store vp<%7>, ir<%37>
    CLONE ir<%indvars.iv.next624> = add nsw ir<%indvars.iv623>, ir<1>
    CLONE ir<%indvars.iv.next622> = add nsw ir<%indvars.iv621>, ir<1>
    CLONE ir<%dec152> = add nsw ir<%yyn.0563>, ir<-1>
    CLONE ir<%cmp138> = icmp ugt ir<%yyn.0563>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end153.loopexit>, scalar.ph

ir-bb<while.end153.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: mainQSort3' from blocksort.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body140.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %0) + %ltLo.1.ph.lcssa29) smin ((-1 * %ltLo.1.ph.lcssa29) + %unLo.1.lcssa26)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    WIDEN-INDUCTION %indvars.iv623 = phi %idxprom19.lcssa, %indvars.iv.next624, ir<1>
    WIDEN-INDUCTION %indvars.iv621 = phi %36, %indvars.iv.next622, ir<1>
    WIDEN-INDUCTION %yyn.0563 = phi %sub130.sub131, %dec152, ir<-1>
    CLONE ir<%arrayidx143> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv623>
    vp<%4> = vector-pointer ir<%arrayidx143>
    WIDEN ir<%37> = load vp<%4>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%ptr>, ir<%indvars.iv621>
    vp<%5> = vector-pointer ir<%arrayidx145>
    WIDEN ir<%38> = load vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx143>
    WIDEN store vp<%6>, ir<%38>
    vp<%7> = vector-pointer ir<%arrayidx145>
    WIDEN store vp<%7>, ir<%37>
    CLONE ir<%indvars.iv.next624> = add nsw ir<%indvars.iv623>, ir<1>
    CLONE ir<%indvars.iv.next622> = add nsw ir<%indvars.iv621>, ir<1>
    CLONE ir<%dec152> = add nsw ir<%yyn.0563>, ir<-1>
    CLONE ir<%cmp138> = icmp ugt ir<%yyn.0563>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end153.loopexit>, scalar.ph

ir-bb<while.end153.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv623 = phi i64 [ %idxprom19.lcssa, %while.body140.preheader ], [ %indvars.iv.next624, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv621 = phi i64 [ %36, %while.body140.preheader ], [ %indvars.iv.next622, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %yyn.0563 = phi i32 [ %sub130.sub131, %while.body140.preheader ], [ %dec152, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx143 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv623 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv621 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next624 = add nsw i64 %indvars.iv623, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next622 = add nsw i64 %indvars.iv621, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec152 = add nsw i32 %yyn.0563, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp138 = icmp ugt i32 %yyn.0563, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp138, label %while.body140, label %while.end153.loopexit of type:br
LV: Scalar loop costs: 12.
-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv623 = phi i64 [ %idxprom19.lcssa, %while.body140.preheader ], [ %indvars.iv.next624, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv621 = phi i64 [ %36, %while.body140.preheader ], [ %indvars.iv.next622, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %yyn.0563 = phi i32 [ %sub130.sub131, %while.body140.preheader ], [ %dec152, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx143 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv623 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv621 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next624 = add nsw i64 %indvars.iv623, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next622 = add nsw i64 %indvars.iv621, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec152 = add nsw i32 %yyn.0563, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp138 = icmp ugt i32 %yyn.0563, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp138, label %while.body140, label %while.end153.loopexit of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 17179869188, RTCostB: 51539607540
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 17179869188, RTCostB: 51539607540
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv623 = phi i64 [ %idxprom19.lcssa, %while.body140.preheader ], [ %indvars.iv.next624, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv621 = phi i64 [ %36, %while.body140.preheader ], [ %indvars.iv.next622, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %yyn.0563 = phi i32 [ %sub130.sub131, %while.body140.preheader ], [ %dec152, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx143 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv623 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv621 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next624 = add nsw i64 %indvars.iv623, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next622 = add nsw i64 %indvars.iv621, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec152 = add nsw i32 %yyn.0563, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp138 = icmp ugt i32 %yyn.0563, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp138, label %while.body140, label %while.end153.loopexit of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 51539607540
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 17179869188
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv623 = phi i64 [ %idxprom19.lcssa, %while.body140.preheader ], [ %indvars.iv.next624, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv621 = phi i64 [ %36, %while.body140.preheader ], [ %indvars.iv.next622, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %yyn.0563 = phi i32 [ %sub130.sub131, %while.body140.preheader ], [ %dec152, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx143 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv623 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv621 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next624 = add nsw i64 %indvars.iv623, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next622 = add nsw i64 %indvars.iv621, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec152 = add nsw i32 %yyn.0563, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp138 = icmp ugt i32 %yyn.0563, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp138, label %while.body140, label %while.end153.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 51539607540
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934620

-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv623 = phi i64 [ %idxprom19.lcssa, %while.body140.preheader ], [ %indvars.iv.next624, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv621 = phi i64 [ %36, %while.body140.preheader ], [ %indvars.iv.next622, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %yyn.0563 = phi i32 [ %sub130.sub131, %while.body140.preheader ], [ %dec152, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx143 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv623 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv621 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next624 = add nsw i64 %indvars.iv623, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next622 = add nsw i64 %indvars.iv621, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec152 = add nsw i32 %yyn.0563, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp138 = icmp ugt i32 %yyn.0563, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp138, label %while.body140, label %while.end153.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 51539607540
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 8589934620, RTCostB: 8589934620
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'mainQSort3' from blocksort.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv623 = phi i64 [ %idxprom19.lcssa, %while.body140.preheader ], [ %indvars.iv.next624, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv621 = phi i64 [ %36, %while.body140.preheader ], [ %indvars.iv.next622, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %yyn.0563 = phi i32 [ %sub130.sub131, %while.body140.preheader ], [ %dec152, %while.body140 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx143 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv623 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %37 = load i32, ptr %arrayidx143, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx145 = getelementptr inbounds i32, ptr %ptr, i64 %indvars.iv621 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %38 = load i32, ptr %arrayidx145, align 4, !tbaa !6 of type:load
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %38, ptr %arrayidx143, align 4, !tbaa !6 of type:store
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %37, ptr %arrayidx145, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next624 = add nsw i64 %indvars.iv623, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next622 = add nsw i64 %indvars.iv621, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %dec152 = add nsw i32 %yyn.0563, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp138 = icmp ugt i32 %yyn.0563, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp138, label %while.body140, label %while.end153.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 4294967372, RTCostB: 51539607540
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 4294967372, RTCostB: 8589934620
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: mainQSort3 at line: blocksort.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body140.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (((-1 * %0) + %ltLo.1.ph.lcssa29) smin ((-1 * %ltLo.1.ph.lcssa29) + %unLo.1.lcssa26)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%12>
    vp<%4>    = DERIVED-IV ir<%idxprom19.lcssa> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    vp<%6>    = DERIVED-IV ir<%36> + vp<%3> * ir<1>
    vp<%7> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%arrayidx143> = getelementptr inbounds ir<%ptr>, vp<%5>
    vp<%8> = vector-pointer ir<%arrayidx143>
    WIDEN ir<%44> = load vp<%8>
    CLONE ir<%arrayidx145> = getelementptr inbounds ir<%ptr>, vp<%7>
    vp<%9> = vector-pointer ir<%arrayidx145>
    WIDEN ir<%45> = load vp<%9>
    vp<%10> = vector-pointer ir<%arrayidx143>
    WIDEN store vp<%10>, ir<%45>
    vp<%11> = vector-pointer ir<%arrayidx145>
    WIDEN store vp<%11>, ir<%44>
    EMIT vp<%12> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%12>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%14> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%14>
Successor(s): ir-bb<while.end153.loopexit>, scalar.ph

ir-bb<while.end153.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 5
Loops Analyzed: 44
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o bzip2.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                bzip2.c
MVT: v2i32
@@ Instruction =>  %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
@@ Instruction =>  store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
MVT: v4i16
@@ Instruction =>  %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
@@ Instruction =>  store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
MVT: v8i8
@@ Instruction =>  %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
@@ Instruction =>  store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
MVT: v16i8
@@ Instruction =>  %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
@@ Instruction =>  store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
MVT: nxv16i8
@@ Instruction =>  %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
MVT: nxv2i64
@@ Instruction =>  %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
MVT: nxv4i32
@@ Instruction =>  %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
MVT: nxv8i16
@@ Instruction =>  %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
MVT: nxv16i8
@@ Instruction =>  %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
@@ Instruction =>  store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: uInt64_toAscii' from bzip2.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.end>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%do.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv3 = phi 0, %indvars.iv.next4, ir<1>
    CLONE ir<%2> = sub nsw ir<%1>, ir<%indvars.iv3>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%buf>, ir<0>, ir<%2>
    CLONE ir<%3> = load ir<%arrayidx7>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%outbuf>, ir<%indvars.iv3>
    CLONE store ir<%3>, ir<%arrayidx9>
    CLONE ir<%indvars.iv.next4> = add nuw nsw ir<%indvars.iv3>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next4>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: uInt64_toAscii' from bzip2.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.end>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%do.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv3 = phi 0, %indvars.iv.next4, ir<1>
    CLONE ir<%2> = sub nsw ir<%1>, ir<%indvars.iv3>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%buf>, ir<0>, ir<%2>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx7>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%outbuf>, ir<%indvars.iv3>
    vp<%5> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%5>, ir<%3>
    CLONE ir<%indvars.iv.next4> = add nuw nsw ir<%indvars.iv3>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next4>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}

========== Loop: uInt64_toAscii' from bzip2.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.end>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%do.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv3 = phi 0, %indvars.iv.next4, ir<1>
    CLONE ir<%2> = sub nsw ir<%1>, ir<%indvars.iv3>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%buf>, ir<0>, ir<%2>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx7>
    WIDEN ir<%3> = load vp<%4>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%outbuf>, ir<%indvars.iv3>
    vp<%5> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%5>, ir<%3>
    CLONE ir<%indvars.iv.next4> = add nuw nsw ir<%indvars.iv3>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next4>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 14
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 12
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 12, CostB * EstimatedWidthA: 14
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 28
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 12
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 48
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 56
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 112
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 96
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 14

-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 28

-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 56
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 56

-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 112
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 112
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'uInt64_toAscii' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv3 = phi i64 [ 0, %do.end ], [ %indvars.iv.next4, %for.body ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %2 = sub nsw i64 %1, %indvars.iv3 of type:sub
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx7 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 %2 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %3 = load i8, ptr %arrayidx7, align 1, !tbaa !6 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx9 = getelementptr inbounds i8, ptr %outbuf, i64 %indvars.iv3 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %3, ptr %arrayidx9, align 1, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next4, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: 1, EstimatedWidthB: 1, CostB: 7
CostA * EstimatedWidthB: 6, CostB * EstimatedWidthA: 224
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 6
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 6
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 192
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 12
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 48
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 6
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 24, CostB * EstimatedWidthA: 64
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 7
B VF: 8, EstimatedWidthB: 8, CostB: 6
CostA * EstimatedWidthB: 56, CostB * EstimatedWidthA: 96
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 28
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 56
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 6
B VF: 16, EstimatedWidthB: 16, CostB: 7
CostA * EstimatedWidthB: 96, CostB * EstimatedWidthA: 112
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: uInt64_toAscii at line: bzip2.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: uInt64_toAscii at line: bzip2.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<do.end>:
  EMIT vp<%2> = EXPAND SCEV {1,+,1}<nuw><%do.body>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%2> = sub nsw ir<%1>, vp<%4>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%buf>, ir<0>, ir<%2>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx7>
    WIDEN ir<%3> = load vp<%5>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%outbuf>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%6>, ir<%3>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: uInt64_toAscii at line: bzip2.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%39> = sub nsw ir<%1>, vp<%3>
    CLONE ir<%arrayidx7> = getelementptr inbounds ir<%buf>, ir<0>, ir<%39>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx7>
    WIDEN ir<%40> = load vp<%4>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%outbuf>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%5>, ir<%40>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%wide.trip.count>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end>, scalar.ph

ir-bb<for.end>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 3
Loops Epilogues Vectorized: 1
================================================
MVT: nxv16i8
MVT: nxv16i8
MVT: nxv8i16
@@ Instruction =>  %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: uncompressStream' from bzip2.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%7>, ir<%indvars.iv>
    CLONE ir<%9> = load ir<%arrayidx>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%unused>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%9>, ir<%arrayidx36>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: uncompressStream' from bzip2.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%7>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%unused>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%5>, ir<%9>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: uncompressStream' from bzip2.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %8 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%7>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%9> = load vp<%4>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%unused>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%5>, ir<%9>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 10737418236, RTCostB: 12884901882
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10737418236, RTCostB: 12884901882
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225484, RTCostB: 12884901882
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225484, RTCostB: 10737418236
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 3221225484
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 12884901882
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 1073741862
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 12884901882
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 536870998

-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 12884901882
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 536870998

-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 12884901882
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 536870998

-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 12884901882
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 536870998
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'uncompressStream' from bzip2.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx = getelementptr inbounds i8, ptr %7, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %9 = load i8, ptr %arrayidx, align 1, !tbaa !10 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx36 = getelementptr inbounds [5000 x i8], ptr %unused, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %9, ptr %arrayidx36, align 1, !tbaa !10 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 268435638, RTCostB: 12884901882
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 268435638, RTCostB: 536870998
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 3221225484, RTCostB: 10737418236
A is not scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 3221225484
A is not scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 1073741862
A is scalable.	B is not scalable.	
RTCostA: 2147483662, RTCostB: 536870998
A is scalable.	B is not scalable.	
RTCostA: 1073741862, RTCostB: 536870998
A is scalable.	B is not scalable.	
RTCostA: 536870998, RTCostB: 536870998
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: uncompressStream at line: bzip2.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: uncompressStream at line: bzip2.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %9 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%7>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%14> = load vp<%5>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%unused>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%6>, ir<%14>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: uncompressStream at line: bzip2.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%7>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%41> = load vp<%4>
    CLONE ir<%arrayidx36> = getelementptr inbounds ir<%unused>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx36>
    WIDEN store vp<%5>, ir<%41>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%wide.trip.count>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end.loopexit>, scalar.ph

ir-bb<for.end.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 6
Loops Epilogues Vectorized: 2
================================================
MVT: nxv8i16
MVT: nxv8i16
MVT: nxv16i8
MVT: nxv16i8
MVT: nxv16i8
MVT: nxv16i8
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o bzlib.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                bzlib.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o compress.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                compress.c
@@ Instruction =>  store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: generateMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%yy>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%conv>, ir<%arrayidx9>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond13.preheader.loopexit>, scalar.ph

ir-bb<for.cond13.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: generateMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%yy>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%4>, ir<%conv>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond13.preheader.loopexit>, scalar.ph

ir-bb<for.cond13.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: generateMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv = phi 0, %indvars.iv.next, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%yy>, ir<0>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%4>, ir<%conv>
    WIDEN ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond13.preheader.loopexit>, scalar.ph

ir-bb<for.cond13.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450942, RTCostB: 8589934588
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354567, RTCostB: 8589934588
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354567, RTCostB: 6442450942
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1610612758, RTCostB: 8589934588
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1610612758, RTCostB: 2684354567
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 1342177330, RTCostB: 8589934588
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1342177330, RTCostB: 1610612758
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 8589934588
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1342177330

-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 8589934588
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 1342177330

-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 8589934588
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 1342177330
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16

-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 805306422, RTCostB: 8589934588
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 805306422, RTCostB: 1073741848
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'generateMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ 0, %for.body7.preheader ], [ %indvars.iv.next, %for.body7 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %conv = trunc i64 %indvars.iv to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx9 = getelementptr inbounds [256 x i8], ptr %yy, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %conv, ptr %arrayidx9, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.cond13.preheader.loopexit, label %for.body7 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 671088754, RTCostB: 8589934588
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 671088754, RTCostB: 805306422
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 2684354567, RTCostB: 6442450942
A is not scalable.	B is not scalable.	
RTCostA: 1610612758, RTCostB: 2684354567
A is not scalable.	B is not scalable.	
RTCostA: 1342177330, RTCostB: 1610612758
A is scalable.	B is not scalable.	
RTCostA: 1610612745, RTCostB: 1342177330
A is scalable.	B is not scalable.	
RTCostA: 1073741848, RTCostB: 1342177330
A is scalable.	B is scalable.	
RTCostA: 805306422, RTCostB: 1073741848
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: generateMTFValues at line: compress.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: generateMTFValues at line: compress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body7.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %3 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%yy>, ir<0>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%5>, ir<%conv>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond13.preheader.loopexit>, scalar.ph

ir-bb<for.cond13.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: generateMTFValues at line: compress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv = phi 0, %indvars.iv.next\l" +
    "  ir<%conv>, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx9> = getelementptr inbounds ir<%yy>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx9>
    WIDEN store vp<%4>, ir<%conv>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%wide.trip.count>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond13.preheader.loopexit>, scalar.ph

ir-bb<for.cond13.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 1
Loops Analyzed: 5
Loops Epilogues Vectorized: 1
================================================
@@ Instruction =>  store i8 %., ptr %arrayidx91, align 1, !tbaa !17 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %., ptr %arrayidx91, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %., ptr %arrayidx91, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %., ptr %arrayidx91, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %., ptr %arrayidx91, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %., ptr %arrayidx91, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %., ptr %arrayidx91, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %., ptr %arrayidx91, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %., ptr %arrayidx91, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body72.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax (2 + %6)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv3970 = phi 0, %indvars.iv.next3971, ir<1>
    CLONE ir<%cmp73.not> = icmp slt ir<%indvars.iv3970>, ir<%31>
    CLONE ir<%cmp76.not> = icmp sgt ir<%indvars.iv3970>, ir<%30>
    CLONE ir<%or.cond3873> = select ir<%cmp73.not>, ir<true>, ir<%cmp76.not>
    CLONE ir<%arrayidx91> = getelementptr inbounds ir<%len79>, ir<0>, ir<%29>, ir<%indvars.iv3970>
    CLONE ir<%.> = select ir<%or.cond3873>, ir<15>, ir<0>
    CLONE store ir<%.>, ir<%arrayidx91>
    CLONE ir<%indvars.iv.next3971> = add nuw nsw ir<%indvars.iv3970>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next3971>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body72.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax (2 + %6)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv3970 = phi 0, %indvars.iv.next3971, ir<1>
    WIDEN ir<%cmp73.not> = icmp slt ir<%indvars.iv3970>, ir<%31>
    WIDEN ir<%cmp76.not> = icmp sgt ir<%indvars.iv3970>, ir<%30>
    WIDEN-SELECT ir<%or.cond3873> = select ir<%cmp73.not>, ir<true>, ir<%cmp76.not>
    CLONE ir<%arrayidx91> = getelementptr inbounds ir<%len79>, ir<0>, ir<%29>, ir<%indvars.iv3970>
    WIDEN-SELECT ir<%.> = select ir<%or.cond3873>, ir<15>, ir<0>
    vp<%4> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%4>, ir<%.>
    WIDEN ir<%indvars.iv.next3971> = add nuw nsw ir<%indvars.iv3970>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next3971>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body72.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax (2 + %6)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv3970 = phi 0, %indvars.iv.next3971, ir<1>
    WIDEN ir<%cmp73.not> = icmp slt ir<%indvars.iv3970>, ir<%31>
    WIDEN ir<%cmp76.not> = icmp sgt ir<%indvars.iv3970>, ir<%30>
    WIDEN-SELECT ir<%or.cond3873> = select ir<%cmp73.not>, ir<true>, ir<%cmp76.not>
    CLONE ir<%arrayidx91> = getelementptr inbounds ir<%len79>, ir<0>, ir<%29>, ir<%indvars.iv3970>
    WIDEN-SELECT ir<%.> = select ir<%or.cond3873>, ir<15>, ir<0>
    vp<%4> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%4>, ir<%.>
    WIDEN ir<%indvars.iv.next3971> = add nuw nsw ir<%indvars.iv3970>, ir<1>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next3971>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 1 for VF 1 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 6 for VF 2 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 16106127353, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 16106127353, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 2 for VF 4 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 12 for VF 4 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 11811160066, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 11811160066, RTCostB: 16106127353
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 4 for VF 8 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 24 for VF 8 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Vector loop of width 8 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 10468982801, RTCostB: 17179869176
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10468982801, RTCostB: 11811160066
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 8 for VF 16 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 8 for VF 16 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 48 for VF 16 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Vector loop of width 16 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 10066329645, RTCostB: 17179869176
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 10066329645, RTCostB: 10468982801
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 10066329645

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096401, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3758096401, RTCostB: 10066329645
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 16

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2684354606, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2684354606, RTCostB: 3758096401
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Vector loop of width vscale x 8 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 2147483752, RTCostB: 17179869176
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 2147483752, RTCostB: 2684354606
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: vscale x 4

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv3970 = phi i64 [ 0, %for.body72.lr.ph ], [ %indvars.iv.next3971, %for.body72 ] of type:phi
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %cmp73.not = icmp slt i64 %indvars.iv3970, %31 of type:icmp
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %cmp76.not = icmp sgt i64 %indvars.iv3970, %30 of type:icmp
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %or.cond3873 = select i1 %cmp73.not, i1 true, i1 %cmp76.not of type:select
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx91 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %29, i64 %indvars.iv3970 of type:getelementptr
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %. = select i1 %or.cond3873, i8 15, i8 0 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %., ptr %arrayidx91, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next3971 = add nuw nsw i64 %indvars.iv3970, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next3971, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond.not, label %for.end95.loopexit, label %for.body72 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1879048412, RTCostB: 17179869176
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1879048412, RTCostB: 2147483752
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 11811160066, RTCostB: 16106127353
A is not scalable.	B is not scalable.	
RTCostA: 10468982801, RTCostB: 11811160066
A is not scalable.	B is not scalable.	
RTCostA: 10066329645, RTCostB: 10468982801
A is scalable.	B is not scalable.	
RTCostA: 3758096401, RTCostB: 10066329645
A is scalable.	B is scalable.	
RTCostA: 2684354606, RTCostB: 3758096401
A is scalable.	B is scalable.	
RTCostA: 2147483752, RTCostB: 2684354606
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: sendMTFValues at line: compress.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=1 at function: sendMTFValues at line: compress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body72.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax (2 + %6)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv3970 = phi 0, %indvars.iv.next3971, ir<1>
    vp<%5> = SCALAR-STEPS vp<%3>, ir<1>
    WIDEN ir<%cmp73.not> = icmp slt vp<%4>, ir<%31>
    WIDEN ir<%cmp76.not> = icmp sgt vp<%4>, ir<%30>
    WIDEN-SELECT ir<%or.cond3873> = select ir<%cmp73.not>, ir<true>, ir<%cmp76.not>
    CLONE ir<%arrayidx91> = getelementptr inbounds ir<%len79>, ir<0>, ir<%29>, vp<%5>
    WIDEN-SELECT ir<%.> = select ir<%or.cond3873>, ir<15>, ir<0>
    vp<%6> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%6>, ir<%.>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: sendMTFValues at line: compress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%wide.trip.count> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv3970 = phi 0, %indvars.iv.next3971, ir<1>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    WIDEN ir<%cmp73.not> = icmp slt ir<%indvars.iv3970>, ir<%31>
    WIDEN ir<%cmp76.not> = icmp sgt ir<%indvars.iv3970>, ir<%30>
    WIDEN-SELECT ir<%or.cond3873> = select ir<%cmp73.not>, ir<true>, ir<%cmp76.not>
    CLONE ir<%arrayidx91> = getelementptr inbounds ir<%len79>, ir<0>, ir<%29>, vp<%3>
    WIDEN-SELECT ir<%.> = select ir<%or.cond3873>, ir<15>, ir<0>
    vp<%4> = vector-pointer ir<%arrayidx91>
    WIDEN store vp<%4>, ir<%.>
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<%wide.trip.count>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.end95.loopexit>, scalar.ph

ir-bb<for.end95.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 2 -> VectorType: <16 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 2 -> VectorType: <16 x i16> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 10 -> VectorType: <2 x i16> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 10 -> VectorType: <2 x i16> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 20 -> VectorType: <4 x i16> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 20 -> VectorType: <4 x i16> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 40 -> VectorType: <8 x i16> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 40 -> VectorType: <8 x i16> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 80 -> VectorType: <16 x i16> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 80 -> VectorType: <16 x i16> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: Invalid -> VectorType: <vscale x 1 x i16> -> ttilog -> 
@@ Instruction =>  %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 2 x i16> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 4 x i16> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 -> Cost: 1 -> VectorType: <vscale x 8 x i16> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<for.body1140>:
  EMIT vp<%3> = EXPAND SCEV (zext i32 %nGroups.0 to i64)
No successors

vector.ph:
  EMIT vp<%4> = VF * Part + ir<0>
  EMIT vp<%5> = active lane mask vp<%4>, vp<%3>
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%10>
    ACTIVE-LANE-MASK-PHI vp<%7> = phi vp<%5>, vp<%12>
    WIDEN-INDUCTION %indvars.iv3998 = phi 0, %indvars.iv.next3999, ir<1>
    EMIT vp<%8> = WIDEN-CANONICAL-INDUCTION vp<%6>
    EMIT vp<%9> = icmp ule vp<%8>, vp<%2>
    CLONE ir<%arrayidx1152> = getelementptr inbounds ir<%len79>, ir<0>, ir<%indvars.iv3998>, ir<%idxprom1151>
    CLONE ir<%286> = load ir<%arrayidx1152>, vp<%7>
    CLONE ir<%conv1153> = zext ir<%286>
    CLONE ir<%arrayidx1155> = getelementptr inbounds ir<%cost>, ir<0>, ir<%indvars.iv3998>
    CLONE ir<%287> = load ir<%arrayidx1155>, vp<%7>
    CLONE ir<%add1157> = add ir<%287>, ir<%conv1153>
    CLONE store ir<%add1157>, ir<%arrayidx1155>, vp<%7>
    CLONE ir<%indvars.iv.next3999> = add nuw nsw ir<%indvars.iv3998>, ir<1>
    CLONE ir<%exitcond4002.not> = icmp eq ir<%indvars.iv.next3999>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add vp<%6>, vp<%0>
    EMIT vp<%11> = VF * Part + vp<%10>
    EMIT vp<%12> = active lane mask vp<%11>, vp<%3>
    EMIT vp<%13> = not vp<%12>
    EMIT branch-on-cond vp<%13>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.end1161>, scalar.ph

ir-bb<for.end1161>:
No successors

scalar.ph:
No successors
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<for.body1140>:
  EMIT vp<%3> = EXPAND SCEV (zext i32 %nGroups.0 to i64)
No successors

vector.ph:
  EMIT vp<%4> = VF * Part + ir<0>
  EMIT vp<%5> = active lane mask vp<%4>, vp<%3>
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%12>
    ACTIVE-LANE-MASK-PHI vp<%7> = phi vp<%5>, vp<%14>
    WIDEN-INDUCTION %indvars.iv3998 = phi 0, %indvars.iv.next3999, ir<1>
    EMIT vp<%8> = WIDEN-CANONICAL-INDUCTION vp<%6>
    EMIT vp<%9> = icmp ule vp<%8>, vp<%2>
    REPLICATE ir<%arrayidx1152> = getelementptr inbounds ir<%len79>, ir<0>, ir<%indvars.iv3998>, ir<%idxprom1151>
    REPLICATE ir<%286> = load ir<%arrayidx1152>, vp<%7>
    WIDEN-CAST ir<%conv1153> = zext  ir<%286> to i16
    CLONE ir<%arrayidx1155> = getelementptr inbounds ir<%cost>, ir<0>, ir<%indvars.iv3998>
    vp<%10> = vector-pointer ir<%arrayidx1155>
    WIDEN ir<%287> = load vp<%10>, vp<%7>
    WIDEN ir<%add1157> = add ir<%287>, ir<%conv1153>
    vp<%11> = vector-pointer ir<%arrayidx1155>
    WIDEN store vp<%11>, ir<%add1157>, vp<%7>
    WIDEN ir<%indvars.iv.next3999> = add nuw nsw ir<%indvars.iv3998>, ir<1>
    CLONE ir<%exitcond4002.not> = icmp eq ir<%indvars.iv.next3999>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add vp<%6>, vp<%0>
    EMIT vp<%13> = VF * Part + vp<%12>
    EMIT vp<%14> = active lane mask vp<%13>, vp<%3>
    EMIT vp<%15> = not vp<%14>
    EMIT branch-on-cond vp<%15>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.end1161>, scalar.ph

ir-bb<for.end1161>:
No successors

scalar.ph:
No successors
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<for.body1140>:
  EMIT vp<%3> = EXPAND SCEV (zext i32 %nGroups.0 to i64)
No successors

vector.ph:
  EMIT vp<%4> = VF * Part + ir<0>
  EMIT vp<%5> = active lane mask vp<%4>, vp<%3>
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%12>
    ACTIVE-LANE-MASK-PHI vp<%7> = phi vp<%5>, vp<%14>
    WIDEN-INDUCTION %indvars.iv3998 = phi 0, %indvars.iv.next3999, ir<1>
    EMIT vp<%8> = WIDEN-CANONICAL-INDUCTION vp<%6>
    EMIT vp<%9> = icmp ule vp<%8>, vp<%2>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx1152> = getelementptr inbounds ir<%len79>, ir<0>, ir<%indvars.iv3998>, ir<%idxprom1151>
    REPLICATE ir<%286> = load ir<%arrayidx1152>, vp<%7>
    WIDEN-CAST ir<%conv1153> = zext  ir<%286> to i16
    CLONE ir<%arrayidx1155> = getelementptr inbounds ir<%cost>, ir<0>, ir<%indvars.iv3998>
    vp<%10> = vector-pointer ir<%arrayidx1155>
    WIDEN ir<%287> = load vp<%10>, vp<%7>
    WIDEN ir<%add1157> = add ir<%287>, ir<%conv1153>
    vp<%11> = vector-pointer ir<%arrayidx1155>
    WIDEN store vp<%11>, ir<%add1157>, vp<%7>
    WIDEN ir<%indvars.iv.next3999> = add nuw nsw ir<%indvars.iv3998>, ir<1>
    CLONE ir<%exitcond4002.not> = icmp eq ir<%indvars.iv.next3999>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add vp<%6>, vp<%0>
    EMIT vp<%13> = VF * Part + vp<%12>
    EMIT vp<%14> = active lane mask vp<%13>, vp<%3>
    EMIT vp<%15> = not vp<%14>
    EMIT branch-on-cond vp<%15>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.end1161>, scalar.ph

ir-bb<for.end1161>:
No successors

scalar.ph:
No successors
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<for.body1140>:
  EMIT vp<%3> = EXPAND SCEV (zext i32 %nGroups.0 to i64)
No successors

vector.ph:
  EMIT vp<%4> = VF * Part + ir<0>
  EMIT vp<%5> = active lane mask vp<%4>, vp<%3>
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%12>
    ACTIVE-LANE-MASK-PHI vp<%7> = phi vp<%5>, vp<%14>
    WIDEN-INDUCTION %indvars.iv3998 = phi 0, %indvars.iv.next3999, ir<1>
    EMIT vp<%8> = WIDEN-CANONICAL-INDUCTION vp<%6>
    EMIT vp<%9> = icmp ule vp<%8>, vp<%2>
    WIDEN-GEP Inv[Inv][Var][Inv] ir<%arrayidx1152> = getelementptr inbounds ir<%len79>, ir<0>, ir<%indvars.iv3998>, ir<%idxprom1151>
    WIDEN ir<%286> = load ir<%arrayidx1152>, vp<%7>
    WIDEN-CAST ir<%conv1153> = zext  ir<%286> to i16
    CLONE ir<%arrayidx1155> = getelementptr inbounds ir<%cost>, ir<0>, ir<%indvars.iv3998>
    vp<%10> = vector-pointer ir<%arrayidx1155>
    WIDEN ir<%287> = load vp<%10>, vp<%7>
    WIDEN ir<%add1157> = add ir<%287>, ir<%conv1153>
    vp<%11> = vector-pointer ir<%arrayidx1155>
    WIDEN store vp<%11>, ir<%add1157>, vp<%7>
    WIDEN ir<%indvars.iv.next3999> = add nuw nsw ir<%indvars.iv3998>, ir<1>
    CLONE ir<%exitcond4002.not> = icmp eq ir<%indvars.iv.next3999>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%12> = add vp<%6>, vp<%0>
    EMIT vp<%13> = VF * Part + vp<%12>
    EMIT vp<%14> = active lane mask vp<%13>, vp<%3>
    EMIT vp<%15> = not vp<%14>
    EMIT branch-on-cond vp<%15>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.end1161>, scalar.ph

ir-bb<for.end1161>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv3998 = phi i64 [ 0, %for.body1140 ], [ %indvars.iv.next3999, %for.body1147 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1152 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv3998, i64 %idxprom1151 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %286 = load i8, ptr %arrayidx1152, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv1153 = zext i8 %286 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1155 = getelementptr inbounds [6 x i16], ptr %cost, i64 0, i64 %indvars.iv3998 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add1157 = add i16 %287, %conv1153 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next3999 = add nuw nsw i64 %indvars.iv3998, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond4002.not = icmp eq i64 %indvars.iv.next3999, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond4002.not, label %for.end1161, label %for.body1147 of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv3998 = phi i64 [ 0, %for.body1140 ], [ %indvars.iv.next3999, %for.body1147 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1152 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv3998, i64 %idxprom1151 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 2 For instruction:   %286 = load i8, ptr %arrayidx1152, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1153 = zext i8 %286 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1155 = getelementptr inbounds [6 x i16], ptr %cost, i64 0, i64 %indvars.iv3998 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add1157 = add i16 %287, %conv1153 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next3999 = add nuw nsw i64 %indvars.iv3998, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond4002.not = icmp eq i64 %indvars.iv.next3999, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond4002.not, label %for.end1161, label %for.body1147 of type:br
LV: Vector loop of width 2 costs: 1500012
A is not scalable.	B is not scalable.	
RTCostA: 12000096, RTCostB: 63
A is not scalable.	B is not scalable.	
RTCostA: 12000096, RTCostB: 63

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv3998 = phi i64 [ 0, %for.body1140 ], [ %indvars.iv.next3999, %for.body1147 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1152 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv3998, i64 %idxprom1151 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 4 For instruction:   %286 = load i8, ptr %arrayidx1152, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1153 = zext i8 %286 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1155 = getelementptr inbounds [6 x i16], ptr %cost, i64 0, i64 %indvars.iv3998 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add1157 = add i16 %287, %conv1153 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next3999 = add nuw nsw i64 %indvars.iv3998, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond4002.not = icmp eq i64 %indvars.iv.next3999, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond4002.not, label %for.end1161, label %for.body1147 of type:br
LV: Vector loop of width 4 costs: 750011
A is not scalable.	B is not scalable.	
RTCostA: 6000090, RTCostB: 63
A is not scalable.	B is not scalable.	
RTCostA: 6000090, RTCostB: 63

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv3998 = phi i64 [ 0, %for.body1140 ], [ %indvars.iv.next3999, %for.body1147 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1152 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv3998, i64 %idxprom1151 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 8 For instruction:   %286 = load i8, ptr %arrayidx1152, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %conv1153 = zext i8 %286 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1155 = getelementptr inbounds [6 x i16], ptr %cost, i64 0, i64 %indvars.iv3998 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %add1157 = add i16 %287, %conv1153 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next3999 = add nuw nsw i64 %indvars.iv3998, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond4002.not = icmp eq i64 %indvars.iv.next3999, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond4002.not, label %for.end1161, label %for.body1147 of type:br
LV: Vector loop of width 8 costs: 375010
A is not scalable.	B is not scalable.	
RTCostA: 3000086, RTCostB: 63
A is not scalable.	B is not scalable.	
RTCostA: 3000086, RTCostB: 63

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv3998 = phi i64 [ 0, %for.body1140 ], [ %indvars.iv.next3999, %for.body1147 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1152 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv3998, i64 %idxprom1151 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 3000000 for VF 16 For instruction:   %286 = load i8, ptr %arrayidx1152, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %conv1153 = zext i8 %286 to i16 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1155 = getelementptr inbounds [6 x i16], ptr %cost, i64 0, i64 %indvars.iv3998 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 2 for VF 16 For instruction:   %add1157 = add i16 %287, %conv1153 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next3999 = add nuw nsw i64 %indvars.iv3998, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond4002.not = icmp eq i64 %indvars.iv.next3999, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond4002.not, label %for.end1161, label %for.body1147 of type:br
LV: Vector loop of width 16 costs: 187510
A is not scalable.	B is not scalable.	
RTCostA: 3000171, RTCostB: 63
A is not scalable.	B is not scalable.	
RTCostA: 3000171, RTCostB: 63

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv3998 = phi i64 [ 0, %for.body1140 ], [ %indvars.iv.next3999, %for.body1147 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1152 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv3998, i64 %idxprom1151 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %286 = load i8, ptr %arrayidx1152, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv1153 = zext i8 %286 to i16 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1155 = getelementptr inbounds [6 x i16], ptr %cost, i64 0, i64 %indvars.iv3998 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add1157 = add i16 %287, %conv1153 of type:add
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next3999 = add nuw nsw i64 %indvars.iv3998, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond4002.not = icmp eq i64 %indvars.iv.next3999, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond4002.not, label %for.end1161, label %for.body1147 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 63
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 63

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv3998 = phi i64 [ 0, %for.body1140 ], [ %indvars.iv.next3999, %for.body1147 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1152 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv3998, i64 %idxprom1151 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %286 = load i8, ptr %arrayidx1152, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1153 = zext i8 %286 to i16 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1155 = getelementptr inbounds [6 x i16], ptr %cost, i64 0, i64 %indvars.iv3998 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add1157 = add i16 %287, %conv1153 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next3999 = add nuw nsw i64 %indvars.iv3998, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond4002.not = icmp eq i64 %indvars.iv.next3999, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond4002.not, label %for.end1161, label %for.body1147 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 94, RTCostB: 63
A is scalable.	B is not scalable.	
RTCostA: 94, RTCostB: 63

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv3998 = phi i64 [ 0, %for.body1140 ], [ %indvars.iv.next3999, %for.body1147 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1152 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv3998, i64 %idxprom1151 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %286 = load i8, ptr %arrayidx1152, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1153 = zext i8 %286 to i16 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1155 = getelementptr inbounds [6 x i16], ptr %cost, i64 0, i64 %indvars.iv3998 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add1157 = add i16 %287, %conv1153 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next3999 = add nuw nsw i64 %indvars.iv3998, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond4002.not = icmp eq i64 %indvars.iv.next3999, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond4002.not, label %for.end1161, label %for.body1147 of type:br
LV: Vector loop of width vscale x 4 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 88, RTCostB: 63
A is scalable.	B is not scalable.	
RTCostA: 88, RTCostB: 63

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv3998 = phi i64 [ 0, %for.body1140 ], [ %indvars.iv.next3999, %for.body1147 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1152 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv3998, i64 %idxprom1151 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   %286 = load i8, ptr %arrayidx1152, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %conv1153 = zext i8 %286 to i16 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1155 = getelementptr inbounds [6 x i16], ptr %cost, i64 0, i64 %indvars.iv3998 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %287 = load i16, ptr %arrayidx1155, align 2, !tbaa !24 of type:load
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %add1157 = add i16 %287, %conv1153 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i16 %add1157, ptr %arrayidx1155, align 2, !tbaa !24 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next3999 = add nuw nsw i64 %indvars.iv3998, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond4002.not = icmp eq i64 %indvars.iv.next3999, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond4002.not, label %for.end1161, label %for.body1147 of type:br
LV: Vector loop of width vscale x 8 costs: 10
A is scalable.	B is not scalable.	
RTCostA: 170, RTCostB: 63
A is scalable.	B is not scalable.	
RTCostA: 170, RTCostB: 63
LV: Selecting VF: 1 With Cost: 9.
@@ Instruction =>  store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 -> Cost: 10 -> VectorType: <2 x i8> -> ttilog -> MaskedMemoryOpCost(10)
@@ Instruction =>  store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 -> Cost: 20 -> VectorType: <4 x i8> -> ttilog -> MaskedMemoryOpCost(20)
@@ Instruction =>  store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 -> Cost: 40 -> VectorType: <8 x i8> -> ttilog -> MaskedMemoryOpCost(40)
@@ Instruction =>  store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 -> Cost: 80 -> VectorType: <16 x i8> -> ttilog -> MaskedMemoryOpCost(80)
@@ Instruction =>  store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MaskedMemoryOpCost(1)
@@ Instruction =>  store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MaskedMemoryOpCost(1)
========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<if.end1715>:
  EMIT vp<%3> = EXPAND SCEV (zext i32 %nGroups.0 to i64)
No successors

vector.ph:
  EMIT vp<%4> = VF * Part + ir<0>
  EMIT vp<%5> = active lane mask vp<%4>, vp<%3>
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%10>
    ACTIVE-LANE-MASK-PHI vp<%7> = phi vp<%5>, vp<%12>
    WIDEN-INDUCTION %indvars.iv4031 = phi 0, %indvars.iv.next4032, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv4031 = phi 0, %indvars.iv.next4032\l" +
    "  ir<%conv1720>, ir<1>
    EMIT vp<%8> = WIDEN-CANONICAL-INDUCTION vp<%6>
    EMIT vp<%9> = icmp ule vp<%8>, vp<%2>
    CLONE ir<%arrayidx1722> = getelementptr inbounds ir<%pos>, ir<0>, ir<%indvars.iv4031>
    CLONE store ir<%conv1720>, ir<%arrayidx1722>, vp<%7>
    CLONE ir<%indvars.iv.next4032> = add nuw nsw ir<%indvars.iv4031>, ir<1>
    CLONE ir<%exitcond4035.not> = icmp eq ir<%indvars.iv.next4032>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%10> = add vp<%6>, vp<%0>
    EMIT vp<%11> = VF * Part + vp<%10>
    EMIT vp<%12> = active lane mask vp<%11>, vp<%3>
    EMIT vp<%13> = not vp<%12>
    EMIT branch-on-cond vp<%13>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.cond1726.preheader>, scalar.ph

ir-bb<for.cond1726.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<if.end1715>:
  EMIT vp<%3> = EXPAND SCEV (zext i32 %nGroups.0 to i64)
No successors

vector.ph:
  EMIT vp<%4> = VF * Part + ir<0>
  EMIT vp<%5> = active lane mask vp<%4>, vp<%3>
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%11>
    ACTIVE-LANE-MASK-PHI vp<%7> = phi vp<%5>, vp<%13>
    WIDEN-INDUCTION %indvars.iv4031 = phi 0, %indvars.iv.next4032, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv4031 = phi 0, %indvars.iv.next4032\l" +
    "  ir<%conv1720>, ir<1>
    EMIT vp<%8> = WIDEN-CANONICAL-INDUCTION vp<%6>
    EMIT vp<%9> = icmp ule vp<%8>, vp<%2>
    CLONE ir<%arrayidx1722> = getelementptr inbounds ir<%pos>, ir<0>, ir<%indvars.iv4031>
    vp<%10> = vector-pointer ir<%arrayidx1722>
    WIDEN store vp<%10>, ir<%conv1720>, vp<%7>
    WIDEN ir<%indvars.iv.next4032> = add nuw nsw ir<%indvars.iv4031>, ir<1>
    CLONE ir<%exitcond4035.not> = icmp eq ir<%indvars.iv.next4032>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%11> = add vp<%6>, vp<%0>
    EMIT vp<%12> = VF * Part + vp<%11>
    EMIT vp<%13> = active lane mask vp<%12>, vp<%3>
    EMIT vp<%14> = not vp<%13>
    EMIT branch-on-cond vp<%14>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.cond1726.preheader>, scalar.ph

ir-bb<for.cond1726.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%2> = backedge-taken count
vp<%3> = original trip-count

ir-bb<if.end1715>:
  EMIT vp<%3> = EXPAND SCEV (zext i32 %nGroups.0 to i64)
No successors

vector.ph:
  EMIT vp<%4> = VF * Part + ir<0>
  EMIT vp<%5> = active lane mask vp<%4>, vp<%3>
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%11>
    ACTIVE-LANE-MASK-PHI vp<%7> = phi vp<%5>, vp<%13>
    WIDEN-INDUCTION %indvars.iv4031 = phi 0, %indvars.iv.next4032, ir<1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv4031 = phi 0, %indvars.iv.next4032\l" +
    "  ir<%conv1720>, ir<1>
    EMIT vp<%8> = WIDEN-CANONICAL-INDUCTION vp<%6>
    EMIT vp<%9> = icmp ule vp<%8>, vp<%2>
    CLONE ir<%arrayidx1722> = getelementptr inbounds ir<%pos>, ir<0>, ir<%indvars.iv4031>
    vp<%10> = vector-pointer ir<%arrayidx1722>
    WIDEN store vp<%10>, ir<%conv1720>, vp<%7>
    WIDEN ir<%indvars.iv.next4032> = add nuw nsw ir<%indvars.iv4031>, ir<1>
    CLONE ir<%exitcond4035.not> = icmp eq ir<%indvars.iv.next4032>, ir<%11>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%11> = add vp<%6>, vp<%0>
    EMIT vp<%12> = VF * Part + vp<%11>
    EMIT vp<%13> = active lane mask vp<%12>, vp<%3>
    EMIT vp<%14> = not vp<%13>
    EMIT branch-on-cond vp<%14>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.cond1726.preheader>, scalar.ph

ir-bb<for.cond1726.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Scalar loop costs: 4.
-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 10 for VF 2 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Vector loop of width 2 costs: 6
A is not scalable.	B is not scalable.	
RTCostA: 48, RTCostB: 28
A is not scalable.	B is not scalable.	
RTCostA: 48, RTCostB: 28

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 20 for VF 4 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Vector loop of width 4 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 28
A is not scalable.	B is not scalable.	
RTCostA: 46, RTCostB: 28

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 40 for VF 8 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Vector loop of width 8 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 45, RTCostB: 28
A is not scalable.	B is not scalable.	
RTCostA: 45, RTCostB: 28

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 80 for VF 16 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Vector loop of width 16 costs: 5
A is not scalable.	B is not scalable.	
RTCostA: 89, RTCostB: 28
A is not scalable.	B is not scalable.	
RTCostA: 89, RTCostB: 28

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 28
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 28

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Vector loop of width vscale x 2 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 6, RTCostB: 28
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6, RTCostB: 28
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 4, RTCostB: 28
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 4, RTCostB: 6
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 6, RTCostB: 28
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 6, RTCostB: 4

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv4031 = phi i64 [ 0, %if.end1715 ], [ %indvars.iv.next4032, %for.body1719 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %conv1720 = trunc i64 %indvars.iv4031 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1722 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv4031 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %conv1720, ptr %arrayidx1722, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next4032 = add nuw nsw i64 %indvars.iv4031, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %exitcond4035.not = icmp eq i64 %indvars.iv.next4032, %11 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %exitcond4035.not, label %for.cond1726.preheader, label %for.body1719 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 10, RTCostB: 28
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 10, RTCostB: 4
LV: Selecting VF: vscale x 4 With Cost: 0.
LEV: Unable to vectorize epilogue because no epilogue is allowed.
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=1 at function: sendMTFValues at line: compress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
vp<%3> = original trip-count

ir-bb<if.end1715>:
  EMIT vp<%3> = EXPAND SCEV (zext i32 %nGroups.0 to i64)
No successors

vector.ph:
  EMIT vp<%4> = VF * Part + ir<0>
  EMIT vp<%5> = active lane mask vp<%4>, vp<%3>
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%10>
    ACTIVE-LANE-MASK-PHI vp<%7> = phi vp<%5>, vp<%12>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv4031 = phi 0, %indvars.iv.next4032\l" +
    "  ir<%conv1720>, ir<1>
    vp<%8> = SCALAR-STEPS vp<%6>, ir<1>
    CLONE ir<%arrayidx1722> = getelementptr inbounds ir<%pos>, ir<0>, vp<%8>
    vp<%9> = vector-pointer ir<%arrayidx1722>
    WIDEN store vp<%9>, ir<%conv1720>, vp<%7>
    EMIT vp<%10> = add vp<%6>, vp<%0>
    EMIT vp<%11> = VF * Part + vp<%10>
    EMIT vp<%12> = active lane mask vp<%11>, vp<%3>
    EMIT vp<%13> = not vp<%12>
    EMIT branch-on-cond vp<%13>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT branch-on-cond ir<true>
Successor(s): ir-bb<for.cond1726.preheader>, scalar.ph

ir-bb<for.cond1726.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1761.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax (2 + %6)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv4042 = phi %indvars.iv.next4043, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%minLen.03931> = phi ir<32>, ir<%minLen.1>
    WIDEN-REDUCTION-PHI ir<%maxLen.03930> = phi ir<0>, ir<%spec.select3878>
    CLONE ir<%arrayidx1766> = getelementptr inbounds ir<%len79>, ir<0>, ir<%indvars.iv4047>, ir<%indvars.iv4042>
    CLONE ir<%421> = load ir<%arrayidx1766>
    CLONE ir<%conv1767> = zext ir<%421>
    CLONE ir<%spec.select3878> = call @llvm.smax.i32(ir<%maxLen.03930>, ir<%conv1767>)
    CLONE ir<%minLen.1> = call @llvm.smin.i32(ir<%minLen.03931>, ir<%conv1767>)
    CLONE ir<%indvars.iv.next4043> = add nuw nsw ir<%indvars.iv4042>, ir<1>
    CLONE ir<%exitcond4046.not> = icmp eq ir<%indvars.iv.next4043>, ir<%13>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%minLen.03931>, ir<%minLen.1>
  EMIT vp<%7> = compute-reduction-result ir<%maxLen.03930>, ir<%spec.select3878>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end1796>, scalar.ph

ir-bb<for.end1796>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select3878.lcssa = vp<%7>
Live-out i32 %minLen.1.lcssa = vp<%6>
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1761.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax (2 + %6)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv4042 = phi %indvars.iv.next4043, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%minLen.03931> = phi ir<32>, ir<%minLen.1>
    WIDEN-REDUCTION-PHI ir<%maxLen.03930> = phi ir<0>, ir<%spec.select3878>
    CLONE ir<%arrayidx1766> = getelementptr inbounds ir<%len79>, ir<0>, ir<%indvars.iv4047>, ir<%indvars.iv4042>
    vp<%4> = vector-pointer ir<%arrayidx1766>
    WIDEN ir<%421> = load vp<%4>
    WIDEN-CAST ir<%conv1767> = zext  ir<%421> to i32
    WIDEN-CALL ir<%spec.select3878> = call @llvm.smax.i32(ir<%maxLen.03930>, ir<%conv1767>) (using vector intrinsic)
    WIDEN-CALL ir<%minLen.1> = call @llvm.smin.i32(ir<%minLen.03931>, ir<%conv1767>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next4043> = add nuw nsw ir<%indvars.iv4042>, ir<1>
    CLONE ir<%exitcond4046.not> = icmp eq ir<%indvars.iv.next4043>, ir<%13>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%minLen.03931>, ir<%minLen.1>
  EMIT vp<%8> = compute-reduction-result ir<%maxLen.03930>, ir<%spec.select3878>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end1796>, scalar.ph

ir-bb<for.end1796>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select3878.lcssa = vp<%8>
Live-out i32 %minLen.1.lcssa = vp<%7>
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1761.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax (2 + %6)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv4042 = phi %indvars.iv.next4043, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%minLen.03931> = phi ir<32>, ir<%minLen.1>
    WIDEN-REDUCTION-PHI ir<%maxLen.03930> = phi ir<0>, ir<%spec.select3878>
    CLONE ir<%arrayidx1766> = getelementptr inbounds ir<%len79>, ir<0>, ir<%indvars.iv4047>, ir<%indvars.iv4042>
    vp<%4> = vector-pointer ir<%arrayidx1766>
    WIDEN ir<%421> = load vp<%4>
    WIDEN-CAST ir<%conv1767> = zext  ir<%421> to i32
    WIDEN-CALL ir<%spec.select3878> = call @llvm.smax.i32(ir<%maxLen.03930>, ir<%conv1767>) (using vector intrinsic)
    WIDEN-CALL ir<%minLen.1> = call @llvm.smin.i32(ir<%minLen.03931>, ir<%conv1767>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next4043> = add nuw nsw ir<%indvars.iv4042>, ir<1>
    CLONE ir<%exitcond4046.not> = icmp eq ir<%indvars.iv.next4043>, ir<%13>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%minLen.03931>, ir<%minLen.1>
  EMIT vp<%8> = compute-reduction-result ir<%maxLen.03930>, ir<%spec.select3878>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end1796>, scalar.ph

ir-bb<for.end1796>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select3878.lcssa = vp<%8>
Live-out i32 %minLen.1.lcssa = vp<%7>
}


-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv4042 = phi i64 [ %indvars.iv.next4043, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %minLen.03931 = phi i32 [ %minLen.1, %for.body1761 ], [ 32, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %maxLen.03930 = phi i32 [ %spec.select3878, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1766 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv4047, i64 %indvars.iv4042 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv1767 = zext i8 %421 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 1 For instruction:   %spec.select3878 = tail call i32 @llvm.smax.i32(i32 %maxLen.03930, i32 %conv1767) of type:call
LV: Found an estimated cost of 2 for VF 1 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.03931, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next4043 = add nuw nsw i64 %indvars.iv4042, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond4046.not = icmp eq i64 %indvars.iv.next4043, %13 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond4046.not, label %for.end1796, label %for.body1761 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv4042 = phi i64 [ %indvars.iv.next4043, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %minLen.03931 = phi i32 [ %minLen.1, %for.body1761 ], [ 32, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %maxLen.03930 = phi i32 [ %spec.select3878, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1766 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv4047, i64 %indvars.iv4042 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1767 = zext i8 %421 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select3878 = tail call i32 @llvm.smax.i32(i32 %maxLen.03930, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.03931, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next4043 = add nuw nsw i64 %indvars.iv4042, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond4046.not = icmp eq i64 %indvars.iv.next4043, %13 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond4046.not, label %for.end1796, label %for.body1761 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676415, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676415, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv4042 = phi i64 [ %indvars.iv.next4043, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %minLen.03931 = phi i32 [ %minLen.1, %for.body1761 ], [ 32, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %maxLen.03930 = phi i32 [ %spec.select3878, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1766 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv4047, i64 %indvars.iv4042 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1767 = zext i8 %421 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select3878 = tail call i32 @llvm.smax.i32(i32 %maxLen.03930, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.03931, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next4043 = add nuw nsw i64 %indvars.iv4042, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond4046.not = icmp eq i64 %indvars.iv.next4043, %13 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond4046.not, label %for.end1796, label %for.body1761 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096401, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096401, RTCostB: 9663676415
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv4042 = phi i64 [ %indvars.iv.next4043, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %minLen.03931 = phi i32 [ %minLen.1, %for.body1761 ], [ 32, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %maxLen.03930 = phi i32 [ %spec.select3878, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1766 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv4047, i64 %indvars.iv4042 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 3 for VF 8 For instruction:   %conv1767 = zext i8 %421 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select3878 = tail call i32 @llvm.smax.i32(i32 %maxLen.03930, i32 %conv1767) of type:call
LV: Found an estimated cost of 2 for VF 8 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.03931, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next4043 = add nuw nsw i64 %indvars.iv4042, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond4046.not = icmp eq i64 %indvars.iv.next4043, %13 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond4046.not, label %for.end1796, label %for.body1761 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354606, RTCostB: 17179869176
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354606, RTCostB: 3758096401
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv4042 = phi i64 [ %indvars.iv.next4043, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %minLen.03931 = phi i32 [ %minLen.1, %for.body1761 ], [ 32, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %maxLen.03930 = phi i32 [ %spec.select3878, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1766 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv4047, i64 %indvars.iv4042 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 6 for VF 16 For instruction:   %conv1767 = zext i8 %421 to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %spec.select3878 = tail call i32 @llvm.smax.i32(i32 %maxLen.03930, i32 %conv1767) of type:call
LV: Found an estimated cost of 4 for VF 16 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.03931, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next4043 = add nuw nsw i64 %indvars.iv4042, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond4046.not = icmp eq i64 %indvars.iv.next4043, %13 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond4046.not, label %for.end1796, label %for.body1761 of type:br
LV: Vector loop of width 16 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2281701479, RTCostB: 17179869176
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2281701479, RTCostB: 2684354606
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv4042 = phi i64 [ %indvars.iv.next4043, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %minLen.03931 = phi i32 [ %minLen.1, %for.body1761 ], [ 32, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %maxLen.03930 = phi i32 [ %spec.select3878, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1766 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv4047, i64 %indvars.iv4042 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv1767 = zext i8 %421 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select3878 = tail call i32 @llvm.smax.i32(i32 %maxLen.03930, i32 %conv1767) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.03931, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next4043 = add nuw nsw i64 %indvars.iv4042, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond4046.not = icmp eq i64 %indvars.iv.next4043, %13 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond4046.not, label %for.end1796, label %for.body1761 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2281701479

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv4042 = phi i64 [ %indvars.iv.next4043, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %minLen.03931 = phi i32 [ %minLen.1, %for.body1761 ], [ 32, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %maxLen.03930 = phi i32 [ %spec.select3878, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1766 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv4047, i64 %indvars.iv4042 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1767 = zext i8 %421 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select3878 = tail call i32 @llvm.smax.i32(i32 %maxLen.03930, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.03931, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next4043 = add nuw nsw i64 %indvars.iv4042, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond4046.not = icmp eq i64 %indvars.iv.next4043, %13 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond4046.not, label %for.end1796, label %for.body1761 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 2281701479

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv4042 = phi i64 [ %indvars.iv.next4043, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %minLen.03931 = phi i32 [ %minLen.1, %for.body1761 ], [ 32, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %maxLen.03930 = phi i32 [ %spec.select3878, %for.body1761 ], [ 0, %for.body1761.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1766 = getelementptr inbounds [6 x [258 x i8]], ptr %len79, i64 0, i64 %indvars.iv4047, i64 %indvars.iv4042 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %421 = load i8, ptr %arrayidx1766, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv1767 = zext i8 %421 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select3878 = tail call i32 @llvm.smax.i32(i32 %maxLen.03930, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.03931, i32 %conv1767) of type:call
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next4043 = add nuw nsw i64 %indvars.iv4042, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond4046.not = icmp eq i64 %indvars.iv.next4043, %13 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond4046.not, label %for.end1796, label %for.body1761 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177331, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177331, RTCostB: 2281701479
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: sendMTFValues at line: compress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1761.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 (1 smax (2 + %6)) to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%minLen.03931> = phi ir<32>, ir<%minLen.1>
    WIDEN-REDUCTION-PHI ir<%maxLen.03930> = phi ir<0>, ir<%spec.select3878>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx1766> = getelementptr inbounds ir<%len79>, ir<0>, ir<%indvars.iv4047>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx1766>
    WIDEN ir<%421> = load vp<%5>
    WIDEN-CAST ir<%conv1767> = zext  ir<%421> to i32
    WIDEN-CALL ir<%spec.select3878> = call @llvm.smax.i32(ir<%maxLen.03930>, ir<%conv1767>) (using vector intrinsic)
    WIDEN-CALL ir<%minLen.1> = call @llvm.smin.i32(ir<%minLen.03931>, ir<%conv1767>) (using vector intrinsic)
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%minLen.03931>, ir<%minLen.1>
  EMIT vp<%9> = compute-reduction-result ir<%maxLen.03930>, ir<%spec.select3878>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end1796>, scalar.ph

ir-bb<for.end1796>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select3878.lcssa = vp<%9>
Live-out i32 %minLen.1.lcssa = vp<%8>
}
================ Final VPlan ================

@@ Instruction =>  store i8 0, ptr %arrayidx1820, align 1, !tbaa !17 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4142, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4145, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4146, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4147, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4148, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4149, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4150, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4151, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4152, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4153, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4154, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4155, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4156, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4157, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %spec.store.select4158, ptr %arrayidx1820, align 1 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 0, ptr %arrayidx1820, align 1, !tbaa !17 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4142, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4145, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4146, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4147, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4148, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4149, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4150, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4151, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4152, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4153, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4154, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4155, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4156, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4157, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %spec.store.select4158, ptr %arrayidx1820, align 1 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 0, ptr %arrayidx1820, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4142, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4145, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4146, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4147, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4148, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4149, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4150, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4151, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4152, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4153, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4154, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4155, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4156, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4157, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4158, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 0, ptr %arrayidx1820, align 1, !tbaa !17 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4142, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4145, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4146, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4147, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4148, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4149, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4150, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4151, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4152, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4153, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4154, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4155, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4156, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4157, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %spec.store.select4158, ptr %arrayidx1820, align 1 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<16> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv4057 = phi 0, %indvars.iv.next4058, ir<1>
    CLONE ir<%arrayidx1820> = getelementptr inbounds ir<%inUse16>, ir<0>, ir<%indvars.iv4057>
    CLONE store ir<0>, ir<%arrayidx1820>
    CLONE ir<%449> = shl nuw nsw ir<%indvars.iv4057>, ir<4>
    CLONE ir<%arrayidx1828> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%449>
    CLONE ir<%450> = load ir<%arrayidx1828>
    CLONE ir<%tobool.not> = icmp ne ir<%450>, ir<0>
    CLONE ir<%spec.store.select> = zext ir<%tobool.not>
    CLONE store ir<%spec.store.select>, ir<%arrayidx1820>
    CLONE ir<%451> = or disjoint ir<%449>, ir<1>
    CLONE ir<%arrayidx1828.1> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%451>
    CLONE ir<%452> = load ir<%arrayidx1828.1>
    CLONE ir<%tobool.not.1> = icmp eq ir<%452>, ir<0>
    CLONE ir<%spec.store.select4142> = select ir<%tobool.not.1>, ir<%spec.store.select>, ir<1>
    CLONE store ir<%spec.store.select4142>, ir<%arrayidx1820>
    CLONE ir<%453> = or disjoint ir<%449>, ir<2>
    CLONE ir<%arrayidx1828.2> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%453>
    CLONE ir<%454> = load ir<%arrayidx1828.2>
    CLONE ir<%tobool.not.2> = icmp eq ir<%454>, ir<0>
    CLONE ir<%spec.store.select4145> = select ir<%tobool.not.2>, ir<%spec.store.select4142>, ir<1>
    CLONE store ir<%spec.store.select4145>, ir<%arrayidx1820>
    CLONE ir<%455> = or disjoint ir<%449>, ir<3>
    CLONE ir<%arrayidx1828.3> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%455>
    CLONE ir<%456> = load ir<%arrayidx1828.3>
    CLONE ir<%tobool.not.3> = icmp eq ir<%456>, ir<0>
    CLONE ir<%spec.store.select4146> = select ir<%tobool.not.3>, ir<%spec.store.select4145>, ir<1>
    CLONE store ir<%spec.store.select4146>, ir<%arrayidx1820>
    CLONE ir<%457> = or disjoint ir<%449>, ir<4>
    CLONE ir<%arrayidx1828.4> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%457>
    CLONE ir<%458> = load ir<%arrayidx1828.4>
    CLONE ir<%tobool.not.4> = icmp eq ir<%458>, ir<0>
    CLONE ir<%spec.store.select4147> = select ir<%tobool.not.4>, ir<%spec.store.select4146>, ir<1>
    CLONE store ir<%spec.store.select4147>, ir<%arrayidx1820>
    CLONE ir<%459> = or disjoint ir<%449>, ir<5>
    CLONE ir<%arrayidx1828.5> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%459>
    CLONE ir<%460> = load ir<%arrayidx1828.5>
    CLONE ir<%tobool.not.5> = icmp eq ir<%460>, ir<0>
    CLONE ir<%spec.store.select4148> = select ir<%tobool.not.5>, ir<%spec.store.select4147>, ir<1>
    CLONE store ir<%spec.store.select4148>, ir<%arrayidx1820>
    CLONE ir<%461> = or disjoint ir<%449>, ir<6>
    CLONE ir<%arrayidx1828.6> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%461>
    CLONE ir<%462> = load ir<%arrayidx1828.6>
    CLONE ir<%tobool.not.6> = icmp eq ir<%462>, ir<0>
    CLONE ir<%spec.store.select4149> = select ir<%tobool.not.6>, ir<%spec.store.select4148>, ir<1>
    CLONE store ir<%spec.store.select4149>, ir<%arrayidx1820>
    CLONE ir<%463> = or disjoint ir<%449>, ir<7>
    CLONE ir<%arrayidx1828.7> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%463>
    CLONE ir<%464> = load ir<%arrayidx1828.7>
    CLONE ir<%tobool.not.7> = icmp eq ir<%464>, ir<0>
    CLONE ir<%spec.store.select4150> = select ir<%tobool.not.7>, ir<%spec.store.select4149>, ir<1>
    CLONE store ir<%spec.store.select4150>, ir<%arrayidx1820>
    CLONE ir<%465> = or disjoint ir<%449>, ir<8>
    CLONE ir<%arrayidx1828.8> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%465>
    CLONE ir<%466> = load ir<%arrayidx1828.8>
    CLONE ir<%tobool.not.8> = icmp eq ir<%466>, ir<0>
    CLONE ir<%spec.store.select4151> = select ir<%tobool.not.8>, ir<%spec.store.select4150>, ir<1>
    CLONE store ir<%spec.store.select4151>, ir<%arrayidx1820>
    CLONE ir<%467> = or disjoint ir<%449>, ir<9>
    CLONE ir<%arrayidx1828.9> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%467>
    CLONE ir<%468> = load ir<%arrayidx1828.9>
    CLONE ir<%tobool.not.9> = icmp eq ir<%468>, ir<0>
    CLONE ir<%spec.store.select4152> = select ir<%tobool.not.9>, ir<%spec.store.select4151>, ir<1>
    CLONE store ir<%spec.store.select4152>, ir<%arrayidx1820>
    CLONE ir<%469> = or disjoint ir<%449>, ir<10>
    CLONE ir<%arrayidx1828.10> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%469>
    CLONE ir<%470> = load ir<%arrayidx1828.10>
    CLONE ir<%tobool.not.10> = icmp eq ir<%470>, ir<0>
    CLONE ir<%spec.store.select4153> = select ir<%tobool.not.10>, ir<%spec.store.select4152>, ir<1>
    CLONE store ir<%spec.store.select4153>, ir<%arrayidx1820>
    CLONE ir<%471> = or disjoint ir<%449>, ir<11>
    CLONE ir<%arrayidx1828.11> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%471>
    CLONE ir<%472> = load ir<%arrayidx1828.11>
    CLONE ir<%tobool.not.11> = icmp eq ir<%472>, ir<0>
    CLONE ir<%spec.store.select4154> = select ir<%tobool.not.11>, ir<%spec.store.select4153>, ir<1>
    CLONE store ir<%spec.store.select4154>, ir<%arrayidx1820>
    CLONE ir<%473> = or disjoint ir<%449>, ir<12>
    CLONE ir<%arrayidx1828.12> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%473>
    CLONE ir<%474> = load ir<%arrayidx1828.12>
    CLONE ir<%tobool.not.12> = icmp eq ir<%474>, ir<0>
    CLONE ir<%spec.store.select4155> = select ir<%tobool.not.12>, ir<%spec.store.select4154>, ir<1>
    CLONE store ir<%spec.store.select4155>, ir<%arrayidx1820>
    CLONE ir<%475> = or disjoint ir<%449>, ir<13>
    CLONE ir<%arrayidx1828.13> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%475>
    CLONE ir<%476> = load ir<%arrayidx1828.13>
    CLONE ir<%tobool.not.13> = icmp eq ir<%476>, ir<0>
    CLONE ir<%spec.store.select4156> = select ir<%tobool.not.13>, ir<%spec.store.select4155>, ir<1>
    CLONE store ir<%spec.store.select4156>, ir<%arrayidx1820>
    CLONE ir<%477> = or disjoint ir<%449>, ir<14>
    CLONE ir<%arrayidx1828.14> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%477>
    CLONE ir<%478> = load ir<%arrayidx1828.14>
    CLONE ir<%tobool.not.14> = icmp eq ir<%478>, ir<0>
    CLONE ir<%spec.store.select4157> = select ir<%tobool.not.14>, ir<%spec.store.select4156>, ir<1>
    CLONE store ir<%spec.store.select4157>, ir<%arrayidx1820>
    CLONE ir<%479> = or disjoint ir<%449>, ir<15>
    CLONE ir<%arrayidx1828.15> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%479>
    CLONE ir<%480> = load ir<%arrayidx1828.15>
    CLONE ir<%tobool.not.15> = icmp eq ir<%480>, ir<0>
    CLONE ir<%spec.store.select4158> = select ir<%tobool.not.15>, ir<%spec.store.select4157>, ir<1>
    CLONE store ir<%spec.store.select4158>, ir<%arrayidx1820>
    CLONE ir<%indvars.iv.next4058> = add nuw nsw ir<%indvars.iv4057>, ir<1>
    CLONE ir<%exitcond4061.not> = icmp eq ir<%indvars.iv.next4058>, ir<16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<16>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.end1838>, scalar.ph

ir-bb<for.end1838>:
No successors

scalar.ph:
No successors
}

========== Loop: sendMTFValues' from compress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<16> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%20>
    WIDEN-INDUCTION %indvars.iv4057 = phi 0, %indvars.iv.next4058, ir<1>
    CLONE ir<%arrayidx1820> = getelementptr inbounds ir<%inUse16>, ir<0>, ir<%indvars.iv4057>
    vp<%3> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%3>, ir<0>
    WIDEN ir<%449> = shl nuw nsw ir<%indvars.iv4057>, ir<4>
    REPLICATE ir<%arrayidx1828> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%449>
    REPLICATE ir<%450> = load ir<%arrayidx1828>
    WIDEN ir<%tobool.not> = icmp ne ir<%450>, ir<0>
    WIDEN-CAST ir<%spec.store.select> = zext  ir<%tobool.not> to i8
    vp<%4> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%4>, ir<%spec.store.select>
    WIDEN ir<%451> = or disjoint ir<%449>, ir<1>
    REPLICATE ir<%arrayidx1828.1> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%451>
    REPLICATE ir<%452> = load ir<%arrayidx1828.1>
    WIDEN ir<%tobool.not.1> = icmp eq ir<%452>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4142> = select ir<%tobool.not.1>, ir<%spec.store.select>, ir<1>
    vp<%5> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%5>, ir<%spec.store.select4142>
    WIDEN ir<%453> = or disjoint ir<%449>, ir<2>
    REPLICATE ir<%arrayidx1828.2> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%453>
    REPLICATE ir<%454> = load ir<%arrayidx1828.2>
    WIDEN ir<%tobool.not.2> = icmp eq ir<%454>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4145> = select ir<%tobool.not.2>, ir<%spec.store.select4142>, ir<1>
    vp<%6> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%6>, ir<%spec.store.select4145>
    WIDEN ir<%455> = or disjoint ir<%449>, ir<3>
    REPLICATE ir<%arrayidx1828.3> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%455>
    REPLICATE ir<%456> = load ir<%arrayidx1828.3>
    WIDEN ir<%tobool.not.3> = icmp eq ir<%456>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4146> = select ir<%tobool.not.3>, ir<%spec.store.select4145>, ir<1>
    vp<%7> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%7>, ir<%spec.store.select4146>
    WIDEN ir<%457> = or disjoint ir<%449>, ir<4>
    REPLICATE ir<%arrayidx1828.4> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%457>
    REPLICATE ir<%458> = load ir<%arrayidx1828.4>
    WIDEN ir<%tobool.not.4> = icmp eq ir<%458>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4147> = select ir<%tobool.not.4>, ir<%spec.store.select4146>, ir<1>
    vp<%8> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%8>, ir<%spec.store.select4147>
    WIDEN ir<%459> = or disjoint ir<%449>, ir<5>
    REPLICATE ir<%arrayidx1828.5> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%459>
    REPLICATE ir<%460> = load ir<%arrayidx1828.5>
    WIDEN ir<%tobool.not.5> = icmp eq ir<%460>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4148> = select ir<%tobool.not.5>, ir<%spec.store.select4147>, ir<1>
    vp<%9> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%9>, ir<%spec.store.select4148>
    WIDEN ir<%461> = or disjoint ir<%449>, ir<6>
    REPLICATE ir<%arrayidx1828.6> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%461>
    REPLICATE ir<%462> = load ir<%arrayidx1828.6>
    WIDEN ir<%tobool.not.6> = icmp eq ir<%462>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4149> = select ir<%tobool.not.6>, ir<%spec.store.select4148>, ir<1>
    vp<%10> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%10>, ir<%spec.store.select4149>
    WIDEN ir<%463> = or disjoint ir<%449>, ir<7>
    REPLICATE ir<%arrayidx1828.7> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%463>
    REPLICATE ir<%464> = load ir<%arrayidx1828.7>
    WIDEN ir<%tobool.not.7> = icmp eq ir<%464>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4150> = select ir<%tobool.not.7>, ir<%spec.store.select4149>, ir<1>
    vp<%11> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%11>, ir<%spec.store.select4150>
    WIDEN ir<%465> = or disjoint ir<%449>, ir<8>
    REPLICATE ir<%arrayidx1828.8> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%465>
    REPLICATE ir<%466> = load ir<%arrayidx1828.8>
    WIDEN ir<%tobool.not.8> = icmp eq ir<%466>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4151> = select ir<%tobool.not.8>, ir<%spec.store.select4150>, ir<1>
    vp<%12> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%12>, ir<%spec.store.select4151>
    WIDEN ir<%467> = or disjoint ir<%449>, ir<9>
    REPLICATE ir<%arrayidx1828.9> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%467>
    REPLICATE ir<%468> = load ir<%arrayidx1828.9>
    WIDEN ir<%tobool.not.9> = icmp eq ir<%468>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4152> = select ir<%tobool.not.9>, ir<%spec.store.select4151>, ir<1>
    vp<%13> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%13>, ir<%spec.store.select4152>
    WIDEN ir<%469> = or disjoint ir<%449>, ir<10>
    REPLICATE ir<%arrayidx1828.10> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%469>
    REPLICATE ir<%470> = load ir<%arrayidx1828.10>
    WIDEN ir<%tobool.not.10> = icmp eq ir<%470>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4153> = select ir<%tobool.not.10>, ir<%spec.store.select4152>, ir<1>
    vp<%14> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%14>, ir<%spec.store.select4153>
    WIDEN ir<%471> = or disjoint ir<%449>, ir<11>
    REPLICATE ir<%arrayidx1828.11> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%471>
    REPLICATE ir<%472> = load ir<%arrayidx1828.11>
    WIDEN ir<%tobool.not.11> = icmp eq ir<%472>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4154> = select ir<%tobool.not.11>, ir<%spec.store.select4153>, ir<1>
    vp<%15> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%15>, ir<%spec.store.select4154>
    WIDEN ir<%473> = or disjoint ir<%449>, ir<12>
    REPLICATE ir<%arrayidx1828.12> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%473>
    REPLICATE ir<%474> = load ir<%arrayidx1828.12>
    WIDEN ir<%tobool.not.12> = icmp eq ir<%474>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4155> = select ir<%tobool.not.12>, ir<%spec.store.select4154>, ir<1>
    vp<%16> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%16>, ir<%spec.store.select4155>
    WIDEN ir<%475> = or disjoint ir<%449>, ir<13>
    REPLICATE ir<%arrayidx1828.13> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%475>
    REPLICATE ir<%476> = load ir<%arrayidx1828.13>
    WIDEN ir<%tobool.not.13> = icmp eq ir<%476>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4156> = select ir<%tobool.not.13>, ir<%spec.store.select4155>, ir<1>
    vp<%17> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%17>, ir<%spec.store.select4156>
    WIDEN ir<%477> = or disjoint ir<%449>, ir<14>
    REPLICATE ir<%arrayidx1828.14> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%477>
    REPLICATE ir<%478> = load ir<%arrayidx1828.14>
    WIDEN ir<%tobool.not.14> = icmp eq ir<%478>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4157> = select ir<%tobool.not.14>, ir<%spec.store.select4156>, ir<1>
    vp<%18> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%18>, ir<%spec.store.select4157>
    WIDEN ir<%479> = or disjoint ir<%449>, ir<15>
    REPLICATE ir<%arrayidx1828.15> = getelementptr inbounds ir<%inUse>, ir<0>, ir<%479>
    REPLICATE ir<%480> = load ir<%arrayidx1828.15>
    WIDEN ir<%tobool.not.15> = icmp eq ir<%480>, ir<0>
    WIDEN-SELECT ir<%spec.store.select4158> = select ir<%tobool.not.15>, ir<%spec.store.select4157>, ir<1>
    vp<%19> = vector-pointer ir<%arrayidx1820>
    WIDEN store vp<%19>, ir<%spec.store.select4158>
    WIDEN ir<%indvars.iv.next4058> = add nuw nsw ir<%indvars.iv4057>, ir<1>
    CLONE ir<%exitcond4061.not> = icmp eq ir<%indvars.iv.next4058>, ir<16>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%20> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%20>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%22> = icmp eq ir<16>, vp<%1>
  EMIT branch-on-cond vp<%22>
Successor(s): ir-bb<for.end1838>, scalar.ph

ir-bb<for.end1838>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv4057 = phi i64 [ 0, %for.end1814 ], [ %indvars.iv.next4058, %for.body1818 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1820 = getelementptr inbounds [16 x i8], ptr %inUse16, i64 0, i64 %indvars.iv4057 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 0, ptr %arrayidx1820, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %449 = shl nuw nsw i64 %indvars.iv4057, 4 of type:shl
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %449 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %450 = load i8, ptr %arrayidx1828, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not = icmp ne i8 %450, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select = zext i1 %tobool.not to i8 of type:zext
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %451 = or disjoint i64 %449, 1 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.1 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %451 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %452 = load i8, ptr %arrayidx1828.1, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.1 = icmp eq i8 %452, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4142 = select i1 %tobool.not.1, i8 %spec.store.select, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4142, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %453 = or disjoint i64 %449, 2 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.2 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %453 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %454 = load i8, ptr %arrayidx1828.2, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.2 = icmp eq i8 %454, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4145 = select i1 %tobool.not.2, i8 %spec.store.select4142, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4145, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %455 = or disjoint i64 %449, 3 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.3 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %455 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %456 = load i8, ptr %arrayidx1828.3, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.3 = icmp eq i8 %456, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4146 = select i1 %tobool.not.3, i8 %spec.store.select4145, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4146, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %457 = or disjoint i64 %449, 4 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.4 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %457 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %458 = load i8, ptr %arrayidx1828.4, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.4 = icmp eq i8 %458, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4147 = select i1 %tobool.not.4, i8 %spec.store.select4146, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4147, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %459 = or disjoint i64 %449, 5 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.5 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %459 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %460 = load i8, ptr %arrayidx1828.5, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.5 = icmp eq i8 %460, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4148 = select i1 %tobool.not.5, i8 %spec.store.select4147, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4148, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %461 = or disjoint i64 %449, 6 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.6 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %461 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %462 = load i8, ptr %arrayidx1828.6, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.6 = icmp eq i8 %462, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4149 = select i1 %tobool.not.6, i8 %spec.store.select4148, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4149, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %463 = or disjoint i64 %449, 7 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.7 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %463 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %464 = load i8, ptr %arrayidx1828.7, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.7 = icmp eq i8 %464, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4150 = select i1 %tobool.not.7, i8 %spec.store.select4149, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4150, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %465 = or disjoint i64 %449, 8 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.8 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %465 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %466 = load i8, ptr %arrayidx1828.8, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.8 = icmp eq i8 %466, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4151 = select i1 %tobool.not.8, i8 %spec.store.select4150, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4151, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %467 = or disjoint i64 %449, 9 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.9 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %467 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %468 = load i8, ptr %arrayidx1828.9, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.9 = icmp eq i8 %468, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4152 = select i1 %tobool.not.9, i8 %spec.store.select4151, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4152, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %469 = or disjoint i64 %449, 10 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.10 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %469 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %470 = load i8, ptr %arrayidx1828.10, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.10 = icmp eq i8 %470, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4153 = select i1 %tobool.not.10, i8 %spec.store.select4152, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4153, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %471 = or disjoint i64 %449, 11 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.11 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %471 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %472 = load i8, ptr %arrayidx1828.11, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.11 = icmp eq i8 %472, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4154 = select i1 %tobool.not.11, i8 %spec.store.select4153, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4154, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %473 = or disjoint i64 %449, 12 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.12 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %473 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %474 = load i8, ptr %arrayidx1828.12, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.12 = icmp eq i8 %474, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4155 = select i1 %tobool.not.12, i8 %spec.store.select4154, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4155, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %475 = or disjoint i64 %449, 13 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.13 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %475 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %476 = load i8, ptr %arrayidx1828.13, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.13 = icmp eq i8 %476, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4156 = select i1 %tobool.not.13, i8 %spec.store.select4155, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4156, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %477 = or disjoint i64 %449, 14 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.14 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %477 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %478 = load i8, ptr %arrayidx1828.14, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.14 = icmp eq i8 %478, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4157 = select i1 %tobool.not.14, i8 %spec.store.select4156, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4157, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %479 = or disjoint i64 %449, 15 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1828.15 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %479 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %480 = load i8, ptr %arrayidx1828.15, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %tobool.not.15 = icmp eq i8 %480, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 1 For instruction:   %spec.store.select4158 = select i1 %tobool.not.15, i8 %spec.store.select4157, i8 1 of type:select
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %spec.store.select4158, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next4058 = add nuw nsw i64 %indvars.iv4057, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond4061.not = icmp eq i64 %indvars.iv.next4058, 16 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond4061.not, label %for.end1838, label %for.body1818 of type:br
LV: Scalar loop costs: 116.
-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv4057 = phi i64 [ 0, %for.end1814 ], [ %indvars.iv.next4058, %for.body1818 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1820 = getelementptr inbounds [16 x i8], ptr %inUse16, i64 0, i64 %indvars.iv4057 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 0, ptr %arrayidx1820, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %449 = shl nuw nsw i64 %indvars.iv4057, 4 of type:shl
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %449 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %450 = load i8, ptr %arrayidx1828, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not = icmp ne i8 %450, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select = zext i1 %tobool.not to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %451 = or disjoint i64 %449, 1 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.1 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %451 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %452 = load i8, ptr %arrayidx1828.1, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.1 = icmp eq i8 %452, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4142 = select i1 %tobool.not.1, i8 %spec.store.select, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4142, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %453 = or disjoint i64 %449, 2 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.2 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %453 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %454 = load i8, ptr %arrayidx1828.2, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.2 = icmp eq i8 %454, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4145 = select i1 %tobool.not.2, i8 %spec.store.select4142, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4145, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %455 = or disjoint i64 %449, 3 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.3 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %455 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %456 = load i8, ptr %arrayidx1828.3, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.3 = icmp eq i8 %456, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4146 = select i1 %tobool.not.3, i8 %spec.store.select4145, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4146, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %457 = or disjoint i64 %449, 4 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.4 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %457 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %458 = load i8, ptr %arrayidx1828.4, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.4 = icmp eq i8 %458, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4147 = select i1 %tobool.not.4, i8 %spec.store.select4146, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4147, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %459 = or disjoint i64 %449, 5 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.5 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %459 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %460 = load i8, ptr %arrayidx1828.5, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.5 = icmp eq i8 %460, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4148 = select i1 %tobool.not.5, i8 %spec.store.select4147, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4148, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %461 = or disjoint i64 %449, 6 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.6 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %461 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %462 = load i8, ptr %arrayidx1828.6, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.6 = icmp eq i8 %462, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4149 = select i1 %tobool.not.6, i8 %spec.store.select4148, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4149, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %463 = or disjoint i64 %449, 7 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.7 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %463 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %464 = load i8, ptr %arrayidx1828.7, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.7 = icmp eq i8 %464, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4150 = select i1 %tobool.not.7, i8 %spec.store.select4149, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4150, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %465 = or disjoint i64 %449, 8 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.8 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %465 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %466 = load i8, ptr %arrayidx1828.8, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.8 = icmp eq i8 %466, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4151 = select i1 %tobool.not.8, i8 %spec.store.select4150, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4151, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %467 = or disjoint i64 %449, 9 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.9 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %467 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %468 = load i8, ptr %arrayidx1828.9, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.9 = icmp eq i8 %468, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4152 = select i1 %tobool.not.9, i8 %spec.store.select4151, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4152, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %469 = or disjoint i64 %449, 10 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.10 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %469 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %470 = load i8, ptr %arrayidx1828.10, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.10 = icmp eq i8 %470, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4153 = select i1 %tobool.not.10, i8 %spec.store.select4152, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4153, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %471 = or disjoint i64 %449, 11 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.11 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %471 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %472 = load i8, ptr %arrayidx1828.11, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.11 = icmp eq i8 %472, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4154 = select i1 %tobool.not.11, i8 %spec.store.select4153, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4154, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %473 = or disjoint i64 %449, 12 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.12 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %473 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %474 = load i8, ptr %arrayidx1828.12, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.12 = icmp eq i8 %474, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4155 = select i1 %tobool.not.12, i8 %spec.store.select4154, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4155, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %475 = or disjoint i64 %449, 13 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.13 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %475 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %476 = load i8, ptr %arrayidx1828.13, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.13 = icmp eq i8 %476, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4156 = select i1 %tobool.not.13, i8 %spec.store.select4155, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4156, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %477 = or disjoint i64 %449, 14 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.14 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %477 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %478 = load i8, ptr %arrayidx1828.14, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.14 = icmp eq i8 %478, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4157 = select i1 %tobool.not.14, i8 %spec.store.select4156, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4157, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %479 = or disjoint i64 %449, 15 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1828.15 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %479 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %480 = load i8, ptr %arrayidx1828.15, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %tobool.not.15 = icmp eq i8 %480, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.store.select4158 = select i1 %tobool.not.15, i8 %spec.store.select4157, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %spec.store.select4158, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next4058 = add nuw nsw i64 %indvars.iv4057, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond4061.not = icmp eq i64 %indvars.iv.next4058, 16 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond4061.not, label %for.end1838, label %for.body1818 of type:br
LV: Vector loop of width 2 costs: 299
A is not scalable.	B is not scalable.	
RTCostA: 4784, RTCostB: 1856
A is not scalable.	B is not scalable.	
RTCostA: 4784, RTCostB: 1856

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv4057 = phi i64 [ 0, %for.end1814 ], [ %indvars.iv.next4058, %for.body1818 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1820 = getelementptr inbounds [16 x i8], ptr %inUse16, i64 0, i64 %indvars.iv4057 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 0, ptr %arrayidx1820, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %449 = shl nuw nsw i64 %indvars.iv4057, 4 of type:shl
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %449 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %450 = load i8, ptr %arrayidx1828, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not = icmp ne i8 %450, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select = zext i1 %tobool.not to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %451 = or disjoint i64 %449, 1 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.1 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %451 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %452 = load i8, ptr %arrayidx1828.1, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.1 = icmp eq i8 %452, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4142 = select i1 %tobool.not.1, i8 %spec.store.select, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4142, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %453 = or disjoint i64 %449, 2 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.2 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %453 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %454 = load i8, ptr %arrayidx1828.2, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.2 = icmp eq i8 %454, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4145 = select i1 %tobool.not.2, i8 %spec.store.select4142, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4145, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %455 = or disjoint i64 %449, 3 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.3 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %455 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %456 = load i8, ptr %arrayidx1828.3, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.3 = icmp eq i8 %456, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4146 = select i1 %tobool.not.3, i8 %spec.store.select4145, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4146, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %457 = or disjoint i64 %449, 4 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.4 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %457 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %458 = load i8, ptr %arrayidx1828.4, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.4 = icmp eq i8 %458, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4147 = select i1 %tobool.not.4, i8 %spec.store.select4146, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4147, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %459 = or disjoint i64 %449, 5 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.5 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %459 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %460 = load i8, ptr %arrayidx1828.5, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.5 = icmp eq i8 %460, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4148 = select i1 %tobool.not.5, i8 %spec.store.select4147, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4148, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %461 = or disjoint i64 %449, 6 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.6 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %461 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %462 = load i8, ptr %arrayidx1828.6, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.6 = icmp eq i8 %462, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4149 = select i1 %tobool.not.6, i8 %spec.store.select4148, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4149, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %463 = or disjoint i64 %449, 7 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.7 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %463 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %464 = load i8, ptr %arrayidx1828.7, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.7 = icmp eq i8 %464, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4150 = select i1 %tobool.not.7, i8 %spec.store.select4149, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4150, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %465 = or disjoint i64 %449, 8 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.8 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %465 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %466 = load i8, ptr %arrayidx1828.8, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.8 = icmp eq i8 %466, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4151 = select i1 %tobool.not.8, i8 %spec.store.select4150, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4151, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %467 = or disjoint i64 %449, 9 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.9 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %467 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %468 = load i8, ptr %arrayidx1828.9, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.9 = icmp eq i8 %468, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4152 = select i1 %tobool.not.9, i8 %spec.store.select4151, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4152, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %469 = or disjoint i64 %449, 10 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.10 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %469 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %470 = load i8, ptr %arrayidx1828.10, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.10 = icmp eq i8 %470, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4153 = select i1 %tobool.not.10, i8 %spec.store.select4152, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4153, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %471 = or disjoint i64 %449, 11 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.11 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %471 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %472 = load i8, ptr %arrayidx1828.11, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.11 = icmp eq i8 %472, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4154 = select i1 %tobool.not.11, i8 %spec.store.select4153, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4154, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %473 = or disjoint i64 %449, 12 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.12 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %473 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %474 = load i8, ptr %arrayidx1828.12, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.12 = icmp eq i8 %474, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4155 = select i1 %tobool.not.12, i8 %spec.store.select4154, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4155, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %475 = or disjoint i64 %449, 13 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.13 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %475 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %476 = load i8, ptr %arrayidx1828.13, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.13 = icmp eq i8 %476, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4156 = select i1 %tobool.not.13, i8 %spec.store.select4155, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4156, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %477 = or disjoint i64 %449, 14 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.14 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %477 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %478 = load i8, ptr %arrayidx1828.14, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.14 = icmp eq i8 %478, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4157 = select i1 %tobool.not.14, i8 %spec.store.select4156, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4157, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %479 = or disjoint i64 %449, 15 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1828.15 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %479 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %480 = load i8, ptr %arrayidx1828.15, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %tobool.not.15 = icmp eq i8 %480, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.store.select4158 = select i1 %tobool.not.15, i8 %spec.store.select4157, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %spec.store.select4158, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next4058 = add nuw nsw i64 %indvars.iv4057, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond4061.not = icmp eq i64 %indvars.iv.next4058, 16 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond4061.not, label %for.end1838, label %for.body1818 of type:br
LV: Vector loop of width 4 costs: 265
A is not scalable.	B is not scalable.	
RTCostA: 4244, RTCostB: 1856
A is not scalable.	B is not scalable.	
RTCostA: 4244, RTCostB: 1856

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv4057 = phi i64 [ 0, %for.end1814 ], [ %indvars.iv.next4058, %for.body1818 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1820 = getelementptr inbounds [16 x i8], ptr %inUse16, i64 0, i64 %indvars.iv4057 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 0, ptr %arrayidx1820, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %449 = shl nuw nsw i64 %indvars.iv4057, 4 of type:shl
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %449 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %450 = load i8, ptr %arrayidx1828, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not = icmp ne i8 %450, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select = zext i1 %tobool.not to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %451 = or disjoint i64 %449, 1 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.1 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %451 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %452 = load i8, ptr %arrayidx1828.1, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.1 = icmp eq i8 %452, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4142 = select i1 %tobool.not.1, i8 %spec.store.select, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4142, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %453 = or disjoint i64 %449, 2 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.2 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %453 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %454 = load i8, ptr %arrayidx1828.2, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.2 = icmp eq i8 %454, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4145 = select i1 %tobool.not.2, i8 %spec.store.select4142, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4145, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %455 = or disjoint i64 %449, 3 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.3 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %455 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %456 = load i8, ptr %arrayidx1828.3, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.3 = icmp eq i8 %456, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4146 = select i1 %tobool.not.3, i8 %spec.store.select4145, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4146, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %457 = or disjoint i64 %449, 4 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.4 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %457 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %458 = load i8, ptr %arrayidx1828.4, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.4 = icmp eq i8 %458, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4147 = select i1 %tobool.not.4, i8 %spec.store.select4146, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4147, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %459 = or disjoint i64 %449, 5 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.5 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %459 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %460 = load i8, ptr %arrayidx1828.5, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.5 = icmp eq i8 %460, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4148 = select i1 %tobool.not.5, i8 %spec.store.select4147, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4148, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %461 = or disjoint i64 %449, 6 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.6 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %461 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %462 = load i8, ptr %arrayidx1828.6, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.6 = icmp eq i8 %462, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4149 = select i1 %tobool.not.6, i8 %spec.store.select4148, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4149, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %463 = or disjoint i64 %449, 7 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.7 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %463 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %464 = load i8, ptr %arrayidx1828.7, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.7 = icmp eq i8 %464, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4150 = select i1 %tobool.not.7, i8 %spec.store.select4149, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4150, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %465 = or disjoint i64 %449, 8 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.8 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %465 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %466 = load i8, ptr %arrayidx1828.8, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.8 = icmp eq i8 %466, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4151 = select i1 %tobool.not.8, i8 %spec.store.select4150, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4151, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %467 = or disjoint i64 %449, 9 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.9 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %467 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %468 = load i8, ptr %arrayidx1828.9, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.9 = icmp eq i8 %468, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4152 = select i1 %tobool.not.9, i8 %spec.store.select4151, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4152, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %469 = or disjoint i64 %449, 10 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.10 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %469 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %470 = load i8, ptr %arrayidx1828.10, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.10 = icmp eq i8 %470, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4153 = select i1 %tobool.not.10, i8 %spec.store.select4152, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4153, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %471 = or disjoint i64 %449, 11 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.11 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %471 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %472 = load i8, ptr %arrayidx1828.11, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.11 = icmp eq i8 %472, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4154 = select i1 %tobool.not.11, i8 %spec.store.select4153, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4154, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %473 = or disjoint i64 %449, 12 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.12 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %473 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %474 = load i8, ptr %arrayidx1828.12, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.12 = icmp eq i8 %474, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4155 = select i1 %tobool.not.12, i8 %spec.store.select4154, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4155, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %475 = or disjoint i64 %449, 13 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.13 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %475 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %476 = load i8, ptr %arrayidx1828.13, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.13 = icmp eq i8 %476, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4156 = select i1 %tobool.not.13, i8 %spec.store.select4155, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4156, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %477 = or disjoint i64 %449, 14 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.14 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %477 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %478 = load i8, ptr %arrayidx1828.14, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.14 = icmp eq i8 %478, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4157 = select i1 %tobool.not.14, i8 %spec.store.select4156, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4157, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %479 = or disjoint i64 %449, 15 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1828.15 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %479 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %480 = load i8, ptr %arrayidx1828.15, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 8 For instruction:   %tobool.not.15 = icmp eq i8 %480, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 8 For instruction:   %spec.store.select4158 = select i1 %tobool.not.15, i8 %spec.store.select4157, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %spec.store.select4158, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next4058 = add nuw nsw i64 %indvars.iv4057, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond4061.not = icmp eq i64 %indvars.iv.next4058, 16 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond4061.not, label %for.end1838, label %for.body1818 of type:br
LV: Vector loop of width 8 costs: 254
A is not scalable.	B is not scalable.	
RTCostA: 4076, RTCostB: 1856
A is not scalable.	B is not scalable.	
RTCostA: 4076, RTCostB: 1856

-----------------Function that is being costed:'sendMTFValues' from compress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv4057 = phi i64 [ 0, %for.end1814 ], [ %indvars.iv.next4058, %for.body1818 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1820 = getelementptr inbounds [16 x i8], ptr %inUse16, i64 0, i64 %indvars.iv4057 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 0, ptr %arrayidx1820, align 1, !tbaa !17 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %449 = shl nuw nsw i64 %indvars.iv4057, 4 of type:shl
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %449 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %450 = load i8, ptr %arrayidx1828, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not = icmp ne i8 %450, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select = zext i1 %tobool.not to i8 of type:zext
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %451 = or disjoint i64 %449, 1 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.1 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %451 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %452 = load i8, ptr %arrayidx1828.1, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.1 = icmp eq i8 %452, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4142 = select i1 %tobool.not.1, i8 %spec.store.select, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4142, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %453 = or disjoint i64 %449, 2 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.2 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %453 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %454 = load i8, ptr %arrayidx1828.2, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.2 = icmp eq i8 %454, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4145 = select i1 %tobool.not.2, i8 %spec.store.select4142, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4145, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %455 = or disjoint i64 %449, 3 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.3 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %455 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %456 = load i8, ptr %arrayidx1828.3, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.3 = icmp eq i8 %456, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4146 = select i1 %tobool.not.3, i8 %spec.store.select4145, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4146, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %457 = or disjoint i64 %449, 4 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.4 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %457 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %458 = load i8, ptr %arrayidx1828.4, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.4 = icmp eq i8 %458, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4147 = select i1 %tobool.not.4, i8 %spec.store.select4146, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4147, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %459 = or disjoint i64 %449, 5 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.5 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %459 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %460 = load i8, ptr %arrayidx1828.5, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.5 = icmp eq i8 %460, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4148 = select i1 %tobool.not.5, i8 %spec.store.select4147, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4148, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %461 = or disjoint i64 %449, 6 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.6 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %461 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %462 = load i8, ptr %arrayidx1828.6, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.6 = icmp eq i8 %462, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4149 = select i1 %tobool.not.6, i8 %spec.store.select4148, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4149, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %463 = or disjoint i64 %449, 7 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.7 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %463 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %464 = load i8, ptr %arrayidx1828.7, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.7 = icmp eq i8 %464, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4150 = select i1 %tobool.not.7, i8 %spec.store.select4149, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4150, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %465 = or disjoint i64 %449, 8 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.8 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %465 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %466 = load i8, ptr %arrayidx1828.8, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.8 = icmp eq i8 %466, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4151 = select i1 %tobool.not.8, i8 %spec.store.select4150, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4151, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %467 = or disjoint i64 %449, 9 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.9 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %467 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %468 = load i8, ptr %arrayidx1828.9, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.9 = icmp eq i8 %468, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4152 = select i1 %tobool.not.9, i8 %spec.store.select4151, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4152, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %469 = or disjoint i64 %449, 10 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.10 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %469 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %470 = load i8, ptr %arrayidx1828.10, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.10 = icmp eq i8 %470, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4153 = select i1 %tobool.not.10, i8 %spec.store.select4152, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4153, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %471 = or disjoint i64 %449, 11 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.11 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %471 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %472 = load i8, ptr %arrayidx1828.11, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.11 = icmp eq i8 %472, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4154 = select i1 %tobool.not.11, i8 %spec.store.select4153, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4154, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %473 = or disjoint i64 %449, 12 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.12 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %473 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %474 = load i8, ptr %arrayidx1828.12, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.12 = icmp eq i8 %474, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4155 = select i1 %tobool.not.12, i8 %spec.store.select4154, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4155, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %475 = or disjoint i64 %449, 13 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.13 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %475 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %476 = load i8, ptr %arrayidx1828.13, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.13 = icmp eq i8 %476, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4156 = select i1 %tobool.not.13, i8 %spec.store.select4155, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4156, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %477 = or disjoint i64 %449, 14 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.14 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %477 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %478 = load i8, ptr %arrayidx1828.14, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.14 = icmp eq i8 %478, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4157 = select i1 %tobool.not.14, i8 %spec.store.select4156, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4157, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %479 = or disjoint i64 %449, 15 of type:or
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1828.15 = getelementptr inbounds [256 x i8], ptr %inUse, i64 0, i64 %479 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %480 = load i8, ptr %arrayidx1828.15, align 1, !tbaa !17 of type:load
LV: Found an estimated cost of 1 for VF 16 For instruction:   %tobool.not.15 = icmp eq i8 %480, 0 of type:icmp
LV: Found an estimated cost of 1 for VF 16 For instruction:   %spec.store.select4158 = select i1 %tobool.not.15, i8 %spec.store.select4157, i8 1 of type:select
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %spec.store.select4158, ptr %arrayidx1820, align 1 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next4058 = add nuw nsw i64 %indvars.iv4057, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond4061.not = icmp eq i64 %indvars.iv.next4058, 16 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond4061.not, label %for.end1838, label %for.body1818 of type:br
LV: Vector loop of width 16 costs: 251
A is not scalable.	B is not scalable.	
RTCostA: 4026, RTCostB: 1856
A is not scalable.	B is not scalable.	
RTCostA: 4026, RTCostB: 1856
LV: Selecting VF: 1 With Cost: 116.
maxbefore: 2
maxafter: 2
================================================
Loops Vectorized: 4
Loops Analyzed: 23
Loops Epilogues Vectorized: 2
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o crctable.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                crctable.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o decompress.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                decompress.c
@@ Instruction =>  store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nGroups.1> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %v1442.05078 = phi %inc1451, 0, ir<1>
    CLONE ir<%idxprom1448> = zext ir<%v1442.05078>
    CLONE ir<%arrayidx1449> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1448>
    CLONE store ir<%v1442.05078>, ir<%arrayidx1449>
    CLONE ir<%inc1451> = add ir<%v1442.05078>, ir<1>
    CLONE ir<%conv1444> = zext ir<%inc1451>
    CLONE ir<%cmp1445> = icmp ugt ir<%nGroups.1>, ir<%conv1444>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<%nGroups.1>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.cond1453.preheader.loopexit>, scalar.ph

ir-bb<for.cond1453.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nGroups.1> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %v1442.05078 = phi %inc1451, 0, ir<1>
    CLONE ir<%idxprom1448> = zext ir<%v1442.05078>
    CLONE ir<%arrayidx1449> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1448>
    vp<%3> = vector-pointer ir<%arrayidx1449>
    WIDEN store vp<%3>, ir<%v1442.05078>
    WIDEN ir<%inc1451> = add ir<%v1442.05078>, ir<1>
    CLONE ir<%conv1444> = zext ir<%inc1451>
    CLONE ir<%cmp1445> = icmp ugt ir<%nGroups.1>, ir<%conv1444>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%nGroups.1>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond1453.preheader.loopexit>, scalar.ph

ir-bb<for.cond1453.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nGroups.1> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %v1442.05078 = phi %inc1451, 0, ir<1>
    CLONE ir<%idxprom1448> = zext ir<%v1442.05078>
    CLONE ir<%arrayidx1449> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1448>
    vp<%3> = vector-pointer ir<%arrayidx1449>
    WIDEN store vp<%3>, ir<%v1442.05078>
    WIDEN ir<%inc1451> = add ir<%v1442.05078>, ir<1>
    CLONE ir<%conv1444> = zext ir<%inc1451>
    CLONE ir<%cmp1445> = icmp ugt ir<%nGroups.1>, ir<%conv1444>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<%nGroups.1>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.cond1453.preheader.loopexit>, scalar.ph

ir-bb<for.cond1453.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Scalar loop costs: 5.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 10
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 7
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 7, CostB * EstimatedWidthA: 10
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 5, CostB * EstimatedWidthA: 20
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 28
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Vector loop of width 8 costs: 0
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 40
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 40
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 80
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 10
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 8

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 20
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 40
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 32

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 80
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %v1442.05078 = phi i8 [ %inc1451, %for.body1447 ], [ 0, %for.body1447.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %idxprom1448 = zext i8 %v1442.05078 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1449 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1448 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   store i8 %v1442.05078, ptr %arrayidx1449, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %inc1451 = add i8 %v1442.05078, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %conv1444 = zext i8 %inc1451 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp1445 = icmp ugt i32 %nGroups.1, %conv1444 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp1445, label %for.body1447, label %for.cond1453.preheader.loopexit of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: 1, EstimatedWidthB: 1, CostB: 5
CostA * EstimatedWidthB: 4, CostB * EstimatedWidthA: 160
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 4
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 5
B VF: 2, EstimatedWidthB: 2, CostB: 7
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 28
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 4
B VF: 4, EstimatedWidthB: 4, CostB: 5
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 40
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 4
B VF: 8, EstimatedWidthB: 8, CostB: 4
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 32
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 4
B VF: 16, EstimatedWidthB: 16, CostB: 4
CostA * EstimatedWidthB: 64, CostB * EstimatedWidthA: 64
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: BZ2_decompress at line: decompress.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nGroups.1> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %v1442.05078 = phi %inc1451, 0, ir<1>
    vp<%4>    = DERIVED-IV ir<0> + vp<%2> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%idxprom1448> = zext vp<%5>
    CLONE ir<%arrayidx1449> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1448>
    vp<%6> = vector-pointer ir<%arrayidx1449>
    WIDEN store vp<%6>, vp<%3>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%nGroups.1>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.cond1453.preheader.loopexit>, scalar.ph

ir-bb<for.cond1453.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%nGroups.1> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %v1442.05078 = phi %inc1451, 0, ir<1>
    vp<%3>    = DERIVED-IV ir<0> + vp<%2> * ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%idxprom1448> = zext vp<%4>
    CLONE ir<%arrayidx1449> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1448>
    vp<%5> = vector-pointer ir<%arrayidx1449>
    WIDEN store vp<%5>, ir<%v1442.05078>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<%nGroups.1>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond1453.preheader.loopexit>, scalar.ph

ir-bb<for.cond1453.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

MVT: v2i32
@@ Instruction =>  %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1466.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %903 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom1460, ir<-1>
    CLONE ir<%sub1468> = add nuw nsw ir<%indvars.iv>, ir<4294967295>
    CLONE ir<%idxprom1469> = and ir<%sub1468>, ir<4294967295>
    CLONE ir<%arrayidx1470> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1469>
    CLONE ir<%905> = load ir<%arrayidx1470>
    CLONE ir<%arrayidx1472> = getelementptr inbounds ir<%pos>, ir<0>, ir<%indvars.iv>
    CLONE store ir<%905>, ir<%arrayidx1472>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%906> = and ir<%indvars.iv.next>, ir<255>
    CLONE ir<%cmp1464.not> = icmp eq ir<%906>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end1474.loopexit>, scalar.ph

ir-bb<while.end1474.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1466.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %903 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom1460, ir<-1>
    CLONE ir<%sub1468> = add nuw nsw ir<%indvars.iv>, ir<4294967295>
    CLONE ir<%idxprom1469> = and ir<%sub1468>, ir<4294967295>
    CLONE ir<%arrayidx1470> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1469>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx1470>
    WIDEN ir<%905> = load vp<%4>
    CLONE ir<%arrayidx1472> = getelementptr inbounds ir<%pos>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx1472>
    WIDEN store vp<%5>, ir<%905>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%906> = and ir<%indvars.iv.next>, ir<255>
    CLONE ir<%cmp1464.not> = icmp eq ir<%906>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end1474.loopexit>, scalar.ph

ir-bb<while.end1474.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1466.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %903 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, %idxprom1460, ir<-1>
    CLONE ir<%sub1468> = add nuw nsw ir<%indvars.iv>, ir<4294967295>
    CLONE ir<%idxprom1469> = and ir<%sub1468>, ir<4294967295>
    CLONE ir<%arrayidx1470> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1469>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx1470>
    WIDEN ir<%905> = load vp<%4>
    CLONE ir<%arrayidx1472> = getelementptr inbounds ir<%pos>, ir<0>, ir<%indvars.iv>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx1472>
    WIDEN store vp<%5>, ir<%905>
    CLONE ir<%indvars.iv.next> = add nsw ir<%indvars.iv>, ir<-1>
    CLONE ir<%906> = and ir<%indvars.iv.next>, ir<255>
    CLONE ir<%cmp1464.not> = icmp eq ir<%906>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end1474.loopexit>, scalar.ph

ir-bb<while.end1474.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
RTCostA: 1786, RTCostB: 2040
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 1786, RTCostB: 2040
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 654, RTCostB: 2040
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 654, RTCostB: 1786
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF 8 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 304, RTCostB: 2040
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 304, RTCostB: 654
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 16 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF 16 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
RTCostA: 270, RTCostB: 2040
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 270, RTCostB: 304
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2040
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 270

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
RTCostA: 528, RTCostB: 2040
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 528, RTCostB: 270

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 304, RTCostB: 2040
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 304, RTCostB: 270

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 240, RTCostB: 2040
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 240, RTCostB: 270
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %while.body1466 ], [ %idxprom1460, %while.body1466.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %sub1468 = add nuw nsw i64 %indvars.iv, 4294967295 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %idxprom1469 = and i64 %sub1468, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1470 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %idxprom1469 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %905 = load i8, ptr %arrayidx1470, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx1472 = getelementptr inbounds [6 x i8], ptr %pos, i64 0, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %905, ptr %arrayidx1472, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next = add nsw i64 %indvars.iv, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %906 = and i64 %indvars.iv.next, 255 of type:and
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %cmp1464.not = icmp eq i64 %906, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp1464.not, label %while.end1474.loopexit, label %while.body1466 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 304, RTCostB: 2040
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 304, RTCostB: 240
LV: Selecting VF: vscale x 8 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
RTCostA: 654, RTCostB: 1786
A is not scalable.	B is not scalable.	
RTCostA: 304, RTCostB: 654
A is scalable.	B is not scalable.	
RTCostA: 528, RTCostB: 304
A is scalable.	B is not scalable.	
RTCostA: 304, RTCostB: 304
LEV: Vectorizing epilogue loop with VF = vscale x 4 at function: BZ2_decompress at line: decompress.c
LEV: EpilogueVF.Width: vscale x 4
Executing best plan with VF=vscale x 8, UF=2 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body1466.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i8 %903 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<%idxprom1460> + vp<%3> * ir<-1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<-1>
    CLONE ir<%sub1468> = add nuw nsw vp<%5>, ir<4294967295>
    CLONE ir<%idxprom1469> = and ir<%sub1468>, ir<4294967295>
    CLONE ir<%arrayidx1470> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1469>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx1470>
    WIDEN ir<%932> = load vp<%6>
    CLONE ir<%arrayidx1472> = getelementptr inbounds ir<%pos>, ir<0>, vp<%5>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx1472>
    WIDEN store vp<%7>, ir<%932>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.end1474.loopexit>, scalar.ph

ir-bb<while.end1474.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 4, UF=1 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%idxprom1460> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3>    = DERIVED-IV ir<%idxprom1460> + vp<%2> * ir<-1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<-1>
    CLONE ir<%sub1468> = add nuw nsw vp<%4>, ir<4294967295>
    CLONE ir<%idxprom1469> = and ir<%sub1468>, ir<4294967295>
    CLONE ir<%arrayidx1470> = getelementptr inbounds ir<%pos>, ir<0>, ir<%idxprom1469>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx1470>
    WIDEN ir<%979> = load vp<%5>
    CLONE ir<%arrayidx1472> = getelementptr inbounds ir<%pos>, ir<0>, vp<%4>
    vp<%6> = vector-pointer (reverse) ir<%arrayidx1472>
    WIDEN store vp<%6>, ir<%979>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<%idxprom1460>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.end1474.loopexit>, scalar.ph

ir-bb<while.end1474.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 -> Cost: 4 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)
@@ Instruction =>  %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)
@@ Instruction =>  %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> 
@@ Instruction =>  %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 -> Cost: 1 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)
========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1685.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %alphaSize.5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5272 = phi %indvars.iv.next5273, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%minLen.05087> = phi ir<32>, ir<%minLen.1>
    WIDEN-REDUCTION-PHI ir<%maxLen.05086> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx1690> = getelementptr inbounds ir<%len1686>, ir<0>, ir<%indvars.iv5278>, ir<%indvars.iv5272>
    CLONE ir<%1136> = load ir<%arrayidx1690>
    CLONE ir<%conv1691> = zext ir<%1136>
    CLONE ir<%spec.select> = call @llvm.smax.i32(ir<%maxLen.05086>, ir<%conv1691>)
    CLONE ir<%minLen.1> = call @llvm.smin.i32(ir<%minLen.05087>, ir<%conv1691>)
    CLONE ir<%indvars.iv.next5273> = add nuw nsw ir<%indvars.iv5272>, ir<1>
    CLONE ir<%exitcond5277.not> = icmp eq ir<%indvars.iv.next5273>, ir<%wide.trip.count5276>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = compute-reduction-result ir<%minLen.05087>, ir<%minLen.1>
  EMIT vp<%7> = compute-reduction-result ir<%maxLen.05086>, ir<%spec.select>
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.end1720.loopexit>, scalar.ph

ir-bb<for.end1720.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%7>
Live-out i32 %minLen.1.lcssa = vp<%6>
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1685.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %alphaSize.5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv5272 = phi %indvars.iv.next5273, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%minLen.05087> = phi ir<32>, ir<%minLen.1>
    WIDEN-REDUCTION-PHI ir<%maxLen.05086> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx1690> = getelementptr inbounds ir<%len1686>, ir<0>, ir<%indvars.iv5278>, ir<%indvars.iv5272>
    vp<%4> = vector-pointer ir<%arrayidx1690>
    WIDEN ir<%1136> = load vp<%4>
    WIDEN-CAST ir<%conv1691> = zext  ir<%1136> to i32
    WIDEN-CALL ir<%spec.select> = call @llvm.smax.i32(ir<%maxLen.05086>, ir<%conv1691>) (using vector intrinsic)
    WIDEN-CALL ir<%minLen.1> = call @llvm.smin.i32(ir<%minLen.05087>, ir<%conv1691>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next5273> = add nuw nsw ir<%indvars.iv5272>, ir<1>
    CLONE ir<%exitcond5277.not> = icmp eq ir<%indvars.iv.next5273>, ir<%wide.trip.count5276>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%minLen.05087>, ir<%minLen.1>
  EMIT vp<%8> = compute-reduction-result ir<%maxLen.05086>, ir<%spec.select>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end1720.loopexit>, scalar.ph

ir-bb<for.end1720.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%8>
Live-out i32 %minLen.1.lcssa = vp<%7>
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1685.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %alphaSize.5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv5272 = phi %indvars.iv.next5273, 0, ir<1>
    WIDEN-REDUCTION-PHI ir<%minLen.05087> = phi ir<32>, ir<%minLen.1>
    WIDEN-REDUCTION-PHI ir<%maxLen.05086> = phi ir<0>, ir<%spec.select>
    CLONE ir<%arrayidx1690> = getelementptr inbounds ir<%len1686>, ir<0>, ir<%indvars.iv5278>, ir<%indvars.iv5272>
    vp<%4> = vector-pointer ir<%arrayidx1690>
    WIDEN ir<%1136> = load vp<%4>
    WIDEN-CAST ir<%conv1691> = zext  ir<%1136> to i32
    WIDEN-CALL ir<%spec.select> = call @llvm.smax.i32(ir<%maxLen.05086>, ir<%conv1691>) (using vector intrinsic)
    WIDEN-CALL ir<%minLen.1> = call @llvm.smin.i32(ir<%minLen.05087>, ir<%conv1691>) (using vector intrinsic)
    CLONE ir<%indvars.iv.next5273> = add nuw nsw ir<%indvars.iv5272>, ir<1>
    CLONE ir<%exitcond5277.not> = icmp eq ir<%indvars.iv.next5273>, ir<%wide.trip.count5276>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = compute-reduction-result ir<%minLen.05087>, ir<%minLen.1>
  EMIT vp<%8> = compute-reduction-result ir<%maxLen.05086>, ir<%spec.select>
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end1720.loopexit>, scalar.ph

ir-bb<for.end1720.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%8>
Live-out i32 %minLen.1.lcssa = vp<%7>
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv5272 = phi i64 [ %indvars.iv.next5273, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %minLen.05087 = phi i32 [ %minLen.1, %for.body1685 ], [ 32, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %maxLen.05086 = phi i32 [ %spec.select, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1690 = getelementptr inbounds [6 x [258 x i8]], ptr %len1686, i64 0, i64 %indvars.iv5278, i64 %indvars.iv5272 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv1691 = zext i8 %1136 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 1 For instruction:   %spec.select = tail call i32 @llvm.smax.i32(i32 %maxLen.05086, i32 %conv1691) of type:call
LV: Found an estimated cost of 2 for VF 1 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.05087, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5273 = add nuw nsw i64 %indvars.iv5272, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond5277.not = icmp eq i64 %indvars.iv.next5273, %wide.trip.count5276 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond5277.not, label %for.end1720.loopexit, label %for.body1685 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv5272 = phi i64 [ %indvars.iv.next5273, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %minLen.05087 = phi i32 [ %minLen.1, %for.body1685 ], [ 32, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %maxLen.05086 = phi i32 [ %spec.select, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1690 = getelementptr inbounds [6 x [258 x i8]], ptr %len1686, i64 0, i64 %indvars.iv5278, i64 %indvars.iv5272 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 4 for VF 2 For instruction:   %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1691 = zext i8 %1136 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = tail call i32 @llvm.smax.i32(i32 %maxLen.05086, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.05087, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5273 = add nuw nsw i64 %indvars.iv5272, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond5277.not = icmp eq i64 %indvars.iv.next5273, %wide.trip.count5276 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond5277.not, label %for.end1720.loopexit, label %for.body1685 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
RTCostA: 9663676415, RTCostB: 17179869176
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 9663676415, RTCostB: 17179869176
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv5272 = phi i64 [ %indvars.iv.next5273, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %minLen.05087 = phi i32 [ %minLen.1, %for.body1685 ], [ 32, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %maxLen.05086 = phi i32 [ %spec.select, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1690 = getelementptr inbounds [6 x [258 x i8]], ptr %len1686, i64 0, i64 %indvars.iv5278, i64 %indvars.iv5272 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1691 = zext i8 %1136 to i32 of type:zext
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = tail call i32 @llvm.smax.i32(i32 %maxLen.05086, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.05087, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next5273 = add nuw nsw i64 %indvars.iv5272, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond5277.not = icmp eq i64 %indvars.iv.next5273, %wide.trip.count5276 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond5277.not, label %for.end1720.loopexit, label %for.body1685 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096401, RTCostB: 17179869176
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3758096401, RTCostB: 9663676415
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv5272 = phi i64 [ %indvars.iv.next5273, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %minLen.05087 = phi i32 [ %minLen.1, %for.body1685 ], [ 32, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %maxLen.05086 = phi i32 [ %spec.select, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1690 = getelementptr inbounds [6 x [258 x i8]], ptr %len1686, i64 0, i64 %indvars.iv5278, i64 %indvars.iv5272 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 8 For instruction:   %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 3 for VF 8 For instruction:   %conv1691 = zext i8 %1136 to i32 of type:zext
LV: Found an estimated cost of 2 for VF 8 For instruction:   %spec.select = tail call i32 @llvm.smax.i32(i32 %maxLen.05086, i32 %conv1691) of type:call
LV: Found an estimated cost of 2 for VF 8 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.05087, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next5273 = add nuw nsw i64 %indvars.iv5272, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond5277.not = icmp eq i64 %indvars.iv.next5273, %wide.trip.count5276 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond5277.not, label %for.end1720.loopexit, label %for.body1685 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354606, RTCostB: 17179869176
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2684354606, RTCostB: 3758096401
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv5272 = phi i64 [ %indvars.iv.next5273, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %minLen.05087 = phi i32 [ %minLen.1, %for.body1685 ], [ 32, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %maxLen.05086 = phi i32 [ %spec.select, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx1690 = getelementptr inbounds [6 x [258 x i8]], ptr %len1686, i64 0, i64 %indvars.iv5278, i64 %indvars.iv5272 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 16 For instruction:   %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 6 for VF 16 For instruction:   %conv1691 = zext i8 %1136 to i32 of type:zext
LV: Found an estimated cost of 4 for VF 16 For instruction:   %spec.select = tail call i32 @llvm.smax.i32(i32 %maxLen.05086, i32 %conv1691) of type:call
LV: Found an estimated cost of 4 for VF 16 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.05087, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next5273 = add nuw nsw i64 %indvars.iv5272, 1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %exitcond5277.not = icmp eq i64 %indvars.iv.next5273, %wide.trip.count5276 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %exitcond5277.not, label %for.end1720.loopexit, label %for.body1685 of type:br
LV: Vector loop of width 16 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 2281701479, RTCostB: 17179869176
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 2281701479, RTCostB: 2684354606
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv5272 = phi i64 [ %indvars.iv.next5273, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %minLen.05087 = phi i32 [ %minLen.1, %for.body1685 ], [ 32, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %maxLen.05086 = phi i32 [ %spec.select, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1690 = getelementptr inbounds [6 x [258 x i8]], ptr %len1686, i64 0, i64 %indvars.iv5278, i64 %indvars.iv5272 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %conv1691 = zext i8 %1136 to i32 of type:zext
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = tail call i32 @llvm.smax.i32(i32 %maxLen.05086, i32 %conv1691) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.05087, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next5273 = add nuw nsw i64 %indvars.iv5272, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond5277.not = icmp eq i64 %indvars.iv.next5273, %wide.trip.count5276 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond5277.not, label %for.end1720.loopexit, label %for.body1685 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 2281701479

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv5272 = phi i64 [ %indvars.iv.next5273, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %minLen.05087 = phi i32 [ %minLen.1, %for.body1685 ], [ 32, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %maxLen.05086 = phi i32 [ %spec.select, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1690 = getelementptr inbounds [6 x [258 x i8]], ptr %len1686, i64 0, i64 %indvars.iv5278, i64 %indvars.iv5272 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1691 = zext i8 %1136 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = tail call i32 @llvm.smax.i32(i32 %maxLen.05086, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.05087, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5273 = add nuw nsw i64 %indvars.iv5272, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond5277.not = icmp eq i64 %indvars.iv.next5273, %wide.trip.count5276 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond5277.not, label %for.end1720.loopexit, label %for.body1685 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 17179869176
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225490, RTCostB: 2281701479

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv5272 = phi i64 [ %indvars.iv.next5273, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %minLen.05087 = phi i32 [ %minLen.1, %for.body1685 ], [ 32, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %maxLen.05086 = phi i32 [ %spec.select, %for.body1685 ], [ 0, %for.body1685.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1690 = getelementptr inbounds [6 x [258 x i8]], ptr %len1686, i64 0, i64 %indvars.iv5278, i64 %indvars.iv5272 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1136 = load i8, ptr %arrayidx1690, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %conv1691 = zext i8 %1136 to i32 of type:zext
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = tail call i32 @llvm.smax.i32(i32 %maxLen.05086, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %minLen.1 = tail call i32 @llvm.smin.i32(i32 %minLen.05087, i32 %conv1691) of type:call
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next5273 = add nuw nsw i64 %indvars.iv5272, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond5277.not = icmp eq i64 %indvars.iv.next5273, %wide.trip.count5276 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond5277.not, label %for.end1720.loopexit, label %for.body1685 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1342177331, RTCostB: 17179869176
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 1342177331, RTCostB: 2281701479
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: 16
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body1685.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %alphaSize.5 to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-REDUCTION-PHI ir<%minLen.05087> = phi ir<32>, ir<%minLen.1>
    WIDEN-REDUCTION-PHI ir<%maxLen.05086> = phi ir<0>, ir<%spec.select>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx1690> = getelementptr inbounds ir<%len1686>, ir<0>, ir<%indvars.iv5278>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx1690>
    WIDEN ir<%1136> = load vp<%5>
    WIDEN-CAST ir<%conv1691> = zext  ir<%1136> to i32
    WIDEN-CALL ir<%spec.select> = call @llvm.smax.i32(ir<%maxLen.05086>, ir<%conv1691>) (using vector intrinsic)
    WIDEN-CALL ir<%minLen.1> = call @llvm.smin.i32(ir<%minLen.05087>, ir<%conv1691>) (using vector intrinsic)
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = compute-reduction-result ir<%minLen.05087>, ir<%minLen.1>
  EMIT vp<%9> = compute-reduction-result ir<%maxLen.05086>, ir<%spec.select>
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<for.end1720.loopexit>, scalar.ph

ir-bb<for.end1720.loopexit>:
No successors

scalar.ph:
No successors

Live-out i32 %spec.select.lcssa = vp<%9>
Live-out i32 %minLen.1.lcssa = vp<%8>
}
================ Final VPlan ================

MVT: v4i32
@@ Instruction =>  store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 -> Cost: 6 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(4) = LT.first(2) * (2) -> ASM: [REV64, EXT]
MVT: v4i32
@@ Instruction =>  store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 -> Cost: 12 -> VectorType: <16 x i32> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(8) = LT.first(4) * (2) -> ASM: [REV64, EXT]
MVT: v2i32
@@ Instruction =>  store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 -> Cost: 2 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i32
@@ Instruction =>  store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 -> Cost: 3 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v4i32
@@ Instruction =>  store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 -> Cost: 6 -> VectorType: <8 x i32> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(4) = LT.first(2) * (2) -> ASM: [REV64, EXT]
MVT: nxv4i32
@@ Instruction =>  store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 -> Cost: 2 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 -> Cost: 2 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<16> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv5295 = phi 15, %indvars.iv.next5296, ir<-1>
    WIDEN-INDUCTION %indvars.iv5293 = phi 4095, %indvars.iv.next5294, ir<-16>
    CLONE ir<%1166> = shl nsw ir<%indvars.iv5295>, ir<4>
    CLONE ir<%1167> = trunc ir<%1166>
    CLONE ir<%conv1762> = or disjoint ir<%1167>, ir<15>
    CLONE ir<%arrayidx1764> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv5293>
    CLONE store ir<%conv1762>, ir<%arrayidx1764>
    CLONE ir<%indvars.iv.next5290> = add nsw ir<%indvars.iv5293>, ir<-1>
    CLONE ir<%1168> = trunc ir<%1166>
    CLONE ir<%conv1762.1> = or disjoint ir<%1168>, ir<14>
    CLONE ir<%arrayidx1764.1> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290>
    CLONE store ir<%conv1762.1>, ir<%arrayidx1764.1>
    CLONE ir<%indvars.iv.next5290.1> = add nsw ir<%indvars.iv5293>, ir<-2>
    CLONE ir<%1169> = trunc ir<%1166>
    CLONE ir<%conv1762.2> = or disjoint ir<%1169>, ir<13>
    CLONE ir<%arrayidx1764.2> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.1>
    CLONE store ir<%conv1762.2>, ir<%arrayidx1764.2>
    CLONE ir<%indvars.iv.next5290.2> = add nsw ir<%indvars.iv5293>, ir<-3>
    CLONE ir<%1170> = trunc ir<%1166>
    CLONE ir<%conv1762.3> = or disjoint ir<%1170>, ir<12>
    CLONE ir<%arrayidx1764.3> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.2>
    CLONE store ir<%conv1762.3>, ir<%arrayidx1764.3>
    CLONE ir<%indvars.iv.next5290.3> = add nsw ir<%indvars.iv5293>, ir<-4>
    CLONE ir<%1171> = trunc ir<%1166>
    CLONE ir<%conv1762.4> = or disjoint ir<%1171>, ir<11>
    CLONE ir<%arrayidx1764.4> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.3>
    CLONE store ir<%conv1762.4>, ir<%arrayidx1764.4>
    CLONE ir<%indvars.iv.next5290.4> = add nsw ir<%indvars.iv5293>, ir<-5>
    CLONE ir<%1172> = trunc ir<%1166>
    CLONE ir<%conv1762.5> = or disjoint ir<%1172>, ir<10>
    CLONE ir<%arrayidx1764.5> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.4>
    CLONE store ir<%conv1762.5>, ir<%arrayidx1764.5>
    CLONE ir<%indvars.iv.next5290.5> = add nsw ir<%indvars.iv5293>, ir<-6>
    CLONE ir<%1173> = trunc ir<%1166>
    CLONE ir<%conv1762.6> = or disjoint ir<%1173>, ir<9>
    CLONE ir<%arrayidx1764.6> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.5>
    CLONE store ir<%conv1762.6>, ir<%arrayidx1764.6>
    CLONE ir<%indvars.iv.next5290.6> = add nsw ir<%indvars.iv5293>, ir<-7>
    CLONE ir<%1174> = trunc ir<%1166>
    CLONE ir<%conv1762.7> = or disjoint ir<%1174>, ir<8>
    CLONE ir<%arrayidx1764.7> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.6>
    CLONE store ir<%conv1762.7>, ir<%arrayidx1764.7>
    CLONE ir<%indvars.iv.next5290.7> = add nsw ir<%indvars.iv5293>, ir<-8>
    CLONE ir<%1175> = trunc ir<%1166>
    CLONE ir<%conv1762.8> = or disjoint ir<%1175>, ir<7>
    CLONE ir<%arrayidx1764.8> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.7>
    CLONE store ir<%conv1762.8>, ir<%arrayidx1764.8>
    CLONE ir<%indvars.iv.next5290.8> = add nsw ir<%indvars.iv5293>, ir<-9>
    CLONE ir<%1176> = trunc ir<%1166>
    CLONE ir<%conv1762.9> = or disjoint ir<%1176>, ir<6>
    CLONE ir<%arrayidx1764.9> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.8>
    CLONE store ir<%conv1762.9>, ir<%arrayidx1764.9>
    CLONE ir<%indvars.iv.next5290.9> = add nsw ir<%indvars.iv5293>, ir<-10>
    CLONE ir<%1177> = trunc ir<%1166>
    CLONE ir<%conv1762.10> = or disjoint ir<%1177>, ir<5>
    CLONE ir<%arrayidx1764.10> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.9>
    CLONE store ir<%conv1762.10>, ir<%arrayidx1764.10>
    CLONE ir<%indvars.iv.next5290.10> = add nsw ir<%indvars.iv5293>, ir<-11>
    CLONE ir<%1178> = trunc ir<%1166>
    CLONE ir<%conv1762.11> = or disjoint ir<%1178>, ir<4>
    CLONE ir<%arrayidx1764.11> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.10>
    CLONE store ir<%conv1762.11>, ir<%arrayidx1764.11>
    CLONE ir<%indvars.iv.next5290.11> = add nsw ir<%indvars.iv5293>, ir<-12>
    CLONE ir<%1179> = trunc ir<%1166>
    CLONE ir<%conv1762.12> = or disjoint ir<%1179>, ir<3>
    CLONE ir<%arrayidx1764.12> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.11>
    CLONE store ir<%conv1762.12>, ir<%arrayidx1764.12>
    CLONE ir<%indvars.iv.next5290.12> = add nsw ir<%indvars.iv5293>, ir<-13>
    CLONE ir<%1180> = trunc ir<%1166>
    CLONE ir<%conv1762.13> = or disjoint ir<%1180>, ir<2>
    CLONE ir<%arrayidx1764.13> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.12>
    CLONE store ir<%conv1762.13>, ir<%arrayidx1764.13>
    CLONE ir<%indvars.iv.next5290.13> = add nsw ir<%indvars.iv5293>, ir<-14>
    CLONE ir<%1181> = trunc ir<%1166>
    CLONE ir<%conv1762.14> = or disjoint ir<%1181>, ir<1>
    CLONE ir<%arrayidx1764.14> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.13>
    CLONE store ir<%conv1762.14>, ir<%arrayidx1764.14>
    CLONE ir<%indvars.iv.next5290.14> = add nsw ir<%indvars.iv5293>, ir<-15>
    CLONE ir<%conv1762.15> = trunc ir<%1166>
    CLONE ir<%arrayidx1764.15> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.14>
    CLONE store ir<%conv1762.15>, ir<%arrayidx1764.15>
    CLONE ir<%1182> = trunc ir<%indvars.iv.next5290.14>
    CLONE ir<%indvars.iv.next5294> = add nsw ir<%indvars.iv5293>, ir<-16>
    CLONE ir<%arrayidx1771> = getelementptr inbounds ir<%mtfbase>, ir<0>, ir<%indvars.iv5295>
    CLONE store ir<%1182>, ir<%arrayidx1771>
    CLONE ir<%indvars.iv.next5296> = add nsw ir<%indvars.iv5295>, ir<-1>
    CLONE ir<%cmp1753.not> = icmp eq ir<%indvars.iv5295>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<16>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<if.then1777>, scalar.ph

ir-bb<if.then1777>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<16> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5295 = phi 15, %indvars.iv.next5296, ir<-1>
    WIDEN-INDUCTION %indvars.iv5293 = phi 4095, %indvars.iv.next5294, ir<-16>
    WIDEN ir<%1166> = shl nsw ir<%indvars.iv5295>, ir<4>
    WIDEN-CAST ir<%1167> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762> = or disjoint ir<%1167>, ir<15>
    REPLICATE ir<%arrayidx1764> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv5293>
    REPLICATE store ir<%conv1762>, ir<%arrayidx1764>
    WIDEN ir<%indvars.iv.next5290> = add nsw ir<%indvars.iv5293>, ir<-1>
    WIDEN-CAST ir<%1168> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.1> = or disjoint ir<%1168>, ir<14>
    REPLICATE ir<%arrayidx1764.1> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290>
    REPLICATE store ir<%conv1762.1>, ir<%arrayidx1764.1>
    WIDEN ir<%indvars.iv.next5290.1> = add nsw ir<%indvars.iv5293>, ir<-2>
    WIDEN-CAST ir<%1169> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.2> = or disjoint ir<%1169>, ir<13>
    REPLICATE ir<%arrayidx1764.2> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.1>
    REPLICATE store ir<%conv1762.2>, ir<%arrayidx1764.2>
    WIDEN ir<%indvars.iv.next5290.2> = add nsw ir<%indvars.iv5293>, ir<-3>
    WIDEN-CAST ir<%1170> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.3> = or disjoint ir<%1170>, ir<12>
    REPLICATE ir<%arrayidx1764.3> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.2>
    REPLICATE store ir<%conv1762.3>, ir<%arrayidx1764.3>
    WIDEN ir<%indvars.iv.next5290.3> = add nsw ir<%indvars.iv5293>, ir<-4>
    WIDEN-CAST ir<%1171> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.4> = or disjoint ir<%1171>, ir<11>
    REPLICATE ir<%arrayidx1764.4> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.3>
    REPLICATE store ir<%conv1762.4>, ir<%arrayidx1764.4>
    WIDEN ir<%indvars.iv.next5290.4> = add nsw ir<%indvars.iv5293>, ir<-5>
    WIDEN-CAST ir<%1172> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.5> = or disjoint ir<%1172>, ir<10>
    REPLICATE ir<%arrayidx1764.5> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.4>
    REPLICATE store ir<%conv1762.5>, ir<%arrayidx1764.5>
    WIDEN ir<%indvars.iv.next5290.5> = add nsw ir<%indvars.iv5293>, ir<-6>
    WIDEN-CAST ir<%1173> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.6> = or disjoint ir<%1173>, ir<9>
    REPLICATE ir<%arrayidx1764.6> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.5>
    REPLICATE store ir<%conv1762.6>, ir<%arrayidx1764.6>
    WIDEN ir<%indvars.iv.next5290.6> = add nsw ir<%indvars.iv5293>, ir<-7>
    WIDEN-CAST ir<%1174> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.7> = or disjoint ir<%1174>, ir<8>
    REPLICATE ir<%arrayidx1764.7> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.6>
    REPLICATE store ir<%conv1762.7>, ir<%arrayidx1764.7>
    WIDEN ir<%indvars.iv.next5290.7> = add nsw ir<%indvars.iv5293>, ir<-8>
    WIDEN-CAST ir<%1175> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.8> = or disjoint ir<%1175>, ir<7>
    REPLICATE ir<%arrayidx1764.8> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.7>
    REPLICATE store ir<%conv1762.8>, ir<%arrayidx1764.8>
    WIDEN ir<%indvars.iv.next5290.8> = add nsw ir<%indvars.iv5293>, ir<-9>
    WIDEN-CAST ir<%1176> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.9> = or disjoint ir<%1176>, ir<6>
    REPLICATE ir<%arrayidx1764.9> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.8>
    REPLICATE store ir<%conv1762.9>, ir<%arrayidx1764.9>
    WIDEN ir<%indvars.iv.next5290.9> = add nsw ir<%indvars.iv5293>, ir<-10>
    WIDEN-CAST ir<%1177> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.10> = or disjoint ir<%1177>, ir<5>
    REPLICATE ir<%arrayidx1764.10> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.9>
    REPLICATE store ir<%conv1762.10>, ir<%arrayidx1764.10>
    WIDEN ir<%indvars.iv.next5290.10> = add nsw ir<%indvars.iv5293>, ir<-11>
    WIDEN-CAST ir<%1178> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.11> = or disjoint ir<%1178>, ir<4>
    REPLICATE ir<%arrayidx1764.11> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.10>
    REPLICATE store ir<%conv1762.11>, ir<%arrayidx1764.11>
    WIDEN ir<%indvars.iv.next5290.11> = add nsw ir<%indvars.iv5293>, ir<-12>
    WIDEN-CAST ir<%1179> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.12> = or disjoint ir<%1179>, ir<3>
    REPLICATE ir<%arrayidx1764.12> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.11>
    REPLICATE store ir<%conv1762.12>, ir<%arrayidx1764.12>
    WIDEN ir<%indvars.iv.next5290.12> = add nsw ir<%indvars.iv5293>, ir<-13>
    WIDEN-CAST ir<%1180> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.13> = or disjoint ir<%1180>, ir<2>
    REPLICATE ir<%arrayidx1764.13> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.12>
    REPLICATE store ir<%conv1762.13>, ir<%arrayidx1764.13>
    WIDEN ir<%indvars.iv.next5290.13> = add nsw ir<%indvars.iv5293>, ir<-14>
    WIDEN-CAST ir<%1181> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.14> = or disjoint ir<%1181>, ir<1>
    REPLICATE ir<%arrayidx1764.14> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.13>
    REPLICATE store ir<%conv1762.14>, ir<%arrayidx1764.14>
    WIDEN ir<%indvars.iv.next5290.14> = add nsw ir<%indvars.iv5293>, ir<-15>
    WIDEN-CAST ir<%conv1762.15> = trunc  ir<%1166> to i8
    REPLICATE ir<%arrayidx1764.15> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.14>
    REPLICATE store ir<%conv1762.15>, ir<%arrayidx1764.15>
    WIDEN-CAST ir<%1182> = trunc  ir<%indvars.iv.next5290.14> to i32
    WIDEN ir<%indvars.iv.next5294> = add nsw ir<%indvars.iv5293>, ir<-16>
    CLONE ir<%arrayidx1771> = getelementptr inbounds ir<%mtfbase>, ir<0>, ir<%indvars.iv5295>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx1771>
    WIDEN store vp<%3>, ir<%1182>
    WIDEN ir<%indvars.iv.next5296> = add nsw ir<%indvars.iv5295>, ir<-1>
    CLONE ir<%cmp1753.not> = icmp eq ir<%indvars.iv5295>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<16>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.then1777>, scalar.ph

ir-bb<if.then1777>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<16> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5295 = phi 15, %indvars.iv.next5296, ir<-1>
    WIDEN-INDUCTION %indvars.iv5293 = phi 4095, %indvars.iv.next5294, ir<-16>
    WIDEN ir<%1166> = shl nsw ir<%indvars.iv5295>, ir<4>
    WIDEN-CAST ir<%1167> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762> = or disjoint ir<%1167>, ir<15>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv5293>
    REPLICATE store ir<%conv1762>, ir<%arrayidx1764>
    WIDEN ir<%indvars.iv.next5290> = add nsw ir<%indvars.iv5293>, ir<-1>
    WIDEN-CAST ir<%1168> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.1> = or disjoint ir<%1168>, ir<14>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.1> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290>
    REPLICATE store ir<%conv1762.1>, ir<%arrayidx1764.1>
    WIDEN ir<%indvars.iv.next5290.1> = add nsw ir<%indvars.iv5293>, ir<-2>
    WIDEN-CAST ir<%1169> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.2> = or disjoint ir<%1169>, ir<13>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.2> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.1>
    REPLICATE store ir<%conv1762.2>, ir<%arrayidx1764.2>
    WIDEN ir<%indvars.iv.next5290.2> = add nsw ir<%indvars.iv5293>, ir<-3>
    WIDEN-CAST ir<%1170> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.3> = or disjoint ir<%1170>, ir<12>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.3> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.2>
    REPLICATE store ir<%conv1762.3>, ir<%arrayidx1764.3>
    WIDEN ir<%indvars.iv.next5290.3> = add nsw ir<%indvars.iv5293>, ir<-4>
    WIDEN-CAST ir<%1171> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.4> = or disjoint ir<%1171>, ir<11>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.4> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.3>
    REPLICATE store ir<%conv1762.4>, ir<%arrayidx1764.4>
    WIDEN ir<%indvars.iv.next5290.4> = add nsw ir<%indvars.iv5293>, ir<-5>
    WIDEN-CAST ir<%1172> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.5> = or disjoint ir<%1172>, ir<10>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.5> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.4>
    REPLICATE store ir<%conv1762.5>, ir<%arrayidx1764.5>
    WIDEN ir<%indvars.iv.next5290.5> = add nsw ir<%indvars.iv5293>, ir<-6>
    WIDEN-CAST ir<%1173> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.6> = or disjoint ir<%1173>, ir<9>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.6> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.5>
    REPLICATE store ir<%conv1762.6>, ir<%arrayidx1764.6>
    WIDEN ir<%indvars.iv.next5290.6> = add nsw ir<%indvars.iv5293>, ir<-7>
    WIDEN-CAST ir<%1174> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.7> = or disjoint ir<%1174>, ir<8>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.7> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.6>
    REPLICATE store ir<%conv1762.7>, ir<%arrayidx1764.7>
    WIDEN ir<%indvars.iv.next5290.7> = add nsw ir<%indvars.iv5293>, ir<-8>
    WIDEN-CAST ir<%1175> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.8> = or disjoint ir<%1175>, ir<7>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.8> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.7>
    REPLICATE store ir<%conv1762.8>, ir<%arrayidx1764.8>
    WIDEN ir<%indvars.iv.next5290.8> = add nsw ir<%indvars.iv5293>, ir<-9>
    WIDEN-CAST ir<%1176> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.9> = or disjoint ir<%1176>, ir<6>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.9> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.8>
    REPLICATE store ir<%conv1762.9>, ir<%arrayidx1764.9>
    WIDEN ir<%indvars.iv.next5290.9> = add nsw ir<%indvars.iv5293>, ir<-10>
    WIDEN-CAST ir<%1177> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.10> = or disjoint ir<%1177>, ir<5>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.10> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.9>
    REPLICATE store ir<%conv1762.10>, ir<%arrayidx1764.10>
    WIDEN ir<%indvars.iv.next5290.10> = add nsw ir<%indvars.iv5293>, ir<-11>
    WIDEN-CAST ir<%1178> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.11> = or disjoint ir<%1178>, ir<4>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.11> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.10>
    REPLICATE store ir<%conv1762.11>, ir<%arrayidx1764.11>
    WIDEN ir<%indvars.iv.next5290.11> = add nsw ir<%indvars.iv5293>, ir<-12>
    WIDEN-CAST ir<%1179> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.12> = or disjoint ir<%1179>, ir<3>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.12> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.11>
    REPLICATE store ir<%conv1762.12>, ir<%arrayidx1764.12>
    WIDEN ir<%indvars.iv.next5290.12> = add nsw ir<%indvars.iv5293>, ir<-13>
    WIDEN-CAST ir<%1180> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.13> = or disjoint ir<%1180>, ir<2>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.13> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.12>
    REPLICATE store ir<%conv1762.13>, ir<%arrayidx1764.13>
    WIDEN ir<%indvars.iv.next5290.13> = add nsw ir<%indvars.iv5293>, ir<-14>
    WIDEN-CAST ir<%1181> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.14> = or disjoint ir<%1181>, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.14> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.13>
    REPLICATE store ir<%conv1762.14>, ir<%arrayidx1764.14>
    WIDEN ir<%indvars.iv.next5290.14> = add nsw ir<%indvars.iv5293>, ir<-15>
    WIDEN-CAST ir<%conv1762.15> = trunc  ir<%1166> to i8
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.15> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.14>
    REPLICATE store ir<%conv1762.15>, ir<%arrayidx1764.15>
    WIDEN-CAST ir<%1182> = trunc  ir<%indvars.iv.next5290.14> to i32
    WIDEN ir<%indvars.iv.next5294> = add nsw ir<%indvars.iv5293>, ir<-16>
    CLONE ir<%arrayidx1771> = getelementptr inbounds ir<%mtfbase>, ir<0>, ir<%indvars.iv5295>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx1771>
    WIDEN store vp<%3>, ir<%1182>
    WIDEN ir<%indvars.iv.next5296> = add nsw ir<%indvars.iv5295>, ir<-1>
    CLONE ir<%cmp1753.not> = icmp eq ir<%indvars.iv5295>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<16>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.then1777>, scalar.ph

ir-bb<if.then1777>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<16> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5295 = phi 15, %indvars.iv.next5296, ir<-1>
    WIDEN-INDUCTION %indvars.iv5293 = phi 4095, %indvars.iv.next5294, ir<-16>
    WIDEN ir<%1166> = shl nsw ir<%indvars.iv5295>, ir<4>
    WIDEN-CAST ir<%1167> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762> = or disjoint ir<%1167>, ir<15>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv5293>
    WIDEN store ir<%arrayidx1764>, ir<%conv1762>
    WIDEN ir<%indvars.iv.next5290> = add nsw ir<%indvars.iv5293>, ir<-1>
    WIDEN-CAST ir<%1168> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.1> = or disjoint ir<%1168>, ir<14>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.1> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290>
    WIDEN store ir<%arrayidx1764.1>, ir<%conv1762.1>
    WIDEN ir<%indvars.iv.next5290.1> = add nsw ir<%indvars.iv5293>, ir<-2>
    WIDEN-CAST ir<%1169> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.2> = or disjoint ir<%1169>, ir<13>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.2> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.1>
    WIDEN store ir<%arrayidx1764.2>, ir<%conv1762.2>
    WIDEN ir<%indvars.iv.next5290.2> = add nsw ir<%indvars.iv5293>, ir<-3>
    WIDEN-CAST ir<%1170> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.3> = or disjoint ir<%1170>, ir<12>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.3> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.2>
    WIDEN store ir<%arrayidx1764.3>, ir<%conv1762.3>
    WIDEN ir<%indvars.iv.next5290.3> = add nsw ir<%indvars.iv5293>, ir<-4>
    WIDEN-CAST ir<%1171> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.4> = or disjoint ir<%1171>, ir<11>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.4> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.3>
    WIDEN store ir<%arrayidx1764.4>, ir<%conv1762.4>
    WIDEN ir<%indvars.iv.next5290.4> = add nsw ir<%indvars.iv5293>, ir<-5>
    WIDEN-CAST ir<%1172> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.5> = or disjoint ir<%1172>, ir<10>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.5> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.4>
    WIDEN store ir<%arrayidx1764.5>, ir<%conv1762.5>
    WIDEN ir<%indvars.iv.next5290.5> = add nsw ir<%indvars.iv5293>, ir<-6>
    WIDEN-CAST ir<%1173> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.6> = or disjoint ir<%1173>, ir<9>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.6> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.5>
    WIDEN store ir<%arrayidx1764.6>, ir<%conv1762.6>
    WIDEN ir<%indvars.iv.next5290.6> = add nsw ir<%indvars.iv5293>, ir<-7>
    WIDEN-CAST ir<%1174> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.7> = or disjoint ir<%1174>, ir<8>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.7> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.6>
    WIDEN store ir<%arrayidx1764.7>, ir<%conv1762.7>
    WIDEN ir<%indvars.iv.next5290.7> = add nsw ir<%indvars.iv5293>, ir<-8>
    WIDEN-CAST ir<%1175> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.8> = or disjoint ir<%1175>, ir<7>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.8> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.7>
    WIDEN store ir<%arrayidx1764.8>, ir<%conv1762.8>
    WIDEN ir<%indvars.iv.next5290.8> = add nsw ir<%indvars.iv5293>, ir<-9>
    WIDEN-CAST ir<%1176> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.9> = or disjoint ir<%1176>, ir<6>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.9> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.8>
    WIDEN store ir<%arrayidx1764.9>, ir<%conv1762.9>
    WIDEN ir<%indvars.iv.next5290.9> = add nsw ir<%indvars.iv5293>, ir<-10>
    WIDEN-CAST ir<%1177> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.10> = or disjoint ir<%1177>, ir<5>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.10> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.9>
    WIDEN store ir<%arrayidx1764.10>, ir<%conv1762.10>
    WIDEN ir<%indvars.iv.next5290.10> = add nsw ir<%indvars.iv5293>, ir<-11>
    WIDEN-CAST ir<%1178> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.11> = or disjoint ir<%1178>, ir<4>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.11> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.10>
    WIDEN store ir<%arrayidx1764.11>, ir<%conv1762.11>
    WIDEN ir<%indvars.iv.next5290.11> = add nsw ir<%indvars.iv5293>, ir<-12>
    WIDEN-CAST ir<%1179> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.12> = or disjoint ir<%1179>, ir<3>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.12> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.11>
    WIDEN store ir<%arrayidx1764.12>, ir<%conv1762.12>
    WIDEN ir<%indvars.iv.next5290.12> = add nsw ir<%indvars.iv5293>, ir<-13>
    WIDEN-CAST ir<%1180> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.13> = or disjoint ir<%1180>, ir<2>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.13> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.12>
    WIDEN store ir<%arrayidx1764.13>, ir<%conv1762.13>
    WIDEN ir<%indvars.iv.next5290.13> = add nsw ir<%indvars.iv5293>, ir<-14>
    WIDEN-CAST ir<%1181> = trunc  ir<%1166> to i8
    WIDEN ir<%conv1762.14> = or disjoint ir<%1181>, ir<1>
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.14> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.13>
    WIDEN store ir<%arrayidx1764.14>, ir<%conv1762.14>
    WIDEN ir<%indvars.iv.next5290.14> = add nsw ir<%indvars.iv5293>, ir<-15>
    WIDEN-CAST ir<%conv1762.15> = trunc  ir<%1166> to i8
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx1764.15> = getelementptr inbounds ir<%mtfa>, ir<0>, ir<%indvars.iv.next5290.14>
    WIDEN store ir<%arrayidx1764.15>, ir<%conv1762.15>
    WIDEN-CAST ir<%1182> = trunc  ir<%indvars.iv.next5290.14> to i32
    WIDEN ir<%indvars.iv.next5294> = add nsw ir<%indvars.iv5293>, ir<-16>
    CLONE ir<%arrayidx1771> = getelementptr inbounds ir<%mtfbase>, ir<0>, ir<%indvars.iv5295>
    vp<%3> = vector-pointer (reverse) ir<%arrayidx1771>
    WIDEN store vp<%3>, ir<%1182>
    WIDEN ir<%indvars.iv.next5296> = add nsw ir<%indvars.iv5295>, ir<-1>
    CLONE ir<%cmp1753.not> = icmp eq ir<%indvars.iv5295>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq ir<16>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<if.then1777>, scalar.ph

ir-bb<if.then1777>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv5295 = phi i64 [ 15, %for.end1738 ], [ %indvars.iv.next5296, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv5293 = phi i64 [ 4095, %for.end1738 ], [ %indvars.iv.next5294, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1166 = shl nsw i64 %indvars.iv5295, 4 of type:shl
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1167 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762 = or disjoint i8 %1167, 15 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv5293 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762, ptr %arrayidx1764, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290 = add nsw i64 %indvars.iv5293, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1168 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.1 = or disjoint i8 %1168, 14 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.1 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.1, ptr %arrayidx1764.1, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.1 = add nsw i64 %indvars.iv5293, -2 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1169 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.2 = or disjoint i8 %1169, 13 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.2 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.1 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.2, ptr %arrayidx1764.2, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.2 = add nsw i64 %indvars.iv5293, -3 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1170 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.3 = or disjoint i8 %1170, 12 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.3 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.2 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.3, ptr %arrayidx1764.3, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.3 = add nsw i64 %indvars.iv5293, -4 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1171 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.4 = or disjoint i8 %1171, 11 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.4 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.3 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.4, ptr %arrayidx1764.4, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.4 = add nsw i64 %indvars.iv5293, -5 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1172 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.5 = or disjoint i8 %1172, 10 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.5 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.4 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.5, ptr %arrayidx1764.5, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.5 = add nsw i64 %indvars.iv5293, -6 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1173 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.6 = or disjoint i8 %1173, 9 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.6 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.5 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.6, ptr %arrayidx1764.6, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.6 = add nsw i64 %indvars.iv5293, -7 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1174 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.7 = or disjoint i8 %1174, 8 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.7 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.6 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.7, ptr %arrayidx1764.7, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.7 = add nsw i64 %indvars.iv5293, -8 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1175 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.8 = or disjoint i8 %1175, 7 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.8 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.7 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.8, ptr %arrayidx1764.8, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.8 = add nsw i64 %indvars.iv5293, -9 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1176 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.9 = or disjoint i8 %1176, 6 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.9 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.8 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.9, ptr %arrayidx1764.9, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.9 = add nsw i64 %indvars.iv5293, -10 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1177 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.10 = or disjoint i8 %1177, 5 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.10 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.9 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.10, ptr %arrayidx1764.10, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.10 = add nsw i64 %indvars.iv5293, -11 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1178 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.11 = or disjoint i8 %1178, 4 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.11 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.10 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.11, ptr %arrayidx1764.11, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.11 = add nsw i64 %indvars.iv5293, -12 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1179 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.12 = or disjoint i8 %1179, 3 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.12 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.11 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.12, ptr %arrayidx1764.12, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.12 = add nsw i64 %indvars.iv5293, -13 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1180 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.13 = or disjoint i8 %1180, 2 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.13 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.12 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.13, ptr %arrayidx1764.13, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.13 = add nsw i64 %indvars.iv5293, -14 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1181 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %conv1762.14 = or disjoint i8 %1181, 1 of type:or
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.14 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.13 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.14, ptr %arrayidx1764.14, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5290.14 = add nsw i64 %indvars.iv5293, -15 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %conv1762.15 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1764.15 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.14 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %conv1762.15, ptr %arrayidx1764.15, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1182 = trunc nsw i64 %indvars.iv.next5290.14 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5294 = add nsw i64 %indvars.iv5293, -16 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx1771 = getelementptr inbounds [16 x i32], ptr %mtfbase, i64 0, i64 %indvars.iv5295 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5296 = add nsw i64 %indvars.iv5295, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp1753.not = icmp eq i64 %indvars.iv5295, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp1753.not, label %if.then1777, label %for.cond1756.preheader of type:br
LV: Scalar loop costs: 68.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv5295 = phi i64 [ 15, %for.end1738 ], [ %indvars.iv.next5296, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv5293 = phi i64 [ 4095, %for.end1738 ], [ %indvars.iv.next5294, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1166 = shl nsw i64 %indvars.iv5295, 4 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1167 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762 = or disjoint i8 %1167, 15 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv5293 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 12 for VF 2 For instruction:   store i8 %conv1762, ptr %arrayidx1764, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290 = add nsw i64 %indvars.iv5293, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1168 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.1 = or disjoint i8 %1168, 14 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.1 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.1, ptr %arrayidx1764.1, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.1 = add nsw i64 %indvars.iv5293, -2 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1169 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.2 = or disjoint i8 %1169, 13 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.2 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.2, ptr %arrayidx1764.2, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.2 = add nsw i64 %indvars.iv5293, -3 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1170 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.3 = or disjoint i8 %1170, 12 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.3 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.3, ptr %arrayidx1764.3, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.3 = add nsw i64 %indvars.iv5293, -4 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1171 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.4 = or disjoint i8 %1171, 11 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.4 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.4, ptr %arrayidx1764.4, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.4 = add nsw i64 %indvars.iv5293, -5 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1172 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.5 = or disjoint i8 %1172, 10 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.5 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.5, ptr %arrayidx1764.5, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.5 = add nsw i64 %indvars.iv5293, -6 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1173 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.6 = or disjoint i8 %1173, 9 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.6 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.6, ptr %arrayidx1764.6, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.6 = add nsw i64 %indvars.iv5293, -7 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1174 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.7 = or disjoint i8 %1174, 8 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.7 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.7, ptr %arrayidx1764.7, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.7 = add nsw i64 %indvars.iv5293, -8 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1175 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.8 = or disjoint i8 %1175, 7 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.8 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.8, ptr %arrayidx1764.8, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.8 = add nsw i64 %indvars.iv5293, -9 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1176 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.9 = or disjoint i8 %1176, 6 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.9 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.9, ptr %arrayidx1764.9, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.9 = add nsw i64 %indvars.iv5293, -10 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1177 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.10 = or disjoint i8 %1177, 5 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.10 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.10, ptr %arrayidx1764.10, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.10 = add nsw i64 %indvars.iv5293, -11 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1178 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.11 = or disjoint i8 %1178, 4 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.11 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.11, ptr %arrayidx1764.11, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.11 = add nsw i64 %indvars.iv5293, -12 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1179 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.12 = or disjoint i8 %1179, 3 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.12 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.12, ptr %arrayidx1764.12, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.12 = add nsw i64 %indvars.iv5293, -13 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1180 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.13 = or disjoint i8 %1180, 2 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.13 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.13, ptr %arrayidx1764.13, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.13 = add nsw i64 %indvars.iv5293, -14 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1181 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.14 = or disjoint i8 %1181, 1 of type:or
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.14 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.14, ptr %arrayidx1764.14, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5290.14 = add nsw i64 %indvars.iv5293, -15 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %conv1762.15 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1764.15 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %conv1762.15, ptr %arrayidx1764.15, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1182 = trunc nsw i64 %indvars.iv.next5290.14 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5294 = add nsw i64 %indvars.iv5293, -16 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx1771 = getelementptr inbounds [16 x i32], ptr %mtfbase, i64 0, i64 %indvars.iv5295 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 2 For instruction:   store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5296 = add nsw i64 %indvars.iv5295, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp1753.not = icmp eq i64 %indvars.iv5295, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp1753.not, label %if.then1777, label %for.cond1756.preheader of type:br
LV: Vector loop of width 2 costs: 257
A is not scalable.	B is not scalable.	
RTCostA: 4120, RTCostB: 1088
A is not scalable.	B is not scalable.	
RTCostA: 4120, RTCostB: 1088

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv5295 = phi i64 [ 15, %for.end1738 ], [ %indvars.iv.next5296, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv5293 = phi i64 [ 4095, %for.end1738 ], [ %indvars.iv.next5294, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1166 = shl nsw i64 %indvars.iv5295, 4 of type:shl
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1167 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762 = or disjoint i8 %1167, 15 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv5293 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 24 for VF 4 For instruction:   store i8 %conv1762, ptr %arrayidx1764, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290 = add nsw i64 %indvars.iv5293, -1 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1168 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.1 = or disjoint i8 %1168, 14 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.1 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.1, ptr %arrayidx1764.1, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.1 = add nsw i64 %indvars.iv5293, -2 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1169 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.2 = or disjoint i8 %1169, 13 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.2 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.2, ptr %arrayidx1764.2, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.2 = add nsw i64 %indvars.iv5293, -3 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1170 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.3 = or disjoint i8 %1170, 12 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.3 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.3, ptr %arrayidx1764.3, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.3 = add nsw i64 %indvars.iv5293, -4 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1171 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.4 = or disjoint i8 %1171, 11 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.4 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.4, ptr %arrayidx1764.4, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.4 = add nsw i64 %indvars.iv5293, -5 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1172 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.5 = or disjoint i8 %1172, 10 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.5 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.5, ptr %arrayidx1764.5, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.5 = add nsw i64 %indvars.iv5293, -6 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1173 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.6 = or disjoint i8 %1173, 9 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.6 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.6, ptr %arrayidx1764.6, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.6 = add nsw i64 %indvars.iv5293, -7 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1174 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.7 = or disjoint i8 %1174, 8 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.7 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.7, ptr %arrayidx1764.7, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.7 = add nsw i64 %indvars.iv5293, -8 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1175 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.8 = or disjoint i8 %1175, 7 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.8 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.8, ptr %arrayidx1764.8, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.8 = add nsw i64 %indvars.iv5293, -9 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1176 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.9 = or disjoint i8 %1176, 6 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.9 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.9, ptr %arrayidx1764.9, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.9 = add nsw i64 %indvars.iv5293, -10 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1177 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.10 = or disjoint i8 %1177, 5 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.10 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.10, ptr %arrayidx1764.10, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.10 = add nsw i64 %indvars.iv5293, -11 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1178 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.11 = or disjoint i8 %1178, 4 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.11 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.11, ptr %arrayidx1764.11, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.11 = add nsw i64 %indvars.iv5293, -12 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1179 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.12 = or disjoint i8 %1179, 3 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.12 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.12, ptr %arrayidx1764.12, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.12 = add nsw i64 %indvars.iv5293, -13 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1180 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.13 = or disjoint i8 %1180, 2 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.13 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.13, ptr %arrayidx1764.13, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.13 = add nsw i64 %indvars.iv5293, -14 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1181 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %conv1762.14 = or disjoint i8 %1181, 1 of type:or
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.14 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.14, ptr %arrayidx1764.14, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5290.14 = add nsw i64 %indvars.iv5293, -15 of type:add
LV: Found an estimated cost of 3 for VF 4 For instruction:   %conv1762.15 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1764.15 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %conv1762.15, ptr %arrayidx1764.15, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1182 = trunc nsw i64 %indvars.iv.next5290.14 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5294 = add nsw i64 %indvars.iv5293, -16 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx1771 = getelementptr inbounds [16 x i32], ptr %mtfbase, i64 0, i64 %indvars.iv5295 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5296 = add nsw i64 %indvars.iv5295, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp1753.not = icmp eq i64 %indvars.iv5295, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp1753.not, label %if.then1777, label %for.cond1756.preheader of type:br
LV: Vector loop of width 4 costs: 257
A is not scalable.	B is not scalable.	
RTCostA: 4112, RTCostB: 1088
A is not scalable.	B is not scalable.	
RTCostA: 4112, RTCostB: 1088

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv5295 = phi i64 [ 15, %for.end1738 ], [ %indvars.iv.next5296, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv5293 = phi i64 [ 4095, %for.end1738 ], [ %indvars.iv.next5294, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1166 = shl nsw i64 %indvars.iv5295, 4 of type:shl
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1167 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762 = or disjoint i8 %1167, 15 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv5293 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 48 for VF 8 For instruction:   store i8 %conv1762, ptr %arrayidx1764, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290 = add nsw i64 %indvars.iv5293, -1 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1168 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.1 = or disjoint i8 %1168, 14 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.1 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.1, ptr %arrayidx1764.1, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.1 = add nsw i64 %indvars.iv5293, -2 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1169 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.2 = or disjoint i8 %1169, 13 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.2 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.2, ptr %arrayidx1764.2, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.2 = add nsw i64 %indvars.iv5293, -3 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1170 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.3 = or disjoint i8 %1170, 12 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.3 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.3, ptr %arrayidx1764.3, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.3 = add nsw i64 %indvars.iv5293, -4 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1171 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.4 = or disjoint i8 %1171, 11 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.4 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.4, ptr %arrayidx1764.4, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.4 = add nsw i64 %indvars.iv5293, -5 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1172 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.5 = or disjoint i8 %1172, 10 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.5 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.5, ptr %arrayidx1764.5, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.5 = add nsw i64 %indvars.iv5293, -6 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1173 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.6 = or disjoint i8 %1173, 9 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.6 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.6, ptr %arrayidx1764.6, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.6 = add nsw i64 %indvars.iv5293, -7 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1174 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.7 = or disjoint i8 %1174, 8 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.7 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.7, ptr %arrayidx1764.7, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.7 = add nsw i64 %indvars.iv5293, -8 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1175 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.8 = or disjoint i8 %1175, 7 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.8 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.8, ptr %arrayidx1764.8, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.8 = add nsw i64 %indvars.iv5293, -9 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1176 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.9 = or disjoint i8 %1176, 6 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.9 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.9, ptr %arrayidx1764.9, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.9 = add nsw i64 %indvars.iv5293, -10 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1177 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.10 = or disjoint i8 %1177, 5 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.10 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.10, ptr %arrayidx1764.10, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.10 = add nsw i64 %indvars.iv5293, -11 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1178 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.11 = or disjoint i8 %1178, 4 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.11 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.11, ptr %arrayidx1764.11, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.11 = add nsw i64 %indvars.iv5293, -12 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1179 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.12 = or disjoint i8 %1179, 3 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.12 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.12, ptr %arrayidx1764.12, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.12 = add nsw i64 %indvars.iv5293, -13 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1180 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.13 = or disjoint i8 %1180, 2 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.13 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.13, ptr %arrayidx1764.13, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.13 = add nsw i64 %indvars.iv5293, -14 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %1181 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %conv1762.14 = or disjoint i8 %1181, 1 of type:or
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.14 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.14, ptr %arrayidx1764.14, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5290.14 = add nsw i64 %indvars.iv5293, -15 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %conv1762.15 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1764.15 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %conv1762.15, ptr %arrayidx1764.15, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 8 For instruction:   %1182 = trunc nsw i64 %indvars.iv.next5290.14 to i32 of type:trunc
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5294 = add nsw i64 %indvars.iv5293, -16 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx1771 = getelementptr inbounds [16 x i32], ptr %mtfbase, i64 0, i64 %indvars.iv5295 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 6 for VF 8 For instruction:   store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5296 = add nsw i64 %indvars.iv5295, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp1753.not = icmp eq i64 %indvars.iv5295, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp1753.not, label %if.then1777, label %for.cond1756.preheader of type:br
LV: Vector loop of width 8 costs: 251
A is not scalable.	B is not scalable.	
RTCostA: 4016, RTCostB: 1088
A is not scalable.	B is not scalable.	
RTCostA: 4016, RTCostB: 1088

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv5295 = phi i64 [ 15, %for.end1738 ], [ %indvars.iv.next5296, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv5293 = phi i64 [ 4095, %for.end1738 ], [ %indvars.iv.next5294, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1166 = shl nsw i64 %indvars.iv5295, 4 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1167 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762 = or disjoint i8 %1167, 15 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv5293 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762, ptr %arrayidx1764, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290 = add nsw i64 %indvars.iv5293, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1168 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.1 = or disjoint i8 %1168, 14 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.1 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.1, ptr %arrayidx1764.1, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.1 = add nsw i64 %indvars.iv5293, -2 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1169 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.2 = or disjoint i8 %1169, 13 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.2 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.1 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.2, ptr %arrayidx1764.2, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.2 = add nsw i64 %indvars.iv5293, -3 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1170 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.3 = or disjoint i8 %1170, 12 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.3 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.2 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.3, ptr %arrayidx1764.3, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.3 = add nsw i64 %indvars.iv5293, -4 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1171 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.4 = or disjoint i8 %1171, 11 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.4 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.3 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.4, ptr %arrayidx1764.4, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.4 = add nsw i64 %indvars.iv5293, -5 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1172 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.5 = or disjoint i8 %1172, 10 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.5 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.4 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.5, ptr %arrayidx1764.5, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.5 = add nsw i64 %indvars.iv5293, -6 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1173 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.6 = or disjoint i8 %1173, 9 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.6 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.5 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.6, ptr %arrayidx1764.6, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.6 = add nsw i64 %indvars.iv5293, -7 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1174 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.7 = or disjoint i8 %1174, 8 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.7 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.6 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.7, ptr %arrayidx1764.7, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.7 = add nsw i64 %indvars.iv5293, -8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1175 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.8 = or disjoint i8 %1175, 7 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.8 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.7 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.8, ptr %arrayidx1764.8, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.8 = add nsw i64 %indvars.iv5293, -9 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1176 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.9 = or disjoint i8 %1176, 6 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.9 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.8 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.9, ptr %arrayidx1764.9, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.9 = add nsw i64 %indvars.iv5293, -10 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1177 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.10 = or disjoint i8 %1177, 5 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.10 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.9 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.10, ptr %arrayidx1764.10, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.10 = add nsw i64 %indvars.iv5293, -11 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1178 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.11 = or disjoint i8 %1178, 4 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.11 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.10 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.11, ptr %arrayidx1764.11, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.11 = add nsw i64 %indvars.iv5293, -12 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1179 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.12 = or disjoint i8 %1179, 3 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.12 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.11 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.12, ptr %arrayidx1764.12, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.12 = add nsw i64 %indvars.iv5293, -13 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1180 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.13 = or disjoint i8 %1180, 2 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.13 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.12 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.13, ptr %arrayidx1764.13, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.13 = add nsw i64 %indvars.iv5293, -14 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1181 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %conv1762.14 = or disjoint i8 %1181, 1 of type:or
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.14 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.13 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.14, ptr %arrayidx1764.14, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5290.14 = add nsw i64 %indvars.iv5293, -15 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %conv1762.15 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1764.15 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.14 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %conv1762.15, ptr %arrayidx1764.15, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1182 = trunc nsw i64 %indvars.iv.next5290.14 to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5294 = add nsw i64 %indvars.iv5293, -16 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx1771 = getelementptr inbounds [16 x i32], ptr %mtfbase, i64 0, i64 %indvars.iv5295 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5296 = add nsw i64 %indvars.iv5295, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp1753.not = icmp eq i64 %indvars.iv5295, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp1753.not, label %if.then1777, label %for.cond1756.preheader of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1088
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1088

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv5295 = phi i64 [ 15, %for.end1738 ], [ %indvars.iv.next5296, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv5293 = phi i64 [ 4095, %for.end1738 ], [ %indvars.iv.next5294, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1166 = shl nsw i64 %indvars.iv5295, 4 of type:shl
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1167 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762 = or disjoint i8 %1167, 15 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv5293 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762, ptr %arrayidx1764, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290 = add nsw i64 %indvars.iv5293, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1168 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.1 = or disjoint i8 %1168, 14 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.1 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.1, ptr %arrayidx1764.1, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.1 = add nsw i64 %indvars.iv5293, -2 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1169 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.2 = or disjoint i8 %1169, 13 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.2 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.2, ptr %arrayidx1764.2, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.2 = add nsw i64 %indvars.iv5293, -3 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1170 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.3 = or disjoint i8 %1170, 12 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.3 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.3, ptr %arrayidx1764.3, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.3 = add nsw i64 %indvars.iv5293, -4 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1171 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.4 = or disjoint i8 %1171, 11 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.4 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.4, ptr %arrayidx1764.4, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.4 = add nsw i64 %indvars.iv5293, -5 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1172 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.5 = or disjoint i8 %1172, 10 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.5 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.5, ptr %arrayidx1764.5, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.5 = add nsw i64 %indvars.iv5293, -6 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1173 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.6 = or disjoint i8 %1173, 9 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.6 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.6, ptr %arrayidx1764.6, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.6 = add nsw i64 %indvars.iv5293, -7 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1174 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.7 = or disjoint i8 %1174, 8 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.7 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.7, ptr %arrayidx1764.7, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.7 = add nsw i64 %indvars.iv5293, -8 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1175 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.8 = or disjoint i8 %1175, 7 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.8 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.8, ptr %arrayidx1764.8, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.8 = add nsw i64 %indvars.iv5293, -9 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1176 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.9 = or disjoint i8 %1176, 6 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.9 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.9, ptr %arrayidx1764.9, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.9 = add nsw i64 %indvars.iv5293, -10 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1177 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.10 = or disjoint i8 %1177, 5 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.10 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.10, ptr %arrayidx1764.10, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.10 = add nsw i64 %indvars.iv5293, -11 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1178 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.11 = or disjoint i8 %1178, 4 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.11 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.11, ptr %arrayidx1764.11, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.11 = add nsw i64 %indvars.iv5293, -12 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1179 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.12 = or disjoint i8 %1179, 3 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.12 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.12, ptr %arrayidx1764.12, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.12 = add nsw i64 %indvars.iv5293, -13 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1180 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.13 = or disjoint i8 %1180, 2 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.13 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.13, ptr %arrayidx1764.13, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.13 = add nsw i64 %indvars.iv5293, -14 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1181 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %conv1762.14 = or disjoint i8 %1181, 1 of type:or
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.14 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.14, ptr %arrayidx1764.14, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5290.14 = add nsw i64 %indvars.iv5293, -15 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %conv1762.15 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1764.15 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %conv1762.15, ptr %arrayidx1764.15, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1182 = trunc nsw i64 %indvars.iv.next5290.14 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5294 = add nsw i64 %indvars.iv5293, -16 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx1771 = getelementptr inbounds [16 x i32], ptr %mtfbase, i64 0, i64 %indvars.iv5295 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5296 = add nsw i64 %indvars.iv5295, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp1753.not = icmp eq i64 %indvars.iv5295, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp1753.not, label %if.then1777, label %for.cond1756.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 173
A is scalable.	B is not scalable.	
RTCostA: 2772, RTCostB: 1088
A is scalable.	B is not scalable.	
RTCostA: 2772, RTCostB: 1088

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv5295 = phi i64 [ 15, %for.end1738 ], [ %indvars.iv.next5296, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv5293 = phi i64 [ 4095, %for.end1738 ], [ %indvars.iv.next5294, %for.cond1756.preheader ] of type:phi
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %1166 = shl nsw i64 %indvars.iv5295, 4 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1167 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762 = or disjoint i8 %1167, 15 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv5293 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762, ptr %arrayidx1764, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290 = add nsw i64 %indvars.iv5293, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1168 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.1 = or disjoint i8 %1168, 14 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.1 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.1, ptr %arrayidx1764.1, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.1 = add nsw i64 %indvars.iv5293, -2 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1169 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.2 = or disjoint i8 %1169, 13 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.2 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.1 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.2, ptr %arrayidx1764.2, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.2 = add nsw i64 %indvars.iv5293, -3 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1170 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.3 = or disjoint i8 %1170, 12 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.3 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.2 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.3, ptr %arrayidx1764.3, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.3 = add nsw i64 %indvars.iv5293, -4 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1171 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.4 = or disjoint i8 %1171, 11 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.4 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.3 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.4, ptr %arrayidx1764.4, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.4 = add nsw i64 %indvars.iv5293, -5 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1172 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.5 = or disjoint i8 %1172, 10 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.5 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.4 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.5, ptr %arrayidx1764.5, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.5 = add nsw i64 %indvars.iv5293, -6 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1173 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.6 = or disjoint i8 %1173, 9 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.6 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.5 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.6, ptr %arrayidx1764.6, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.6 = add nsw i64 %indvars.iv5293, -7 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1174 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.7 = or disjoint i8 %1174, 8 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.7 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.6 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.7, ptr %arrayidx1764.7, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.7 = add nsw i64 %indvars.iv5293, -8 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1175 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.8 = or disjoint i8 %1175, 7 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.8 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.7 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.8, ptr %arrayidx1764.8, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.8 = add nsw i64 %indvars.iv5293, -9 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1176 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.9 = or disjoint i8 %1176, 6 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.9 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.8 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.9, ptr %arrayidx1764.9, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.9 = add nsw i64 %indvars.iv5293, -10 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1177 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.10 = or disjoint i8 %1177, 5 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.10 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.9 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.10, ptr %arrayidx1764.10, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.10 = add nsw i64 %indvars.iv5293, -11 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1178 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.11 = or disjoint i8 %1178, 4 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.11 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.10 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.11, ptr %arrayidx1764.11, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.11 = add nsw i64 %indvars.iv5293, -12 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1179 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.12 = or disjoint i8 %1179, 3 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.12 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.11 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.12, ptr %arrayidx1764.12, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.12 = add nsw i64 %indvars.iv5293, -13 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1180 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.13 = or disjoint i8 %1180, 2 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.13 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.12 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.13, ptr %arrayidx1764.13, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.13 = add nsw i64 %indvars.iv5293, -14 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1181 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.14 = or disjoint i8 %1181, 1 of type:or
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.14 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.13 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.14, ptr %arrayidx1764.14, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5290.14 = add nsw i64 %indvars.iv5293, -15 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %conv1762.15 = trunc i64 %1166 to i8 of type:trunc
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1764.15 = getelementptr inbounds [4096 x i8], ptr %mtfa, i64 0, i64 %indvars.iv.next5290.14 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %conv1762.15, ptr %arrayidx1764.15, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %1182 = trunc nsw i64 %indvars.iv.next5290.14 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5294 = add nsw i64 %indvars.iv5293, -16 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx1771 = getelementptr inbounds [16 x i32], ptr %mtfbase, i64 0, i64 %indvars.iv5295 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i32 %1182, ptr %arrayidx1771, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5296 = add nsw i64 %indvars.iv5295, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp1753.not = icmp eq i64 %indvars.iv5295, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp1753.not, label %if.then1777, label %for.cond1756.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 171
A is scalable.	B is not scalable.	
RTCostA: 2736, RTCostB: 1088
A is scalable.	B is not scalable.	
RTCostA: 2736, RTCostB: 1088
LV: Selecting VF: 1 With Cost: 68.
maxbefore: 2
maxafter: 2
========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2207.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-5 + %nextSym.0) to i64) /u 4))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5335 = phi %1258, %indvars.iv.next5336, ir<-4>
    CLONE ir<%1260> = trunc ir<%indvars.iv5335>
    CLONE ir<%add2208> = add ir<%1256>, ir<%1260>
    CLONE ir<%sub2210> = add nsw ir<%add2208>, ir<-1>
    CLONE ir<%idxprom2211> = sext ir<%sub2210>
    CLONE ir<%arrayidx2212> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2211>
    CLONE ir<%1261> = load ir<%arrayidx2212>
    CLONE ir<%idxprom2214> = sext ir<%add2208>
    CLONE ir<%arrayidx2215> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2214>
    CLONE store ir<%1261>, ir<%arrayidx2215>
    CLONE ir<%sub2217> = add nsw ir<%add2208>, ir<-2>
    CLONE ir<%idxprom2218> = sext ir<%sub2217>
    CLONE ir<%arrayidx2219> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2218>
    CLONE ir<%1262> = load ir<%arrayidx2219>
    CLONE store ir<%1262>, ir<%arrayidx2212>
    CLONE ir<%sub2225> = add nsw ir<%add2208>, ir<-3>
    CLONE ir<%idxprom2226> = sext ir<%sub2225>
    CLONE ir<%arrayidx2227> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2226>
    CLONE ir<%1263> = load ir<%arrayidx2227>
    CLONE store ir<%1263>, ir<%arrayidx2219>
    CLONE ir<%sub2233> = add nsw ir<%add2208>, ir<-4>
    CLONE ir<%idxprom2234> = sext ir<%sub2233>
    CLONE ir<%arrayidx2235> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2234>
    CLONE ir<%1264> = load ir<%arrayidx2235>
    CLONE store ir<%1264>, ir<%arrayidx2227>
    CLONE ir<%indvars.iv.next5336> = add ir<%indvars.iv5335>, ir<-4>
    CLONE ir<%1265> = trunc ir<%indvars.iv.next5336>
    CLONE ir<%cmp2205> = icmp ugt ir<%1265>, ir<3>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond2242.preheader>, scalar.ph

ir-bb<while.cond2242.preheader>:
No successors

scalar.ph:
No successors

Live-out i32 %.lcssa5597 = ir<%1265>
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2207.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-5 + %nextSym.0) to i64) /u 4))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5335 = phi %1258, %indvars.iv.next5336, ir<-4>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv5335 = phi %1258, %indvars.iv.next5336\l" +
    "  ir<%1260>, ir<-4>
    WIDEN ir<%add2208> = add ir<%1256>, ir<%1260>
    WIDEN ir<%sub2210> = add nsw ir<%add2208>, ir<-1>
    WIDEN-CAST ir<%idxprom2211> = sext  ir<%sub2210> to i64
    REPLICATE ir<%arrayidx2212> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2211>
    REPLICATE ir<%1261> = load ir<%arrayidx2212>
    WIDEN-CAST ir<%idxprom2214> = sext  ir<%add2208> to i64
    REPLICATE ir<%arrayidx2215> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2214>
    REPLICATE store ir<%1261>, ir<%arrayidx2215>
    WIDEN ir<%sub2217> = add nsw ir<%add2208>, ir<-2>
    WIDEN-CAST ir<%idxprom2218> = sext  ir<%sub2217> to i64
    REPLICATE ir<%arrayidx2219> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2218>
    REPLICATE ir<%1262> = load ir<%arrayidx2219>
    REPLICATE store ir<%1262>, ir<%arrayidx2212>
    WIDEN ir<%sub2225> = add nsw ir<%add2208>, ir<-3>
    WIDEN-CAST ir<%idxprom2226> = sext  ir<%sub2225> to i64
    REPLICATE ir<%arrayidx2227> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2226>
    REPLICATE ir<%1263> = load ir<%arrayidx2227>
    REPLICATE store ir<%1263>, ir<%arrayidx2219>
    WIDEN ir<%sub2233> = add nsw ir<%add2208>, ir<-4>
    WIDEN-CAST ir<%idxprom2234> = sext  ir<%sub2233> to i64
    REPLICATE ir<%arrayidx2235> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2234>
    REPLICATE ir<%1264> = load ir<%arrayidx2235>
    REPLICATE store ir<%1264>, ir<%arrayidx2227>
    WIDEN ir<%indvars.iv.next5336> = add ir<%indvars.iv5335>, ir<-4>
    WIDEN-CAST ir<%1265> = trunc  ir<%indvars.iv.next5336> to i32
    CLONE ir<%cmp2205> = icmp ugt ir<%1265>, ir<3>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond2242.preheader>, scalar.ph

ir-bb<while.cond2242.preheader>:
No successors

scalar.ph:
No successors

Live-out i32 %.lcssa5597 = ir<%1265>
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2207.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-5 + %nextSym.0) to i64) /u 4))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5335 = phi %1258, %indvars.iv.next5336, ir<-4>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv5335 = phi %1258, %indvars.iv.next5336\l" +
    "  ir<%1260>, ir<-4>
    WIDEN ir<%add2208> = add ir<%1256>, ir<%1260>
    WIDEN ir<%sub2210> = add nsw ir<%add2208>, ir<-1>
    WIDEN-CAST ir<%idxprom2211> = sext  ir<%sub2210> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2212> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2211>
    REPLICATE ir<%1261> = load ir<%arrayidx2212>
    WIDEN-CAST ir<%idxprom2214> = sext  ir<%add2208> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2215> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2214>
    REPLICATE store ir<%1261>, ir<%arrayidx2215>
    WIDEN ir<%sub2217> = add nsw ir<%add2208>, ir<-2>
    WIDEN-CAST ir<%idxprom2218> = sext  ir<%sub2217> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2219> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2218>
    REPLICATE ir<%1262> = load ir<%arrayidx2219>
    REPLICATE store ir<%1262>, ir<%arrayidx2212>
    WIDEN ir<%sub2225> = add nsw ir<%add2208>, ir<-3>
    WIDEN-CAST ir<%idxprom2226> = sext  ir<%sub2225> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2227> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2226>
    REPLICATE ir<%1263> = load ir<%arrayidx2227>
    REPLICATE store ir<%1263>, ir<%arrayidx2219>
    WIDEN ir<%sub2233> = add nsw ir<%add2208>, ir<-4>
    WIDEN-CAST ir<%idxprom2234> = sext  ir<%sub2233> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2235> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2234>
    REPLICATE ir<%1264> = load ir<%arrayidx2235>
    REPLICATE store ir<%1264>, ir<%arrayidx2227>
    WIDEN ir<%indvars.iv.next5336> = add ir<%indvars.iv5335>, ir<-4>
    WIDEN-CAST ir<%1265> = trunc  ir<%indvars.iv.next5336> to i32
    CLONE ir<%cmp2205> = icmp ugt ir<%1265>, ir<3>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond2242.preheader>, scalar.ph

ir-bb<while.cond2242.preheader>:
No successors

scalar.ph:
No successors

Live-out i32 %.lcssa5597 = ir<%1265>
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2207.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + ((zext i32 (-5 + %nextSym.0) to i64) /u 4))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5335 = phi %1258, %indvars.iv.next5336, ir<-4>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv5335 = phi %1258, %indvars.iv.next5336\l" +
    "  ir<%1260>, ir<-4>
    WIDEN ir<%add2208> = add ir<%1256>, ir<%1260>
    WIDEN ir<%sub2210> = add nsw ir<%add2208>, ir<-1>
    WIDEN-CAST ir<%idxprom2211> = sext  ir<%sub2210> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2212> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2211>
    WIDEN ir<%1261> = load ir<%arrayidx2212>
    WIDEN-CAST ir<%idxprom2214> = sext  ir<%add2208> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2215> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2214>
    WIDEN store ir<%arrayidx2215>, ir<%1261>
    WIDEN ir<%sub2217> = add nsw ir<%add2208>, ir<-2>
    WIDEN-CAST ir<%idxprom2218> = sext  ir<%sub2217> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2219> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2218>
    WIDEN ir<%1262> = load ir<%arrayidx2219>
    WIDEN store ir<%arrayidx2212>, ir<%1262>
    WIDEN ir<%sub2225> = add nsw ir<%add2208>, ir<-3>
    WIDEN-CAST ir<%idxprom2226> = sext  ir<%sub2225> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2227> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2226>
    WIDEN ir<%1263> = load ir<%arrayidx2227>
    WIDEN store ir<%arrayidx2219>, ir<%1263>
    WIDEN ir<%sub2233> = add nsw ir<%add2208>, ir<-4>
    WIDEN-CAST ir<%idxprom2234> = sext  ir<%sub2233> to i64
    WIDEN-GEP Inv[Inv][Var] ir<%arrayidx2235> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2234>
    WIDEN ir<%1264> = load ir<%arrayidx2235>
    WIDEN store ir<%arrayidx2227>, ir<%1264>
    WIDEN ir<%indvars.iv.next5336> = add ir<%indvars.iv5335>, ir<-4>
    WIDEN-CAST ir<%1265> = trunc  ir<%indvars.iv.next5336> to i32
    CLONE ir<%cmp2205> = icmp ugt ir<%1265>, ir<3>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond2242.preheader>, scalar.ph

ir-bb<while.cond2242.preheader>:
No successors

scalar.ph:
No successors

Live-out i32 %.lcssa5597 = ir<%1265>
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Scalar loop costs: 28.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 30 for VF 2 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Vector loop of width 2 costs: 126
A is not scalable.	B is not scalable.	
RTCostA: 135828340736, RTCostB: 30064771072
A is not scalable.	B is not scalable.	
RTCostA: 135828340736, RTCostB: 30064771072

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 2 for VF 4 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 60 for VF 4 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 4 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Vector loop of width 4 costs: 124
A is not scalable.	B is not scalable.	
RTCostA: 133949292544, RTCostB: 30064771072
A is not scalable.	B is not scalable.	
RTCostA: 133949292544, RTCostB: 30064771072

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF 8 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of 2 for VF 8 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 8 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 8 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF 8 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 4 for VF 8 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 120 for VF 8 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 8 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 2 for VF 8 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Vector loop of width 8 costs: 124
A is not scalable.	B is not scalable.	
RTCostA: 133815074816, RTCostB: 30064771072
A is not scalable.	B is not scalable.	
RTCostA: 133815074816, RTCostB: 30064771072

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of 4 for VF 16 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of 4 for VF 16 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 8 for VF 16 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 8 for VF 16 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 16 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 8 for VF 16 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 16 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 8 for VF 16 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF 16 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 8 for VF 16 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of 240 for VF 16 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 8 for VF 16 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 4 for VF 16 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Vector loop of width 16 costs: 124
A is not scalable.	B is not scalable.	
RTCostA: 133747965952, RTCostB: 30064771072
A is not scalable.	B is not scalable.	
RTCostA: 133747965952, RTCostB: 30064771072

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771072
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771072

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Vector loop of width vscale x 2 costs: 85
A is scalable.	B is not scalable.	
RTCostA: 91536490496, RTCostB: 30064771072
A is scalable.	B is not scalable.	
RTCostA: 91536490496, RTCostB: 30064771072

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 81 for VF vscale x 4 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Vector loop of width vscale x 4 costs: 83
A is scalable.	B is not scalable.	
RTCostA: 89657442304, RTCostB: 30064771072
A is scalable.	B is not scalable.	
RTCostA: 89657442304, RTCostB: 30064771072

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 161 for VF vscale x 8 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF vscale x 8 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 6 for VF vscale x 8 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Vector loop of width vscale x 8 costs: 83
A is scalable.	B is not scalable.	
RTCostA: 89187680256, RTCostB: 30064771072
A is scalable.	B is not scalable.	
RTCostA: 89187680256, RTCostB: 30064771072

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv5335 = phi i64 [ %1258, %while.body2207.preheader ], [ %indvars.iv.next5336, %while.body2207 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %1260 = trunc i64 %indvars.iv5335 to i32 of type:trunc
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %add2208 = add i32 %1256, %1260 of type:add
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %sub2210 = add nsw i32 %add2208, -1 of type:add
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %idxprom2211 = sext i32 %sub2210 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2212 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2211 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   %1261 = load i8, ptr %arrayidx2212, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %idxprom2214 = sext i32 %add2208 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2215 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2214 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   store i8 %1261, ptr %arrayidx2215, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %sub2217 = add nsw i32 %add2208, -2 of type:add
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %idxprom2218 = sext i32 %sub2217 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2219 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2218 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   %1262 = load i8, ptr %arrayidx2219, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   store i8 %1262, ptr %arrayidx2212, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %sub2225 = add nsw i32 %add2208, -3 of type:add
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %idxprom2226 = sext i32 %sub2225 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2227 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2226 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   %1263 = load i8, ptr %arrayidx2227, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   store i8 %1263, ptr %arrayidx2219, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 4 for VF vscale x 16 For instruction:   %sub2233 = add nsw i32 %add2208, -4 of type:add
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %idxprom2234 = sext i32 %sub2233 to i64 of type:sext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2235 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2234 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   %1264 = load i8, ptr %arrayidx2235, align 1, !tbaa !42 of type:load
LV: Decision: GatherScatter
LV: Found an estimated cost of 321 for VF vscale x 16 For instruction:   store i8 %1264, ptr %arrayidx2227, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 8 for VF vscale x 16 For instruction:   %indvars.iv.next5336 = add i64 %indvars.iv5335, -4 of type:add
LV: Found an estimated cost of 12 for VF vscale x 16 For instruction:   %1265 = trunc i64 %indvars.iv.next5336 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %cmp2205 = icmp ugt i32 %1265, 3 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp2205, label %while.body2207, label %while.cond2242.preheader of type:br
LV: Vector loop of width vscale x 16 costs: 82
A is scalable.	B is not scalable.	
RTCostA: 88885690368, RTCostB: 30064771072
A is scalable.	B is not scalable.	
RTCostA: 88885690368, RTCostB: 30064771072
LV: Selecting VF: 1 With Cost: 28.
maxbefore: 2
maxafter: 2
MVT: v2i32
@@ Instruction =>  %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v2i32
@@ Instruction =>  store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 -> Cost: 5 -> VectorType: <2 x i8> -> ttilog -> MemoryOpCost(4)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v4i16
@@ Instruction =>  store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 -> Cost: 3 -> VectorType: <4 x i8> -> ttilog -> MemoryOpCost(2)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v8i8
@@ Instruction =>  store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [REV64]
MVT: v16i8
@@ Instruction =>  %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: v16i8
@@ Instruction =>  store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 -> Cost: 3 -> VectorType: <16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(2) = LT.first(1) * (2) -> ASM: [REV64, EXT]
MVT: nxv16i8
@@ Instruction =>  %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 -> Cost: Invalid -> VectorType: <vscale x 1 x i8> -> ttilog -> -> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv2i64
@@ Instruction =>  store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 2 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv4i32
@@ Instruction =>  store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 4 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv8i16
@@ Instruction =>  store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 8 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
MVT: nxv16i8
@@ Instruction =>  store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 -> Cost: 2 -> VectorType: <vscale x 16 x i8> -> ttilog -> MemoryOpCost(1)-> ShuffleCost(1) = LT.first(1) * (1) -> ASM: [Unknown]
========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nn.0.lcssa5489) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5339 = phi %1259, %indvars.iv.next5340, ir<-1>
    CLONE ir<%1266> = trunc ir<%indvars.iv5339>
    CLONE ir<%add2247> = add ir<%1256>, ir<%1266>
    CLONE ir<%sub2248> = add ir<%add2247>, ir<-1>
    CLONE ir<%idxprom2249> = zext ir<%sub2248>
    CLONE ir<%arrayidx2250> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2249>
    CLONE ir<%1267> = load ir<%arrayidx2250>
    CLONE ir<%idxprom2253> = zext ir<%add2247>
    CLONE ir<%arrayidx2254> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2253>
    CLONE store ir<%1267>, ir<%arrayidx2254>
    CLONE ir<%indvars.iv.next5340> = add nsw ir<%indvars.iv5339>, ir<-1>
    CLONE ir<%1268> = and ir<%indvars.iv.next5340>, ir<4294967295>
    CLONE ir<%cmp2243.not> = icmp eq ir<%1268>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.end2256.loopexit>, scalar.ph

ir-bb<while.end2256.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 32==========
VPlan 'Initial VPlan for VF={2,4,8,16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nn.0.lcssa5489) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv5339 = phi %1259, %indvars.iv.next5340, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv5339 = phi %1259, %indvars.iv.next5340\l" +
    "  ir<%1266>, ir<-1>
    CLONE ir<%add2247> = add ir<%1256>, ir<%1266>
    CLONE ir<%sub2248> = add ir<%add2247>, ir<-1>
    CLONE ir<%idxprom2249> = zext ir<%sub2248>
    CLONE ir<%arrayidx2250> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2249>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx2250>
    WIDEN ir<%1267> = load vp<%4>
    CLONE ir<%idxprom2253> = zext ir<%add2247>
    CLONE ir<%arrayidx2254> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2253>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx2254>
    WIDEN store vp<%5>, ir<%1267>
    CLONE ir<%indvars.iv.next5340> = add nsw ir<%indvars.iv5339>, ir<-1>
    CLONE ir<%1268> = and ir<%indvars.iv.next5340>, ir<4294967295>
    CLONE ir<%cmp2243.not> = icmp eq ir<%1268>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end2256.loopexit>, scalar.ph

ir-bb<while.end2256.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 32==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nn.0.lcssa5489) to i64))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv5339 = phi %1259, %indvars.iv.next5340, ir<-1>
    WIDEN-INDUCTION\l" +
    "  %indvars.iv5339 = phi %1259, %indvars.iv.next5340\l" +
    "  ir<%1266>, ir<-1>
    CLONE ir<%add2247> = add ir<%1256>, ir<%1266>
    CLONE ir<%sub2248> = add ir<%add2247>, ir<-1>
    CLONE ir<%idxprom2249> = zext ir<%sub2248>
    CLONE ir<%arrayidx2250> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2249>
    vp<%4> = vector-pointer (reverse) ir<%arrayidx2250>
    WIDEN ir<%1267> = load vp<%4>
    CLONE ir<%idxprom2253> = zext ir<%add2247>
    CLONE ir<%arrayidx2254> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2253>
    vp<%5> = vector-pointer (reverse) ir<%arrayidx2254>
    WIDEN store vp<%5>, ir<%1267>
    CLONE ir<%indvars.iv.next5340> = add nsw ir<%indvars.iv5339>, ir<-1>
    CLONE ir<%1268> = and ir<%indvars.iv.next5340>, ir<4294967295>
    CLONE ir<%cmp2243.not> = icmp eq ir<%1268>, ir<0>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.end2256.loopexit>, scalar.ph

ir-bb<while.end2256.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 1 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 5 for VF 2 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 2 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Vector loop of width 2 costs: 7
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 14
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 14
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 14, CostB * EstimatedWidthA: 16
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 4 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 4 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 32
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 14
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 8 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF 8 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF 8 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 8 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Vector loop of width 8 costs: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 64
Candidate VF: 8 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 80
Update Chosen Factor with Candidate VF: 8 and ChosenFactor VF: 4

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 16 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF 16 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF 16 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF 16 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF 16 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF 16 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 3 for VF 16 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF 16 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF 16 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF 16 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF 16 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Vector loop of width 16 costs: 0
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 10
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 10, CostB * EstimatedWidthA: 128
Candidate VF: 16 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 10
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 128
Update Chosen Factor with Candidate VF: 16 and ChosenFactor VF: 8

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 20

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 32
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 40

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 4 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 64
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 8
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 80

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 8 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 8 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 8 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Vector loop of width vscale x 8 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 128
Candidate VF: vscale x 8 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 8
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 160
Update Chosen Factor with Candidate VF: vscale x 8 and ChosenFactor VF: 16

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %indvars.iv5339 = phi i64 [ %1259, %while.body2245.preheader ], [ %indvars.iv.next5340, %while.body2245 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %1266 = trunc nuw i64 %indvars.iv5339 to i32 of type:trunc
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %add2247 = add i32 %1256, %1266 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %sub2248 = add i32 %add2247, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %idxprom2249 = zext i32 %sub2248 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2250 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2249 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   %1267 = load i8, ptr %arrayidx2250, align 1, !tbaa !42 of type:load
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %idxprom2253 = zext i32 %add2247 to i64 of type:zext
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %arrayidx2254 = getelementptr inbounds [4096 x i8], ptr %mtfa2200, i64 0, i64 %idxprom2253 of type:getelementptr
LV: Decision: Widen_Reverse
LV: Found an estimated cost of 2 for VF vscale x 16 For instruction:   store i8 %1267, ptr %arrayidx2254, align 1, !tbaa !42 of type:store
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %indvars.iv.next5340 = add nsw i64 %indvars.iv5339, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 16 For instruction:   %1268 = and i64 %indvars.iv.next5340, 4294967295 of type:and
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   %cmp2243.not = icmp eq i64 %1268, 0 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 16 For instruction:   br i1 %cmp2243.not, label %while.end2256.loopexit, label %while.body2245 of type:br
LV: Vector loop of width vscale x 16 costs: 0
A is scalable.	B is not scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 8
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 256
Candidate VF: vscale x 16 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 16, EstimatedWidthA: 32, CostA: 8
B VF: vscale x 8, EstimatedWidthB: 16, CostB: 8
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 256
Update Chosen Factor with Candidate VF: vscale x 16 and ChosenFactor VF: vscale x 8
LV: Selecting VF: vscale x 16 With Cost: 0.
maxbefore: 2
maxafter: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 10
B VF: 2, EstimatedWidthB: 2, CostB: 14
CostA * EstimatedWidthB: 20, CostB * EstimatedWidthA: 56
A is not scalable.	B is not scalable.	
A VF: 8, EstimatedWidthA: 8, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 10
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 80
A is not scalable.	B is not scalable.	
A VF: 16, EstimatedWidthA: 16, CostA: 10
B VF: 8, EstimatedWidthB: 8, CostB: 8
CostA * EstimatedWidthB: 80, CostB * EstimatedWidthA: 128
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 40
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 8
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 80
A is scalable.	B is not scalable.	
A VF: vscale x 8, EstimatedWidthA: 16, CostA: 8
B VF: 16, EstimatedWidthB: 16, CostB: 10
CostA * EstimatedWidthB: 128, CostB * EstimatedWidthA: 160
LEV: Vectorizing epilogue loop with VF = vscale x 8 at function: BZ2_decompress at line: decompress.c
LEV: EpilogueVF.Width: vscale x 8
Executing best plan with VF=vscale x 16, UF=2 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2245.preheader>:
  EMIT vp<%2> = EXPAND SCEV (1 + (zext i32 (-1 + %nn.0.lcssa5489) to i64))<nuw><nsw>
No successors

vector.ph:
  SCALAR-CAST vp<%3> = trunc ir<-1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%4> = CANONICAL-INDUCTION ir<0>, vp<%10>
    vp<%5>    = DERIVED-IV ir<%1259> + vp<%4> * ir<-1>
    SCALAR-CAST vp<%6> = trunc vp<%5> to i32
    vp<%7> = SCALAR-STEPS vp<%6>, vp<%3>
    CLONE ir<%add2247> = add ir<%1256>, vp<%7>
    CLONE ir<%sub2248> = add ir<%add2247>, ir<-1>
    CLONE ir<%idxprom2249> = zext ir<%sub2248>
    CLONE ir<%arrayidx2250> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2249>
    vp<%8> = vector-pointer (reverse) ir<%arrayidx2250>
    WIDEN ir<%1302> = load vp<%8>
    CLONE ir<%idxprom2253> = zext ir<%add2247>
    CLONE ir<%arrayidx2254> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2253>
    vp<%9> = vector-pointer (reverse) ir<%arrayidx2254>
    WIDEN store vp<%9>, ir<%1302>
    EMIT vp<%10> = add nuw vp<%4>, vp<%0>
    EMIT branch-on-count vp<%10>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%12> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%12>
Successor(s): ir-bb<while.end2256.loopexit>, scalar.ph

ir-bb<while.end2256.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

Executing best plan with VF=vscale x 8, UF=1 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<%1262> = original trip-count

vector.ph:
  SCALAR-CAST vp<%2> = trunc ir<-1> to i32
Successor(s): vector loop

<x1> vector loop: {
  vec.epilog.vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%1259> + vp<%3> * ir<-1>
    SCALAR-CAST vp<%5> = trunc vp<%4> to i32
    vp<%6> = SCALAR-STEPS vp<%5>, vp<%2>
    CLONE ir<%add2247> = add ir<%1256>, vp<%6>
    CLONE ir<%sub2248> = add ir<%add2247>, ir<-1>
    CLONE ir<%idxprom2249> = zext ir<%sub2248>
    CLONE ir<%arrayidx2250> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2249>
    vp<%7> = vector-pointer (reverse) ir<%arrayidx2250>
    WIDEN ir<%1357> = load vp<%7>
    CLONE ir<%idxprom2253> = zext ir<%add2247>
    CLONE ir<%arrayidx2254> = getelementptr inbounds ir<%mtfa2200>, ir<0>, ir<%idxprom2253>
    vp<%8> = vector-pointer (reverse) ir<%arrayidx2254>
    WIDEN store vp<%8>, ir<%1357>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq ir<%1262>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<while.end2256.loopexit>, scalar.ph

ir-bb<while.end2256.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2157.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5343 = phi %1250, %indvars.iv.next5344, ir<1>
    WIDEN-INDUCTION %es.65129 = phi %inc2139, %dec2167, ir<-1>
    CLONE ir<%exitcond5348.not> = icmp eq ir<%indvars.iv5343>, ir<%wide.trip.count5347>
  Successor(s): if.end2161

  if.end2161:
    CLONE ir<%1252> = load ir<%ll162163>
    CLONE ir<%arrayidx2165> = getelementptr inbounds ir<%1252>, ir<%indvars.iv5343>
    CLONE store ir<%conv2162>, ir<%arrayidx2165>
    CLONE ir<%indvars.iv.next5344> = add nsw ir<%indvars.iv5343>, ir<1>
    CLONE ir<%dec2167> = add nsw ir<%es.65129>, ir<-1>
    CLONE ir<%cmp2155> = icmp sgt ir<%es.65129>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 16==========
VPlan 'Initial VPlan for VF={2,4,8},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2157.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5343 = phi %1250, %indvars.iv.next5344, ir<1>
    WIDEN-INDUCTION %es.65129 = phi %inc2139, %dec2167, ir<-1>
    CLONE ir<%exitcond5348.not> = icmp eq ir<%indvars.iv5343>, ir<%wide.trip.count5347>
  Successor(s): if.end2161

  if.end2161:
    CLONE ir<%1252> = load ir<%ll162163>
    REPLICATE ir<%arrayidx2165> = getelementptr inbounds ir<%1252>, ir<%indvars.iv5343>
    REPLICATE store ir<%conv2162>, ir<%arrayidx2165>
    REPLICATE ir<%indvars.iv.next5344> = add nsw ir<%indvars.iv5343>, ir<1>
    CLONE ir<%dec2167> = add nsw ir<%es.65129>, ir<-1>
    CLONE ir<%cmp2155> = icmp sgt ir<%es.65129>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2157.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5343 = phi %1250, %indvars.iv.next5344, ir<1>
    WIDEN-INDUCTION %es.65129 = phi %inc2139, %dec2167, ir<-1>
    CLONE ir<%exitcond5348.not> = icmp eq ir<%indvars.iv5343>, ir<%wide.trip.count5347>
  Successor(s): if.end2161

  if.end2161:
    CLONE ir<%1252> = load ir<%ll162163>
    WIDEN-GEP Var[Var] ir<%arrayidx2165> = getelementptr inbounds ir<%1252>, ir<%indvars.iv5343>
    REPLICATE store ir<%conv2162>, ir<%arrayidx2165>
    WIDEN ir<%indvars.iv.next5344> = add nsw ir<%indvars.iv5343>, ir<1>
    CLONE ir<%dec2167> = add nsw ir<%es.65129>, ir<-1>
    CLONE ir<%cmp2155> = icmp sgt ir<%es.65129>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2157.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5343 = phi %1250, %indvars.iv.next5344, ir<1>
    WIDEN-INDUCTION %es.65129 = phi %inc2139, %dec2167, ir<-1>
    CLONE ir<%exitcond5348.not> = icmp eq ir<%indvars.iv5343>, ir<%wide.trip.count5347>
  Successor(s): if.end2161

  if.end2161:
    CLONE ir<%1252> = load ir<%ll162163>
    WIDEN-GEP Var[Var] ir<%arrayidx2165> = getelementptr inbounds ir<%1252>, ir<%indvars.iv5343>
    WIDEN store ir<%arrayidx2165>, ir<%conv2162>
    WIDEN ir<%indvars.iv.next5344> = add nsw ir<%indvars.iv5343>, ir<1>
    CLONE ir<%dec2167> = add nsw ir<%es.65129>, ir<-1>
    CLONE ir<%cmp2155> = icmp sgt ir<%es.65129>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv5343 = phi i64 [ %1250, %while.body2157.lr.ph ], [ %indvars.iv.next5344, %if.end2161 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %es.65129 = phi i32 [ %inc2139, %while.body2157.lr.ph ], [ %dec2167, %if.end2161 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond5348.not = icmp eq i64 %indvars.iv5343, %wide.trip.count5347 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond5348.not, label %save_state_and_return.loopexit5561, label %if.end2161 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1252 = load ptr, ptr %ll162163, align 8, !tbaa !49 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2165 = getelementptr inbounds i16, ptr %1252, i64 %indvars.iv5343 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i16 %conv2162, ptr %arrayidx2165, align 2, !tbaa !70 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5344 = add nsw i64 %indvars.iv5343, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec2167 = add nsw i32 %es.65129, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2155 = icmp sgt i32 %es.65129, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2155, label %while.body2157, label %if.end2185.loopexit5234 of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv5343 = phi i64 [ %1250, %while.body2157.lr.ph ], [ %indvars.iv.next5344, %if.end2161 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %es.65129 = phi i32 [ %inc2139, %while.body2157.lr.ph ], [ %dec2167, %if.end2161 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond5348.not = icmp eq i64 %indvars.iv5343, %wide.trip.count5347 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond5348.not, label %save_state_and_return.loopexit5561, label %if.end2161 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   %1252 = load ptr, ptr %ll162163, align 8, !tbaa !49 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2165 = getelementptr inbounds i16, ptr %1252, i64 %indvars.iv5343 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i16 %conv2162, ptr %arrayidx2165, align 2, !tbaa !70 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5344 = add nsw i64 %indvars.iv5343, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec2167 = add nsw i32 %es.65129, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2155 = icmp sgt i32 %es.65129, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp2155, label %while.body2157, label %if.end2185.loopexit5234 of type:br
LV: Vector loop of width 2 costs: 16

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv5343 = phi i64 [ %1250, %while.body2157.lr.ph ], [ %indvars.iv.next5344, %if.end2161 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %es.65129 = phi i32 [ %inc2139, %while.body2157.lr.ph ], [ %dec2167, %if.end2161 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond5348.not = icmp eq i64 %indvars.iv5343, %wide.trip.count5347 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond5348.not, label %save_state_and_return.loopexit5561, label %if.end2161 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1252 = load ptr, ptr %ll162163, align 8, !tbaa !49 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2165 = getelementptr inbounds i16, ptr %1252, i64 %indvars.iv5343 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i16 %conv2162, ptr %arrayidx2165, align 2, !tbaa !70 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next5344 = add nsw i64 %indvars.iv5343, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec2167 = add nsw i32 %es.65129, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2155 = icmp sgt i32 %es.65129, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp2155, label %while.body2157, label %if.end2185.loopexit5234 of type:br
LV: Vector loop of width 4 costs: 14

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 8 For instruction:   %indvars.iv5343 = phi i64 [ %1250, %while.body2157.lr.ph ], [ %indvars.iv.next5344, %if.end2161 ] of type:phi
LV: Found an estimated cost of 0 for VF 8 For instruction:   %es.65129 = phi i32 [ %inc2139, %while.body2157.lr.ph ], [ %dec2167, %if.end2161 ] of type:phi
LV: Found an estimated cost of 1 for VF 8 For instruction:   %exitcond5348.not = icmp eq i64 %indvars.iv5343, %wide.trip.count5347 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %exitcond5348.not, label %save_state_and_return.loopexit5561, label %if.end2161 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF 8 For instruction:   %1252 = load ptr, ptr %ll162163, align 8, !tbaa !49 of type:load
LV: Found an estimated cost of 0 for VF 8 For instruction:   %arrayidx2165 = getelementptr inbounds i16, ptr %1252, i64 %indvars.iv5343 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 104 for VF 8 For instruction:   store i16 %conv2162, ptr %arrayidx2165, align 2, !tbaa !70 of type:store
LV: Found an estimated cost of 1 for VF 8 For instruction:   %indvars.iv.next5344 = add nsw i64 %indvars.iv5343, 1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %dec2167 = add nsw i32 %es.65129, -1 of type:add
LV: Found an estimated cost of 1 for VF 8 For instruction:   %cmp2155 = icmp sgt i32 %es.65129, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 8 For instruction:   br i1 %cmp2155, label %while.body2157, label %if.end2185.loopexit5234 of type:br
LV: Vector loop of width 8 costs: 13

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv5343 = phi i64 [ %1250, %while.body2157.lr.ph ], [ %indvars.iv.next5344, %if.end2161 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %es.65129 = phi i32 [ %inc2139, %while.body2157.lr.ph ], [ %dec2167, %if.end2161 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond5348.not = icmp eq i64 %indvars.iv5343, %wide.trip.count5347 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond5348.not, label %save_state_and_return.loopexit5561, label %if.end2161 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %1252 = load ptr, ptr %ll162163, align 8, !tbaa !49 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2165 = getelementptr inbounds i16, ptr %1252, i64 %indvars.iv5343 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i16 %conv2162, ptr %arrayidx2165, align 2, !tbaa !70 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5344 = add nsw i64 %indvars.iv5343, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec2167 = add nsw i32 %es.65129, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2155 = icmp sgt i32 %es.65129, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2155, label %while.body2157, label %if.end2185.loopexit5234 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv5343 = phi i64 [ %1250, %while.body2157.lr.ph ], [ %indvars.iv.next5344, %if.end2161 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %es.65129 = phi i32 [ %inc2139, %while.body2157.lr.ph ], [ %dec2167, %if.end2161 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond5348.not = icmp eq i64 %indvars.iv5343, %wide.trip.count5347 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond5348.not, label %save_state_and_return.loopexit5561, label %if.end2161 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %1252 = load ptr, ptr %ll162163, align 8, !tbaa !49 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2165 = getelementptr inbounds i16, ptr %1252, i64 %indvars.iv5343 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i16 %conv2162, ptr %arrayidx2165, align 2, !tbaa !70 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5344 = add nsw i64 %indvars.iv5343, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec2167 = add nsw i32 %es.65129, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2155 = icmp sgt i32 %es.65129, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2155, label %while.body2157, label %if.end2185.loopexit5234 of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 25232932841, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 25232932841, RTCostB: 17179869176
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2157.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%1250> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%1252> = load ir<%ll162163>
    CLONE ir<%arrayidx2165> = getelementptr inbounds ir<%1252>, vp<%5>
    CLONE store ir<%conv2162>, ir<%arrayidx2165>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2173.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5349 = phi %1265, %indvars.iv.next5350, ir<1>
    WIDEN-INDUCTION %es.75134 = phi %inc2139, %dec2183, ir<-1>
    CLONE ir<%exitcond5355.not> = icmp eq ir<%indvars.iv5349>, ir<%wide.trip.count5354>
  Successor(s): if.end2177

  if.end2177:
    CLONE ir<%1267> = load ir<%tt2179>
    CLONE ir<%arrayidx2181> = getelementptr inbounds ir<%1267>, ir<%indvars.iv5349>
    CLONE store ir<%conv2178>, ir<%arrayidx2181>
    CLONE ir<%indvars.iv.next5350> = add nsw ir<%indvars.iv5349>, ir<1>
    CLONE ir<%dec2183> = add nsw ir<%es.75134>, ir<-1>
    CLONE ir<%cmp2171> = icmp sgt ir<%es.75134>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2173.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5349 = phi %1265, %indvars.iv.next5350, ir<1>
    WIDEN-INDUCTION %es.75134 = phi %inc2139, %dec2183, ir<-1>
    CLONE ir<%exitcond5355.not> = icmp eq ir<%indvars.iv5349>, ir<%wide.trip.count5354>
  Successor(s): if.end2177

  if.end2177:
    CLONE ir<%1267> = load ir<%tt2179>
    REPLICATE ir<%arrayidx2181> = getelementptr inbounds ir<%1267>, ir<%indvars.iv5349>
    REPLICATE store ir<%conv2178>, ir<%arrayidx2181>
    REPLICATE ir<%indvars.iv.next5350> = add nsw ir<%indvars.iv5349>, ir<1>
    CLONE ir<%dec2183> = add nsw ir<%es.75134>, ir<-1>
    CLONE ir<%cmp2171> = icmp sgt ir<%es.75134>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={vscale x 1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2173.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5349 = phi %1265, %indvars.iv.next5350, ir<1>
    WIDEN-INDUCTION %es.75134 = phi %inc2139, %dec2183, ir<-1>
    CLONE ir<%exitcond5355.not> = icmp eq ir<%indvars.iv5349>, ir<%wide.trip.count5354>
  Successor(s): if.end2177

  if.end2177:
    CLONE ir<%1267> = load ir<%tt2179>
    WIDEN-GEP Var[Var] ir<%arrayidx2181> = getelementptr inbounds ir<%1267>, ir<%indvars.iv5349>
    REPLICATE store ir<%conv2178>, ir<%arrayidx2181>
    WIDEN ir<%indvars.iv.next5350> = add nsw ir<%indvars.iv5349>, ir<1>
    CLONE ir<%dec2183> = add nsw ir<%es.75134>, ir<-1>
    CLONE ir<%cmp2171> = icmp sgt ir<%es.75134>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 4==========
VPlan 'Initial VPlan for VF={vscale x 2},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2173.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv5349 = phi %1265, %indvars.iv.next5350, ir<1>
    WIDEN-INDUCTION %es.75134 = phi %inc2139, %dec2183, ir<-1>
    CLONE ir<%exitcond5355.not> = icmp eq ir<%indvars.iv5349>, ir<%wide.trip.count5354>
  Successor(s): if.end2177

  if.end2177:
    CLONE ir<%1267> = load ir<%tt2179>
    WIDEN-GEP Var[Var] ir<%arrayidx2181> = getelementptr inbounds ir<%1267>, ir<%indvars.iv5349>
    WIDEN store ir<%arrayidx2181>, ir<%conv2178>
    WIDEN ir<%indvars.iv.next5350> = add nsw ir<%indvars.iv5349>, ir<1>
    CLONE ir<%dec2183> = add nsw ir<%es.75134>, ir<-1>
    CLONE ir<%cmp2171> = icmp sgt ir<%es.75134>, ir<1>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv5349 = phi i64 [ %1265, %while.body2173.lr.ph ], [ %indvars.iv.next5350, %if.end2177 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %es.75134 = phi i32 [ %inc2139, %while.body2173.lr.ph ], [ %dec2183, %if.end2177 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond5355.not = icmp eq i64 %indvars.iv5349, %wide.trip.count5354 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond5355.not, label %save_state_and_return.loopexit5560, label %if.end2177 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1267 = load ptr, ptr %tt2179, align 8, !tbaa !51 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2181 = getelementptr inbounds i32, ptr %1267, i64 %indvars.iv5349 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %conv2178, ptr %arrayidx2181, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5350 = add nsw i64 %indvars.iv5349, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %dec2183 = add nsw i32 %es.75134, -1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %cmp2171 = icmp sgt i32 %es.75134, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %cmp2171, label %while.body2173, label %if.end2185.loopexit of type:br
LV: Scalar loop costs: 8.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv5349 = phi i64 [ %1265, %while.body2173.lr.ph ], [ %indvars.iv.next5350, %if.end2177 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %es.75134 = phi i32 [ %inc2139, %while.body2173.lr.ph ], [ %dec2183, %if.end2177 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond5355.not = icmp eq i64 %indvars.iv5349, %wide.trip.count5354 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond5355.not, label %save_state_and_return.loopexit5560, label %if.end2177 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF 2 For instruction:   %1267 = load ptr, ptr %tt2179, align 8, !tbaa !51 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2181 = getelementptr inbounds i32, ptr %1267, i64 %indvars.iv5349 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 26 for VF 2 For instruction:   store i32 %conv2178, ptr %arrayidx2181, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5350 = add nsw i64 %indvars.iv5349, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %dec2183 = add nsw i32 %es.75134, -1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %cmp2171 = icmp sgt i32 %es.75134, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %cmp2171, label %while.body2173, label %if.end2185.loopexit of type:br
LV: Vector loop of width 2 costs: 16

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv5349 = phi i64 [ %1265, %while.body2173.lr.ph ], [ %indvars.iv.next5350, %if.end2177 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %es.75134 = phi i32 [ %inc2139, %while.body2173.lr.ph ], [ %dec2183, %if.end2177 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond5355.not = icmp eq i64 %indvars.iv5349, %wide.trip.count5354 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond5355.not, label %save_state_and_return.loopexit5560, label %if.end2177 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF 4 For instruction:   %1267 = load ptr, ptr %tt2179, align 8, !tbaa !51 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2181 = getelementptr inbounds i32, ptr %1267, i64 %indvars.iv5349 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of 52 for VF 4 For instruction:   store i32 %conv2178, ptr %arrayidx2181, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next5350 = add nsw i64 %indvars.iv5349, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %dec2183 = add nsw i32 %es.75134, -1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %cmp2171 = icmp sgt i32 %es.75134, 1 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %cmp2171, label %while.body2173, label %if.end2185.loopexit of type:br
LV: Vector loop of width 4 costs: 14

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv5349 = phi i64 [ %1265, %while.body2173.lr.ph ], [ %indvars.iv.next5350, %if.end2177 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %es.75134 = phi i32 [ %inc2139, %while.body2173.lr.ph ], [ %dec2183, %if.end2177 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond5355.not = icmp eq i64 %indvars.iv5349, %wide.trip.count5354 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond5355.not, label %save_state_and_return.loopexit5560, label %if.end2177 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 1 For instruction:   %1267 = load ptr, ptr %tt2179, align 8, !tbaa !51 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2181 = getelementptr inbounds i32, ptr %1267, i64 %indvars.iv5349 of type:getelementptr
LV: Decision: Scalarize
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %conv2178, ptr %arrayidx2181, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %indvars.iv.next5350 = add nsw i64 %indvars.iv5349, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %dec2183 = add nsw i32 %es.75134, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %cmp2171 = icmp sgt i32 %es.75134, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %cmp2171, label %while.body2173, label %if.end2185.loopexit of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 17179869176

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv5349 = phi i64 [ %1265, %while.body2173.lr.ph ], [ %indvars.iv.next5350, %if.end2177 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %es.75134 = phi i32 [ %inc2139, %while.body2173.lr.ph ], [ %dec2183, %if.end2177 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond5355.not = icmp eq i64 %indvars.iv5349, %wide.trip.count5354 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond5355.not, label %save_state_and_return.loopexit5560, label %if.end2177 of type:br

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 2 for VF vscale x 2 For instruction:   %1267 = load ptr, ptr %tt2179, align 8, !tbaa !51 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2181 = getelementptr inbounds i32, ptr %1267, i64 %indvars.iv5349 of type:getelementptr
LV: Decision: GatherScatter
LV: Found an estimated cost of 41 for VF vscale x 2 For instruction:   store i32 %conv2178, ptr %arrayidx2181, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5350 = add nsw i64 %indvars.iv5349, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %dec2183 = add nsw i32 %es.75134, -1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %cmp2171 = icmp sgt i32 %es.75134, 1 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %cmp2171, label %while.body2173, label %if.end2185.loopexit of type:br
LV: Vector loop of width vscale x 2 costs: 11
A is scalable.	B is not scalable.	
RTCostA: 25232932841, RTCostB: 17179869176
A is scalable.	B is not scalable.	
RTCostA: 25232932841, RTCostB: 17179869176
LV: Selecting VF: 1 With Cost: 8.
maxbefore: 2
maxafter: 2
Executing best plan with VF=1, UF=2 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<while.body2173.lr.ph>:
  EMIT vp<%2> = EXPAND SCEV (1 + (((-1 * (sext i32 %nblock.6 to i64))<nsw> + ((sext i32 %nblock.6 to i64) smax (sext i32 %nblockMAX.6 to i64))) umin_seq (zext i32 (1 + (-1 * (1 smin (1 + %es.4))) + %es.4) to i64)))<nuw><nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%4>    = DERIVED-IV ir<%1265> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%1267> = load ir<%tt2179>
    CLONE ir<%arrayidx2181> = getelementptr inbounds ir<%1267>, vp<%5>
    CLONE store ir<%conv2178>, ir<%arrayidx2181>
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
Successor(s): scalar.ph

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv5356 = phi 1, %indvars.iv.next5357, ir<1>
    CLONE ir<%1492> = add nsw ir<%indvars.iv5356>, ir<-1>
    CLONE ir<%arrayidx2569> = getelementptr inbounds ir<%unzftab2566>, ir<0>, ir<%1492>
    CLONE ir<%1493> = load ir<%arrayidx2569>
    CLONE ir<%arrayidx2572> = getelementptr inbounds ir<%cftab>, ir<0>, ir<%indvars.iv5356>
    CLONE store ir<%1493>, ir<%arrayidx2572>
    CLONE ir<%indvars.iv.next5357> = add nuw nsw ir<%indvars.iv5356>, ir<1>
    CLONE ir<%exitcond5361.not> = icmp eq ir<%indvars.iv.next5357>, ir<257>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.body2579.preheader>, scalar.ph

ir-bb<for.body2579.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv5356 = phi 1, %indvars.iv.next5357, ir<1>
    CLONE ir<%1492> = add nsw ir<%indvars.iv5356>, ir<-1>
    CLONE ir<%arrayidx2569> = getelementptr inbounds ir<%unzftab2566>, ir<0>, ir<%1492>
    vp<%3> = vector-pointer ir<%arrayidx2569>
    WIDEN ir<%1493> = load vp<%3>
    CLONE ir<%arrayidx2572> = getelementptr inbounds ir<%cftab>, ir<0>, ir<%indvars.iv5356>
    vp<%4> = vector-pointer ir<%arrayidx2572>
    WIDEN store vp<%4>, ir<%1493>
    CLONE ir<%indvars.iv.next5357> = add nuw nsw ir<%indvars.iv5356>, ir<1>
    CLONE ir<%exitcond5361.not> = icmp eq ir<%indvars.iv.next5357>, ir<257>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body2579.preheader>, scalar.ph

ir-bb<for.body2579.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv5356 = phi 1, %indvars.iv.next5357, ir<1>
    CLONE ir<%1492> = add nsw ir<%indvars.iv5356>, ir<-1>
    CLONE ir<%arrayidx2569> = getelementptr inbounds ir<%unzftab2566>, ir<0>, ir<%1492>
    vp<%3> = vector-pointer ir<%arrayidx2569>
    WIDEN ir<%1493> = load vp<%3>
    CLONE ir<%arrayidx2572> = getelementptr inbounds ir<%cftab>, ir<0>, ir<%indvars.iv5356>
    vp<%4> = vector-pointer ir<%arrayidx2572>
    WIDEN store vp<%4>, ir<%1493>
    CLONE ir<%indvars.iv.next5357> = add nuw nsw ir<%indvars.iv5356>, ir<1>
    CLONE ir<%exitcond5361.not> = icmp eq ir<%indvars.iv.next5357>, ir<257>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.body2579.preheader>, scalar.ph

ir-bb<for.body2579.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv5356 = phi i64 [ 1, %if.end2560 ], [ %indvars.iv.next5357, %for.body2565 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %1492 = add nsw i64 %indvars.iv5356, -1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2569 = getelementptr inbounds [256 x i32], ptr %unzftab2566, i64 0, i64 %1492 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2572 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5356 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5357 = add nuw nsw i64 %indvars.iv5356, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond5361.not = icmp eq i64 %indvars.iv.next5357, 257 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond5361.not, label %for.body2579.preheader, label %for.body2565 of type:br
LV: Scalar loop costs: 7.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv5356 = phi i64 [ 1, %if.end2560 ], [ %indvars.iv.next5357, %for.body2565 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1492 = add nsw i64 %indvars.iv5356, -1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2569 = getelementptr inbounds [256 x i32], ptr %unzftab2566, i64 0, i64 %1492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2572 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5356 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5357 = add nuw nsw i64 %indvars.iv5356, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond5361.not = icmp eq i64 %indvars.iv.next5357, 257 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond5361.not, label %for.body2579.preheader, label %for.body2565 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 640, RTCostB: 1792
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 640, RTCostB: 1792
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv5356 = phi i64 [ 1, %if.end2560 ], [ %indvars.iv.next5357, %for.body2565 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1492 = add nsw i64 %indvars.iv5356, -1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2569 = getelementptr inbounds [256 x i32], ptr %unzftab2566, i64 0, i64 %1492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2572 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5356 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next5357 = add nuw nsw i64 %indvars.iv5356, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond5361.not = icmp eq i64 %indvars.iv.next5357, 257 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond5361.not, label %for.body2579.preheader, label %for.body2565 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 1792
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 640
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv5356 = phi i64 [ 1, %if.end2560 ], [ %indvars.iv.next5357, %for.body2565 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %1492 = add nsw i64 %indvars.iv5356, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2569 = getelementptr inbounds [256 x i32], ptr %unzftab2566, i64 0, i64 %1492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2572 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5356 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next5357 = add nuw nsw i64 %indvars.iv5356, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond5361.not = icmp eq i64 %indvars.iv.next5357, 257 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond5361.not, label %for.body2579.preheader, label %for.body2565 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1792
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 320

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv5356 = phi i64 [ 1, %if.end2560 ], [ %indvars.iv.next5357, %for.body2565 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1492 = add nsw i64 %indvars.iv5356, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2569 = getelementptr inbounds [256 x i32], ptr %unzftab2566, i64 0, i64 %1492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2572 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5356 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5357 = add nuw nsw i64 %indvars.iv5356, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond5361.not = icmp eq i64 %indvars.iv.next5357, 257 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond5361.not, label %for.body2579.preheader, label %for.body2565 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 1792
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 320, RTCostB: 320
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv5356 = phi i64 [ 1, %if.end2560 ], [ %indvars.iv.next5357, %for.body2565 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1492 = add nsw i64 %indvars.iv5356, -1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2569 = getelementptr inbounds [256 x i32], ptr %unzftab2566, i64 0, i64 %1492 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1493 = load i32, ptr %arrayidx2569, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2572 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5356 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %1493, ptr %arrayidx2572, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next5357 = add nuw nsw i64 %indvars.iv5356, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond5361.not = icmp eq i64 %indvars.iv.next5357, 257 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond5361.not, label %for.body2579.preheader, label %for.body2565 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 160, RTCostB: 1792
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 160, RTCostB: 320
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<256> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%3>    = DERIVED-IV ir<1> + vp<%2> * ir<1>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%1492> = add nsw vp<%4>, ir<-1>
    CLONE ir<%arrayidx2569> = getelementptr inbounds ir<%unzftab2566>, ir<0>, ir<%1492>
    vp<%5> = vector-pointer ir<%arrayidx2569>
    WIDEN ir<%1493> = load vp<%5>
    CLONE ir<%arrayidx2572> = getelementptr inbounds ir<%cftab>, ir<0>, vp<%4>
    vp<%6> = vector-pointer ir<%arrayidx2572>
    WIDEN store vp<%6>, ir<%1493>
    EMIT vp<%7> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq ir<256>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.body2579.preheader>, scalar.ph

ir-bb<for.body2579.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<257> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%3>
    WIDEN-INDUCTION %indvars.iv5373 = phi 0, %indvars.iv.next5374, ir<1>
    CLONE ir<%arrayidx2627> = getelementptr inbounds ir<%cftab>, ir<0>, ir<%indvars.iv5373>
    CLONE ir<%1529> = load ir<%arrayidx2627>
    CLONE ir<%arrayidx2629> = getelementptr inbounds ir<%cftabCopy>, ir<0>, ir<%indvars.iv5373>
    CLONE store ir<%1529>, ir<%arrayidx2629>
    CLONE ir<%indvars.iv.next5374> = add nuw nsw ir<%indvars.iv5373>, ir<1>
    CLONE ir<%exitcond5377.not> = icmp eq ir<%indvars.iv.next5374>, ir<257>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%3> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%3>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%5> = icmp eq ir<257>, vp<%1>
  EMIT branch-on-cond vp<%5>
Successor(s): ir-bb<for.cond2633.preheader>, scalar.ph

ir-bb<for.cond2633.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<257> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv5373 = phi 0, %indvars.iv.next5374, ir<1>
    CLONE ir<%arrayidx2627> = getelementptr inbounds ir<%cftab>, ir<0>, ir<%indvars.iv5373>
    vp<%3> = vector-pointer ir<%arrayidx2627>
    WIDEN ir<%1529> = load vp<%3>
    CLONE ir<%arrayidx2629> = getelementptr inbounds ir<%cftabCopy>, ir<0>, ir<%indvars.iv5373>
    vp<%4> = vector-pointer ir<%arrayidx2629>
    WIDEN store vp<%4>, ir<%1529>
    CLONE ir<%indvars.iv.next5374> = add nuw nsw ir<%indvars.iv5373>, ir<1>
    CLONE ir<%exitcond5377.not> = icmp eq ir<%indvars.iv.next5374>, ir<257>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<257>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond2633.preheader>, scalar.ph

ir-bb<for.cond2633.preheader>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_decompress' from decompress.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<257> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%5>
    WIDEN-INDUCTION %indvars.iv5373 = phi 0, %indvars.iv.next5374, ir<1>
    CLONE ir<%arrayidx2627> = getelementptr inbounds ir<%cftab>, ir<0>, ir<%indvars.iv5373>
    vp<%3> = vector-pointer ir<%arrayidx2627>
    WIDEN ir<%1529> = load vp<%3>
    CLONE ir<%arrayidx2629> = getelementptr inbounds ir<%cftabCopy>, ir<0>, ir<%indvars.iv5373>
    vp<%4> = vector-pointer ir<%arrayidx2629>
    WIDEN store vp<%4>, ir<%1529>
    CLONE ir<%indvars.iv.next5374> = add nuw nsw ir<%indvars.iv5373>, ir<1>
    CLONE ir<%exitcond5377.not> = icmp eq ir<%indvars.iv.next5374>, ir<257>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%5> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%5>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%7> = icmp eq ir<257>, vp<%1>
  EMIT branch-on-cond vp<%7>
Successor(s): ir-bb<for.cond2633.preheader>, scalar.ph

ir-bb<for.cond2633.preheader>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv5373 = phi i64 [ 0, %for.cond2621.preheader ], [ %indvars.iv.next5374, %for.body2624 ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2627 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx2629 = getelementptr inbounds [257 x i32], ptr %cftabCopy, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next5374 = add nuw nsw i64 %indvars.iv5373, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond5377.not = icmp eq i64 %indvars.iv.next5374, 257 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond5377.not, label %for.cond2633.preheader, label %for.body2624 of type:br
LV: Scalar loop costs: 6.
-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv5373 = phi i64 [ 0, %for.cond2621.preheader ], [ %indvars.iv.next5374, %for.body2624 ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2627 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx2629 = getelementptr inbounds [257 x i32], ptr %cftabCopy, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next5374 = add nuw nsw i64 %indvars.iv5373, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond5377.not = icmp eq i64 %indvars.iv.next5374, 257 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond5377.not, label %for.cond2633.preheader, label %for.body2624 of type:br
LV: Vector loop of width 2 costs: 2
A is not scalable.	B is not scalable.	
RTCostA: 518, RTCostB: 1542
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 518, RTCostB: 1542
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv5373 = phi i64 [ 0, %for.cond2621.preheader ], [ %indvars.iv.next5374, %for.body2624 ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2627 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx2629 = getelementptr inbounds [257 x i32], ptr %cftabCopy, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next5374 = add nuw nsw i64 %indvars.iv5373, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond5377.not = icmp eq i64 %indvars.iv.next5374, 257 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond5377.not, label %for.cond2633.preheader, label %for.body2624 of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 262, RTCostB: 1542
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 262, RTCostB: 518
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv5373 = phi i64 [ 0, %for.cond2621.preheader ], [ %indvars.iv.next5374, %for.body2624 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2627 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx2629 = getelementptr inbounds [257 x i32], ptr %cftabCopy, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next5374 = add nuw nsw i64 %indvars.iv5373, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond5377.not = icmp eq i64 %indvars.iv.next5374, 257 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond5377.not, label %for.cond2633.preheader, label %for.body2624 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 1542
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 262

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv5373 = phi i64 [ 0, %for.cond2621.preheader ], [ %indvars.iv.next5374, %for.body2624 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2627 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx2629 = getelementptr inbounds [257 x i32], ptr %cftabCopy, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next5374 = add nuw nsw i64 %indvars.iv5373, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond5377.not = icmp eq i64 %indvars.iv.next5374, 257 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond5377.not, label %for.cond2633.preheader, label %for.body2624 of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 262, RTCostB: 1542
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 262, RTCostB: 262
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'BZ2_decompress' from decompress.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv5373 = phi i64 [ 0, %for.cond2621.preheader ], [ %indvars.iv.next5374, %for.body2624 ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2627 = getelementptr inbounds [257 x i32], ptr %cftab, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %1529 = load i32, ptr %arrayidx2627, align 4, !tbaa !69 of type:load
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx2629 = getelementptr inbounds [257 x i32], ptr %cftabCopy, i64 0, i64 %indvars.iv5373 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %1529, ptr %arrayidx2629, align 4, !tbaa !69 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next5374 = add nuw nsw i64 %indvars.iv5373, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond5377.not = icmp eq i64 %indvars.iv.next5374, 257 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond5377.not, label %for.cond2633.preheader, label %for.body2624 of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 134, RTCostB: 1542
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 134, RTCostB: 262
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: BZ2_decompress at line: decompress.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
Live-in ir<257> = original trip-count

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%2> = CANONICAL-INDUCTION ir<0>, vp<%6>
    vp<%3> = SCALAR-STEPS vp<%2>, ir<1>
    CLONE ir<%arrayidx2627> = getelementptr inbounds ir<%cftab>, ir<0>, vp<%3>
    vp<%4> = vector-pointer ir<%arrayidx2627>
    WIDEN ir<%1529> = load vp<%4>
    CLONE ir<%arrayidx2629> = getelementptr inbounds ir<%cftabCopy>, ir<0>, vp<%3>
    vp<%5> = vector-pointer ir<%arrayidx2629>
    WIDEN store vp<%5>, ir<%1529>
    EMIT vp<%6> = add nuw vp<%2>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq ir<257>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<for.cond2633.preheader>, scalar.ph

ir-bb<for.cond2633.preheader>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 6
Loops Analyzed: 59
Loops Epilogues Vectorized: 3
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o huffman.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                huffman.c
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: BZ2_hbMakeCodeLengths' from huffman.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %alphaSize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%freq>, ir<%indvars.iv>
    CLONE ir<%4> = load ir<%arrayidx>
    CLONE ir<%spec.select> = call @llvm.umax.i32(ir<%4>, ir<1>)
    CLONE ir<%shl> = shl ir<%spec.select>, ir<8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx5> = getelementptr inbounds ir<%weight>, ir<0>, ir<%indvars.iv.next>
    CLONE store ir<%shl>, ir<%arrayidx5>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_hbMakeCodeLengths' from huffman.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %alphaSize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%freq>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i32(ir<%4>, ir<1>) (using vector intrinsic)
    WIDEN ir<%shl> = shl ir<%spec.select>, ir<8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx5> = getelementptr inbounds ir<%weight>, ir<0>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer ir<%arrayidx5>
    WIDEN store vp<%5>, ir<%shl>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_hbMakeCodeLengths' from huffman.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %alphaSize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv = phi %indvars.iv.next, 0, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%freq>, ir<%indvars.iv>
    vp<%4> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%4>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i32(ir<%4>, ir<1>) (using vector intrinsic)
    WIDEN ir<%shl> = shl ir<%spec.select>, ir<8>
    CLONE ir<%indvars.iv.next> = add nuw nsw ir<%indvars.iv>, ir<1>
    CLONE ir<%arrayidx5> = getelementptr inbounds ir<%weight>, ir<0>, ir<%indvars.iv.next>
    vp<%5> = vector-pointer ir<%arrayidx5>
    WIDEN store vp<%5>, ir<%shl>
    CLONE ir<%exitcond.not> = icmp eq ir<%indvars.iv.next>, ir<%wide.trip.count>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %freq, i64 %indvars.iv of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 2 for VF 1 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %4, i32 1) of type:call
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl = shl i32 %spec.select, 8 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx5 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond.not, label %while.cond.preheader.loopexit, label %for.body of type:br
LV: Scalar loop costs: 9.
-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %freq, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %4, i32 1) of type:call
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl = shl i32 %spec.select, 8 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx5 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond.not, label %while.cond.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 2 costs: 3
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 6442450947, RTCostB: 19327352823
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %freq, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %4, i32 1) of type:call
LV: Found an estimated cost of 1 for VF 4 For instruction:   %shl = shl i32 %spec.select, 8 of type:shl
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx5 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond.not, label %while.cond.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width 4 costs: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 19327352823
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 6442450947
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %freq, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %4, i32 1) of type:call
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl = shl i32 %spec.select, 8 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx5 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond.not, label %while.cond.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 19327352823
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 3221225493

-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %freq, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %4, i32 1) of type:call
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl = shl i32 %spec.select, 8 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx5 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond.not, label %while.cond.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 2 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 19327352823
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225493, RTCostB: 3221225493
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx = getelementptr inbounds i32, ptr %freq, i64 %indvars.iv of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %4 = load i32, ptr %arrayidx, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %spec.select = tail call i32 @llvm.umax.i32(i32 %4, i32 1) of type:call
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %shl = shl i32 %spec.select, 8 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx5 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv.next of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %shl, ptr %arrayidx5, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond.not, label %while.cond.preheader.loopexit, label %for.body of type:br
LV: Vector loop of width vscale x 4 costs: 0
A is scalable.	B is not scalable.	
RTCostA: 1610612793, RTCostB: 19327352823
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 1610612793, RTCostB: 3221225493
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 0.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: BZ2_hbMakeCodeLengths at line: huffman.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body.preheader>:
  EMIT vp<%2> = EXPAND SCEV (zext i32 %alphaSize to i64)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    vp<%4> = SCALAR-STEPS vp<%3>, ir<1>
    CLONE ir<%arrayidx> = getelementptr inbounds ir<%freq>, vp<%4>
    vp<%5> = vector-pointer ir<%arrayidx>
    WIDEN ir<%4> = load vp<%5>
    WIDEN-CALL ir<%spec.select> = call @llvm.umax.i32(ir<%4>, ir<1>) (using vector intrinsic)
    WIDEN ir<%shl> = shl ir<%spec.select>, ir<8>
    CLONE ir<%indvars.iv.next> = add nuw nsw vp<%4>, ir<1>
    CLONE ir<%arrayidx5> = getelementptr inbounds ir<%weight>, ir<0>, ir<%indvars.iv.next>
    vp<%6> = vector-pointer ir<%arrayidx5>
    WIDEN store vp<%6>, ir<%shl>
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<while.cond.preheader.loopexit>, scalar.ph

ir-bb<while.cond.preheader.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

@@ Instruction =>  %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: BZ2_hbMakeCodeLengths' from huffman.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body223.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %alphaSize) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv391 = phi %indvars.iv.next392, 1, ir<1>
    CLONE ir<%arrayidx225> = getelementptr inbounds ir<%weight>, ir<0>, ir<%indvars.iv391>
    CLONE ir<%81> = load ir<%arrayidx225>
    CLONE ir<%shr226> = ashr ir<%81>, ir<8>
    CLONE ir<%div> = sdiv ir<%shr226>, ir<2>
    CLONE ir<%add227> = shl nsw ir<%div>, ir<8>
    CLONE ir<%shl228> = add nsw ir<%add227>, ir<256>
    CLONE store ir<%shl228>, ir<%arrayidx225>
    CLONE ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond395.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count394>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<while.cond.loopexit.loopexit>, scalar.ph

ir-bb<while.cond.loopexit.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_hbMakeCodeLengths' from huffman.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body223.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %alphaSize) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv391 = phi %indvars.iv.next392, 1, ir<1>
    CLONE ir<%arrayidx225> = getelementptr inbounds ir<%weight>, ir<0>, ir<%indvars.iv391>
    vp<%4> = vector-pointer ir<%arrayidx225>
    WIDEN ir<%81> = load vp<%4>
    WIDEN ir<%shr226> = ashr ir<%81>, ir<8>
    WIDEN ir<%div> = sdiv ir<%shr226>, ir<2>
    WIDEN ir<%add227> = shl nsw ir<%div>, ir<8>
    WIDEN ir<%shl228> = add nsw ir<%add227>, ir<256>
    vp<%5> = vector-pointer ir<%arrayidx225>
    WIDEN store vp<%5>, ir<%shl228>
    CLONE ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond395.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count394>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.cond.loopexit.loopexit>, scalar.ph

ir-bb<while.cond.loopexit.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_hbMakeCodeLengths' from huffman.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body223.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %alphaSize) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%6>
    WIDEN-INDUCTION %indvars.iv391 = phi %indvars.iv.next392, 1, ir<1>
    CLONE ir<%arrayidx225> = getelementptr inbounds ir<%weight>, ir<0>, ir<%indvars.iv391>
    vp<%4> = vector-pointer ir<%arrayidx225>
    WIDEN ir<%81> = load vp<%4>
    WIDEN ir<%shr226> = ashr ir<%81>, ir<8>
    WIDEN ir<%div> = sdiv ir<%shr226>, ir<2>
    WIDEN ir<%add227> = shl nsw ir<%div>, ir<8>
    WIDEN ir<%shl228> = add nsw ir<%add227>, ir<256>
    vp<%5> = vector-pointer ir<%arrayidx225>
    WIDEN store vp<%5>, ir<%shl228>
    CLONE ir<%indvars.iv.next392> = add nuw nsw ir<%indvars.iv391>, ir<1>
    CLONE ir<%exitcond395.not> = icmp eq ir<%indvars.iv.next392>, ir<%wide.trip.count394>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%6> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%6>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%8> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%8>
Successor(s): ir-bb<while.cond.loopexit.loopexit>, scalar.ph

ir-bb<while.cond.loopexit.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv391 = phi i64 [ %indvars.iv.next392, %for.body223 ], [ 1, %for.body223.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx225 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv391 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shr226 = ashr i32 %81, 8 of type:ashr
LV: Found an estimated cost of 5 for VF 1 For instruction:   %div = sdiv i32 %shr226, 2 of type:sdiv
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add227 = shl nsw i32 %div, 8 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl228 = add nsw i32 %add227, 256 of type:add
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond395.not, label %while.cond.loopexit.loopexit, label %for.body223 of type:br
LV: Scalar loop costs: 14.
-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv391 = phi i64 [ %indvars.iv.next392, %for.body223 ], [ 1, %for.body223.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx225 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shr226 = ashr i32 %81, 8 of type:ashr
LV: Found an estimated cost of 15 for VF 2 For instruction:   %div = sdiv i32 %shr226, 2 of type:sdiv
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add227 = shl nsw i32 %div, 8 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl228 = add nsw i32 %add227, 256 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond395.not, label %while.cond.loopexit.loopexit, label %for.body223 of type:br
LV: Vector loop of width 2 costs: 11
A is not scalable.	B is not scalable.	
RTCostA: 23622320120, RTCostB: 30064771058
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 23622320120, RTCostB: 30064771058
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv391 = phi i64 [ %indvars.iv.next392, %for.body223 ], [ 1, %for.body223.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx225 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %shr226 = ashr i32 %81, 8 of type:ashr
LV: Found an estimated cost of 27 for VF 4 For instruction:   %div = sdiv i32 %shr226, 2 of type:sdiv
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add227 = shl nsw i32 %div, 8 of type:shl
LV: Found an estimated cost of 1 for VF 4 For instruction:   %shl228 = add nsw i32 %add227, 256 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond395.not, label %while.cond.loopexit.loopexit, label %for.body223 of type:br
LV: Vector loop of width 4 costs: 8
A is not scalable.	B is not scalable.	
RTCostA: 18253611016, RTCostB: 30064771058
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
RTCostA: 18253611016, RTCostB: 23622320120
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv391 = phi i64 [ %indvars.iv.next392, %for.body223 ], [ 1, %for.body223.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx225 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shr226 = ashr i32 %81, 8 of type:ashr
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %div = sdiv i32 %shr226, 2 of type:sdiv
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add227 = shl nsw i32 %div, 8 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl228 = add nsw i32 %add227, 256 of type:add
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond395.not, label %while.cond.loopexit.loopexit, label %for.body223 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 30064771058
A is scalable.	B is not scalable.	
RTCostA: Invalid, RTCostB: 18253611016

-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv391 = phi i64 [ %indvars.iv.next392, %for.body223 ], [ 1, %for.body223.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx225 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shr226 = ashr i32 %81, 8 of type:ashr
LV: Found an estimated cost of 5 for VF vscale x 2 For instruction:   %div = sdiv i32 %shr226, 2 of type:sdiv
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add227 = shl nsw i32 %div, 8 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl228 = add nsw i32 %add227, 256 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond395.not, label %while.cond.loopexit.loopexit, label %for.body223 of type:br
LV: Vector loop of width vscale x 2 costs: 3
A is scalable.	B is not scalable.	
RTCostA: 6442450974, RTCostB: 30064771058
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
RTCostA: 6442450974, RTCostB: 18253611016
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'BZ2_hbMakeCodeLengths' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv391 = phi i64 [ %indvars.iv.next392, %for.body223 ], [ 1, %for.body223.preheader ] of type:phi
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx225 = getelementptr inbounds [516 x i32], ptr %weight, i64 0, i64 %indvars.iv391 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %81 = load i32, ptr %arrayidx225, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %shr226 = ashr i32 %81, 8 of type:ashr
LV: Found an estimated cost of 5 for VF vscale x 4 For instruction:   %div = sdiv i32 %shr226, 2 of type:sdiv
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add227 = shl nsw i32 %div, 8 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %shl228 = add nsw i32 %add227, 256 of type:add
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %shl228, ptr %arrayidx225, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next392 = add nuw nsw i64 %indvars.iv391, 1 of type:add
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond395.not = icmp eq i64 %indvars.iv.next392, %wide.trip.count394 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond395.not, label %while.cond.loopexit.loopexit, label %for.body223 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
RTCostA: 3221225558, RTCostB: 30064771058
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
RTCostA: 3221225558, RTCostB: 6442450974
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: BZ2_hbMakeCodeLengths at line: huffman.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body223.preheader>:
  EMIT vp<%2> = EXPAND SCEV (-1 + (zext i32 (1 + %alphaSize) to i64))<nsw>
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%8>
    vp<%4>    = DERIVED-IV ir<1> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%arrayidx225> = getelementptr inbounds ir<%weight>, ir<0>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx225>
    WIDEN ir<%81> = load vp<%6>
    WIDEN ir<%shr226> = ashr ir<%81>, ir<8>
    WIDEN ir<%div> = sdiv ir<%shr226>, ir<2>
    WIDEN ir<%add227> = shl nsw ir<%div>, ir<8>
    WIDEN ir<%shl228> = add nsw ir<%add227>, ir<256>
    vp<%7> = vector-pointer ir<%arrayidx225>
    WIDEN store vp<%7>, ir<%shl228>
    EMIT vp<%8> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%8>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%10> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%10>
Successor(s): ir-bb<while.cond.loopexit.loopexit>, scalar.ph

ir-bb<while.cond.loopexit.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 2
Loops Analyzed: 7
Loops Epilogues Vectorized: 0
================================================
@@ Instruction =>  %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: Invalid -> VectorType: <vscale x 1 x i32> -> ttilog -> 
@@ Instruction =>  %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 2 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
@@ Instruction =>  store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 -> Cost: 1 -> VectorType: <vscale x 4 x i32> -> ttilog -> MemoryOpCost(1)
========== Loop: BZ2_hbCreateDecodeTables' from huffman.c==========
========== VPlan for Vector Factor Range: 1 to 2==========
VPlan 'Initial VPlan for VF={1},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body76.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %maxLen to i64) + (-1 * (sext i32 %minLen to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%4>
    WIDEN-INDUCTION %indvars.iv174 = phi %49, %indvars.iv.next175, ir<1>
    CLONE ir<%indvars.iv.next175> = add nsw ir<%indvars.iv174>, ir<1>
    CLONE ir<%arrayidx79> = getelementptr inbounds ir<%limit>, ir<%indvars.iv174>
    CLONE ir<%52> = load ir<%arrayidx79>
    CLONE ir<%add80> = shl ir<%52>, ir<1>
    CLONE ir<%shl81> = add ir<%add80>, ir<2>
    CLONE ir<%arrayidx83> = getelementptr inbounds ir<%base>, ir<%indvars.iv.next175>
    CLONE ir<%53> = load ir<%arrayidx83>
    CLONE ir<%sub84> = sub ir<%shl81>, ir<%53>
    CLONE store ir<%sub84>, ir<%arrayidx83>
    CLONE ir<%exitcond178.not> = icmp eq ir<%indvars.iv.next175>, ir<%wide.trip.count177>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%4> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%4>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%6> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%6>
Successor(s): ir-bb<for.end89.loopexit>, scalar.ph

ir-bb<for.end89.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_hbCreateDecodeTables' from huffman.c==========
========== VPlan for Vector Factor Range: 2 to 8==========
VPlan 'Initial VPlan for VF={2,4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body76.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %maxLen to i64) + (-1 * (sext i32 %minLen to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv174 = phi %49, %indvars.iv.next175, ir<1>
    CLONE ir<%indvars.iv.next175> = add nsw ir<%indvars.iv174>, ir<1>
    CLONE ir<%arrayidx79> = getelementptr inbounds ir<%limit>, ir<%indvars.iv174>
    vp<%4> = vector-pointer ir<%arrayidx79>
    WIDEN ir<%52> = load vp<%4>
    WIDEN ir<%add80> = shl ir<%52>, ir<1>
    WIDEN ir<%shl81> = add ir<%add80>, ir<2>
    CLONE ir<%arrayidx83> = getelementptr inbounds ir<%base>, ir<%indvars.iv.next175>
    vp<%5> = vector-pointer ir<%arrayidx83>
    WIDEN ir<%53> = load vp<%5>
    WIDEN ir<%sub84> = sub ir<%shl81>, ir<%53>
    vp<%6> = vector-pointer ir<%arrayidx83>
    WIDEN store vp<%6>, ir<%sub84>
    CLONE ir<%exitcond178.not> = icmp eq ir<%indvars.iv.next175>, ir<%wide.trip.count177>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end89.loopexit>, scalar.ph

ir-bb<for.end89.loopexit>:
No successors

scalar.ph:
No successors
}

========== Loop: BZ2_hbCreateDecodeTables' from huffman.c==========
========== VPlan for Vector Factor Range: 1 to 8==========
VPlan 'Initial VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body76.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %maxLen to i64) + (-1 * (sext i32 %minLen to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%7>
    WIDEN-INDUCTION %indvars.iv174 = phi %49, %indvars.iv.next175, ir<1>
    CLONE ir<%indvars.iv.next175> = add nsw ir<%indvars.iv174>, ir<1>
    CLONE ir<%arrayidx79> = getelementptr inbounds ir<%limit>, ir<%indvars.iv174>
    vp<%4> = vector-pointer ir<%arrayidx79>
    WIDEN ir<%52> = load vp<%4>
    WIDEN ir<%add80> = shl ir<%52>, ir<1>
    WIDEN ir<%shl81> = add ir<%add80>, ir<2>
    CLONE ir<%arrayidx83> = getelementptr inbounds ir<%base>, ir<%indvars.iv.next175>
    vp<%5> = vector-pointer ir<%arrayidx83>
    WIDEN ir<%53> = load vp<%5>
    WIDEN ir<%sub84> = sub ir<%shl81>, ir<%53>
    vp<%6> = vector-pointer ir<%arrayidx83>
    WIDEN store vp<%6>, ir<%sub84>
    CLONE ir<%exitcond178.not> = icmp eq ir<%indvars.iv.next175>, ir<%wide.trip.count177>
  Successor(s): 

  :
  Successor(s): vector.latch

  vector.latch:
    EMIT vp<%7> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%7>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%9> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%9>
Successor(s): ir-bb<for.end89.loopexit>, scalar.ph

ir-bb<for.end89.loopexit>:
No successors

scalar.ph:
No successors
}


-----------------Function that is being costed:'BZ2_hbCreateDecodeTables' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF 1 For instruction:   %indvars.iv174 = phi i64 [ %49, %for.body76.preheader ], [ %indvars.iv.next175, %for.body76 ] of type:phi
LV: Found an estimated cost of 1 for VF 1 For instruction:   %indvars.iv.next175 = add nsw i64 %indvars.iv174, 1 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx79 = getelementptr inbounds i32, ptr %limit, i64 %indvars.iv174 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %add80 = shl i32 %52, 1 of type:shl
LV: Found an estimated cost of 1 for VF 1 For instruction:   %shl81 = add i32 %add80, 2 of type:add
LV: Found an estimated cost of 0 for VF 1 For instruction:   %arrayidx83 = getelementptr inbounds i32, ptr %base, i64 %indvars.iv.next175 of type:getelementptr
LV: Found an estimated cost of 2 for VF 1 For instruction:   %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 1 For instruction:   %sub84 = sub i32 %shl81, %53 of type:sub
LV: Found an estimated cost of 2 for VF 1 For instruction:   store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 1 For instruction:   %exitcond178.not = icmp eq i64 %indvars.iv.next175, %wide.trip.count177 of type:icmp
LV: Found an estimated cost of 0 for VF 1 For instruction:   br i1 %exitcond178.not, label %for.end89.loopexit, label %for.body76 of type:br
LV: Scalar loop costs: 11.
-----------------Function that is being costed:'BZ2_hbCreateDecodeTables' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF 2 For instruction:   %indvars.iv174 = phi i64 [ %49, %for.body76.preheader ], [ %indvars.iv.next175, %for.body76 ] of type:phi
LV: Found an estimated cost of 1 for VF 2 For instruction:   %indvars.iv.next175 = add nsw i64 %indvars.iv174, 1 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx79 = getelementptr inbounds i32, ptr %limit, i64 %indvars.iv174 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %add80 = shl i32 %52, 1 of type:shl
LV: Found an estimated cost of 1 for VF 2 For instruction:   %shl81 = add i32 %add80, 2 of type:add
LV: Found an estimated cost of 0 for VF 2 For instruction:   %arrayidx83 = getelementptr inbounds i32, ptr %base, i64 %indvars.iv.next175 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 2 For instruction:   %sub84 = sub i32 %shl81, %53 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 2 For instruction:   store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 2 For instruction:   %exitcond178.not = icmp eq i64 %indvars.iv.next175, %wide.trip.count177 of type:icmp
LV: Found an estimated cost of 0 for VF 2 For instruction:   br i1 %exitcond178.not, label %for.end89.loopexit, label %for.body76 of type:br
LV: Vector loop of width 2 costs: 4
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 22
Candidate VF: 2 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 2, EstimatedWidthA: 2, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 22
Update Chosen Factor with Candidate VF: 2 and ChosenFactor VF: 1

-----------------Function that is being costed:'BZ2_hbCreateDecodeTables' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF 4 For instruction:   %indvars.iv174 = phi i64 [ %49, %for.body76.preheader ], [ %indvars.iv.next175, %for.body76 ] of type:phi
LV: Found an estimated cost of 1 for VF 4 For instruction:   %indvars.iv.next175 = add nsw i64 %indvars.iv174, 1 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx79 = getelementptr inbounds i32, ptr %limit, i64 %indvars.iv174 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %add80 = shl i32 %52, 1 of type:shl
LV: Found an estimated cost of 1 for VF 4 For instruction:   %shl81 = add i32 %add80, 2 of type:add
LV: Found an estimated cost of 0 for VF 4 For instruction:   %arrayidx83 = getelementptr inbounds i32, ptr %base, i64 %indvars.iv.next175 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF 4 For instruction:   %sub84 = sub i32 %shl81, %53 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF 4 For instruction:   store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF 4 For instruction:   %exitcond178.not = icmp eq i64 %indvars.iv.next175, %wide.trip.count177 of type:icmp
LV: Found an estimated cost of 0 for VF 4 For instruction:   br i1 %exitcond178.not, label %for.end89.loopexit, label %for.body76 of type:br
LV: Vector loop of width 4 costs: 2
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 44
Candidate VF: 4 is more profitable than ScalarCost VF: 1
A is not scalable.	B is not scalable.	
A VF: 4, EstimatedWidthA: 4, CostA: 8
B VF: 2, EstimatedWidthB: 2, CostB: 8
CostA * EstimatedWidthB: 16, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: 4 and ChosenFactor VF: 2

-----------------Function that is being costed:'BZ2_hbCreateDecodeTables' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %indvars.iv174 = phi i64 [ %49, %for.body76.preheader ], [ %indvars.iv.next175, %for.body76 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %indvars.iv.next175 = add nsw i64 %indvars.iv174, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx79 = getelementptr inbounds i32, ptr %limit, i64 %indvars.iv174 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %add80 = shl i32 %52, 1 of type:shl
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %shl81 = add i32 %add80, 2 of type:add
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   %arrayidx83 = getelementptr inbounds i32, ptr %base, i64 %indvars.iv.next175 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   %sub84 = sub i32 %shl81, %53 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of Invalid for VF vscale x 1 For instruction:   store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 1 For instruction:   %exitcond178.not = icmp eq i64 %indvars.iv.next175, %wide.trip.count177 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 1 For instruction:   br i1 %exitcond178.not, label %for.end89.loopexit, label %for.body76 of type:br
LV: Vector loop of width vscale x 1 costs: Invalid
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 22
A is scalable.	B is not scalable.	
A VF: vscale x 1, EstimatedWidthA: 2, CostA: Invalid
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: Invalid, CostB * EstimatedWidthA: 16

-----------------Function that is being costed:'BZ2_hbCreateDecodeTables' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %indvars.iv174 = phi i64 [ %49, %for.body76.preheader ], [ %indvars.iv.next175, %for.body76 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %indvars.iv.next175 = add nsw i64 %indvars.iv174, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx79 = getelementptr inbounds i32, ptr %limit, i64 %indvars.iv174 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %add80 = shl i32 %52, 1 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %shl81 = add i32 %add80, 2 of type:add
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   %arrayidx83 = getelementptr inbounds i32, ptr %base, i64 %indvars.iv.next175 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %sub84 = sub i32 %shl81, %53 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 2 For instruction:   %exitcond178.not = icmp eq i64 %indvars.iv.next175, %wide.trip.count177 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 2 For instruction:   br i1 %exitcond178.not, label %for.end89.loopexit, label %for.body76 of type:br
LV: Vector loop of width vscale x 2 costs: 2
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 44
Candidate VF: vscale x 2 is more profitable than ScalarCost VF: 1
A is scalable.	B is not scalable.	
A VF: vscale x 2, EstimatedWidthA: 4, CostA: 8
B VF: 4, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 32
Update Chosen Factor with Candidate VF: vscale x 2 and ChosenFactor VF: 4

-----------------Function that is being costed:'BZ2_hbCreateDecodeTables' from huffman.c-----------------
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %indvars.iv174 = phi i64 [ %49, %for.body76.preheader ], [ %indvars.iv.next175, %for.body76 ] of type:phi
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %indvars.iv.next175 = add nsw i64 %indvars.iv174, 1 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx79 = getelementptr inbounds i32, ptr %limit, i64 %indvars.iv174 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %52 = load i32, ptr %arrayidx79, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %add80 = shl i32 %52, 1 of type:shl
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %shl81 = add i32 %add80, 2 of type:add
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   %arrayidx83 = getelementptr inbounds i32, ptr %base, i64 %indvars.iv.next175 of type:getelementptr
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %53 = load i32, ptr %arrayidx83, align 4, !tbaa !6 of type:load
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %sub84 = sub i32 %shl81, %53 of type:sub
LV: Decision: Widen
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   store i32 %sub84, ptr %arrayidx83, align 4, !tbaa !6 of type:store
LV: Found an estimated cost of 1 for VF vscale x 4 For instruction:   %exitcond178.not = icmp eq i64 %indvars.iv.next175, %wide.trip.count177 of type:icmp
LV: Found an estimated cost of 0 for VF vscale x 4 For instruction:   br i1 %exitcond178.not, label %for.end89.loopexit, label %for.body76 of type:br
LV: Vector loop of width vscale x 4 costs: 1
A is scalable.	B is not scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 8
B VF: 1, EstimatedWidthB: 1, CostB: 11
CostA * EstimatedWidthB: 8, CostB * EstimatedWidthA: 88
Candidate VF: vscale x 4 is more profitable than ScalarCost VF: 1
A is scalable.	B is scalable.	
A VF: vscale x 4, EstimatedWidthA: 8, CostA: 8
B VF: vscale x 2, EstimatedWidthB: 4, CostB: 8
CostA * EstimatedWidthB: 32, CostB * EstimatedWidthA: 64
Update Chosen Factor with Candidate VF: vscale x 4 and ChosenFactor VF: vscale x 2
LV: Selecting VF: vscale x 4 With Cost: 1.
maxbefore: 2
maxafter: 2
LEV: Epilogue vectorization is not profitable for this loop
LEV: EpilogueVF.Width: 1
Executing best plan with VF=vscale x 4, UF=2 at function: BZ2_hbCreateDecodeTables at line: huffman.c
================ Final VPlan ================
VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4},UF>=1' {
Live-in vp<%0> = VF * UF
Live-in vp<%1> = vector-trip-count
vp<%2> = original trip-count

ir-bb<for.body76.preheader>:
  EMIT vp<%2> = EXPAND SCEV ((sext i32 %maxLen to i64) + (-1 * (sext i32 %minLen to i64))<nsw>)
No successors

vector.ph:
Successor(s): vector loop

<x1> vector loop: {
  vector.body:
    EMIT vp<%3> = CANONICAL-INDUCTION ir<0>, vp<%9>
    vp<%4>    = DERIVED-IV ir<%49> + vp<%3> * ir<1>
    vp<%5> = SCALAR-STEPS vp<%4>, ir<1>
    CLONE ir<%indvars.iv.next175> = add nsw vp<%5>, ir<1>
    CLONE ir<%arrayidx79> = getelementptr inbounds ir<%limit>, vp<%5>
    vp<%6> = vector-pointer ir<%arrayidx79>
    WIDEN ir<%56> = load vp<%6>
    WIDEN ir<%add80> = shl ir<%56>, ir<1>
    WIDEN ir<%shl81> = add ir<%add80>, ir<2>
    CLONE ir<%arrayidx83> = getelementptr inbounds ir<%base>, ir<%indvars.iv.next175>
    vp<%7> = vector-pointer ir<%arrayidx83>
    WIDEN ir<%57> = load vp<%7>
    WIDEN ir<%sub84> = sub ir<%shl81>, ir<%57>
    vp<%8> = vector-pointer ir<%arrayidx83>
    WIDEN store vp<%8>, ir<%sub84>
    EMIT vp<%9> = add nuw vp<%3>, vp<%0>
    EMIT branch-on-count vp<%9>, vp<%1>
  No successors
}
Successor(s): middle.block

middle.block:
  EMIT vp<%11> = icmp eq vp<%2>, vp<%1>
  EMIT branch-on-cond vp<%11>
Successor(s): ir-bb<for.end89.loopexit>, scalar.ph

ir-bb<for.end89.loopexit>:
No successors

scalar.ph:
No successors
}
================ Final VPlan ================

================================================
Loops Vectorized: 3
Loops Analyzed: 12
Loops Epilogues Vectorized: 0
================================================
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration   -c -o randtable.o -DSPEC_CPU -DNDEBUG    -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions                randtable.c
/home/tomlord/workspace/Tom/llvm-project/arm64-debug/bin/clang -std=gnu89 -static -w -Wno-error=int-conversion -Wno-error=implicit-function-declaration     -march=armv8-a+sve -O3    -fno-slp-vectorize -fno-inline-functions          spec.o blocksort.o bzip2.o bzlib.o compress.o crctable.o decompress.o huffman.o randtable.o                     -o bzip2
